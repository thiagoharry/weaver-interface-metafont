\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}

\secao{1. Introduction}

The original METAFONT is a language made to describe typographical
fonts. It was created on 1984 by Donald Knuth and differs from other
formats for allowing a designer to create different fonts merely by
changing basic parameters in the base description of the font. This
way, a designer should not create a single typographic font, but a
meta-font from which new fonts could be obtained changing these basic
parameters.

The original specification for the METAFONT language can be found in
[KNUTH, 1989], but the implementation described here will not be
compatible with that language. Instead, a new language will be
defined, strongly based on the original METAFONT, but with a different
grammar. The new language will have similar objectives, but it will be
focused on defining typographical fonts that could be interpreted and
rendered on the fly.

As this article defines a subsystem for Weaver Game Engine, and more
specifically a subsystem for the user interface modulus, our objective
here will be define the following function that will interpret a file
with METAFONT source code and load as user interface using the letters
read as texture:

\iniciocodigo
@<Function Declaration (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
@
\fimcodigo

And we will need the header for Weaver user interfaces:

\iniciociodigo
@<Include General Headers (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

But besides loading the typographical fonts to a texture, we also want
to create a font structure that could be used to render text for other
functions:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Before acalling any of these function, it is necessary to call a
initialization function that sets which functions will be called in
some contexts and also sets how many pixels correspond to ``1pt'':

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
void Winit_metafont(void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *),
                    void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    uint64_t (*rand)(void), int pt);
@
\fimcodigo

The functions passed as parameters are respectivelly the one that
allocates memory temporarily , other to free what was allocated by it,
a function to make more permanent allocation, the function that frees
what was allocated by it, a function that returns 64 random bits and
finally how many pixels are ``1pt''. The disallocation functions can
be set to NULL.

\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{metafont.h}.

We can show the structure of the file \monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif  
@<Include General Headers (metafont.h)@>
//@<General Macros (metafont.h)@>
@<Data Structures (metafont.h)@>
@<Function Declaration (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Function Declaration
(weaver.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{metafont.c} file related
with this header, its structure is:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Local Headers (metafont.c)@>
@<Local Macros (metafont.c)@>
@<Local Data Structures (metafont.c)@>
@<Local Variables (metafont.c)@>
@<Local Function Declaration (metafont.c)@>
@<Auxiliary Local Functions (metafont.c)@>
@<API Functions Definition (metafont.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\secao{2. Initialization}

First we will define the initialization function. What it will do is
set some static variables with some functions that we will use in the
program. It also will set in a variable how many pixels correspond to
1pt. The variables that will store these information are:

\iniciocodigo
@<Local Variables (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

And the initialization function that sets these variables:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
void Winit_metafont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
}
@
\fimcodigo


\secao{3. Lexer}

The first thing to be created for a language is its lexer. It will
read the source code in a file and will output a list of tokens, where
tokens are the most basic unit in the language. A token is like a
word.

METAFONT recognizes three kind of tokens: numeric, strings and
symbolic. In practice we will subdivide the symbolic tokens in several
kind of subtokens to store and read them in a more efficient way.

A numeric token will be represented internally as a floating point
number. This is different than specified in the original METAFONT,
where a custom numeric representation was used. As here we are
interested in more speed, we will choose floating point numbers
because they have nowadays more hardware support. This is how a
numeric token is represented:

\iniciocodigo
@<Local Data Structures (metafont.c)@>=
#define TYPE_NUMERIC 1
struct numeric_token{
  int type;   // Should be equal 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

And this is how we will represent string tokens:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_STRING 2
struct string_token{
  int type;   // Should be equal 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

We will store only the first 5 bytes of each given string, even if in
the source code the string is bigger. This is so because unlike in the
original METAFONT, our only use for strings are saying wich Unicode
character each glyph should represent. For this we need only 5 bytes
(at most 4 for the character and a final byte 0). But we could use
them to associate a glyph with ligatures like ``ff'', which also fits
in these 5 bytes.

In the case of symbolic tokens, we need to store their entire name to
know which symbolic token we have. We shoul allocate dynamically
a string to store its name:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_SYMBOLIC 3
struct symbolic_token{
  int type;   // Should be equal 'TYPE_SYMBOLIC'
  void *next, *var;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char *value;
};
@
\fimcodigo

We also added in this token a pointer \monoespaco{var}, because the
token can represent a variable, and therefore could need to point to
the memory region with its content.

But this could consume much more memory than needed. Some symbols are
very common and are embedded in the language. These symbols could use
less space. For example, parenthesis, semicolon and commas. We can
represent them with the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_OPEN_PARENTHESIS  4 // '('
#define TYPE_CLOSE_PARENTHESIS 5 // ')'
#define TYPE_COMMA             6 // ','
#define TYPE_SEMICOLON         7 // ';'
@<METAFONT: Symbolic Token Definition@>
// (...)
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

We can define later more reserved symbolic tokens. We just need to
define them to an unique number greater than 6. Any token whose type
is a number greater or equal than 3 is a symbolic token.

Every token have a pointer to a next token. THis happens because
usually they will be part of a linked list. To deallocate the memory
occupied by a token list given a deallocation function and the given
list, we can use the following function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Now the funtion that represents our lexer. It will get as argument an
allocation function and a string with a path for the file with
METAFONT source code. It will return a linked list of tokens:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Lexer: Rule 1@>
    @<Lexer: Rule 2@>
    @<Lexer: Rule 3@>
    @<Lexer: Rule 4@>
    @<Lexer: Rule 5@>
    @<Lexer: Rule 6@>
    // No rule applied: error
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, we used the struct \monoespaco{FILE}, this means that we need to
include the header with data about input/output to be able to read
files:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

The rules to read tokens consist in reading each line in the source
code applying the following rules for each character in the line:

1) If the next character is a space or a period and is not followed by
a period or a decimal digit, then ignore this character and go to the
next one.

\iniciocodigo
@<Lexer: Rule 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

As we are using \monoespaco{isdigit} function, we need to insert the
following header that declares this function:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) If the character is a percent sign, ignore it and also ignore all
other following characters in this line. Percentage sign is how we
start comments in the language.

\iniciocodigo
@<Lexer: Rule 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) If the next character is a decimal digit or a period, then the next
token in numeric. It will be interpreted from the biggest sequence of
decimal digests and a single optional period representing the decimal
dot present in the input.

\iniciocodigo
@<Lexer: Rule 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

4) If the next character is a double quote, the next token will be a
string. Its content will be all other chacarters until the next double
quote that should be in the same line. If we have a double quote
opening a string, but the same line do not have another double quote
to close the string, this is an error.

\iniciocodigo
@<Lexer: Rule 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


5) If the next character is a parenthesis, semicolon or a comma, the
next token will be symbolic and composed by that single character.

\iniciocodigo
@<Lexer: Rule 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Otherwise, the next token will be symbolic and will be composed by
the longest sequence of 12 families of characteres:

\iniciocodigo
@<Lexer: Rule 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer is read according with subrules 6-a to 6-l
  @<Lexer: Rule A@>
  @<Lexer: Rule B@>
  @<Lexer: Rule C@>
  @<Lexer: Rule D@>
  @<Lexer: Rule E@>
  @<Lexer: Rule F@>
  @<Lexer: Rule G@>
  @<Lexer: Rule H@>
  @<Lexer: Rule I@>
  @<Lexer: Rule J@>
  @<Lexer: Rule K@>
  @<Lexer: Rule L@>
  // Depending on buffer content, generates next token
  @<Lexer: New Reserved Symbolic Token@>
  @<Lexer: New Generic Symbolic Token@>
}
@
\fimcodigo

a) The first family of letters are the uppercase and lowercase
alphabetic letters, digits and underline. A digit cannot be the first
character in the sequence, otherwise it would be considered part of a
numeric token.

\iniciocodigo
@<Lexer: Rule A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) The second family is composed by the symbols for greater, equal and
lesser, colon and ``|''.

\iniciocodigo
@<Lexer: Rule B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acute and grave accents.

\iniciocodigo
@<Lexer: Rule C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Plus and minus.

\iniciocodigo
@<Lexer: Rule D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Slash, backslash and multiplication symbol.

\iniciocodigo
@<Lexer: Rule E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Opening brackets

\iniciocodigo
@<Lexer: Rule F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Hash sign, ampersand, at sign and dollar sign.

\iniciocodigo
@<Lexer: Rule G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Circumflex accent and tilde.

\iniciocodigo
@<Lexer: Rule H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Opening brackets.

\iniciocodigo
@<Lexer: Rule I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Closing brackets.

\iniciocodigo
@<Lexer: Rule J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Opening and closing braces.

\iniciocodigo
@<Lexer: Rule K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Lexer: Rule L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo


After reading the characters for our new symbolic token, we check if
we have a reserved symbolic token: a token representing a language
keyword. We can check this using function \monoespaco{strcmp}
comparing the buffer with some keywords. For now we still will not
show this code because we did not define any reserved symbol, but
anyway we will already include the header to manipulate strings.

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <string.h>
@
\fimcodigo


If we do not have a reserved symbolic token, and if we have something
in our buffer, then we generate a new generic symbolic token:

\iniciocodigo
@<Lexer: New Generic Symbolic Token@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Set Pointer to Internal Variable@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

\secao{4. METAFONT Programs}

When we evaluate a METAFONT program, we need two additional
structures. The first one, which we will call \monoespaco{struct
metafont} will contain all the final information extracted from the
typographical font and that will be needed to render each glyph. The
second structure, which we will call \monoespaco{struct context}
represents the current state in our parser and represents information
that we need to know to interpret correctly the token list. This
second structure can be discarded after we read all the tokens from
our font.

The first thing that our parser needs to know is that a METAFONT
program is a list (possibly empty) of statements ended by a symbolic
token \monoespaco{end} or \monoespaco{dump}:

\alinhaverbatim
<Program> -> <List of Statements> end | <List of Statements> dump
\alinhanormal

for us, there will be no difference between these two kind of programs
and symbols \monoespaco{end} and \monoespaco{dump} will be
equivalent. In the original METAFONT, one of them ends programs that
define typographical fonts and the other ends the description of a
base file (something like a basic standard library).

We will define then a new kind of symbolic token to represent this
end-of-file marking:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>=
#define TYPE_END             8 // The symbolic token 'end' or 'dump'
@
\fimcodigo

And we generate this kind of token when our lexer finds one of these
two keywords (technically METAFONT call them ``sparks'', not
``keywords''):

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>=
if(!strcmp(buffer, "end") || !strcmp(buffer, "dump")){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_END;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

The first parser function to be defined is the one that recognizes an
entire program. It basically checks if the program is ended correctly
and if not, generates an error. If the program is ended correctly, it
passes for the next parser function that evaluates list of statements,
marking the beginning and end of such list:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  struct generic_token *previous = NULL;
  while(end != NULL && end -> type != TYPE_END){
    previous = end;
    end = (struct generic_token *) (end -> next);
  }
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file,
                    (previous == NULL)?(1):(previous -> line));
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, previous);
}
@
\fimcodigo

The context struct still will not be entirely defined. We will show
its content while each attribute becames necessary:

\iniciocodigo
@<Data Structures (metafont.h)@>=
struct context{
  @<Attributes (struct context)@>
};
@
\fimcodigo


And as seen above, one of the contents in \monoespaco{struct metafont}
is the file name from where the font was read. We also will store the
functions that will be use to allocate and disallocate the structure
and its elements:

\iniciocodigo
@<Data Structures (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Attributes (struct metafont)@>
};
@
\fimcodigo

Both data structures will have a function that initializes them and
also finalizes them:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct context *cx);
@
\fimcodigo

The structure \monoespaco{metafont} needs to store more informations,
as it could be allocated both using permanent or temporary memory
allocations. Meanwhile, the context always will be temporary and will
be allocated with temporary functions.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Initialization (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Initialization (struct context)@>
  return cx;
}
@
\fimcodigo

And this is the definition for the functions that frees the memory
occupied by these structures:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalization (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct context *cx){
  if(temporary_free != NULL){
    @<Finalization (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo


\secao{5. List of Statements}

A list of potentially empty statements delimited by a semicolon:

\alinhaverbatim
<List of Statements> -> <Empty> | <Statement> ; <List of Statements>
\alinhanormal

The function that will evaluate and interpret a list of statements is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

This function will iterate over each declaration and execute for all
them, in the order thay appear, the function that evaluates individual
statements. For this, the function will find all semicolons and use
them to detect where each statement begins and where they end:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
        if(!ret)
          return false;
      begin = end -> next;
    }
  }
  return ret;
}
@
\fimcodigo

The function above iterates over each statement, ignoring empty
statements. For each non-empty statement, it assures that the
pointers \monoespaco{begin} and \monoespaco{end} delimit the
individual statement. During the iteration we always ensure that we do
not go outside the region delimited by \monoespaco{begin\_token\_list}
and \monoespaco{end\_token\_list}.

\secao{6. Compound Statements}

An individual statement in the language can be composed by many other
statements. The syntax for this is:

\alinhaverbatim
<Statement> -> <Empty> | <Compound> | <Declaration> | <Assignment> |
               <Definition> | <Command>
<Compound> -> begingroup <List of Statements> <Non-Title> endgroup
\alinhanormal

We already know what is a list of statements and already have a
function to eval them. The non-title declaration, for now, will be
treated as any other statement, because we still do not support title
statements (they are isolated strings). Therefore, a compund statement
is just a list of statements delimited by
tokens \monoespaco{begingroup} and \monoespaco{endgroup}.

Then we need to take into account the existance of these two new kind
of special symbolic tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_BEGINGROUP             9 // O token simbólico 'begingroup'
#define TYPE_ENDGROUP              10 // O token simbólico 'endgroup'
@
\fimcodigo


And we add in the lexer the recipe about how to generate these tokens:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>+=
else if(!strcmp(buffer, "begingroup") || !strcmp(buffer, "endgroup")){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(buffer[0] == 'b')
    new_token -> type = TYPE_BEGINGROUP;
  else
    new_token -> type = TYPE_ENDGROUP;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

And now the function that will evaluate individual statements. As
seen, there are 8 different kinds of statements:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Statement: Empty@>
  @<Statement: Compound@>
  @<Statement: Declaration@>
  @<Statement: Assignment@>
  //@<Statement: Definition@> 
  //@<Statement: Command@>
  // If we are here, we could not identify the statement:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

In the case of an empty statement, probably we will not need to deal
with them. The function \monoespaco{eval\_list\_of\_statements}
silently ignore them before calling this function. But just in case an
empty statement appear by different means, we will explicitly accept
them with the code below:

\iniciocodigo
@<Statement: Empty@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Now let's deal with the compound statement. The first thing to recall
is that it will be important for the language to know in which nesting
level we are to know the scope of each declared variable. Because of
this, our context will store the current nesting
level. Each \monoespaco{begingroup} should increase by 1 the nesting
level and each \monoespaco{endgroup} should decrease by 1. We declare
the nesting level below:

\iniciocodigo
@<Attributes (struct context)@>=
  int nesting_level;
@
\fimcodigo

This should be initialized as zero:

\iniciocodigo
@<Initialization (struct context)@>=
  cx -> nesting_level = 0;
@
\fimcodigo


The second thing to recall is that if we are in a compound statement,
this means that the end of the declaration pointer could be wrong.
For example, supose that the
function \monoespaco{eval\_list\_of\_statements} evaluated the
following tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;]
\alinhanormal

The function correctly would consider the beginning of the first
statement the token \monoespaco{begingroup}. But wrongly would
consider the token \monoespaco{T2} as the end of this statement.
Because it works in a naive logic, always considering the semicolons
as the delimiters for statements, not considering that statements
could contain semicolons. The end of the first statement should be the
token \monoespaco{endgroup} instead.

Instead of increasing the complexity of
function \monoespaco{eval\_list\_of\_statements} making it aware of
compound statements, we will make the
function \monoespaco{eval\_statements} correct the pointers, making
the pointers to delimit correctly the statement. Only after correcting
the pointers, we can pass the list of statements from the compouns
statement to be evaluated:

\iniciocodigo
@<Statement: Compound@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  struct generic_token *t = begin_token_list, *previous = NULL;
  int nesting_level = 0;
  while(t != NULL){
    if(t -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(t -> type == TYPE_ENDGROUP){
      nesting_level --;
      if(nesting_level == 0)
        break;
    }
    previous = t;
    t = (struct generic_token *) (t -> next);
  }
  *end_token_list = t; // Now the statement is correctly delimited
  if(*end_token_list == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed 'begingroup'.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(previous == begin_token_list) // Empty compound statement
    return true;
  else{
    bool ret;
    cx -> nesting_level ++;
    ret = eval_list_of_statements(mf, cx, ((struct generic_token *)
                                         begin_token_list) -> next,
                                  previous);
    cx -> nesting_level --;
    return ret;
  }
}
@
\fimcodigo


\secao{7. Variable Declarations}

The syntax to declare variables is:

\alinhaverbatim
<Declaration> -> <Type> <List of Declarations>
<Type> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<List of Declarations> -> <Tag> | <Tag> , <List of Declarations>
\alinhanormal

A ``tag'' is basically a symbolic token without a predefined meaning
in the language. For example, ``\monoespaco{tag}'' is a tag, but
``\monoespaco{begingroup}'' is not.

To interpret a declaration, we will introduce the following special
tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_T_BOOLEAN               11 // Symbolic token 'boolean'
#define TYPE_T_PATH                  12 // Symbolic token 'path'
#define TYPE_T_PEN                   13 // Symbolic token 'pen'
#define TYPE_T_PICTURE               14 // Symbolic token 'picture'
#define TYPE_T_TRANSFORM             15 // Symbolic token 'transform'
#define TYPE_T_PAIR                  16 // Symbolic token 'pair'
#define TYPE_T_NUMERIC               17 // Symbolic token 'numeric'
@
\fimcodigo

And this is the code for the lexer to indentify these tokens:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>+=
else if(!strcmp(buffer, "boolean") || !strcmp(buffer, "path") ||
        !strcmp(buffer, "pen") || !strcmp(buffer, "picture") ||
        !strcmp(buffer, "transform") || !strcmp(buffer, "pair") ||
        !strcmp(buffer, "numeric")){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  switch(buffer[0]){
  case 'b':
    new_token -> type = TYPE_T_BOOLEAN; break;
  case 'n':
    new_token -> type = TYPE_T_NUMERIC; break;    
  case 't':
    new_token -> type = TYPE_T_TRANSFORM; break;
  default: // paTh, peN, piCture, paIr
    switch(buffer[2]){
      case 't':
        new_token -> type = TYPE_T_PATH; break;
      case 'n':
        new_token -> type = TYPE_T_PEN; break;
      case 'c':
        new_token -> type = TYPE_T_PICTURE; break;
      default:
        new_token -> type = TYPE_T_PAIR; break;
    }
  }
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

When a variable is declared, we need to do two things:

1) If the variable do not exist in the current nesting level, we
should allocate a new structure to store its content. If it already
exist in the current nesting level, an error is returned. A default
value depending of its type if stored in the variable. But it should
not be used before being initialized.

2) We iterate over the following tokens in the list of tokens until
the end of the list or until the current nesting level ends. When we
find a symbolic token with the variable name, we update its pointer to
the newly allocated variable.


As each variable type has its own information and content, the
specifics about how the variable is created can be different. What all
variables have in common is the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
// Generic variable
struct variable{
  int type;
  int nesting_level;
  void *next;  
};
@
\fimcodigo

All variables first store their type, then their nesting level, and
finally, a ponter for the next variable. Depending on the variable
type, more information could be stored after the pointer for the next
variable.

If we are dealing with a global variable, we could want to preserve
and store its name, just in case if later the user would want to
change the variable content indentifying it by the name. In this case,
we would want to use the following structure to store the name with
the variable:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

And the metafont structure will have pointers for these global
variables, with names and without:

\iniciocodigo
@<Attributes (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

These pointers are initialized with NULL:

\iniciocodigo
@<Initialization (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

To disallocate a list of global variables, we just iterate over the
linked list that they create. Some variables, which are more complex,
could need additional operations before removing them, but we will
deal with them later:

\iniciocodigo
@<Finalization (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

And to disallocate a list with preserved names, we act in a similar
way:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *v = (struct named_variable *)
                                 (mf -> named_variables);
  struct named_variable *next;
  while(v != NULL){
    next = (struct named_variable *) (v -> next);
    mf -> free(v -> name);
    mf -> free(v -> var);
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

In the case of variables that are not global, they will be stored in
contexts, not in the metafont struct. After all, their duration always
will be temporary:

\iniciocodigo
@<Attributes (struct context)@>=
  void *variables;
@
\fimcodigo

The list of variables is initialized as empty:

\iniciocodigo
@<Initialization (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

And we finalize it exactly as the list of global variables:

\iniciocodigo
@<Finalization (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

And now let's interpret the variable declaration:

\iniciocodigo
@<Statement: Declaration@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // Todos os tipos de declaração
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insert Declared Variable@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

Inserting a new variable follows the logic below:

\iniciocodigo
@<Insert Declared Variable@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

The function that inserts a new global variable without its name is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

It will allocate a new variable and store it in the local pointed
by \monoespaco{target}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Initializing New Variable@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Inserting a named variable is done with the following function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

The function works in a similar way, first allocating the structure
with the variable nam and then placing the variable there:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));

  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL)
    mf -> named_variables = named;
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

Anf finally, the function that search in a list of tokens for symbolic
tokens with the same name that the allocated new variable and updating
each one to make them point to the newly allocated variable position:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

The function will walk in the linked list starting in the token next
to the declared variable. And t will stop only when there is no more
tokens or when the variable do not exist anymore because we are not
more in its nesting level (it happens when we find
the \monoespaco{endgroup} which ends the current nesting level):

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo



\subsecao{7.1. Numeric Variables}

A numeric variable will be stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparing numeric variables with generic variables, the difference is
that we have an additional floating point variable in the structure
called \monoespaco{value}. It will store the numeric value. When we
create a numeric variable, we initialize it with NaN, which represents
an unknown value:

\iniciocodigo
@<Initializing New Variable@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

Using the macro \monoespaco{NAN} requires the mathematical header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

In the case of numeric variables, nothing additional is needed when we
deallocate them, as they have no additional structure besides a single
floating-point number.

However, besides the variables declared by the users, our version of
the Metafont language will have some additional internal
variables. They always will be present and do not need to be
declared. We will have exactly three of
them: \monoespaco{pt}, \monoespaco{cm} and \monoespaco{mm}. Basically
they will store how many pixels correspond to 1pt, 1cm and 1mm
respectively.

Such internal numeric variables will be declared in the metafont
struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

During the initialization we will allocate space for the three
variables and fill their values:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   pt;
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   28.3465 * pt; // 1cm = 28.3465pt
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   2.83465 * pt; // 1mm = 2.83465pt
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;    

  }
}
@
\fimcodigo

We also will create the following macros to access each one of these
variables more easily:

\iniciocodigo
@<Local Macros (metafont.c)@>=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

To finalize the metafont structure, we need to deallocate these
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

When our lexer creates a new symbolic token which is not a reserved
word, it should check if this token have the same name than an
internal variable. If so, we can then set correctly the pointer to the
variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\secao{8. Assignments}

Assignments are how we initialize variables, how we modify their
values and how we store the result of expressions.

The syntax for an assignment is:

\alinhaverbatim
<Assignment> -> <Variable> = <Right Side> |
                <Variable> := <Right Side> |
<Right Side> -> <Expression> | <Assignment>
\alinhanormal

This means that we can chain assignments, for example, in the code
below, all variables, if numeric, will store the value 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

If in the beginning of a statement we find a variable, then certainly
we are dealing with an assignment.

We will begin teaching our lexer that both tokens ``\monoespaco{=}''
and ``\monoespaco{:=}'' are equivalent, represent the same thing and
have an special meaning:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_ASSIGNMENT            18 // O token simbólico '=' ou ':='
@
\fimcodigo

And here is this new token generation:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>+=
else if(!strcmp(buffer, "=") || !strcmp(buffer, ":=")){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_ASSIGNMENT;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

Now that we have this new kind of token, the code to evaluate
assignments is described below. What it does is walk over the tokens
in the assignment detecting all variables that should pass by the
assignment. While it does it, it checks if all them are declared, if
all them have the same type, if we are assigning to something that is
not a variable, if we forget the assignment symbol, or if we are
missing an expression after the assignment. If one of these things are
detected, an error is generated.

The part that we still will not show is how we evaluate the expression
after the last assignment symbol and how in the end we update the
value for each variable to be equal what was evaluated. How we do
these things change depending on the variable types, each type have
its own expressions and its own way of storing the value in the
variables. These details will be shown in the next subsections.

\iniciocodigo
@<Statement: Assignment@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  int type = 0; // Tipo das variáveis na atribuição
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment.\n", mf -> file,
              var -> line);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;    
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;    
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  // @<Atribuição de Variável Numérica@>
  return true;
}
@
\fimcodigo


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim
