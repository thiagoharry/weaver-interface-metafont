k\input tex/epsf.tex
\font\sixteen=cmbx12
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx12
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\def\matrix#1#2#3#4#5#6#7#8#9{\left[{{#1 \atop #4}\atop
      {\scriptstyle #7}}{{#2 \atop #5}\atop {\scriptstyle #8}}{{#3\atop
      #6}\atop{\scriptstyle #9}}\right]}


\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{WEAVEFONT: A Description Language for Typographical Fonts}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of  WEAVEFONT, a language
 created to represent typographical fonts, vector illustrations and
 animations. The language is strongly based on METAFONT, a description
 language created by Donald Knuth in 1984. The syntax is very similar
 for both languages, but WEAVEFONT was created to run and produce images
 in real time using OpenGL. Therefore, changes were made to make the language
 faster for this goal. Contrary to METAFONT, WEAVEFONT do not support macros
 and is an imperative language. Several useful features from METAFONT that
 were implemented with macros, in WEAVEFONT are a direct part of the language.}

\secao{Index}

\def\indice#1{\leaders\hbox{.}\hfill #1}

1. Introduction \indice{3}

1.1. Literate Programming \indice{4}

2. General Auxiliary Code \indice{6}

2.1. Linear Algebra Code \indice{6}

2.2. Mutexes and Critical Sections \indice{9}

3. Initialization and Finalization \indice{10}

4. Lexer \indice{11}

4.1. Token Types \indice{11}

4.2. Lexical Analysis \indice{13}

5. WEAVEFONT Programs \indice{22}

5.1. Running Programs \indice{22}

5.2. Handling Errors \indice{24}

5.3. Splitting List of Statements in Individual Statements \indice{27}

6. A Compound Statement: The Compound Block \indice{29}

6.1. Supporting Compound Statements \indice{29}

6.2. The Statement \monoespaco{begingroup}$\ldots$\monoespaco{endgroup} \indice{34}

7. Variable Declarations \indice{35}

7.1. Numeric Variables \indice{41}

7.2. Pair Variables \indice{43}

7.3. Transform Variables \indice{43}

7.4. Path Variables \indice{44}

7.5. Pen Variables \indice{46}

7.6. Picture Variables \indice{50}

7.7. Boolean Variables \indice{52}

8. Assignments \indice{52}

8.1. Numeric Assignments and Expressions \indice{56}

8.1.1. Sum and Subtraction: Normal and Pythagorean \indice{56}

8.1.2. Multiplication and Division \indice{60}

8.1.3. Modulus, Sine, Cosine, Exponentials, Floor and
  Random Uniform Values \indice{63}

8.1.4. Isolated Numbers and Random Normal Values \indice{69}

8.2. Pair Assignments and Expressions \indice{73}

8.2.1. Sum and Subtraction \indice{73}

8.2.2. Transformers and Scalar Multiplication and Division \indice{75}

8.2.3. Pair Intermediary Values, Literals and Variables \indice{80}

8.2.4. Pairs in Numeric Expressions \indice{84}

8.3. Transform Assignments and Expressions \indice{86}

8.3.1. Transforming Transformers \indice{87}

8.3.2 Transform Tertiary Expressions: Literals and Variables \indice{90}

8.3.3. Transforms in Numeric Expressions \indice{93}

8.3.4. Transforms in Pair Expressions \indice{94}

8.4. Path Assignments and Expressions \indice{95}

8.4.1. Joining Paths \indice{XX}

8.4.2. Tertiary Path Expressions \indice{XX}

8.4.3. Secondary Path Expressions: Transformers \indice{XX}

8.4.4. Primary Path Expressions \indice{XX}

8.4.5. Path in Numeric Expressions \indice{XX}

8.4.6. Path in Pair Expressions \indice{XX}

8.5. Pen Assignments and Expressions \indice{XX}

8.5.1. Pen Tertiary Expression \indice{XX}

8.5.2. Pen Transformers \indice{XX}

8.5.3. Variables, Null Pen, Circular Pen and Arbitrary Pen \indice{XX}

8.5.4. Pens in Path Expressions \indice{XX}

8.6. Picture Assignments and Expressions \indice{XX}

8.6.1. Picture Tertiary Expressions: Sum and Subtraction \indice{XX}

8.6.2. Picture Secondary Expressions: Transformers \indice{XX}

8.6.3. Inverters, Identity and Empty Images \indice{XX}

8.6.4. Pictures in Numeric Expressions \indice{XX}

8.7. Boolean Assignments and Expressions \indice{XX}

8.7.1. Comparisons \indice{XX}

8.7.2. Operation OR \indice{XX}

8.7.3. Operator AND \indice{XX}

8.7.4. Boolean Literals, Variables, NOT and Simple Predicates \indice{XX}

8.8. Identifying Expression Types \indice{XX}

9. Compound Statements: Conditional Statement \indice{XX}

10. The \monoespaco{pickup} Command \indice{XX}

10.1. Extremity Points in Pens \indice{XX}

10.2. Triangulation \indice{XX}

10.3. Reading the \monoespaco{pickup} Command\indice{XX}

10.4. Operators \monoespaco{bot}, \monoespaco{top}, \monoespaco{lft},
\monoespaco{rt}\indice{XX}

11. The \monoespaco{draw} and \monoespaco{erase} Command\indice{XX}

11.1. Preparing Framebuffer \indice{XX}

11.2. Drawing Shaders\indice{XX}

11.3. Drawing Paths \indice{XX}

12. Compound Statement: Character Definition \indice{XX}

12.1 Unicode and UTF-8 \indice{XX}

13. API Functions to Use the Fonts \indice{XX}

References \indice{XX}


\secao{1. Introduction}

The first description language for typographical fonts was
METAFONT. It was created on 1984 by Donald Knuth and differs from
other formats for allowing a designer to create different fonts merely
by changing basic parameters in the base description of the font. This
way, a designer should not create a single typographic font, but a
meta-font from which new fonts could be obtained changing these basic
parameters. Here we also will call ``meta-font'' the fonts defined by
our system, which should not be confused with the METAFONT language.

The original specification for the METAFONT language can be found in
[KNUTH, 1989]. Based on this language, we will define here the
language WEAVEFONT, which will have similar goals, except that it will
be focused on defining typographical fonts that could be interpreted
and rendered on the fly.

The source-code defined in this article can be used standalone, or
together with more files from Weaver Geme Engine, as the language
WEAVEFONT is a part of that bigger project. When we run the source
code from inside the game engine, then we have the
macro \monoespaco{WEAVER\_ENGINE} defined. In this case, we must define
the following function:

\iniciocodigo
@<Function Declaration (metafont.h)@>=
#if defined(WEAVER_ENGINE)
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
#endif
@
\fimcodigo

This function will read a file (\monoespaco{source\_filename}) and
create after interpret its WEAVEFONT code a new vector image or a
vector animation.

And we will also need the header for Weaver user interfaces:

\iniciocodigo
@<Include General Headers (metafont.h)@>=
#if defined(WEAVER_ENGINE)
#include "interface.h"
#endif
@
\fimcodigo

Either if we are running our code from inside the Weaver Engine or
not, we always will need a function to load a new typographic font, a
meta-font from a file. After reading it, we can render the characters
defined there. Add after this, we will need to deallocate the struct
containing all the data from that font. Therefore, we will need to
export a function to create and another to destroy a meta-font read
from a file:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
struct metafont *_Wnew_metafont(char *filename);
void _Wdestroy_metafont(struct metafont *mf);
@
\fimcodigo

In a single project, we could read and keep in memory several
different meta-fonts to render the characters and images stored in
them. But before creating the first one, it is necessary to call a
initialization function that sets which functions will be called in
some contexts and also how many dots per inch has our screen (DPI):

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
bool _Winit_weavefont(void *(*temporary_alloc)(size_t),
                     void (*temporary_free)(void *),
                     void *(*permanent_alloc)(size_t),
                     void (*permanent_free)(void *),
                     uint64_t (*rand)(void), int dpi);
@
\fimcodigo

The functions passed as parameters are respectivelly the one that
allocates memory temporarily , other to free what was allocated by it,
a function to make more permanent allocation, the function that frees
what was allocated by it, a function that returns 64 random bits and
finally our DPI. The disallocation functions can be set to NULL. The
function returns true if the initialization was successful.

After using this library API, the function below should be called to
finalize it:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
void _Wfinish_weavefont(void);
@
\fimcodigo

If an error was found in a WEAVEFONT source code that defines a
meta-font, then the following exported function could be used to print
a diagnostic message in the screen:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
void _Wprint_metafont_error(struct metafont *);
@
\fimcodigo


\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{metafont.h}.

We can show the structure of the file \monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#include <stdlib.h> // Define 'atof' and 'abs' functions
#if defined(__linux__) || defined(BSD) || defined(__EMSCRIPTEN__)
#include <GLES3/gl3.h> // Our language renders with OpenGL
#endif
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif
@<Include General Headers (metafont.h)@>
//@<General Macros (metafont.h)@>
@<General Declarations (metafont.h)@>
@<Data Structures (metafont.h)@>
@<Function Declaration (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Function Declaration
(weaver.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{metafont.c} file related
with this header, its structure is:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Local Headers (metafont.c)@>
@<Local Macros (metafont.c)@>
@<Local Data Structures (metafont.c)@>
@<Local Variables (metafont.c)@>
@<Local Function Declaration (metafont.c)@>
@<Auxiliary Local Functions (metafont.c)@>
@<API Functions Definition (metafont.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\secao{2. General Auxiliary Code}

The code presented in this Section will be an introduction about how
we define code in this article. All code here will be widely used in
the next Sections and all code will be independant of the specific
data structure used by Weaver Metafont.

\subsecao{2.1. Linear Algebra Code}

We will use very frequently matrices $3\times 3$, that usually will
represent linear transformations over a vector space with 3
dimensions. Such matrices will be an array of 9 elements,
representing the matrix content.

The matrix elements will be organized as below, according with how
they are stored in array M:

$$
\matrix{M[0]}{M[1]}{M[2]}{M[3]}{M[4]}{M[5]}{M[6]}{M[7]}{M[8]}
$$


We can initialize an identity matrix with:

\iniciocodigo
@<Local Macros (metafont.c)@>=
#define INITIALIZE_IDENTITY_MATRIX(I) {\
  int _i;\
  for(_i = 0; _i < 9; _i++)\
    I[_i] = ((_i%4)?(0.0):(1.0));\
}   
@
\fimcodigo

Despite our dealings in a vector space with 3 dimensions, on practice
all the values we deal will be contained in the plane $\{(x, y, 1)\}$
with $x$ and $y$ being real numbers. The reason for working in 3
dimensions is that we want to represent translations (or shifting
points) as linear transforms, and this is only possible if we assume
that our 2D plane is inside a 3D vector space.

Given a 3-dimentional vector $(x, y, 1)$, we can transform it in a new
 vector $(x', y', 1)$ applying a linear transformation represented by
 the matrix below:

$$\left[x\; y\; 1\right]
\matrix{M[0]}{M[1]}{0}{M[3]}{M[4]}{0}{M[6]}{M[7]}{1}
=\left[x'\;\; y'\;\; 1\right]
$$

The new coordinates $(x', y')$ can be computed using the macros below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define LINEAR_TRANSFORM_X(x, y, M) (x * M[0] + y * M[3] + M[6])
#define LINEAR_TRANSFORM_Y(x, y, M) (x * M[1] + y * M[4] + M[7])
@
\fimcodigo

The matrix multiplication is associative as seen below:

$$
\left((x, y, 1)\cdot A\right) \cdot B = (x, y, 1)\cdot \left(A \cdot B\right)
$$

This means that the applying the linear transform $AB$ over a vector
is the same than first applying the linear transform $A$ and then the
linear transform $B$. The code below accumulate two linear transforms
computing $AB$ and storing the result in $A$. Notice that our code
always assumes that all matrices have $(0, 0, 1)^T$ as the last
column:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define MATRIX_MULTIPLICATION(A, B) {\
  float _a0 = A[0], _a1 = A[1], _a3 = A[3], _a4 = A[4], _a6 = A[6],\
        _a7 = A[7];\
  A[0] = _a0 * B[0] + _a1 * B[3];\
  A[1] = _a0 * B[1] + _a1 * B[4];\
  A[3] = _a3 * B[0] + _a4 * B[3];\
  A[4] = _a3 * B[1] + _a4 * B[4];\
  A[6] = _a6 * B[0] + _a7 * B[3] + B[6];\
  A[7] = _a6 * B[1] + _a7 * B[4] + B[7];\
}
@
\fimcodigo

Some linear transforms are very common. For them, we will create more
macros to perform them more easily. For example, rotating a vector
$(x, y, 1)$ around the axis $(0, 0, 1)$ by the angle $\theta$. This
can be done multiplying by the matrix:

$$\left[x\; y\; 1\right]
\matrix{cos(\theta)}{sin(\theta)}{0}{-\sin(\theta)}{cos(\theta)}{0}{0}{0}{1}
=\left[x\cdot cos(\theta) - y\cdot sin(\theta)\;\; x\cdot sin(\theta)
+ y\cdot cos(\theta)\;\; 1\right]
$$

Applying the linear transform above over a matrix can be done using
 the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_ROTATE(M, theta) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  double _cos_theta, _sin_theta;\
  _sin_theta = sin(theta);\
  _cos_theta = cos(theta);\
  M[0] = _m0 * _cos_theta - _m1 * _sin_theta;\
  M[1] = _m0 * _sin_theta + _m1 * _cos_theta;\
  M[3] = _m3 * _cos_theta - _m4 * _sin_theta;\
  M[4] = _m3 * _sin_theta + _m4 * _cos_theta;\
  M[6] = _m6 * _cos_theta - _m7 * _sin_theta;\
  M[7] = _m6 * _sin_theta + _m7 * _cos_theta;\
}
@
\fimcodigo

Another relevant linear transform is changing the vector sizes,
compressing or stretching them. To perform this in the axis $x$, we
multiply by the following matrix:

$$\left[x\; y\; 1\right]
\matrix{s}{0}{0}{0}{1}{0}{0}{0}{1}
=\left[sx\;\; y\;\; 1\right]
$$

And this is done by the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE_X(M, s) {\
  M[0] = M[0] * s;\
  M[3] = M[3] * s;\
  M[6] = M[6] * s;\
}
@
\fimcodigo

Perform this in the axis $y$ means multiplying:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{s}{0}{0}{0}{1}
=\left[x\;\; sy\;\; 1\right]
$$

And we use the following code:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE_Y(M, s) {\
  M[1] = M[1] * s;\
  M[4] = M[4] * s;\
  M[7] = M[7] * s;\
}
@
\fimcodigo

And doing this in both axis means just applying both transforms in any
order:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE(M, s) {\
  TRANSFORM_SCALE_X(M, s);\
  TRANSFORM_SCALE_Y(M, s);\
}
@
\fimcodigo

The translation, or shifting, is the only operation here that requires
three dimensions to work as a linear transform. Shifting a vector $a$
in the horizontal and $b$ in the vertical is done by the matrix
multiplication:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{1}{0}{a}{b}{1}
=\left[x+a\;\; y+b\;\; 1\right]
$$

This matrix multiplication is done using the following macro:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SHIFT(M, a, b) {\
  M[6] = M[6] + a;\
  M[7] = M[7] + b;\
}
@
\fimcodigo

Slant using $s$ as the intensity is performed by the multiplication:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{s}{1}{0}{a}{b}{1}
=\left[x+sy\;\; y\;\; 1\right]
$$

Which we apply over other matrices using the macro:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SLANT(M, s) {\
  M[0] = M[0] + s * M[1];\
  M[3] = M[3] + s * M[4];\
  M[6] = M[6] + s * M[7];\
}
@
\fimcodigo


The last special transform described here is changing the scale in the
complex plane. This means multiplying the points by a pair $(s, t)$,
treating all them as complex numbers. This performs a scale change and
a rotation at the same time. And it is done multiplying by the matrix:

$$\left[x\; y\; 1\right]
\matrix{s}{t}{0}{-t}{s}{0}{0}{0}{1}
=\left[sx-ty\;\; tx+sy\;\; 1\right]
$$

Performing this operation in another matrix can be done using:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE_Z(M, s, t) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  M[0] = _m0 * s - _m1 * t;\
  M[1] = _m0 * t + _m1 * s;\
  M[3] = _m3 * s - _m4 * t;\
  M[4] = _m3 * t + _m4 * s;\
  M[6] = _m6 * s - _m7 * t;\
  M[7] = _m6 * t + _m7 * s;\
}
@
\fimcodigo

\subsecao{2.2. Mutexes and Critical Sections}

A mutex is a data sctructure that controls the access for multiple
processes to a single common resource. They are treated differently
depending on the operating system and environment. Because of its
non-portability, we will introduce them here, we need to use slightly
different functions and declarations, depending on where the code is
compiled.

On Linux and BSD a Mutex is defined using the library
\monoespaco{pthread} and follows its naming convention. On Web Assembly,
Emscripten implements the same API, but it will work only if the web
page uses the correct HTTP headers. Because of this, we will use
mutexes on Web Assembly only if the user asks defining macro
\monoespaco{W\_ALWAYS\_USE\_THREADS}. On Windows there is a difference
between mutexes, which can be shared between multiple programs and
critical sections, which can be shared only between threds from a
single program. For our use case, we need a critical section, not a
mutex.

\iniciocodigo
@<Mutex Declaration@>=
#if defined(_WIN32)
CRITICAL_SECTION mutex;
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
pthread_mutex_t mutex;
#endif
@
\fimcodigo

This means that on Linux and BSD we need to insert the
header \monoespaco{pthread}. On windows, the default header that we
already placed on \monoespaco{metafont.h} is enough.

\iniciocodigo
@<Include General Headers (metafont.h)@>=
#if defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#include <pthread.h>
#endif
@
\fimcodigo

To initialize a mutex (or critical section), we use these functions:

\iniciocodigo
@<Local Macros (metafont.c)@>=
#if defined(_WIN32)
#define MUTEX_INIT(mutex) InitializeCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_INIT(mutex) pthread_mutex_init(&mutex, NULL);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_INIT(mutex)
#endif
@
\fimcodigo

When we do not need a mutex (or critical section) anymore, we need to
use some function to close it:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#if defined(_WIN32)
#define MUTEX_DESTROY(mutex) DeleteCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_DESTROY(mutex) pthread_mutex_destroy(&mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_DESTROY(mutex)
#endif
@
\fimcodigo

When we have a mutex, there are two main operations defined over
them. The first is asking to use the mutex. If another process is
already using it, then this call would block and we wait until the
mutex is free again:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#if defined(_WIN32)
#define MUTEX_WAIT(mutex) EnterCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_WAIT(mutex) pthread_mutex_lock(&mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_WAIT(mutex)
#endif
@
\fimcodigo

And finally, after we used the mutex, we can free it again, letting
other processes use it:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#if defined(_WIN32)
#define MUTEX_SIGNAL(mutex) LeaveCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_SIGNAL(mutex) pthread_mutex_unlock(&mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_SIGNAL(mutex)
#endif
@
\fimcodigo


\secao{3. Initialization and Finalization}

First we will define the initialization function. What it will do is
set some static variables that will be used by other functions. It
also will set in a variable our screen pixel density in DPI. The
variables that will store these information are:

\iniciocodigo
@<Local Variables (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int dpi;
@
\fimcodigo

And the initialization function that sets these variables:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
bool _Winit_weavefont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pixel_density){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  dpi = pixel_density;
  @<WEAVEFONT Initialization@>
  return true;
}
@
\fimcodigo

There is also a finalization function and when we update the
initialization function, we may need to update with correnponding code
the finalization function:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
void _Wfinish_weavefont(void){
  @<WEAVEFONT Finalization@>
}
@
\fimcodigo

Global variables and informations about a meta-font that need to be
kept on the long term, always will be allocated with the permanent
allocation function. Local variables inside the rendering instructions
for each character always will be allocated with the temporary
allocation function. If the memory manages distinguishes between these
two allocations (like in Weaver Game Engine), these will be two
different functions. In most other cases, the same function would be
passed in both arguments, probably a \monoespaco{malloc}. In this
case, both deallocation functions also would be the
same \monoespaco{free} function. In Weaver Game Engine, we hgave no
deallocation functions: the ``permanent'' allocation is freed in the
end of each game loop and the temporary allocation is freed at the end
of each frame.

As we expect that these functions will be called only once per
program, we do not need to use a mutex for them.

\secao{4. Lexer}

\subsecao{4.1. Token Types}

The first thing to be created for a language is its lexer. It will
read the source code in a file and will output a list of tokens, where
tokens are the most basic unit in the language. A token is like a
word: the most basic element in a language.

WEAVEFONT recognizes three kind of tokens: numeric, strings and
symbolic. In practice we will subdivide the symbolic tokens in several
kind of subtokens to store and read them in a more efficient way. Here
is where we define the three basic token types, and where we will
place all other subtypes of symbolic tokens:

\iniciocodigo
@<Local Data Structures (metafont.c)@>=
enum { // Token types
  TYPE_NUMERIC = 1, TYPE_STRING, TYPE_SYMBOLIC,
  // The 3 basic token types (numeric, string and symbolic) are above.
  // Others will be placed below:
  @<WEAVEFONT: Symbolic Token Definition@>
  // And the last one that shouldn't be used, except to represent errors:
  TYPE_INVALID_TOKEN
};
@
\fimcodigo

A numeric token will be represented internally as a floating point
number. This is different than specified in the original METAFONT,
where a custom fixed-point numeric representation was used. This
choice will make our operations over numbers faster, as we count with
hardware support for this. This is how a numeric token is represented:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct numeric_token{
  int type;   // Should be equal 'TYPE_NUMERIC'
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

And this is how we will represent string tokens:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct string_token{
  int type;   // Should be equal 'TYPE_STRING'
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
  // Pointer for the glyph represented by string (will be used in Section XXX)
  struct _glyph *glyph;
};
@
\fimcodigo

We will store only the first 4 bytes of each given string, even if in
the source code the string is bigger. This is so because unlike in the
original METAFONT, our only use for strings are saying wich Unicode
character each glyph should represent. For this we need only 4 bytes.

In the case of symbolic tokens, we need to store their entire name to
know which symbolic token we have. We should allocate dynamically
a string to store its name:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct symbolic_token{
  int type;   // Should be equal 'TYPE_SYMBOLIC'
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  void *var;
  char *value;
};
@
\fimcodigo

We also added in this token a pointer \monoespaco{var}, because the
token can represent a variable, and therefore could need to point to
the memory region with its content.

But this could consume much more memory than needed. Some symbols are
very common and are embedded in the language. These symbols could use
less space. For example, parenthesis, semicolon and commas. We can
represent them with the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct generic_token{
  int type;   // A subtype of symbolic token
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

We just need to define a subtype for each of them:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>=
TYPE_OPEN_PARENTHESIS,  // '('
TYPE_CLOSE_PARENTHESIS, // ')'
TYPE_COMMA,             // ','
TYPE_SEMICOLON,         // ';'
@
\fimcodigo


We can define later more reserved symbolic tokens. Notice that by
C \monoespaco{enum} rules, any token whose type is a number greater or
equal than 3 is a symbolic token.

Every token have a pointer to a next token. This happens because
usually they will be part of a linked list.

Tokens are created by the permanent allocation function. We need to
keep them on memory because we may need to read and interpret them
many times, each one to render a new character. Because of this, we
avoid to store in them information that is not needed. For example,
their line numbers in the source code is useful for debugging. Font
designers and image creators would use this information, but most
casual users never would debug the WEAVEFONT code that they run,
Because of this, we store this information only if we are in debugging
mode.

To deallocate the memory occupied by a token list, we can use the
following function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void free_token_list(void *token_list){
  if(permanent_free != NULL && token_list != NULL){
    struct generic_token *p, *p_next;
    p = token_list;
    while(p != NULL){
      p_next = p -> next;
      if(p -> type == TYPE_SYMBOLIC)
        permanent_free(((struct symbolic_token *) p) -> value);
      permanent_free(p);
      p = p_next;
    }
  }
}
@
\fimcodigo

\subsecao{4.2. Lexical Analysis}

Now the funtion that represents our lexer. It gets as argument the
struct for our meta-font (whose contents we still will define) and a
string with a path for the file with METAFONT source code. It will
produce a token list and will store in its two last arguments the
pointer for the first and last pointer.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void lexer(struct metafont *mf, char *path, struct generic_token **first_token,
           struct generic_token **last_token){
  FILE *fp;
  char c;
  int line = 1;
  *first_token = NULL;
  *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Lexer: Rule 1@>
    @<Lexer: Rule 2@>
    @<Lexer: Rule 3@>
    @<Lexer: Rule 4@>
    @<Lexer: Rule 5@>
    @<Lexer: Rule 6@>
    // No rule applied: error
    RAISE_ERROR_INVALID_CHAR(mf, NULL, line, c);
    free_token_list(first_token);
    *first_token = NULL;
    *last_token = NULL;
    return;
  }
  fclose(fp);
}
@
\fimcodigo

As we used the struct \monoespaco{FILE}, this means that we need to
include the header with data about input/output to be able to read
files:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

The rules to read tokens consist in reading each line in the source
code applying the following rules for each character in the line:

1) If the next character is a space, tabs or a period and is not followed by
a period or a decimal digit, then ignore this character and go to the
next one.

\iniciocodigo
@<Lexer: Rule 1@>=
if(c == ' ' || c == '\t' ||
   (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

As we are using \monoespaco{isdigit} function, we need to insert the
following header that declares this function:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo

2) If the character is a percent sign, ignore it and also ignore all
other following characters in this line. Percentage sign is how we
start comments in the language.

\iniciocodigo
@<Lexer: Rule 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) If the next character is a decimal digit or a period, then the next
token in numeric. It will be interpreted from the biggest sequence of
decimal digests and a single optional period representing the decimal
dot present in the input.

\iniciocodigo
@<Lexer: Rule 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token =
    (struct numeric_token *) permanent_alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL, 0); //We will define errors on Section 5.2.
    return;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo

4) If the next character is a double quote, the next token will be a
string. Its content will be all other characters until the next double
quote not preceded by a back slash that should be in the same line. If
we have a double quote opening a string, but the same line do not have
another double quote to close the string, this is an error. When
reading a back slash, we always ignore the first one, but we always
consider the next character. This rule allow us to represent a double
quote inside a string (in the form \monoespaco{"\\""}) and a backslash inside the
string (in the form \monoespaco{"\\\\"}).

\iniciocodigo
@<Lexer: Rule 4@>=
if(c == 34){ // 34: ASCII  for double quote
  struct string_token *new_token =
    (struct string_token *) permanent_alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL, line);
    return;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0, prev;
  do{
    prev = c;
    c = fgetc(fp);
    if(i < 5 && (c !='\\' || prev == '\\')){
      new_token -> value[i] = c;
      i ++;
    }
  } while((c != 34 || prev == '\\') && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    RAISE_ERROR_UNCLOSED_STRING(mf, NULL, line, new_token -> value);
    if(permanent_free != NULL)
      permanent_free(new_token);
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    return;
  }
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo


5) If the next character is a parenthesis, semicolon or a comma, the
next token will be symbolic and composed by that single character.

\iniciocodigo
@<Lexer: Rule 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) permanent_alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL,  line);
    return;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo

6) Otherwise, the next token will be symbolic and will be composed by
the longest sequence composed only by characters taken from one of 12
different families:

\iniciocodigo
@<Lexer: Rule 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer is read according with subrules 6-a to 6-l
  @<Lexer: Rule A@>
  @<Lexer: Rule B@>
  @<Lexer: Rule C@>
  @<Lexer: Rule D@>
  @<Lexer: Rule E@>
  @<Lexer: Rule F@>
  @<Lexer: Rule G@>
  @<Lexer: Rule H@>
  @<Lexer: Rule I@>
  @<Lexer: Rule J@>
  @<Lexer: Rule K@>
  @<Lexer: Rule L@>
  // Depending on buffer content, generates next token
  @<Lexer: New Reserved Symbolic Token@>
  @<Lexer: New Generic Symbolic Token@>
}
@
\fimcodigo

a) The first family of letters are the uppercase and lowercase
alphabetic letters, digits and underline. A digit cannot be the first
character in the sequence, otherwise it would be considered part of a
numeric token.

\iniciocodigo
@<Lexer: Rule A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) The second family is composed by the symbols for greater, equal and
lesser, colon and a pipe.

\iniciocodigo
@<Lexer: Rule B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acute and grave accents.

\iniciocodigo
@<Lexer: Rule C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Plus and minus.

\iniciocodigo
@<Lexer: Rule D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Slash, backslash and multiplication symbol.

\iniciocodigo
@<Lexer: Rule E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Opening brackets

\iniciocodigo
@<Lexer: Rule F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Hash sign, ampersand, at sign and dollar sign.

\iniciocodigo
@<Lexer: Rule G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Circumflex accent and tilde.

\iniciocodigo
@<Lexer: Rule H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Opening brackets.

\iniciocodigo
@<Lexer: Rule I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Closing brackets.

\iniciocodigo
@<Lexer: Rule J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Opening and closing braces.

\iniciocodigo
@<Lexer: Rule K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Lexer: Rule L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo


After reading the characters for our new symbolic token, we check if
we have a reserved symbolic token: a token representing a language
keyword. We can check this using function \monoespaco{strcmp}
comparing the buffer with some keywords. We will store a list of
keywords here:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static char* list_of_keywords[] = {
@<List of Keywords@>
  NULL};
@
\fimcodigo

Therefore, to know if we are dealing with a token that represents a
reserved keyword, we check if it is in this NULL terminated list. If
so, we create a token whose type is chosen according with the position
in this list:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // Token types for keywords begin in 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) permanent_alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(*first_token);
      *first_token = *last_token = NULL;
      RAISE_ERROR_NO_MEMORY(mf, NULL, line);
      return;
    }
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(*first_token == NULL)
      *first_token = *last_token = (struct generic_token *) new_token;
    else{
      (*last_token) -> next = (struct generic_token *) new_token;
      *last_token = (struct generic_token *) new_token;
    }
    continue;
  }
}
@
\fimcodigo

To use function \monoespaco{strcmp} we need the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <string.h>
@
\fimcodigo


If we do not have a reserved symbolic token, and if we have something
in our buffer, then we generate a new generic symbolic token. This
token will represent a variable:

\iniciocodigo
@<Lexer: New Generic Symbolic Token@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) permanent_alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL, line);
    return;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  // If this has the name of an internal variable, we can set the pointer
  // for its content right now:
  @<Set Pointer to Internal Variable@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) permanent_alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo

\secao{5. WEAVEFONT Programs}

\subsecao{5.1. Running Programs}

To evaluate a WEAVEFONT program, we need two additional
structures. The first one, which we will call \monoespaco{struct
metafont} will contain all the final information extracted from the
typographical meta-font and that will store all needed information to
render each glyph in that font. The second structure, which we will
call \monoespaco{struct context} represents the current state in our
parser and represents information that we need to know to interpret
correctly the token list. This second structure can be discarded after
we read all the tokens from our font.

In short, for each file with WEAVEFONT source-code, we will produce a
single \monoespaco{struct metafont} with data about the font. And each
time we execute code from this file (when we read the file for the
first time, and each time we render a new character), we create a
new \monoespaco{struct context}, which will be discarded after the
code execution.

The first thing that our parser needs to know is that a WEAVEFONT
program is a list (possibly empty) of statements:

\alinhaverbatim
<Program> -> <List of Statements>
\alinhanormal

In the METAFONT language, it was necessary to indicate the end of
statements with a final \monoespaco{end} statement. In WEAVEFONT
language this is not necessary becaus e we will assume that all code
is in a single file. Therefore, the end of file is the end of
statements.

The first parser function to be defined is the one that recognizes an
entire program. It first checks if the program is empty. If so, then
the function returns: doing nothing is the correct execution of an
empty program. Otherwise, it passes the entire list of statements for
the next function that will split them in individual statements and
execute each one individually. After we run the code, we return if the
execution was successful. 

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_program(struct metafont *mf, struct context *cx,
                  struct generic_token *first_token,
                  struct generic_token *last_token){
  if(first_token == NULL)
    return true;
  if(!eval_list_of_statements(mf, cx, first_token, last_token))
    return false;
  // Additional code to be defined in the future:
  @<After Program Execution@>
  return true;
}
@
\fimcodigo

The context struct still will not be entirely defined. We will show
its content while each attribute becames necessary. For now we will
just show a single variable in this structure that will store the
current UTF-8 character that is being rendered, or the empty string
if no character is being rendered:

\iniciocodigo
@<Data Structures (metafont.h)@>=
struct context{
  char current_character[5];
  @<Attributes (struct context)@>
};
@
\fimcodigo

For the meta-font struct, for now we will define three variables
stored in it. The first one is a mutex, as described in Subsection
2.2. Next we have a string with the filename from where the font
source code was read. The last one is a boolean variable that stores if
the font is still loading or if it finished. A font that is still
loading did not proccessed all the source code in its file. It is
still evaluating the source code statements for the first time. After
it evaluates all the code, then it is not anymore in loading mode and
is ready to render images.

\iniciocodigo
@<Data Structures (metafont.h)@>+=
struct metafont{
  @<Mutex Declaration@>
  char *file;
  bool loading;
  @<Attributes (struct metafont)@>
};
@
\fimcodigo

Both data structures will have a function that initializes them and
also finalizes them (the function that destroys a meta-font
struct, \monoespaco{\_Wdestroy\_metafont}, already was declared in
Section 1, when we listed the headers of functions that would be
exported for the user):

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct metafont *init_metafont(char *filename);
struct context *init_context(struct metafont *mf);
void destroy_context(struct metafont *mf, struct context *cx);
@
\fimcodigo

The structure \monoespaco{metafont} needs to store more informations,
as it could be allocated both using permanent or temporary memory
allocations. Meanwhile, the context always will be temporary and will
be allocated with temporary functions.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct metafont *init_metafont(char *filename){
  struct metafont *mf;
  mf = (struct metafont *) permanent_alloc(sizeof(struct metafont));
  if(mf == NULL)
    return NULL;
  MUTEX_INIT(mf -> mutex);
  // Copying the filename where the code is read
  size_t filename_size = strlen(filename) + 1;
  mf -> file = (char *) permanent_alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  // We initialize in the loading mode
  mf -> loading = true;
  // More code to be defined in the future:
  @<Initialization (struct metafont)@>
  return mf;
}
struct context *init_context(struct metafont *mf){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  if(cx == NULL){
    RAISE_ERROR_NO_MEMORY(mf, NULL, 0); // We will define errors on Section 5.2.
    return NULL;
  }
  cx -> current_character[0] = '\0';
  // To be defined in the future:
  @<Initialization (struct context)@>
  return cx;
}
@
\fimcodigo

And this is the definition for the functions that frees the memory
occupied by these structures:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
void _Wdestroy_metafont(struct metafont *mf){
  if(permanent_free != NULL){
    permanent_free(mf -> file);
    // To be defined in the future:
    @<Finalization (struct metafont)@>
    MUTEX_DESTROY(mf -> mutex);
    permanent_free(mf);
  }
}
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void destroy_context(struct metafont *mf, struct context *cx){
  if(temporary_free != NULL){
    // TO be defined in the future:
    @<Finalization (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo

Like we commented above, the boolean variable \monoespaco{loading}
inside the \monoespaco{struct metafont} must be set to false after the
program is read and executed for the first time. We defined in this
Subsection the code that reads the entire program for the first time
(function \monoespaco{eval\_program}). We just need to update that
code to set this variable to the correct value after the program is
executed:

\iniciocodigo
@<After Program Execution@>=
mf -> loading = false;
@
\fimcodigo

\subsecao{5.2. Handling Errors}

When there are errors in a WEAVEFONT source code, no image or
typographical meta-font will be created. However, the programmer
should have means to discover what was wrong to solve the problem. For
this, we will add in the struct for each meta-font additional data for
error handling and diagnostic:

\iniciocodigo
@<Attributes (struct metafont)@>=
  int errno, errno_line; // Error code and error line
  char errno_character[5]; // Character being rendered during error
  char *errno_str; // String with additional info
  int errno_int; // Integer with additional info
@
\fimcodigo

The idea is that if no error is raised, all the above variables will
be zero or NULL. Therefore, during initialization, we set these values
to zero:

\iniciocodigo
@<Initialization (struct metafont)@>=
mf -> errno = mf -> errno_line = 0;
mf -> errno_character[0] = '\0';
mf -> errno_str = NULL;
mf -> errno_int = 0;
@
\fimcodigo

As long as the first error is raised, the value of \monoespaco{errno}
will change to reflect the found error nature. If we are counting the
lines in our source code (which is true if the
macro \monoespaco{W\_DEBUG\_METAFONT} is defined), then the line where
the error happened also will be stored in \monoespaco{errno\_line}. If
more information must be passed, depending on error nature, we can use
the other variables to store some additional string or an integer.

Only the first error found in a meta-font source code will be
stored. If there are more errors, they will be ignored. All functions
that execute WEAVEFONT source code return a boolean value. If no
errors were found they return true; and if an error was found they
return false.

The different errors will be stored here:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
enum { // Types of error
  ERROR_NO_ERROR = 0,
  // All the different types of error that will be defined:
  @<Types of Error@>
  // And a last one that we hope that won't be used: unknown error
  ERROR_UNKNOWN
};
@
\fimcodigo

Given all the code that we defined until now, there are three
different types of error. Our memory allocation could fail when we
create a new token, context or any other auxiliary structure. Or our
lexer found an unsupported character in the source code. Or we began
defining a string with an opening double quote, but did not close it
until the end of line.

We will not worry here with errors outside the scope of lexical and
syntactic errors. For example, if an user tries to initialize a
meta-font with a file that does not exist, then the font never will be
created and we will have no lexical or syntactic errors.

As it is hard for an user dealing with all different errors when
reading the \monoespaco{errno} variable, a function will be exported
to print in the screen a message with error dignastic:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
void _Wprint_metafont_error(struct metafont *mf){
  char *line_number;
  // First we try to create a string with the error line number.
  // With this formula we compute its max size:
  int str_size = (int)((ceil(log10(mf -> errno_line))+1)*sizeof(char));
  line_number = (char *) temporary_alloc(str_size);
  // But if we have no line number, we keep the string empty:
  if(mf -> errno_line == 0)
    line_number[0] = '\0';
  else
    sprintf(line_number, "%d: ", mf -> errno_line);
  switch(mf -> errno){
  case ERROR_NO_ERROR:
    fprintf(stderr, "%s:%s No errors.\n", mf -> file, line_number);
    break;
  @<Print Error Message@>
  default:
    fprintf(stderr, "%s:%s Unknown error.\n", mf -> file, line_number);
  }
  if(mf -> errno_character[0] != '\0')
    fprintf(stderr, " (while rendering '%s')\n", mf -> errno_character);
  else
    fprintf(stderr, "\n");
  if(temporary_free != NULL)
    temporary_free(line_number);
}
@
\fimcodigo

To add new types of error, we place their names in the error enum,
which will create an error code for the new type. For example, for the
error when we have no memory, when we find an invalid character or
when we have an unclosed string, we could add the following 3 types:

\iniciocodigo
@<Types of Error@>=
ERROR_NO_MEMORY, ERROR_INVALID_CHAR, ERROR_UNCLOSED_STRING,
@
\fimcodigo

All errro code have some common elements. All them get a struct with a
meta-font, an optional struct with the context, a numeric value equal
either zero or the line number where the error was found and all
errors are identified by their numeric code. The following macro is
the generic code that all errrors execute when are raised:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_GENERIC_ERROR(mf, cx, line, error_code) {\
  struct context *_cx = cx;\
  if(!mf -> errno){\
    mf -> errno = error_code;\
    mf -> errno_line = line;\
    if(cx != NULL && _cx -> current_character[0] != '\0')\
      memcpy(mf -> errno_character, _cx -> current_character, 5);}}
@
\fimcodigo

The difference between all different errors is that they could store
different data in variables \monoespaco{errno\_int}
and \monoespaco{errno\_str} depending on their type. And some type of
errors do not store anything in these variables.

The error for insufficient memory, for example, is one of those that
do not store any other specific information:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_NO_MEMORY(mf, cx, line) {\
  RAISE_GENERIC_ERROR(mf, cx, line, ERROR_NO_MEMORY);}
@
\fimcodigo

If we have an unsupported character, the raised error store the
character value at \monoespaco{errno\_int}:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_INVALID_CHAR(mf, cx, line, char) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_INVALID_CHAR);\
    mf -> errno_int = char;}}
@
\fimcodigo

And finally, when raising the error for an unclosed string, we store
the string:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNCLOSED_STRING(mf, cx, line, str) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNCLOSED_STRING);\
    mf -> errno_str = (char *) permanent_alloc(strlen(str)+1);\
    memcpy(mf -> errno_str, str, strlen(str)+1);}}
@
\fimcodigo

To print an error message with diagnostics in the standard error
output for each one of the three types of errors, we use the code:

\iniciocodigo
@<Print Error Message@>=
case ERROR_NO_MEMORY:
  fprintf(stderr, "%s:%s Not enough memory for allocation.", mf -> file,
          line_number);
  break;
case ERROR_INVALID_CHAR:
  fprintf(stderr, "%s:%s Unsupported character in source code: '%x'.",
          mf -> file, line_number, (unsigned) mf -> errno_int);
  break;
case ERROR_UNCLOSED_STRING:
  fprintf(stderr, "%s:%s Unclosed string \"%s\".", mf -> file,
          line_number, mf -> errno_str);
  break;
@
\fimcodigo

Notice that in the unclosed string error we copied the offending
string to \monoespaco{errno\_str} after allocate space for this. This
means that when we are finalizing our \monoespaco{struct metafont}, we
need to check if there is something allocated there and disallocate if
needed:

\iniciocodigo
@<Finalization (struct metafont)@>=
if(mf -> errno_str != NULL && permanent_free != NULL)
  permanent_free(mf -> errno_str);
@
\fimcodigo

The biggest problem with the error macros above is that they require
as second argument the line where the error happened, or zero. If we
have the error line, usually, it is stored in each token. But this
information is lost and the line variable not even exist if the
macro \monoespaco{W\_DEBUG\_METAFONT} is not defined. This means that
when we raise an error, we should always check this macro to choose
the correct second argument: the line in the token where the error was
found or zero. But checking this all the time is a little verbose and
unconfortable.

To avoid this, we will define a new macro for optional variables that
do not exist if the macro \monoespaco{W\_DEBUG\_METAFONT} is not
defined. In this case, the macro just replace itself with the code
received as argument. Otherwise, the macro replaces itself with
zero. This will not cause an error, even if the variable given as
argument is not defined when the debug macro is not defined. The macro
is:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#if defined(W_DEBUG_METAFONT)
#define OPTIONAL(x) x
#else
#define OPTIONAL(x) 0
#endif
@
\fimcodigo



\subsecao{5.3. Splitting List of Statements in Individual Statements}

A list of statements is a possibly empty sequence of statements, which
can be empty, simple or compound and could be placed in any order:

\alinhaverbatim
<List of Statements> -> <Empty> |
                        <Empty> ; <List of Statements> |
                        <Simple Statement> ; <List of Statements> |
                        <Composite Statement> <List of Statements>
\alinhanormal

An empty or simple statement always must be terminated by a
semicolon. But compound statements do not need the semicolon as
delimiter because they already have some sequence of tokens that acts
as an opening for them, and another sequence that acts as their
closing. Between their opening and closing, they can contain other
statements, which also can be simple, empty or compound. For example,
an \monoespaco{if} and all the conditional code that is executed if
some condition is true are all part of a single compound statement.

To correctly evaluate our programs, we must be able to identify and
split single statements from a list of statements. Even when these
compound statements are more complex to be delimited. However, for
now, in this Subsection we will assume a simple heuristics to split
a list of statements in individual statements: we will assume that
all statements are delimited by semicolons.

The function that will split and identify individual statemetns is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_list,
                            struct generic_token *end_list);
@
\fimcodigo

This function job is just split each individual statement from the
list and pass the individual statements to another function that will
execute them. The code is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_list,
                            struct generic_token *end_list){
  struct generic_token *begin, *end = NULL;
  begin = begin_list;
  @<Before Evaluating Code@>
  while(begin != NULL){
    // This loop skips empty statements and places 'begin' in the beginning
    // of the next non-empty statement:
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_list)
        begin = begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    // This loop finds the last token before a ';' and places 'end' there:
    if(end != NULL){
      while(end != end_list && end -> next -> type != TYPE_SEMICOLON)
        end = end -> next;
    }
    // If we found something, we evaluate the individual statement:
    if(begin != NULL){
      if(!eval_statement(mf, cx, begin, &end))
        return false;
      // After evaluation, we place 'begin' in the ';' following 'end':
      if(end != end_list)
        begin = end -> next;
      else
        begin = NULL;
    }
  }
  @<After Evaluating Code@>
  return true;
}
@
\fimcodigo

The above function walks over the entire list of tokens. The loop
invariant for the most external \monoespaco{while} is that when the
iteration begins, the pointer \monoespaco{begin} is always either in a
semicolon token or in the token that is the beginning of the next
non-empty statement. In the first case, we move forward the pointer
ignoring the semicolons: we are just skipping empty
statements. After \monoespaco{begin} is placed in the beginning of
some non-empty statement, we update \monoespaco{end} to the position
of the next token before a semicolon. This way, both tokens now
delimit an individual statement, which we pass to
the \monoespaco{eval\_statement} function. After the evaluation, if we
found no errrors, we place \monoespaco{begin} in the next token, which
should be a semicolon, preserving the loop invariant.

Or at least, this is the illusion kept in that function. In reality,
as we passed the \monoespaco{end} token pointer
to \monoespaco{eval\_statement} by reference, not by value, this
pointer position can be updated when the statement is evaluated. This
happens when a compound function is evaluated: the pointer can be
moved to a backward or forward position based on which is the real
next statement to be executed if we take into account the rules for
compound statements. As this logic is handled
in \monoespaco{eval\_statement}, which we will define in the following
sections, the function \monoespaco{eval\_list\_of\_statements} becomes
very simple.

\secao{6. A Compound Statement: The Compound Block}

\subsecao{6.1. Supporting Compound Statements}

As we seen in the last Section, there are compound statements that can
be composed by several other statements. The gramatical rules for them
are:

\alinhaverbatim
<Compound Statement> -> <Compound Block> |
                        <Conditional> |
                        <Character Definition>
<Compound Block> -> begingroup <List of Statements> endgroup
<Conditional> -> if <Boolean Expression> :
                   <List of Statements>
                 fi
<Character Definition> -> beginchar <Character Description>
                            <List of Statements>
                          endchar
\alinhanormal

By the above rules, the compound statements are three: then can be
blocks (begin with \monoespaco{begingroup} and end
with \monoespaco{endgroup}), conditionals (begin with \monoespaco{if},
end with \monoespaco{fi}) or charactere definition (begin
with \monoespaco{beginchar}, end with \monoespaco{endchar}).

As there are list of statements inside compound statements,we can have
multiple compound statements nested inside each other. But each one
must be closed in the right order. If the last beginning of compound
statement was a \monoespaco{begingroup} and then we find
a \monoespaco{fi} or \monoespaco{endchar}, then the program is not
correct.

To read correctly compound statements, we need to take into account
their delimiting tokens, which we define below:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_BEGINGROUP,            // Symbolic token 'begingroup'
TYPE_ENDGROUP,              // Symbolic token 'endgroup'
TYPE_IF,                    // Symbolic token 'if'
TYPE_FI,                    // Symbolic token 'fi'
TYPE_BEGINCHAR,             // Symbolic token 'beginchar'
TYPE_ENDCHAR,               // Symbolic token 'endchar'
@
\fimcodigo

And we add them to the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>=
"begingroup", "endgroup", "if", "fi", "beginchar", "endchar",
@
\fimcodigo

And now the function that will evaluate individual statements.

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *,
                    struct generic_token *begin, struct generic_token **end);
@
\fimcodigo

The function gets pointers for the first and last tokens that should
delimit an individual statement. For simple statements, both pointers
are correct. For compound statements, that are not delimited by
semicolons as seen in the last Section, the first pointer is correct,
but the end pointer is not. Correcting the last pointer is the
responsability of \monoespaco{eval\_statement}, as this is the
function that know the rules for all individual statements.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_statement(struct metafont *mf, struct context *cx,
                    struct generic_token *begin, struct generic_token **end){
  @<Statement: Compound@>
  @<Statement: Declaration@>
  @<Statement: Assignment@>
  @<Statement: Command@>
  // If we are here, we could not identify the statement:
  RAISE_ERROR_UNKNOWN_STATEMENT(mf, cx, OPTIONAL(begin -> line));
  return false;
}
@
\fimcodigo

The above function will test if it is evaluating a simple or compound
statement. If none of the above options is identified, then we should
raise an error of unknown statement. First we will add this new type
of error:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNKNOWN_STATEMENT,
@
\fimcodigo

And when raising this error, we store information about it:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNKNOWN_STATEMENT(mf, cx, line) {\
  RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNKNOWN_STATEMENT);}
@
\fimcodigo

And if the user asks what went wrong, we print an error message:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNKNOWN_STATEMENT:
  fprintf(stderr, "%s:%s Unknown statement. Perhaps you misspelled some "
          "operator, forgot an assignment or placed a ';' in the wrong "
          "place.", mf -> file, line_number);
  break;
@
\fimcodigo

Now let's deal with the compound statement. The first thing to recall
is that it will be important for the language to know in which nesting
level we are to know the scope of each declared variable. Because of
this, our context will store the current nesting level. Each beginning
of compound statement
(\monoespaco{begingroup}, \monoespaco{if}, \monoespaco{beginchar})
should increase by 1 the nesting level and each ending of compound
statement
(\monoespaco{endgroup}, \monoespaco{fi}, \monoespaco{endchar}) should
decrease by 1. Therefore, we also must to know which token should end
the most recent nesting level. We should store in a stack the expected
tokens that should end our nestings. Therefore, we will know if a
compound statement is closed correctly. We declare the nesting level
and the stack of expected ending tokens below:

\iniciocodigo
@<Attributes (struct context)@>=
  int nesting_level;
  struct generic_token *end_token_stack;
@
\fimcodigo

The nesting level should be initialized to zero and the ending token
stack should begin empty:

\iniciocodigo
@<Initialization (struct context)@>=
  cx -> nesting_level = 0;
  cx -> end_token_stack = NULL;
@
\fimcodigo

To help us to manage nesting levels, we will create two auxiliary
functions. Both of them get as argument a \monoespaco{struct context}
with the evaluation context and a token. The first will begin a new
nesting level using that token and the second will end the current
nesting level. Both of them will return error if an invalid token is
supplied:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok);
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok);
@
\fimcodigo

The first function implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok){
  struct generic_token *end_token;
  end_token = (struct generic_token *)
                    temporary_alloc(sizeof(struct generic_token));
  if(end_token == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(tok -> line));
    return false;
  }
  // Only three types of tokens will be passed for this function:
  switch(tok -> type){
  case TYPE_BEGINGROUP:
    end_token -> type = TYPE_ENDGROUP;
    break;
  case TYPE_IF:
    end_token -> type = TYPE_FI;
    break;
  case TYPE_BEGINCHAR:
    end_token -> type = TYPE_ENDCHAR;
    break;
  default:
    return false;
  }
#if defined(W_DEBUG_METAFONT)
  end_token -> line = tok -> line;
#endif
  cx -> nesting_level ++;
  end_token -> next = cx -> end_token_stack;
  cx -> end_token_stack = end_token;
  return true;
}
@
\fimcodigo

And the second function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok){
  struct generic_token *end_tok = cx -> end_token_stack;
  if(end_tok == NULL){
    RAISE_ERROR_UNEXPECTED_TOKEN(mf, cx, OPTIONAL(tok -> line), tok -> type);
    return false;
  }
  else if(end_tok-> type != tok -> type){
    RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(tok -> line),
                               end_tok -> type, tok -> type);
    return false;
  }
  cx -> nesting_level --;
  cx -> end_token_stack = end_tok -> next;
  if(temporary_free != NULL)
    temporary_free(end_tok);
  return true;
}
@
\fimcodigo

Two different errors can be detected above. We could read the closing
of a compound statement when no compound statement was previously
opened or we could find the closing of some compound statement, when
the last opened compound statement was from another type. We will add
these two different types of error to the list:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNEXPECTED_TOKEN, ERROR_EXPECTED_FOUND,
@
\fimcodigo

In the first case, we store the unexpected token type as an integer in
the error variable:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNEXPECTED_TOKEN(mf, cx, line, tok) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNEXPECTED_TOKEN);\
    mf -> errno_int = tok;}}
@
\fimcodigo

The second case is the errror where we expected to find a given
symbolic token, but instead we found another. We must store in the
error data which was the expected type and what we found instead. The
first we will store as a string with its name. The other we will
store as an integer with its numeric code:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_EXPECTED_FOUND(mf, cx, line, expected, found) {\
  if(!mf -> errno){\
    mf -> errno_int = found;\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_EXPECTED_FOUND);\
    if(found >= 8){\
      size_t _s = strlen(list_of_keywords[found - 8]);\
      mf -> errno_str = (char *) permanent_alloc(_s+1);\
      memcpy(mf -> errno_str, list_of_keywords[expected - 8], _s+1);\
    } else{\
      size_t _s = strlen(token_names_not_in_list_of_keywords[found]);\
      mf -> errno_str = (char *) permanent_alloc(_s+1);\
      memcpy(mf -> errno_str, \
             token_names_not_in_list_of_keywords[expected], _s+1);}}}
@
\fimcodigo

In the above macro we generate the name of the expected token type
thanks to the fact that each token type is a sequential number (all
them are inside an \monoespaco{enum}, defined in Subsection 4.1) and
the name for almost all types is stored in a list of keyword names,
which is also sequential, in the same order than
then \monoespaco{enum} (this list is in Subsection 4.2). Getting a
name, given a numeric code for the type is as simple as subtract the
numeric code and use the result as an index to check the list of
names. For some tokens this does not work: tokens whose numeric code
is smalled than 8 are not treated like keywords and their names is not
in the list. Therefore, we read their names from this other list:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static char *token_names_not_in_list_of_keywords[] = {
  "nil", "<Numeric>", "<String>", "<Variable Name>", "(", ")", ",", ";"};
@
\fimcodigo


To print the error message in both cases, we use the same conversion
from numeric code for the type to the string name, but apply to the
informationstored as integer in \monoespaco{errno\_int}:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNEXPECTED_TOKEN:
  fprintf(stderr, "%s:%s We found '%s' token in a context where such "
          "token makes no sense.", mf -> file, line_number,
          ((mf -> errno_int < 8)?
          (token_names_not_in_list_of_keywords[mf -> errno_int]):
          (list_of_keywords[mf -> errno_int - 8])));
  break;
case ERROR_EXPECTED_FOUND:
  fprintf(stderr, "%s:%s Expected '%s' token. Found '%s' token.",
          mf -> file, line_number, mf -> errno_str,
          ((mf -> errno_int < 8)?
          (token_names_not_in_list_of_keywords[mf -> errno_int]):
          (list_of_keywords[mf -> errno_int - 8])));
  break;
@
\fimcodigo

Notice that if an error happens inside a compound statement, we could
stop the code execution before calling
the \monoespaco{end\_nesting\_level}. Bacause of this, when freeing
the memory for a context, we need to destroy any remaining token in
the stack of expected ending tokens:

\iniciocodigo
@<Finalization (struct context)@>=
if(temporary_free != NULL){
  while(cx -> end_token_stack != NULL){
    struct generic_token *end_tok = cx -> end_token_stack;
    cx -> end_token_stack = end_tok -> next;
    temporary_free(end_tok);
  }  
}
@
\fimcodigo

\subsecao{6.2. The Statement \monoespaco{begingroup}$\ldots$\monoespaco{endgroup}}

How exactly a statement is evaluated? First, recall
that \monoespaco{eval\_list\_of\_statements} function splits the code
using semiconlons as delimiters. Next, each part is given as input to
function \monoespaco{eval\_statement}. As already mentioned, this
behaviour may be a little naive, as compound statements are full
statements that can contain semicolons and other statements. Consider
the following list of tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;][T5];
\alinhanormal

In this sequence, the first three tokens would be passed to be
evaluated. Next would be \monoespaco{[T3][T4]}. And
finally, \monoespaco{[endgroup][T5]}. This is wrong, as we ideally
should evaluate first the beginning of a new nesting block
with \monoespaco{[begingroup]}. Next, each statement in the
block. Next, we end the nesting with \monoespaco{[endgroup]}. And only
then we evaluate \monoespaco{[T5]}.

Fortunately, it's easy to evaluate things in this order. When we get
the three first tokens in the example above, we will evaluate
only \monoespaco{begingroup}, and we will give back the other two
tokens to be evaluated later. We can do this changing the position of
the pointer that marks the end of current statement, like explained in
Subsection 5.3.

When we get the \monoespaco{endgroup}, we will do the same: we
evaluate only the \monoespaco{endgroup} part to close the compound
statement and give back any remaining tokens.

The code to deal with any statement that begins
with \monoespaco{begingroup} is:

\iniciocodigo
@<Statement: Compound@>=
if(begin -> type == TYPE_BEGINGROUP){
  begin_nesting_level(mf, cx, begin);
  // This sets the beginning of next statement as the token after 'begingroup':
  *end = begin;
  return true;
}
@
\fimcodigo

In the same way, if we get an statement that begins
with \monoespaco{endgroup}, we evaluate only this first token
finishing the current nesting level:

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_ENDGROUP){
  if(!end_nesting_level(mf, cx, begin))
    return false;
  *end = begin;
  return true;
}
@
\fimcodigo

What if we finish the evaluation of a program, but we did not finished
some compound statement? In this case, we have a new type of error:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNFINISHED_STATEMENT,
@
\fimcodigo

When this error is raised, we store as an integer the token that began
the unfinished compound statement:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNFINISHED_STATEMENT(mf, cx, line, statement) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNFINISHED_STATEMENT);\
    mf -> errno_int = statement;}}
@
\fimcodigo

The error message warns the user what happened:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNFINISHED_STATEMENT:
  fprintf(stderr, "%s:%s Unfinished statement '%s'.",
          mf -> file, line_number, list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

Always at the end, after evaluating a WEAVEFONT code, the following
test is done to check for this error:

\iniciocodigo
@<After Program Execution@>=
if(cx -> nesting_level > 0){
  RAISE_ERROR_UNFINISHED_STATEMENT(mf, cx,
                                  OPTIONAL(cx -> end_token_stack -> line),
                                  cx -> end_token_stack -> type);
  return false;
}
@
\fimcodigo


\secao{7. Variable Declarations}

The variable declaration is the first of the simple statements that we
will describe. The syntax to declare variables is:

\alinhaverbatim
<Simple Statement> -> <Declaration> | ...
<Declaration> -> <Type> <List of Declarations>
<Type> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<List of Declarations> -> <Tag> | <Tag> , <List of Declarations>
\alinhanormal

A ``tag'' is basically a symbolic token without a predefined meaning
in the language. For example, ``\monoespaco{tag}'' is a tag, but
``\monoespaco{begingroup}'' is not.

To interpret a declaration, we will introduce the following special
tokens:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_T_BOOLEAN,               // Symbolic token 'boolean'
TYPE_T_PATH,                  // Symbolic token 'path'
TYPE_T_PEN,                   // Symbolic token 'pen'
TYPE_T_PICTURE,               // Symbolic token 'picture'
TYPE_T_TRANSFORM,             // Symbolic token 'transform'
TYPE_T_PAIR,                  // Symbolic token 'pair'
TYPE_T_NUMERIC,               // Symbolic token 'numeric'
@
\fimcodigo

And then we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


When a variable is declared, we need to do two things:

1) If the variable do not exist in the current nesting level, we
should allocate a new structure to store its content. If it already
exist in the current nesting level, an error is returned. A default
value depending of its type if stored in the variable. But it should
not be used before being initialized.

2) We iterate over the following tokens in the list of tokens until
the end of the list or until the current nesting level ends. When we
find a symbolic token with the variable name, we update its pointer to
the newly allocated variable.

As each variable type has its own information and content, the
specifics about how the variable is created can be different. What all
variables have in common is the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
// Generic variable
struct variable{
  int type;
  struct variable *next;
};
@
\fimcodigo

All variables first store their type, then a pointer for the next
variable. Depending on the variable type, more information could be
stored after this pointer.

If we are dealing with a global variable, we could want to preserve
and store its name, just in case if later the user would want to
change the variable content indentifying it by the name. In this case,
we would want to use the following structure to store the name with
the variable:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct named_variable{
  char *name;
  struct named_variable *next;
  struct variable *var;
};
@
\fimcodigo

And the metafont structure will have pointers for these named global
variables, and also for other variables stored there:

\iniciocodigo
@<Attributes (struct metafont)@>=
  struct named_variable *named_variables;
  struct variable *variables;
@
\fimcodigo

These pointers are initialized with NULL:

\iniciocodigo
@<Initialization (struct metafont)@>=
mf -> named_variables = NULL;
mf -> variables = NULL;
@
\fimcodigo

To disallocate a list of variables storen on the meta-font, we just
iterate over their linked list. Some variables, which are more
complex, could need additional operations before removing them, but we
will deal with them later. Here we disallocate the variables whose
names we did not preserve:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(permanent_free != NULL){
  struct variable *v = (struct variable *) (mf -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Variable 'v' in 'struct metafont'@>
    permanent_free(v);
    v = next;
  }
}
@
\fimcodigo

And to disallocate a list with preserved names, we act in a similar
way, we just need to also disallocate the structure where we store
their names:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(permanent_free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) named -> var;
    next = (struct named_variable *) (named -> next);
    permanent_free(named -> name);
    @<Finalize Variable 'v' in 'struct metafont'@>
    permanent_free(v);
    permanent_free(named);
    named = next;
  }
}
@
\fimcodigo

In the case of variables that are declared inside a character
specification to be rendered, they will be stored in contexts, not in
the metafont struct. After all, their duration always will be
temporary:

\iniciocodigo
@<Attributes (struct context)@>=
  struct variable *variables;
@
\fimcodigo

The list of variables is initialized as empty:

\iniciocodigo
@<Initialization (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

And we finalize it exactly as the list of global variables:

\iniciocodigo
@<Finalization (struct context)@>+=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Variable 'v' in 'struct context'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

And now let's interpret the variable declaration:. If we find a
variable type in the beginning of a new statement, this means that
this statement is a variable declaration. We just need to get the type
and iterate over all the declared variables creating them. THe
variable names are always intercalated by commas if there is more than
one variable being declared:

\iniciocodigo
@<Statement: Declaration@>=
else if(begin -> type >= TYPE_T_BOOLEAN && begin -> type <= TYPE_T_NUMERIC){
  int type = begin -> type;
  struct symbolic_token *variable = (struct symbolic_token *) (begin -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(variable -> line),
                                 TYPE_SYMBOLIC, variable -> type);
      return false;
    }
    @<Insert Declared Variable@>
    if(variable != (struct symbolic_token *) *end)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(variable -> line),
                                 TYPE_COMMA, variable -> type);
      return false;
    }
    if(variable == (struct symbolic_token *) *end){ // Error: ended with ','
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL((*end) -> line),
                                 TYPE_SEMICOLON, TYPE_COMMA);
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

Creating and inserting a new variable in the code fragment above
means:

\iniciocodigo
@<Insert Declared Variable@>=
{
  void *variable_pointer;
  if(mf -> loading){ // Variable should be stored in 'struct metafont'
    if(cx -> nesting_level != 0 || variable -> value[0] == '_')
      variable_pointer = insert_variable(mf, type, variable,
                                         &(mf -> variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(mf, type, variable, &(cx -> variables));
  if(variable_pointer == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(variable -> line));
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

The function that inserts a new global variable without its name is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_variable(struct metafont *mf,
                                 int type,
                                 struct symbolic_token *variable,
                                 struct variable **target);
@
\fimcodigo

It will allocate a new variable and store it in the local pointed
by \monoespaco{target}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_variable(struct metafont *mf,
                                 int type,
                                 struct symbolic_token *variable,
                                 struct variable **target){
  struct variable *var;
  size_t var_sizes[] = {
    sizeof(struct boolean_variable), sizeof(struct path_variable),
    sizeof(struct pen_variable), sizeof(struct picture_variable),
    sizeof(struct transform_variable), sizeof(struct pair_variable),
    sizeof(struct numeric_variable)
  };
  size_t var_size = var_sizes[type-TYPE_T_BOOLEAN];
  if(mf -> loading)
    var = (struct variable *) permanent_alloc(var_size);
  else
    var = (struct variable *) temporary_alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    @<Initializing New Variable@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Inserting a named variable is done with the following function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

The function works in a similar way, first allocating the structure
with the variable nam and then placing the variable there. As we only
preserve the name of global variables, we surely should use the
permanent allocation function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              permanent_alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) permanent_alloc(name_size);
  if(named -> name == NULL){
    if(permanent_free != NULL)
      permanent_free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(mf, type, var, &(named -> var));
  if(new_var == NULL){
    if(permanent_free != NULL){
      permanent_free(named -> name);
      permanent_free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL)
    mf -> named_variables = named;
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

And finally, the function that search in a list of tokens for symbolic
tokens with the same name that the allocated new variable and updating
each one to make them point to the newly allocated variable position:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

The function will walk in the linked list starting in the token next
to the declared variable. And t will stop only when there is no more
tokens or when the variable do not exist anymore because we are not
more in its nesting level (it happens when we find
the \monoespaco{endgroup}, \monoespaco{fi} or \monoespaco{endchar}
which ends the current nesting level):

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = (struct symbolic_token *) var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP || p -> type == TYPE_IF ||
       p -> type == TYPE_BEGINCHAR)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP || p -> type == TYPE_FI ||
            p -> type == TYPE_ENDCHAR)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Numeric Variables}

A numeric variable will be stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  void *next;
  float value;
};
@
\fimcodigo

Comparing numeric variables with generic variables, the difference is
that we have an additional floating point variable in the structure
called \monoespaco{value}. It will store the numeric value. When we
create a numeric variable, we initialize it with NaN, which represents
an unknown value:

\iniciocodigo
@<Initializing New Variable@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

Using the macro \monoespaco{NAN} requires the mathematical header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

In the case of numeric variables, nothing additional is needed when we
deallocate them, as they have no additional structure besides a single
floating-point number.

However, besides the variables declared by the users, we will have
some additional internal variables. They always will be present and do
not need to be declared. We have exactly six internal numeric
variables: \monoespaco{pt}, \monoespaco{cm}, \monoespaco{mm}, \monoespaco{w},
\monoespaco{h} and \monoespaco{d}. Basically the first three
will store how many pixels correspond to 1pt, 1cm and 1mm
respectively. The next three will store the width, height and depth of
some glyph that we are rendering, or will store zero when we are not
rendering something.

Such internal numeric variables will be declared in the meta-font
struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

During the initialization we will allocate space for the three
variables and fill their values:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_numeric_variables =
             permanent_alloc(6 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   ((double) dpi) / 72.0; // 1in = 72 pt
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   ((double) dpi) / 2.54; // 1in = 2.54cm
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   ((double) dpi) / 25.4; // 1in = 25.4mm
{
  int i;
  for(i = 0; i < 6; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;
  }
}
@
\fimcodigo

We also will create the following macros to access each one of these
variables more easily:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
#define INTERNAL_NUMERIC_W  3
#define INTERNAL_NUMERIC_H  4
#define INTERNAL_NUMERIC_D  5
@
\fimcodigo

To finalize the metafont structure, we need to deallocate these
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(permanent_free != NULL)
  permanent_free(mf -> internal_numeric_variables);
@
\fimcodigo

When our lexer creates a new symbolic token which is not a reserved
word, it should check if this token have the same name than an
internal variable. If so, we can then set correctly the pointer to the
variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
else if(!strcmp(buffer, "w")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_W]);
}
else if(!strcmp(buffer, "h")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_H]);
}
else if(!strcmp(buffer, "d")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_D]);
}
@
\fimcodigo

\subsecao{7.2. Pair Variables}

A pair variable will store point coordinates. They will be stored in
the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct pair_variable{
  int type; // Must be 'TYPE_T_PAIR'
  void *next;
  float x, y;
};
@
\fimcodigo

The difference is that they have space for two floating point values
instead of one. Initially we will represent the first of them with NaN
to represent a non-initialized pair:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Transform Variables}

If a pair variable is a tuple with two numeric values, then a
transform variable is a tuple with six different values. Let's assume
that a transform variable is $(a, b, c, d, e, f)$, what it represents
is a linear transformation in which the pair $(x, y)$ is transformed
in $(x', y')$ by the following matrix multiplication:

$$\left[x\; y\;
      1\right]\matrix{c}{e}{0}{d}{f}{0}{a}{b}{1}=\left[x'\;\; y'\;\;
      1\right]
$$

Or: $(x', y') = (a+cx+dy, b+ex+fy)$.

The order in which we store and use the elements may appear strange,
but we store them in that order for compatibility with the notation
from original METAFONT created by Knuth.

A transform variable therefore, needs to store a linear transformation
in a matrix form:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct transform_variable{
  int type; // Deve ser 'TYPE_T_TRANSFORM'
  void *next;
  float value[9];
};
@
\fimcodigo

A non-initialized transform variable, by default, has its first value marked
as NAN:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_TRANSFORM)
  ((struct transform_variable *) var) -> value[0] = NAN;
@
\fimcodigo

There is an internal transform variable that always is presente and
that represents no transformation at all.  A transform that do not
change the point, that in the metrix notation represents multiplying
by the identity matrix. This transform is represented by the tuple
$(0, 0, 1, 0, 0, 1)$.

The internal transform variables will be stored here:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct transform_variable *internal_transform_variables;
@
\fimcodigo

During initialization we allocate memory for the internal variables
and initialize them:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_transform_variables =
  (struct transform_variable *)
    permanent_alloc(sizeof(struct transform_variable));
if(mf -> internal_transform_variables == NULL){
  if(permanent_free != NULL)
    permanent_free(mf);
  return NULL; //ERRO: Sem memria suficiente
}
// The transform variable 'identity':
mf -> internal_transform_variables[0].type = TYPE_T_TRANSFORM;
INITIALIZE_IDENTITY_MATRIX(mf -> internal_transform_variables[0].value);
@
\fimcodigo

In the finalization, we need to free the allocated memory:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(permanent_free != NULL)
  permanent_free(mf -> internal_transform_variables);
@
\fimcodigo

The variable \monoespaco{identity} will be stored as the first
position in the array of internal transform variables:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_TRANSFORM_IDENTITY 0
@
\fimcodigo

And when reading the source code, we can set correctly the pointer
each time we find a token referencing this internal variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>+=
else if(!strcmp(buffer, "identity"))
  new_token -> var =
          &(mf -> internal_transform_variables[INTERNAL_TRANSFORM_IDENTITY]);
@
\fimcodigo


\subsecao{7.4. Path Variables}

Path variables are the most complex variables in the WEAVEFONT
language. They store a sequence of curves, where the next curve begins
in the same point where the last ended. Each curve can be represented
in several different formats. But all them are cubic Bezir
curves. The path may be cyclic, when the last curve ends in the same
point where the first curbe begins. To store the path contents, we may
need to allocate additional structures. Basically a path variable
store most of it data in a ``point'' array, where each point in the
array is a literal point of the curve with additional data, or is a
pointer to several points that compose a subpath. The variable that
stores a path is:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct path_variable{
  int type; // Must be 'TYPE_T_PATH'
  void *next;
  bool permanent; // Which allocation was used: permanent or temporary
  bool cyclic;
  int length, number_of_points;
  struct path_points *points;
};
@
\fimcodigo

The number of points in a path variable is always greater or equal
than the variable \monoespaco{length}, as each position in the array
with \monoespaco{length} elements is either a point or a subpath with
1 or more points.

In fact, each point in the array may be in one of three different
formats:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define UNINITIALIZED_FORMAT 0 // Do not use, it's just for initialization
#define PROVISIONAL_FORMAT   1 // Still collecting data about the point
#define SUBPATH_FORMAT       2 // Pointer for several points in subpath
#define FINAL_FORMAT         3 // Final format, ready for use
@
\fimcodigo

Now we describe how is the final format, which we expect for our
points.

A Cubic Bezir Curve is defined by two extremity points ($z_1$ and
$z_4$) and two control points ($z_2'$ and $z_3'$). The two extremity
curves are always part of the curve. To obtain the other curve points
given the four points $(z_1, z_2', z_3', z_4)$, we use the following
procedure:

1) Get three intermediate points: $z_{12}'$ is the point halfway the
points $z_1$ and $z_2'$, $z_{23}'$ is the point halfway between $z_2'$
and $z_3'$ and $z_{34}$ is the point halfway between $z_3'$ and $z_4$.

2) Get two intermediate points: $z_{123}'$ is the point halfway
between $z_{12}'$ and $z_{23}'$ while $z_{234}'$ is the point halfway
between $z_{23}'$ and $z_{34}'$.

3) Get the new curve point $z_{1234}$ located halfway between
$z_{123}'$ and $z_{234}'$.

4) Generate the remaining curve points repeating this procedure
recursively over the points $(z_1, z_{12}', z_{123}', z_{1234})$ and
over $(z_{1234}, z_{234}', z_{34}', z_4)$.

It is also possible to define such curves using a formula. Given the
extremity points and the control points, a Cubic Bezir Curve is
defined by the following formula if we vary $t$ between 0 and 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

The data structure that will represent a sequence of Cubic Bezir
Curves is:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct path_points{
  int format; // The point format
  union{
    // Final format: extremity point and 2 control points
    struct{
      float x, y; // Extremity point
      float u_x, u_y, v_x, v_y;   // Next 2 control points after it
    } point;
    // Subpath format: pointer to subpath
    struct path_variable *subpath;
    // Provisional format: other info besides the control points
    struct{
      float x, y; // Ponto de extremidade
      float dir1_x, dir1_y, dir2_x, dir2_y; // Especificadores de direo
      float tension1, tension2;
      bool at_least1, at_least2;
    } prov;
  };
};
@
\fimcodigo

Basically its points will be stored in the
pointer \monoespaco{points}, an array of structs whose number of
elements is equal \monoespaco{length}. Each structure will represent a
point $(x, y)$ or a subpath (if \monoespaco{subpath} is not null, and
in this case we ignore $x$ and $y$). To check the number of points in
a path variable, one could read variable \monoespaco{total\_length}
that considers the points stored recursively in other linked path
variables. The variable \monoespaco{length} stores only the size of
array \monoespaco{points}.

The control points defined
by \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
and \monoespaco{v\_y} are the control points between the current point
or subpath and the next one if it exists. If we have a cyclic path,
the control points in the last point or subpath show how it is
connected to the first point in the path. If we are not in a cyclic
path, then the control points of the last point is ignored.

We will represent a non-initialized path variable setting its length
as -1:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
  ((struct path_variable *) var) -> permanent = mf -> loading;
}
@
\fimcodigo

When we remove a global variable, if it is a path variable and if it
is initialized, then we also need to remove the allocated list of
points. If the variable is in the meta-font structure, we use
permanent disallocation:

\iniciocodigo
@<Finalize Variable 'v' in 'struct metafont'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;  
  if(path -> length != -1 && permanent_free != NULL)
    path_recursive_free(permanent_free, path, false);
}
@
\fimcodigo

If the variable is in the context structure we do the same, but using
a different disallocation function:

\iniciocodigo
@<Finalize Variable 'v' in 'struct context'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL)
    path_recursive_free(temporary_free, path, false);
}
@
\fimcodigo

As a path can contain subpaths and each subpath also can contain more
subpaths, we will use a recursive function to disallocate their
memory. Given a disallocation function and a pointer to a path
variable, we disalloc all its subpaths, and then we disalloc the path
variable. The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].format == SUBPATH_FORMAT)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath, true);
    }
    free_func(path -> points);
    if(free_first_pointer)
      free_func(path);
  }
}
@
\fimcodigo

\subsubsecao{7.4.1. Removing Recursion from Path Variables}

Pathh variables are the most complex variables in WEAVEFONT
language. They can be stored in memory in several different
format. However, some of these formats are provisional and has
undesirable properties. For example, while we can represent a path
storing its subpaths recursively using several pointers, this is not
desirable because it makes hard to access quickly random points in the
path.

After evaluating a path, it will be in the format in which it was more
convenient to assemble given the expression that created the path. But
before storing such variables, we should convert its format for the
one that it is more convenient to handle in future operations.

The first of these conversions is removing recursion from paths. This
will turn \monoespaco{length} and \monoespaco{total\_length} equal,
removing possible confusions and misunderstandings when these values
differ. Besided this, no point in the path will point to a subpath:
all point structures will indeeed represent a single point.

For this, we will define a function that copies a path variable, but
while performing the copy, it will remove the recursion. The function
that performs this copy has the following header, followed by the
header of the auxiliary and recursive function that it will call:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool recursive_copy_points(struct metafont *mf, struct context *cx,
                           void *(*alloc)(size_t),
                           struct path_variable **target,
                           struct path_variable *source,
                           bool alloc_target); // Should we alloc target?
void recursive_aux_copy(struct path_points **dst,
                        struct path_variable *origin);
@
\fimcodigo

The function will use the allocation function given as argument, which
could be the permanent or temporary. Then it initialize the relevant
variables in the target and copy recursively:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool recursive_copy_points(struct metafont *mf, struct context *cx,
                           void *(*alloc)(size_t),
                           struct path_variable **target,
                           struct path_variable *source,
                          bool alloc_target){
  struct path_points *p;
  if(alloc_target){
    *target = (struct path_variable *) alloc(sizeof(struct path_variable));
    if(*target == NULL){
      RAISE_ERROR_NO_MEMORY(mf, cx, 0);
      return false;
    }
  }
  (*target) -> cyclic = source -> cyclic;
  (*target) -> length = source -> number_of_points;
  (*target) -> number_of_points = source -> number_of_points;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> number_of_points);
  p = (*target) -> points;
  recursive_aux_copy(&p, source);
  return true;
}
@
\fimcodigo

The recursive function that copy each point:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin){
  int index = 0;
  while(index <= origin -> length - 1){
    if(origin -> points[index].format != SUBPATH_FORMAT &&
       !isnan(origin -> points[index].point.x)){
      memcpy(*dst, &(origin -> points[index]),  sizeof(struct path_points));
      (*dst) ++;
    }
    else if(origin -> points[index].format == SUBPATH_FORMAT)
      recursive_aux_copy(dst, (struct path_variable *)
                              (origin -> points[index].subpath));
    index  ++;
  }
  return;
}
@
\fimcodigo


\subsecao{7.5. Pen Variables}

A pen variable stores the structure needed to draw lines and forms in
METAFONT. The pens specify the diameter and format of all drawed lines
and points. They are stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct pen_variable{
  int type; // Must be 'TYPE_T_PEN'
  void *next;
  bool permanent; // Variable allocation is permanent or temporary?
  struct path_variable *format; // The format as a cyclic path
  int flags;
  struct pen_variable *referenced; // Not null only in 'currentpen'
  float gl_matrix[9]; // OpenGL matrix transformation
  // The variables below will be manipulated only in Section 10
  GLuint gl_vbo; // The OpenGL vertices after triangulation
  GLsizei indices; // Number of vertices stored above
  // This will store how detailed is our triangulation, which will help us
  // to decide if we need a retriangulation in some cases:
  float triang_resolution;
};
@
\fimcodigo

Here we will give a brief explanation about these variables and why do
we need them:

The variables \monoespaco{type}, \monoespaco{nesting\_level}
are \monoespaco{next} common for all variable types and are not
something new. They are needed so that we will know which variable
type we have, its scope and which is the next variable if we are in a
linked list.

The variable \monoespaco{format} specifies the pen format as a cyclic
path. In the original METAFONT, the format needed to be both cyclic
and convex. Here, we will require that the path must be cyclic and
also should be simple. A simple path is a path whose perimeter do not
crosss over itself. If the restriction is not respected, then the
result will be undefined and we will not ensure that the pen will have
the specified format.

It does not matter how complex is the pen format, to draw it in the
screen, we need to convert it to a set of triangles in a process
called triangulation. Details about how to triangulate or if we need
to triangulate at all, will be stored in the
variable \monoespaco{flags}. Some of the possible flags are:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define FLAG_CONVEX   1
#define FLAG_STRAIGHT 2
#define FLAG_CIRCULAR 4
#define FLAG_SQUARE   8
#define FLAG_NULL    16
@
\fimcodigo

The flag \monoespaco{FLAG\_CONVEX} stores if our pen is convex. If so,
we can use very simple triangulation algorithms that will perform the
computations in O(n).

The flag \monoespaco{FLAG\_STRAIGHT} stores if the pen format is
composed only by straight lines. If so, we can represent it exactly by
triangulation, the result is perfect, not just approximated. This
means that we do not need to redo the triangulation if the pen changes
its size, for example. Conversely, if our pen has non-straight curves,
then the triangulation needs to be redone to show more details if the
pen size is increased. 

The flag \monoespaco{FLAG\_CIRCULAR} stores if we know that the pen has
a circular format. In this case, we can generate the triangulation
without looking at the path variable format.

The flag \monoespaco{FLAG\_SQUARE} stores if this is a square pen. If
so, we also do not need points from the path variable and probably we
can use a premade triangulation.

The flag \monoespaco{FLAG\_NULL} stores if this is a null pen. If so,
it never will need to be triangulated, as it represents a point
without height nor width.

The variable \monoespaco{referenced} will be non-NULL if we are
dealing with a temporary pen which is not stored in a variable and if
this pen references another pen format and vertices. In this case, we
will use if possible the same path format and the same triangulation
than the referenced pen variable. This also means that if the pen is
deallocated, we should not destroy its format nor throw away the
triangulation vertices.

The variable \monoespaco{gl\_matrix} stores the OpenGL matrix
transformation. As the pens will have a more definitive format which
will not be subdivided nor concatenated as in the subpath operations,
then we can represent their linear transformations using this matrix
instead of updating manually their points.

The other variables will me used more on Section 10. The
variable \monoespaco{gl\_vbo} will reference the pen vertices after
the triangulation, when the pen is ready to be drawn. Such vertices,
if they exist, will be stored in the video card. Otherwise, this
variable will be equal 0. The
variables \monoespaco{pen\_lft}, \monoespaco{pen\_rt}, \monoespaco{pen\_top}
and
\monoespaco{pen\_bot} will store respectively the maximum coordinate $x$,
minimum coordinate $x$, maximum coordinate $y$ and minimum coordinate
$y$ for all the points in the
pen. Finally, \monoespaco{triang\_resolution} will store an internal
measure of how detailed is the pen triangulation. It will help us to
choose if we need a more detailed triangulation or if what we have is
enough.

A pen variable that was declared but not initialized will have its
format set as the null pointer, will be non-circular and not
triangulated:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PEN){
  ((struct pen_variable *) var) -> format = NULL;
  ((struct pen_variable *) var) -> gl_vbo = 0;
  ((struct pen_variable *) var) -> indices = 0;
  ((struct pen_variable *) var) -> flags = false;
  ((struct pen_variable *) var) -> referenced = NULL;
  ((struct pen_variable *) var) -> permanent = mf -> loading;
}
@
\fimcodigo


Which means that when we remove a global variable and it is a pen
variable, we need to deallocate the format and throw away its vertices:

\iniciocodigo
@<Finalize Variable 'v' in 'struct metafont'@>+=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && permanent_free != NULL)
    path_recursive_free(permanent_free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
}
@
\fimcodigo

If the variable is not global we do the same, but using a different
disallocation function:

\iniciocodigo
@<Finalize Variable 'v' in 'struct context'@>=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && temporary_free != NULL)
    path_recursive_free(temporary_free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
  @<Finalize Local Pen 'pen'@>
}
@
\fimcodigo

Besides the pen variables declared by users, we will also support
two other internal pen variables that can be used by the users that
will always be declared and initialized. One of them will
be \monoespaco{currentpen} variable that always will store the pen
that we currently are using to draw. The other variable will be a pen
with square format that will be already initialized to obtain better
performance when used.

Such variables will be stored in the Metafont structure:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct pen_variable *internal_pen_variables;
@
\fimcodigo

During initialization we will allocate space for both and we will
initialize them. The variable \monoespaco{currentpen} by default will
begin as an empty pen and \monoespaco{pensquare} will be a square
with side 1:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_pen_variables = (struct pen_variable *)
                                 permanent_alloc(2 * sizeof(struct pen_variable));
if(mf -> internal_pen_variables == NULL){
  if(permanent_free != NULL)
    permanent_free(mf);
  return NULL;
}
mf -> internal_pen_variables[0].format = NULL; // The pen 'currentpen'
mf -> internal_pen_variables[0].type = TYPE_T_PEN;
mf -> internal_pen_variables[0].flags = FLAG_NULL;
mf -> internal_pen_variables[0].referenced = NULL;
mf -> internal_pen_variables[0].gl_vbo = 0;
mf -> internal_pen_variables[0].indices = 0;
mf -> internal_pen_variables[0].permanent = true;
mf -> internal_pen_variables[1].format = NULL; // A caneta 'pensquare'
mf -> internal_pen_variables[1].type = TYPE_T_PEN;
mf -> internal_pen_variables[1].flags = FLAG_CONVEX | FLAG_STRAIGHT |
                                        FLAG_SQUARE;
mf -> internal_pen_variables[1].referenced = NULL;
mf -> internal_pen_variables[1].gl_vbo = 0;
mf -> internal_pen_variables[1].indices = 4;
mf -> internal_pen_variables[1].permanent = true;
{ // Initializing transform matrices
  int j;
  for(j = 0; j < 2; j ++)
    INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[j].gl_matrix);
}
@
\fimcodigo

The following macro will help us to access more easily the position
for each of these internal variables:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_PEN_CURRENTPEN 0
#define INTERNAL_PEN_PENSQUARE  1
@
\fimcodigo

And to finalize the Metafont structure, we need to deallocate the
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(permanent_free != NULL){
  if(mf -> internal_pen_variables[1].format != NULL){
    permanent_free(mf -> internal_pen_variables[1].format -> points);
    permanent_free(mf -> internal_pen_variables[1].format);
  }
  permanent_free(mf -> internal_pen_variables);
}
@
\fimcodigo

And when we read a source code, we need to adjust correctly the
variable pointers when we find reference for internal variables:


\iniciocodigo
@<Set Pointer to Internal Variable@>+=
else if(!strcmp(buffer, "currentpen"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]);
else if(!strcmp(buffer, "pensquare"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_PENSQUARE]);
@
\fimcodigo

The pen '\monoespaco{currentpen}' is special because it can store a
pointer for other pen instead of its own content. But what happens if
we free the memory of a local pen variable that was pointed
by \monoespaco{currentepen}? Easy. In this
case, \monoespaco{currentpen} bacomes a null pen again, restoring its
default values:

\iniciocodigo
@<Finalize Local Pen 'pen'@>=
if(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced == pen){
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].format = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].type = TYPE_T_PEN;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].flags = FLAG_NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].gl_vbo = 0;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].indices = 0;
}
@
\fimcodigo

\subsecao{7.6. Picture Variables}

A picture variable will store a rendered image, possibly created using
pens and Weaver Metafont drawing commands. Contrary to original
METAFONT, Weaver Metafont requires all pictures to have a known width
and height. Therefore, we need to store in this variable its size and
also an OpenGL identifier to a texture:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct picture_variable{
  int type; // Must be 'TYPE_T_PICTURE'
  void *next;
  int width, height;
  GLuint texture;
};
@
\fimcodigo

A declared, but not initialized picture variable will have negative
height and width. Its texture also will be zero:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PICTURE){
  ((struct picture_variable *) var) -> width = -1;
  ((struct picture_variable *) var) -> height = -1;
  ((struct picture_variable *) var) -> texture = 0;
}
@
\fimcodigo

When removing a global variable, if it is a picture variable, we need
to destroy its texture with OpenGL if the texture exists:

\iniciocodigo
@<Finalize Variable 'v' in 'struct metafont'@>+=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

If the variable is not global we do the same:

\iniciocodigo
@<Finalize Variable 'v' in 'struct context'@>=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

We will have a single internal picture variable, which we will call
``\monoespaco{currentpicture}''. In the beginning of all program, this
variable will be declared, but not initialized. To create a list of
our internal picture variables, we declare it in the Metafont
structure:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct picture_variable *internal_picture_variables;
@
\fimcodigo

In the initialization we let the variable as non-initialized:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_picture_variables = (struct picture_variable *)
                                   permanent_alloc(sizeof(struct picture_variable));
if(mf -> internal_picture_variables == NULL){
  if(permanent_free != NULL)
    permanent_free(mf);
  return NULL;
}
// The picture 'currentpicture':
mf -> internal_picture_variables[0].type = TYPE_T_PICTURE;
mf -> internal_picture_variables[0].width = -1;
mf -> internal_picture_variables[0].height = -1;
mf -> internal_picture_variables[0].texture = 0;
@
\fimcodigo

To keep consistency with other internal variables, we create a macro
to reference its position in the array:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_PICTURE_CURRENTPICTURE 0
@
\fimcodigo

When the time to deallocate intrnal variables comes, we should
eliminate its texture if it exists:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> internal_picture_variables[0].texture != 0)
  glDeleteTextures(1, &(mf -> internal_picture_variables[0].texture));
if(permanent_free != NULL)
  permanent_free(mf -> internal_picture_variables);
@
\fimcodigo

And when we read a source code, we need to adjust correctly the
variable pointers when we find reference for
``\monoespaco{currentpicture}'':

\iniciocodigo
@<Set Pointer to Internal Variable@>+=
else if(!strcmp(buffer, "currentpicture"))
  new_token -> var =
          &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE]);
@
\fimcodigo

\subsecao{7.7. Boolean Variables}

The simplest variable type, a boolean variable can store only true or
false. Its struct format is:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct boolean_variable{
  int type; // Deve ser 'TYPE_T_BOOLEAN'
  void *next;
  short value;
};
@
\fimcodigo

The value stored by the variable will be 0 if false, 1 if true or -1
if non-initialized:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_BOOLEAN)
  ((struct boolean_variable *) var) -> value = -1;
@
\fimcodigo


\secao{8. Assignments}

Assignments are how we initialize variables, how we modify their
values and how we store the result of expressions.

The syntax for an assignment is:

\alinhaverbatim
<Simple Statement> -> <Declaration> | <Assignment> | ...
<Assignment> -> <Variable> = <Right Side> |
                <Variable> := <Right Side> |
<Right Side> -> <Expression> | <Assignment>
\alinhanormal

This means that we can chain assignments, for example, in the code
below, all variables, if numeric, will store the value 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

If in the beginning of a statement we find a variable, then certainly
we are dealing with an assignment.

In an assignment statement, the tokens ``\monoespaco{=}'' and
``\monoespaco{:=}'' are equivalent:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_EQUAL,            // Symbolic token '='
TYPE_ASSIGNMENT,       // Symbolic token ':='
@
\fimcodigo

Both types are added to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"=", ":=",
@
\fimcodigo

Now that we have this new kind of token, the code to evaluate
assignments is described below. What it does is walk over the tokens
in the assignment detecting all variables that should pass by the
assignment. While it does it, it checks if all them are declared, if
all them have the same type, if we are assigning to something that is
not a variable, if we forgot the assignment symbol, or if we are
missing an expression after the assignment. If one of these things are
detected, an error is generated.

The part that we still will not show is how we evaluate the expression
after the last assignment symbol and how in the end we update the
value for each variable to be equal what was evaluated. How we do
these things change depending on the variable types, each type have
its own expressions and its own way of storing the value in the
variables. These details will be shown in the next subsections.

\iniciocodigo
@<Statement: Assignment@>=
else if(begin -> type == TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin;
  struct generic_token *begin_expression;
  int type = 0; // Type for the variables being assigned
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(var -> line),
                                TYPE_SYMBOLIC, var -> type);
      return false;
    }
    if(var -> var == NULL){
      RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(var -> line),
                                      var -> value);
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
      RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(var -> line),
                                     var -> value, 
                                     ((struct variable *)(var -> var)) -> type,
                                     type);
      return false;
    }
    if((void *) var != (struct symbolic_token *) end)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_EQUAL && var -> type != TYPE_ASSIGNMENT){
      RAISE_ERROR_UNKNOWN_STATEMENT(mf, cx, OPTIONAL(begin -> line));
      return false;
    }
    if(var != (struct symbolic_token *) end)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL && (var -> next -> type == TYPE_EQUAL ||
                          var -> next -> type == TYPE_ASSIGNMENT));
  if(var == NULL){
    RAISE_ERROR_MISSING_EXPRESSION(mf, cx, OPTIONAL(var -> line), type);
    return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Assignment for Numeric Variables@>
  @<Assignment for Pair Variables@>
  @<Assignment for Transform Variables@>
  @<Assignment for Path Variables@>
  @<Assignment for Pen Variables@>
  @<Assignment for Picture Variables@>
  @<Assignment for Boolean Variables@>
  return true;
}
@
\fimcodigo

The above assignment code will be executed every time that we find a
variable name, a ``tag'' as the first token in a statement. In a valid
program, this happens only when the user is about to perform an
assignment.

The above code focus in dealing with errors. THe
loop \monoespaco{do...while} just verifies if the left side of the
statement is correct. The loop invariant is that in the beginning of
each iteration, we are still in the left side of the assignment and we
have \monoespaco{var} pointing to a token which is the next variable
in a chained assignment. We can raise here some error types that were
already defined, bu we also can produce entirely new errors like:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNDECLARED_VARIABLE, ERROR_WRONG_VARIABLE_TYPE, ERROR_MISSING_EXPRESSION,
@
\fimcodigo

The first possible error to be raised there was already previously
defined and happens when we are in a chained assignment, but one of
the tokens, which should be a variable name, instead is some other
type of token like:

\alinhaverbatim
numeric a;
a = , = 3; % ERROR: expected variable name, got  ","
\alinhanormal

In this example, an error would be raised in the second loop iteration.

The next error happens when we find an undeclared variable in the
assignment. This can happen in any iteration of the loop. IN the above
example, it would have happened if variable \monoespaco{a} was not
previously declared. This is a new type of error and this is the macro
that raises it:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, line, name) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNDECLARED_VARIABLE);\
    mf -> errno_str = (char *) permanent_alloc(strlen(name)+1);\
    memcpy(mf -> errno_str, name, strlen(name)+1);}}
@
\fimcodigo

The macro stores the name of the undeclared variable, and we can use
this information to warn the user about this problem:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNDECLARED_VARIABLE:
  fprintf(stderr, "%s:%s Variable '%s' was not declared.", mf -> file,
          line_number, mf -> errno_str);
  break;
@
\fimcodigo

The next type of error is also new and can happen in code like the one
below:

\alinhaverbatim
numeric a;
picture b;
a = b = 3; % ERROR: Different variable types in same assignment
\alinhanormal

For this error, we should inform the user about the name of the
offending variable, its type, and which type we expected
instead. There are three different informations. But the first two
could be placed in the same place, if we represent the variable as a
string containing its name and type. The macro below creates this
representation, and if used in the example above, it would produce the
string ``\monoespaco{<b:picture>}'' to represent
variable \monoespaco{b}.

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define VARIABLE_TO_STRING(name, type, str) {\
  size_t _s = strlen(name) + 13;\
  str = (char *) permanent_alloc(_s);\
  str[0] = '\0';\
  strcat(str, "<");\
  strcat(str, name);\
  strcat(str, ":");\
  strcat(str, list_of_keywords[type - 8]);\
  strcat(str, ">");}
@
\fimcodigo

With this macro help, we can better represent as a string the
offending variable in the error, giving the user all needed
information about it. The expected type could be stored as an integer:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, line, name, type, expected) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_WRONG_VARIABLE_TYPE);\
    VARIABLE_TO_STRING(name, type, mf -> errno_str);\
    mf -> errno_int = expected;}}
@
\fimcodigo

And here we warn the user about what went wrong:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_WRONG_VARIABLE_TYPE:
  fprintf(stderr, "%s:%s Found '%s', but a variable of type '%s' was expected.",
          mf -> file, line_number, mf -> errno_str,
          list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

The next error can happen only if we are in the first iteration. It
happens if the first token is a variable name, but the second is not
a \monoespaco{=} or \monoespaco{:=}. In this case, two different
things could have happened: the user forgot to type the assignment
operator, or the user made a typo when trying to use some other
statement. In this case, it is difficult to prodece a useful error
message, as two entirely different things could produce this
error. Because of this, we just raise an error of unknown statement.

Finally, the last error, which is detected only after the loop,
happens if we have an incomplete assignment, like:

\alinhaverbatim
numeric a;
a=;
\alinhanormal

In this case, the user forgot an expression. We store the expected
expression type when the error is raised:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_MISSING_EXPRESSION(mf, cx, line, type) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_MISSING_EXPRESSION);\
    mf -> errno_int = type;}}
@
\fimcodigo

And here we print the error diagnostic:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_MISSING_EXPRESSION:
  fprintf(stderr, "%s:%s Missing %s expression.",
          mf -> file, line_number, list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

\subsecao{8.1. Numeric Assignments and Expressions}

How do we assign numeric variables once we checked that we had no
errors on the left side of the assignment? We use the following code:

\iniciocodigo
@<Assignment for Numeric Variables@>=
if(type == TYPE_T_NUMERIC){
  int i;
  struct numeric_variable result;
  // Get right-side expression value:
  if(!eval_numeric_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    // The assignment:
    ((struct numeric_variable *) (var -> var)) -> value = result.value;
    // Getting next variable to assign:
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Now we will write how to interpret numeric expressions.

\subsubsecao{8.1.1. Sum and Subtraction: Normal and Pythagorean}

The rules for numeric expressions begins as:

\alinhaverbatim
<Numeric Expression> -> <Numeric Tertiary>
<Numeric Tertiary> -> <Numeric Secondary> |
                      <Numeric Tertiary> <T-Op> <Numeric Secondary>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

The symbols \monoespaco{+} and \monoespaco{-} represent the usual
addition and subtraction. The symbol \monoespaco{++} should not be
confused with C language increment and means the pythagorean sum:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

This can be easily computed in C using the
function \monoespaco{hypot} from the standard math library.

The symbol \monoespaco{+-+} is the ``pythagorean subtraction'' defined
below:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

We will compute the pythagorean subtraction using the last definition,
as the multiplication of two square roots. This is the computation
that minimizes errors involving overflows and underflows.

The four operators above are the ones with smaller precedence. These
operations will be done only after all other mathematical operations.

We define below the tokens for the operators:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_SUM,                   // O token simblico '+'
TYPE_SUBTRACT,              // O token simblico '-'
TYPE_PYTHAGOREAN_SUM,       // O token simblico '++'
TYPE_PYTHAGOREAN_SUBTRACT,  // O token simblico '+-+'
@
\fimcodigo

However, to correctly identify the tertiary operators insine some
expression requires taking into account delimiters like ``['',
``]'', ``$\{$'' e ``$\}$'', besides parenthesis, whose tokens were
already defined when we introduced the lexer. Because of this, we add
new token types for the delimiters that still were not defined:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_OPEN_BRACKETS,         // O token simblico '['
TYPE_CLOSE_BRACKETS,        // O token simblico ']'
TYPE_OPEN_BRACES,           // O token simblico '{'
TYPE_CLOSE_BRACES,          // O token simblico '}'
@
\fimcodigo

And we add all them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo

Now let's evaluate numeric expressions, which means evaluating
tertiary numeric expressions. The function is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

The tertiary numeric expressions is where we solve additions and
subtractions. By the syntax rules, what we need to do is walk over the
tokens in the expression until find the last tertiary operator that is
not delimited by parenthesis, brackets or braces.

To help with this, the following macros will store, check and count
the nesting level for parenthesis, braces and brackets:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define DECLARE_NESTING_CONTROL() int nesting_parenthesis = 0, \
                                      nesting_brackets = 0, \
                                      nesting_braces = 0;
#define COUNT_NESTING(p) if(p -> type == TYPE_OPEN_PARENTHESIS)           \
                               nesting_parenthesis ++;                    \
                             else if(p -> type == TYPE_CLOSE_PARENTHESIS) \
                               nesting_parenthesis --;                    \
                             else if(p -> type == TYPE_OPEN_BRACKETS)     \
                               nesting_brackets ++;                       \
                             else if(p -> type == TYPE_CLOSE_BRACKETS)    \
                               nesting_brackets --;                       \
                             else if(p -> type == TYPE_OPEN_BRACES)       \
                               nesting_braces ++;                         \
                             else if(p -> type == TYPE_CLOSE_BRACES)      \
                               nesting_braces --;
#define IS_NOT_NESTED() (nesting_parenthesis == 0 && nesting_brackets == 0 && \
                         nesting_braces == 0)
#define RESET_NESTING_COUNT() nesting_parenthesis = 0; \
                              nesting_brackets = 0; \
                              nesting_braces = 0;
@
\fimcodigo

After walking over an expression, we may want to raise an error if we
opened a parenthesis, a bracket or braces which was not closed. For
this, the following macro may be useful:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, line) {\
  if(nesting_parenthesis > 0){\
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, '(');\
    return false;\
  } else if(nesting_parenthesis < 0){\
    RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, ')');\
    return false;\
  } else if(nesting_brackets > 0){\
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, '[');\
    return false;\
  } else if(nesting_brackets < 0){\
    RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, ']');\
    return false;\
  } else if(nesting_braces > 0){\
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, '{');\
    return false;\
  } else if(nesting_braces < 0){\
    RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, '}');\
    return false;}}
@
\fimcodigo

This requires two new types of error:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNCLOSED_DELIMITER, ERROR_UNOPENED_DELIMITER,
@
\fimcodigo

When raising this error, we store the unclosed delimiter as an integer
(as it is composed by a single character):

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, delimiter) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNCLOSED_DELIMITER);\
    mf -> errno_int = delimiter;}}
#define RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, delimiter) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNOPENED_DELIMITER);\
    mf -> errno_int = delimiter;}}
@
\fimcodigo

And this is the error message:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNCLOSED_DELIMITER:
  fprintf(stderr, "%s:%s Delimiter '%c' was not closed.",
          mf -> file, line_number, mf -> errno_int);
  break;
case ERROR_UNOPENED_DELIMITER:
  fprintf(stderr, "%s:%s Delimiter '%c' was not previously opened.",
          mf -> file, line_number, mf -> errno_int);
  break;
@
\fimcodigo

This does not detect all possible errors involving delimiters. For
example, we may get a ``\monoespaco{($\{$)$\}$}'', which is wrong, but
we cannot detect. We will worry about this later. For now, we are
caring about delimiters only because we need to check for operators
outside them to correctly find the operators in tertiary expressions,
and we will worry only about errors that would prevent us to detect
this.

In a tertiary expression, everything in the left side of the rightmost
tertiary operator should be recursively evaluated as another tertiary
expression. Everything in the right side should be interpreted as a
secondary numeric expression. Finally, if we did not find any tertiary
operator, the entire expression is evaluated as a secondary numeric
expression.

However, there are some exceptions, cases in which the
symbols \monoespaco{+} and \monoespaco{-} should not be treated as a
sum or subtraction. For example:

\alinhaverbatim
a = +1;
\alinhanormal

In this case, it is just an unary operator that does not change the
signal for the next element. If we had a \monoespaco{-}, then it would
invert the signal of the next element. There is no sum or subtraction
occurring.

This happens if the operators are in the beginning of the numeric
expression, or if before them there is a comma, an opening bracket, a
multiplication or division symbol, another tertiary operator, or one
of the following tokens that we will define later:
\monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}, \monoespaco{of}, \monoespaco{point},
\monoespaco{precontrol} ou \monoespaco{postcontrol}.

If we have a previous token (\monoespaco{prev}) and the current one
(\monoespaco{cur}), we can check if it represents a valid sum or
subtraction with the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_OF &&                    \
          prev -> type != TYPE_POINT &&                 \
          prev -> type != TYPE_PRECONTROL &&            \
          prev -> type != TYPE_POSTCONTROL &&           \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo

The following code interprets tertiary numeric expressions and
identify correctly the tertiary operators with the help of the macro:


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin,
                             struct generic_token *end,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  p = begin;
  do{ // Find last tertiary operator: '+', '-', '++' or '+-+'
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_PYTHAGOREAN_SUM ||
                          p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
                          IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_tertiary != NULL){ // If we have tertiary operator:
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin, end_tertiary, &a);
    eval_numeric_secondary(mf, cx, begin_secondary, end, &b);
    if(last_sum -> type == TYPE_SUM) // Evaluate '+':
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT) // Evaluate '-':
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM) // Evaluate '++'
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){ // Evaluate '+-+':
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
        RAISE_ERROR_NEGATIVE_SQUARE_ROOT(mf, cx, OPTIONAL(last_sum -> line),
                                         a.value - b.value);
        return false;
      }
    }
    return true;
  }
  else // No tertiary operator:
    return eval_numeric_secondary(mf, cx, begin, end, result);
}
@
\fimcodigo

Notice that an error may happen in the code above when evaluating
pitagorig subtraction. We may get the square root of a negative
number. In this case, we get the following new type of error:

\iniciocodigo
@<Types of Error@>+=
ERROR_NEGATIVE_SQUARE_ROOT,
@
\fimcodigo

When this happens, we store the offending negative number as a string:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_NEGATIVE_SQUARE_ROOT(mf, cx, line, number) {\
  if(!mf -> errno){\
    mf -> errno_str = (char *) permanent_alloc(64);\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_NEGATIVE_SQUARE_ROOT);\
    snprintf(mf -> errno_str, 63, "%g", number);\
    mf -> errno_str[63] = '\0';}}
@
\fimcodigo

And this is how we warn the user about this error:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_NEGATIVE_SQUARE_ROOT:
  fprintf(stderr, "%s:%s Tried to compute square root of negative value '%s'.",
          mf -> file, line_number, mf -> errno_str);
  break;
@
\fimcodigo

\subsubsecao{8.1.2. Multiplication and Division}

The rules to deal with secondary numeric expressions are:

\alinhaverbatim
<Numeric Secondary> -> <Numeric Primary> |
                       <Numeric Secondary> <S-Op> <Numeric Primary>
<S-Op> -> * | /
\alinhanormal

The operators \monoespaco{*} and \monoespaco{/} are respectively the
multiplication and division.

Let's add these operators as reserved tokens and define their types:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_MULTIPLICATION,        // Symbolic token '*'
TYPE_DIVISION,              // Symbolic token '/'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"*", "/",
@
\fimcodigo

The function that will evaluate numeric secondary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin,
                             struct generic_token *end,
                             struct numeric_variable *result);
@
\fimcodigo

And its definition is very similar with the function that evaluates
tertiary expressions, except that this function computes
multiplication and division.

However, there is an additional rule that we should be aware: the
token ``/'' will be considered division only if it is not delimited by
two numeric tokens. If so, then it represents a fraction and it should
be computed with a higher precedence than what we deal here. However,
if the token before the previous one already was considered part of a
fraction, then in this case we have a division despide being
surrounded by numeric tokens. This way the code \monoespaco{1/3/1/3}
is interpreted as a division between two fractions $(1/3)/(1/3)$:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin,
                             struct generic_token *end,
                             struct numeric_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin;
  do{ // Find last secondary operator '*' or '/'
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
                          p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end &&  p -> next -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ // Valid multiplication or division
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_secondary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secondary(mf, cx, begin, end_secondary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION) // Evaluate '*':
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){ // Evaluate '/':
      if(b.value == 0.0){
        RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(last_mul -> line));
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else // No secondary operator:
    return eval_numeric_primary(mf, cx, begin, end, result);
}
@
\fimcodigo

In the avove code, we check again for errors in our delimiters,
despite the fact that we also checked when evaluating the tertiary
expression. This is needed because, for example, the following
incorrect code would not raise any error during tertiary expression
evaluation, but would produce the error only in the above code, when evaluating the secondary expression:

\alinhaverbatim
numeric a;
a=(4*{8)+3}+1;
\alinhanormal

Now we will add the new error caused by division by zero, which can
also happen when we evaluate a division:

\iniciocodigo
@<Types of Error@>+=
ERROR_DIVISION_BY_ZERO,
@
\fimcodigo

When raising this error, no additional information needs to be stored:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, line) {\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_DIVISION_BY_ZERO);}
@
\fimcodigo

And this is the diagnostic message:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_DIVISION_BY_ZERO:
  fprintf(stderr, "%s:%s Division by zero.", mf -> file, line_number);
  break;
@
\fimcodigo

\subsubsecao{8.1.3. Modulus, Sine, Cosine, Exponentials, Floor and
  Random Uniform Values}

The rules for primary numeric expressions are:

\alinhaverbatim
<Numeric Primary> -> <Numeric Atom> |
                     length <Numeric Primary> | (...) |
                     <Numeric Operator> <Numeric Primary>
<Numeric Operator> -> sqrt | sind | cosd | mlog | mexp | floor |
                       uniformdeviate |
                       <Scalar Multiplication Operator>
<Scalar Multiplication Operator> -> + | - |
                       <Primary Numeric Token Before Variable>
<Primary Numeric Token> -> <Numeric Token> / <Numeric Token> |
                           <Numeric Token>
\alinhanormal

The operator \monoespaco{length}, when appearing before a numeric
primery means that we want its modulus. If it appears before another
kind of primary expression, it could mean different things.

All these new operators must be added to the token list:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_LENGTH,         // Symbolic token 'length'
TYPE_SQRT,           // Symbolic token 'sqrt'
TYPE_SIND,           // Symbolic token 'sind'
TYPE_COSD,           // Symbolic token 'cosd'
TYPE_LOG,            // Symbolic token 'log'
TYPE_EXP,            // Symbolic token 'exp'
TYPE_FLOOR,          // Symbolic token 'floor'
TYPE_UNIFORMDEVIATE, // Symbolic token 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

The function that evaluates a primary numeric expression is this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct numeric_variable *result);
@
\fimcodigo


We can decide which syntax rule should be applied while evaluating the
primary numeric expression using seven different interpretation rules:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct numeric_variable *result){
  @<Numeric Primary: Rule 1@>
  @<Numeric Primary: Rule 2@>
  @<Numeric Primary: Rule 3@>
  @<Numeric Primary: Additional Operators@>
  @<Numeric Primary: Rule 4@>
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_NUMERIC);
  return false;
}
@

If we are not able to recognize the primary expression given the
rules, we raise the error:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNKNOWN_EXPRESSION,
@
\fimcodigo

Raising this error means storing the expression type that we weve
evaluating when we found an unrecognizable construction:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, line, type) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNKNOWN_EXPRESSION);\
    mf -> errno_int = type;}}
@
\fimcodigo

And this is the diagnostic message:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNKNOWN_EXPRESSION:
  fprintf(stderr, "%s:%s Unrecognizable %s expression.", mf -> file,
          line_number, list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

The rules to recognize the expression are:

1) If the expression is composed by a single token, or if it begins
with ``('' and ends with ``)'', or if it is composed by three tokens,
a numeric, a division and another numeric, then the entire expression
is a numeric atom:

\iniciocodigo
@<Numeric Primary: Rule 1@>=
if(begin == end || (begin -> type == TYPE_OPEN_PARENTHESIS &&
                    end -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin -> type == TYPE_NUMERIC &&  begin -> next != end &&
     begin -> next -> type == TYPE_DIVISION && begin -> next -> next == end &&
     end -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin, end, result);
}
@
\fimcodigo

2) If we find operator \monoespaco{length}, then we check if the
expression after it is numeric. If so, we compute its modulus. If the
expression have another type, we will define later how the operator
will proceed. We assume that we have a function that discovers the
type of a primary expression.

\iniciocodigo
@<Numeric Primary: Rule 2@>=
else if(begin -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx, begin -> next, end);
  if(expr_type == TYPE_T_NUMERIC){
    struct numeric_variable num;
    if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Evaluate 'length'@>
  else{
    RAISE_ERROR_UNKNOWN_EXPRESSION_TYPE(mf, cx, OPTIONAL(begin -> line),
                                       expr_type);
    return false;
  }
}
@
\fimcodigo

Notice that identifying if we have or not a numeric primary expression
involves calling \monoespaco{get\_primatry\_expression\_type}. This
function will be defined in Subsection 8.8. For now, we just need to
know that given the beginning and ending tokens for some expression,
it returns the expression type. If the type is numeric, the code above
shows how we compute the modulus. Otherwise, we will evaluate it using
other rules that we should define later (in Subsection 8.2.4 and
8.4.5). If the expression is not recognized or is an expression with
an unsupported type in this context, the following error is raised:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNKNOWN_EXPRESSION_TYPE,
@
\fimcodigo

The expression type is stored when we raise this error. The type may
be unknown (is equal -1) or is some type which is not supported:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNKNOWN_EXPRESSION_TYPE(mf, cx, line, type) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNKNOWN_EXPRESSION_TYPE);\
    mf -> errno_int = type;}}
@
\fimcodigo

Depending on the case, we generate different error messages:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNKNOWN_EXPRESSION_TYPE:
  if(mf -> errno_int == -1)
    fprintf(stderr, "%s:%s We could not identity the expression type.",
            mf -> file, line_number);
  else
    fprintf(stderr, "%s:%s Found %s expression in a context where such"
                    "expression was not expected.", mf -> file, line_number,
                    list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo


3) If we find some of the numeric operators, we have a numeric
operator followed by a numeric primary expression.



The first numeric operator is the square root:

\iniciocodigo
@<Numeric Primary: Rule 3@>=
else if(begin -> type == TYPE_SQRT){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  if(num.value < 0.0){
    RAISE_ERROR_NEGATIVE_SQUARE_ROOT(mf, cx, OPTIONAL(begin -> line),
                                    num.value);
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;
}
@
\fimcodigo

Next we have the operator \monoespaco{sind}, which interprets the next
number in degrees (because of this it has the letter ``d'' in the end)
and computes the sine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_SIND){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = sinf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the cosine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_COSD){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the logarithm in $e$ basis:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_LOG){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  if(num.value <= 0.0){
    RAISE_ERROR_NEGATIVE_LOGARITHM(mf, cx, OPTIONAL(begin -> line),
                                   num.value);
    return false;
  }
  result -> value = logf(num.value);
  return true;
}
@
\fimcodigo

This is the new error that is raised when one tries to compute the
logarithm of a negative value:

\iniciocodigo
@<Types of Error@>+=
ERROR_NEGATIVE_LOGARITHM,
@
\fimcodigo

When the error is raised, we convert the offending negative number
that caused the problem to a string:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_NEGATIVE_LOGARITHM(mf, cx, line, number) {\
  if(!mf -> errno){\
    mf -> errno_str = (char *) permanent_alloc(64);\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_NEGATIVE_LOGARITHM);\
    snprintf(mf -> errno_str, 63, "%g", number);\
    mf -> errno_str[63] = '\0';}}
@
\fimcodigo

And warn the user about the problem:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_NEGATIVE_LOGARITHM:
  fprintf(stderr, "%s:%s Tried to compute logarithm of negative value '%s'.",
          mf -> file, line_number, mf -> errno_str);
  break;
@
\fimcodigo

And this is how we compute the exponential which means $exp x = e^x$:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_EXP){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  result -> value = expf(num.value);
  return true;
}
@
\fimcodigo

The floor of a given value:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_FLOOR){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  result -> value = floorf(num.value);
  return true;
}
@
\fimcodigo

About the operator \monoespaco{uniformdeviate}, it generates a number
uniform and random between 0 and the value passed as operand. We can
compute this generating a number between 0 and 1 and then multiply
this value with the operand.

Generating a floating point number between 0 and 1 following a
distribution near to uniform can be done generating a random 64-bit
number and then multiplying it with $2^{-64}$. Not all possible
floating-point numbers could be represented generating them this
way. Numbers smaller than $2^{-64}$ would be ignored and the rounding
would make some numbers near 1 more probable, but we also would have
less density in the range near 1. However, despithe these drawbacks,
the result would be sufficiently precise for our purposes:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_UNIFORMDEVIATE){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;
  }
  return true;
}
@
\fimcodigo

If the next operator is the symbol \monoespaco{+}, this means a
multiplication by 1. This operation can be ignored:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_SUM){
  if(!eval_numeric_primary(mf, cx, begin -> next, end, result))
    return false;
  return true;
}
@
\fimcodigo

But if the operator is a symbol \monoespaco{-}, hen this means a
multiplication by -1:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin -> type == TYPE_SUBTRACT){
  if(!eval_numeric_primary(mf, cx, begin -> next, end, result))
    return false;
  result -> value *= -1;
  return true;
}
@
\fimcodigo

4) In the remaining cases, we have a scalar multiplicationwhere the
scalar is a primary numeric token that is not followed
by \monoespaco{+}, \monoespaco{-} or another numeric token. To deal
with this, we needto identify the beginning and end of the primary
numeric token. BY the rules it is a single numeric token, or three
tokens (two numeric ones separated by a \monoespaco{/}). After
separating the parts, the first part is multiplied by the second (a
numeric primary expression):

\iniciocodigo
@<Numeric Primary: Rule 4@>=
else{
  float token_value;
  struct generic_token *after_token;
  if(begin -> type != TYPE_NUMERIC){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_NUMERIC);
    return false;
  }
  token_value = ((struct numeric_token *) begin) -> value;
  after_token = begin -> next;
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                     TYPE_T_NUMERIC);
      return false;
    }
    after_token = after_token -> next;
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = after_token -> next;
  }
  if(!eval_numeric_primary(mf, cx, after_token, end, result))
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Isolated Numbers and Random Normal Values}

The final rules for numeric expressions are:

\alinhaverbatim
<Numeric Atom> -> <Numeric Variable> |
                  <Primary Numeric Token> |
                  ( <Numeric Expression> ) |
                  normaldeviate
\alinhanormal

The only new token in this part is \monoespaco{normaldeviate}:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_NORMALDEVIATE,   // O token simblico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"normaldeviate",
@
\fimcodigo

This operator creates a new random number taken from a n ormal
distribution with mean 0 and standard deviation 1.

The function that evaluates numeric atoms is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct numeric_variable *result);
@
\fimcodigo

We will decide which rule to apply while evaluating the numeric atom
first checking if we have a single token or not, and then applying
different rules based on this:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct numeric_variable *result){
  if(begin == end){
    @<Numeric Atom: Rule 1@>
    @<Numeric Atom: Rule 2@>
    @<Numeric Atom: Rule 3@>
  }
  else{
    @<Numeric Atom: Rule 4@>
    @<Numeric Atom: Rule 5@>
  }
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_NUMERIC);
  return false;
}
@

1) If we have a single token and it is a numeric token, we just return
its value:

\iniciocodigo
@<Numeric Atom: Rule 1@>=
if(begin -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin) -> value;
  return true;
}
@
\fimcodigo

2) If we have a single token and it is a variable, we return its
content. But we first need to check if the variable was declared, if
it is numeric and if it was initialized:

\iniciocodigo
@<Numeric Atom: Rule 2@>=
if(begin -> type == TYPE_SYMBOLIC){
  struct symbolic_token *var_token = ((struct symbolic_token *) begin);
  struct numeric_variable *var;
  var = var_token -> var;
  if(var == NULL){
    RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                   var_token -> value);
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
    RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(begin -> line),
                                   var_token -> value, var -> type,
                                   TYPE_T_NUMERIC);
    return false;
  }
  if(isnan(var -> value)){
    RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                      var_token -> value);
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

If the variable was not declared or is not numeric, we raise errors
that were already previously defined. If the variable was not
initialized, then we need to raise a new type of error:

\iniciocodigo
@<Types of Error@>+=
ERROR_UNINITIALIZED_VARIABLE,
@
\fimcodigo

When this error happens, we store the variable name to warn the user:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, line, name) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNINITIALIZED_VARIABLE);\
    mf -> errno_str = (char *) permanent_alloc(strlen(name)+1);\
    memcpy(mf -> errno_str, name, strlen(name)+1);}}
@
\fimcodigo

And this is the error message:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_UNINITIALIZED_VARIABLE:
  fprintf(stderr, "%s:%s Uninitialized variable '%s'.",
          mf -> file, line_number, mf -> errno_str);
  break;
@
\fimcodigo

3) Finally, if we have a single token and it is
a \monoespaco{normaldeviate}, then we need to generate a random number
taken from a normal distribution. Given that we already have a
function to generate random bits, we can simulate a normal
distribution following these steps:

a) First we generate two random numbers between -1 and 1. We will call
them $u$ and $v$. e can generate them getting 64 random bits,
multiplying the first 63 by $2^{-63}$ and using the remaining bit to
choose the signal. The result is sufficiently close to uniform.

b) If $u^2+v^2\geq 1$, the numbers form a point outside a circle with
radius 1. In this case, the result should be discarded and we try to
generate numbers again. We also discard the result if both numbers are
zero, as in this case our method do not work.

c) After this, we can produce two numbers following a normal
distribution computing:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

One of the values will be returned. The other can be stored to be
returned next time we need a random normal value. We store it in the
Metafont struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Initially the structure will have no value stored. We will store
values there only after using the procedure descrbed above:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

So, when we need to generate a normal rando value, we always check
first if we already have a pre-generated value, and if not, we
generate two values:

\iniciocodigo
@<Numeric Atom: Rule 3@>=
if(begin -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    do{
      random_bits = random_func();
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Now the cases where we have more than one token. If the first token
in ``('' and the last one is ``)'', we compute the inner expression as
a numeric expression, and then return the result discarding the
parenthesis:

\iniciocodigo
@<Numeric Atom: Rule 4@>=
if(begin -> type == TYPE_OPEN_PARENTHESIS &&
   end -> type == TYPE_CLOSE_PARENTHESIS){
   struct generic_token *p = begin;
   while(p -> next != end)
     p = p -> next;
   if(p == begin){
     RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '(');
     return false;
   }
   if(!eval_numeric_expression(mf, cx, begin -> next, p, result))
     return false;
   return true;
}
@
\fimcodigo

If we find just an empty parenthesis, this is an error. The user
forgot to put some expression in the parenthesis. The raised error has
this new type:

\iniciocodigo
@<Types of Error@>+=
ERROR_EMPTY_DELIMITER,
@
\fimcodigo

When raising this error, we must inform which empty delimiter we
found. It may be parenthesis, braces or brackets:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_EMPTY_DELIMITER(mf, cx, line, delimiter) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_EMPTY_DELIMITER);\
    mf -> errno_int = delimiter;}}
@
\fimcodigo

The error message will be slightly different depending on the delimiter:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_EMPTY_DELIMITER:
  fprintf(stderr, "%s:%s Unexpected empty delimiter '%c%c'.",
          mf -> file, line_number, mf -> errno_int,
          ((mf -> errno_int == '(')?(')'):
            ((mf -> errno_int == '[')?(']'):('}'))));
  break;
@
\fimcodigo


5) Finally, the case when the numeric atom is a fraction composed by a
numeric token, \monoespaco{/} and another numeric token. The result is
obtained dividing both tokens:

\iniciocodigo
@<Numeric Atom: Rule 5@>=
if(begin -> type == TYPE_NUMERIC && end -> type == TYPE_NUMERIC &&
   begin -> next -> type == TYPE_DIVISION){
  if(((struct numeric_token *) end) -> value == 0.0){
    RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(begin -> line));
    return false;
  }
  result -> value = ((struct numeric_token *) begin) -> value /
           ((struct numeric_token *) end) -> value;
  return true;
}
@
\fimcodigo

\subsecao{8.2. Pair Assignments and Expressions}

To make the assignment to pair variables, we use the code below:

\iniciocodigo
@<Assignment for Pair Variables@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    struct pair_variable *v = (struct pair_variable *) var -> var;
    v -> x = result.x;
    v -> y = result.y;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Now let's see how to evaluate  pair expressions.

\subsubsecao{8.2.1. Sum and Subtraction}

The grammar rules for pair tertiary expressions begin with sum and
subtraction:

\alinhaverbatim
<Pair Expression> -> <Pair Tertiary>
<Pair Tertiary> -> <Pair Secondary> |
                   <Pair Tertiary> <PT-Op> <Pair Secondary>
<PT-Op> -> + | -
\alinhanormal

Sum and subtraction is evaluated exactly as expected from vector sum
and subtraction.

The function that evaluates pair expressions is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct pair_variable *result);
@
\fimcodigo

The method to evaluate tertiary pair expressions are not different
from what we already defined with numeric expressions. We just have
fewer tertiary operators here.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct pair_variable a, b;
  p = begin;
  do{ // Find last tertiary operator '+' or '-'
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_tertiary != NULL){
    begin_secondary = last_sum -> next;
    eval_pair_expression(mf, cx, begin, end_tertiary, &a);
    eval_pair_secondary(mf, cx, begin_secondary, end, &b);
    if(last_sum -> type == TYPE_SUM){ // Evaluate '+'
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){ // Evaluate '-'
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else // No tertiary operator:
    return eval_pair_secondary(mf, cx, begin, end, result);
}
@
\fimcodigo

\subsubsecao{8.2.2. Transformers and Scalar Multiplication and Division}

The grammar for secondary pair expressions is:

\alinhaverbatim
<Pair Secondary> -> <Pair Primary> |
                    <Pair Secondary><Mul or Div><Numeric Primary> |
                    <Numeric Secondary> * <Pair Primary> |
                    <Pair Secondary><Transformer>
<Mul or Div> -> * | /
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary> | (...)
\alinhanormal

The above transformer rule is incomplete because we will see the last
existing transformer in Subsection 8.3.1.

For now let's add the seven new keywords representing known
transformers:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_ROTATED,  // Symbolic token 'rotated'
TYPE_SCALED,   // Symbolic token 'scaled'
TYPE_SHIFTED,  // Symbolic token 'shifted'
TYPE_SLANTED,  // Symbolic token 'slanted'
TYPE_XSCALED,  // Symbolic token 'xscaled'
TYPE_YSCALED,  // Symbolic token 'yscaled'
TYPE_ZSCALED,  // Symbolic token 'zscaled'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo


The function that evaluates secondary pair expressions is declared
below:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin,
                         struct generic_token *end,
                         struct pair_variable *result);
@
\fimcodigo

Evaluating a secondary expression here is very similar to what we did
for numeric expressions. We also walk over the token list searching
for the rightmost secondary operator, ignoring anything nested inside
parenthesis and brackets. We follow the same rules to check when we
have a division and when the symbol \monoespaco{/} is just a fraction
separator. The difference is that here we have a total of nine
secondary operators including the transformers. Because of the big
quantity, we will show each of them separately instead of all them in
the code block below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin,
                             struct generic_token *end,
                             struct pair_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin;
  do{ // Find the rightmost secondary operator
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             // Operator 'transformed' still not defined. We will see
             // it defined in Subsection 8.3.4.
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end && p -> next -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ //  Diviso ou operadores vlidos
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_secondary != NULL){
    begin_primary = last_mul -> next;
    @<Secondary Pair Operator: Multiplication@>
    @<Secondary Pair Operator: Division@>
    @<Secondary Pair Operator: Rotation@>
    @<Secondary Pair Operator: Scaling@>
    @<Secondary Pair Operator: Shifting@>
    @<Secondary Pair Operator: Slanting@>
    @<Secondary Pair Operator: X-Scaling@>
    @<Secondary Pair Operator: Y-Scaling@>
    @<Secondary Pair Operator: Z-Scaling@>
    @<Secondary Pair Operator: Additional Operators@>
  }
  else
    return eval_pair_primary(mf, cx, begin, end, result);
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PAIR);
  return false;
}
@
\fimcodigo

The first operator is the multiplication. Notice that we can have two
different multiplications: a pair multiplicated by a numeric or a
numeric multiplicated by a pair. To identify which of the two should
be applied, we must check the primary expression to the right of the
operator.

\iniciocodigo
@<Secondary Pair Operator: Multiplication@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end) == TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    if(!eval_numeric_secondary(mf, cx, begin, end_secondary, &a))
      return false;
    if(!eval_pair_primary(mf, cx, begin_primary, end, &b))
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
      return false;
    if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }
}
@
\fimcodigo

If we have a division, then this always will be a pair divided by a
numeric. We should generate an error in case of division by zero:

\iniciocodigo
@<Secondary Pair Operator: Division@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  if(b.value == 0.0){
    RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(last_mul -> line));
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

If we have a rotation, we rotate our pair counter-clockwise using the
origin as the axis. We interpret angles in degrees, not in radians:

\iniciocodigo
@<Secondary Pair Operator: Rotation@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  theta = 0.0174533 * b.value; // 1 degree = 0.0174533 radians
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

A scaling is the same thing than a multiplication:

\iniciocodigo
@<Secondary Pair Operator: Scaling@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

A shifting is equal a sum, but this operator have a higher precedence:

\iniciocodigo
@<Secondary Pair Operator: Shifting@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_pair_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

The slanting operator shifts a point more to the right depending on
how above the axis $x$ it is and more to the left depending on how
below the axis $x$ it is:

\iniciocodigo
@<Secondary Pair Operator: Slanting@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

A x-scaling multiplies a numeric scalar to the first value in the
pair:

\iniciocodigo
@<Secondary Pair Operator: X-Scaling@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Likewise a y-scaling multiplies a numeric scalar to the second value
in the pair:

\iniciocodigo
@<Secondary Pair Operator: Y-Scaling@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Finally, a z-scaling interprets two pairs as complex numbers and
multiply them:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Secondary Pair Operator: Z-Scaling@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_pair_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Pair Intermediary Values, Literals and Variables}

The final grammar rules for pair expressions are:

\alinhaverbatim
<Pair Primary> -> <Pair Variable> |
                  ( <Numeric Expression> , <Numeric Expression> ) |
                  ( <Pair Expression> ) |
                  (...) |
                  <Numeric Atom> [ <Pair Expression, <Pair Expression>] |
                  <Scalar Multiplication Operator><Pair Primary>
\alinhanormal

We ommited some rules above because there are primary operators that
we will define later, in Subsections 8.4.6 and 10.4.

The novel operator is the constructionn $a[b, c]$, where $b$ and $c$
are pairs. It represents intermediary values between $b$ end $c$. It
is evaluated as $a(b+c)$. This means that $.5[a,b]$ is half the path
between $b$ and $c$.

The other rules are analogous to what we already described in the
grammar for numeric expressions.

The function that will evaluate pair primary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct pair_variable *result);
@
\fimcodigo

Each one of the five grammar rules will be tested separately to
discover which one we should apply when we find a primary expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct pair_variable *result){
  if(begin == end){
    @<Pair Primary: Rule 1@>
  }
  else if(begin -> type == TYPE_OPEN_PARENTHESIS &&
          end -> type == TYPE_CLOSE_PARENTHESIS){
    @<Pair Primary: Rule 2@>
    @<Pair Primary: Rule 3@>
  }
  @<Pair Primary: Other Rules to Be Defined Later@>
  @<Pair Primary: Rule 4@>
  @<Pair Primary: Rule 5@>
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PAIR);
  return false;
}
@

The first rule will be applied when we have a single token in the
expression. The only case when it happens is when we are evaluating a
pair variable:

\iniciocodigo
@<Pair Primary: Rule 1@>=
struct symbolic_token *tok = (struct symbolic_token *) begin;
struct pair_variable *var;
if(tok -> type != TYPE_SYMBOLIC){
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PAIR);
  return false;
}
var = (struct pair_variable *) tok -> var;
if(var == NULL){
  RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                 tok -> value);
  return false;
}
if(var -> type != TYPE_T_PAIR){
  RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(begin -> line),
                                  tok -> value, var -> type,
                                  TYPE_T_PAIR);
  return false;
}
if(isnan(var -> x)){
  RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                    tok -> value);
  return false;
}
result -> x = var -> x;
result -> y = var -> y;
return true;
@
\fimcodigo

If the expression is delimited by parenthesis, we could be facing a
literal representation of a pair in the form $(a, b)$, or we could be
dealing with a pair expression inside parenthesis like in $(pair1+(a,
b))$. We can differentiate the two cases checking the presence of a
comma inside the parenthesis which is not nested in other internal
parenthesis.

\iniciocodigo
@<Pair Primary: Rule 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  if(begin -> next == end){
    RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '(');
    return false;
  }
  begin_a = (struct generic_token *) begin -> next;
  end_a = begin_a;
  DECLARE_NESTING_CONTROL();
  bool literal = true;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(comma -> line),
                                     TYPE_T_PAIR);
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end)
      end_b = (struct generic_token *) end_b -> next;
    if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
      return false;
    if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

In the code above we identify if we are dealing with a literal
checking for a comma. If so, we set in the boolean
variable \monoespaco{literal} as true. Otherwise, immediately after
the last \monoespaco{if} above, we run the following \monoespaco{else}
as the next rule:

\iniciocodigo
@<Pair Primary: Rule 3@>=
else
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
@
\fimcodigo

If the last token is a \monoespaco{]}, then we have a construction of
type $a[B,C]$ for some numeric $a$ and pairs $B$ and $C$. Our task is
separate the three parts $a$, $B$ and $C$, evaluate them and return
$B+a(C-B)$:

\iniciocodigo
@<Pair Primary: Rule 4@>=
else if(end -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  DECLARE_NESTING_CONTROL();
  begin_a = begin;
  end_a = begin_a;
  while(end_a != end){ // a: From beginning expression to token before '['
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() && end_a -> next -> type == TYPE_OPEN_BRACKETS)
      break;
    end_a = end_a -> next;
  }
  if(end_a == end){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_PAIR);
    return false;
  }
  begin_b = end_a -> next;
  begin_b = begin_b -> next; // b: Begin after '['
  end_b = begin_b;
  while(end_b != end){ // b: Ends before ','
    COUNT_NESTING(end_b);
    if(IS_NOT_NESTED() && end_b -> next -> type == TYPE_COMMA)
      break;
    end_b = end_b -> next;
  }
  if(end_b == end){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_PAIR);
    return false;
  }
  begin_c = end_b -> next;
  begin_c = begin_c -> next; // c: Begins after ','
  end_c = begin_c;
  while(end_c != end){ // c: ends in the second to last token
    if(end_c -> next == end)
      break;
    end_c =  end_c -> next;
  }
  if(end_c == end){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_PAIR);
    return false;
  }
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a)) // Eval 'a'
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b)) // Eval 'b'
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c)) // Eval 'c'
    return false;
  result -> x = b.x + a.value * (c.x - b.x); // Computes b + a(c-b)
  result -> y = b.y + a.value * (c.y - b.y);
  return true;
}
@
\fimcodigo

The last rule is when we have a scalar multiplication operator. The
operator can be \monoespaco{+}, \monoespaco{-}, a single numeric token
or a fraction. We have one example for each of the four cases below:

\alinhaverbatim
pair a, b, c, d;
a = +(1, 2);
b = -(1, 2);
c = 2a;
d = 1/2b;
\alinhanormal

The code that deals with such expressions are:

\iniciocodigo
@<Pair Primary: Rule 5@>=
else{
  if(begin -> type == TYPE_SUM) // Unary '+' before expression
    return eval_pair_primary(mf, cx, begin -> next, end, result);
  else if(begin -> type == TYPE_SUBTRACT){ // Unary '-'
    if(!eval_pair_primary(mf, cx, begin -> next, end, result))
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin -> type == TYPE_NUMERIC){ // Number/fraction before expression
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin) -> value;
    tok = begin -> next;
    if(tok -> type == TYPE_DIVISION){ // It is a fraction
      tok = begin -> next;
      if(tok == end || tok -> next == end || tok -> type != TYPE_NUMERIC){
        RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                       TYPE_T_PAIR);
        return false;
      }
      if(((struct numeric_token *) tok) -> value == 0.0){
        RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(begin -> line));
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = tok -> next;
    }
    if(!eval_pair_primary(mf, cx, begin -> next, end, result))
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pairs in Numeric Expressions}

Numeric subexpressions can appear inside pair expressions. For
example, in $a[b,c]$, $a$ is a numeric atom. Likewise, pair
subexpressions can appear inside numeric expressions. We did not
define this in the section about numeric expressions because we still
had not defined how to evaluate pair expressions. There are four
numeric primary operators involving pairs:

\alinhaverbatim
<Numeric Primary> -> length <Pair Primary> | xpart <Pair Primary> |
                       ypart <Pair Primary> | angle <Pair Primary>
\alinhanormal

This require defining the following three new token types:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_XPART,  // Symbolic token 'xpart'
TYPE_YPART,  // Symbolic token 'ypart'
TYPE_ANGLE,  // Symbolic token 'angle'
@
\fimcodigo

They correspond to the following keywords:

\iniciocodigo
@<List of Keywords@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

The first case, which did not need a new token, othe
operator \monoespaco{length} was already being used to get the modulus
of a given number and we had written that it could be used on other
types, not only in numerics. In the case of pairs, this operators
returns the euclidean norm:

\iniciocodigo
@<Evaluate 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) hypot(p.x * p.x, p.y * p.y);
  return true;
}
@
\fimcodigo

The operator \monoespaco{xpart} returns the first value in a
pair. However, we must take an additioonal care: this operator can be
use in contexts other than getting value from a pair, as we will still
see in Sub-subsection 8.3.3. Therefore, first we must check if what we
have after the operator is a pair. If so, we return the first value:

\iniciocodigo
@<Numeric Primary: Additional Operators@>=
else if(begin -> type == TYPE_XPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, begin -> next, end);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
      return false;
    result -> value = p.x;
    return true;
  }
  else{
    @<Numeric Primary: X-Part in Non-Pair@>
  }
}
@
\fimcodigo

While the operator \monoespaco{ypart} returns the second value in a
pair. In this case we also must take care to check if we have as
operand is a pair or some other thing:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin -> type == TYPE_YPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, begin -> next, end);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
      return false;
    result -> value = p.y;
    return true;
  }
  else{
    @<Numeric Primary: Y-Part in Non-Pair@>
  }
}
@
\fimcodigo

Finally, the last operator, \monoespaco{angle}, measure the angle of a
pair. Which means the angle between the segment that connects the
origin to the pair coordintate and the segment that connects the
origin to $(1,0)$. An error will be generated if you try to measure
the angle of $(0,0)$:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
    RAISE_ERROR_ANGLE_OF_ORIGIN(mf, cx, OPTIONAL(begin -> line));
    return false;
  }
  result -> value = (float) acos(p.x / (hypot(p.x, p.y)));
  result -> value *= 57.2958; // Radians to degrees
  return true;
}
@
\fimcodigo

Measuring the angle of origin $(0, 0)$ is an error of type:

\iniciocodigo
@<Types of Error@>+=
ERROR_ANGLE_OF_ORIGIN,
@
\fimcodigo

This is the macro that raises the error:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define RAISE_ERROR_ANGLE_OF_ORIGIN(mf, cx, line) {\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_ANGLE_OF_ORIGIN);}
@
\fimcodigo

And the error message that is shown in the screen:

\iniciocodigo
@<Print Error Message@>+=
case ERROR_ANGLE_OF_ORIGIN:
  fprintf(stderr, "%s:%s Undefined operation 'angle (0, 0)'.",
          mf -> file, line_number);
  break;
@
\fimcodigo

\subsecao{8.3. Transform Assignments and Expressions}

One of the moments where we expect to eval a transform expression is
when making assignments to transform variables. In this case, we apply
a function to evaluate the expression and get the result. Then, we
assign the result for each variable in the left side of the assignment
expression:

\iniciocodigo
@<Assignment for Transform Variables@>=
else if(type == TYPE_T_TRANSFORM){
  int i;
  struct transform_variable result;
  if(!eval_transform_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    memcpy(((struct transform_variable *) var -> var) -> value, result.value,
           sizeof(float) * 9);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Now let's see how do we evaluate a transform expression.

\subsubsecao{8.3.1. Transforming Transformers}

The grammar rules to evaluate a transform expression begins with:

\alinhaverbatim
<Transform Expression> -> <Transform Tertiary>
<Transform Tertiary> -> <Transform Secondary>
<Transform Secondary> -> <Transform Secondary> <Transformer> |
                         <Transform Primary>
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary>
                 transformed <Transform Primary>
\alinhanormal

We have here a new type of token, representing the last type of
transformer that we ommited in the last subsection about pair
expressions:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_TRANSFORMED,  // Symbolic token 'transformed'
@
\fimcodigo

This token correspond to the following keyword:

\iniciocodigo
@<List of Keywords@>+=
"transformed",
@
\fimcodigo


About the grammar rules, they mean that there is no tertiary operators
for transform expressions. Anyway, we will define a function to
evaluate tertiary expressions just to keep our API uniform between
different functions that evaluate expressions and also to keep a
function ready to be modified if in the future a tertiary operator is
added to the language:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin,
                               struct generic_token *end,
                               struct transform_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin,
                               struct generic_token *end,
                               struct transform_variable *result){
  return eval_transform_secondary(mf, cx, begin, end, result);
}
@
\fimcodigo

The function that evaluates secondary transform expressions is this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end,
                              struct transform_variable *result);
@
\fimcodigo

This function works walking over the list os tokens in the expression,
ignoring tokens nested in parenthesis, brackets and braces. Each time
it finds a secondary operator, it stores its position. After walking
all tokens, if we did not find a secondary operator, we evaluate the
entire expression as a primary transform expression. Otherwise,
everything before the last operator is evaluated as a secondary
expression and we apply the operator over the resulting transform that
we find after evaluating the expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end,
                              struct transform_variable *result){
  struct generic_token *p, *last_transform = NULL, *last_token = NULL,
                       *end_secondary = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin;
  do{ // FInds rightmost transform operator:
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() &&
       (p -> type == TYPE_ROTATED || p -> type == TYPE_SCALED ||
        p -> type == TYPE_SHIFTED || p -> type == TYPE_SLANTED ||
        p -> type == TYPE_XSCALED || p -> type == TYPE_YSCALED ||
        p -> type == TYPE_ZSCALED || p -> type == TYPE_TRANSFORMED)){
      last_transform = p;
      end_secondary = last_token;
    }
    last_token = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  } while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(last_transform != NULL){ // We have a secondary operator:
    if(end_secondary == NULL){ // But there is nothing before it:
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                     TYPE_T_TRANSFORM);
      return false;
    }
    if(!eval_transform_secondary(mf, cx, begin, end_secondary, result))
      return false;
    @<Apply Secondary Transformer over Transforms@>
  }
  else // NO secondary operator:
    return eval_transform_primary(mf, cx, begin, end, result);
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_TRANSFORM);
  return false;
}
@
\fimcodigo

Now let's apply the different transformer operators over our transform
variables and results. The first kind of transformer is the rotation,
which we apply with the code below:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>=
if(last_transform -> type == TYPE_ROTATED){
  struct numeric_variable theta;
  double angle_radian;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &theta))
    return false;
  // 1 degree = 0,0174533 radians
  angle_radian = theta.value * 0.0174533;
  TRANSFORM_ROTATE(result -> value, angle_radian);
  return true;
}
@
\fimcodigo

Changing the scale for a transform means running the folllowing code:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_SCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE(result -> value, scale.value);
  return true;
}
@
\fimcodigo

The next transformer makes a translation, or shifting over a distance
$(x, y)$.

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_SHIFTED){
  struct pair_variable shift;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end, &shift))
    return false;
  TRANSFORM_SHIFT(result -> value, shift.x, shift.y);
  return true;
}
@
\fimcodigo


Now the transformer that slants a transform with intensity $s$:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_SLANTED){
  struct numeric_variable slant;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &slant))
    return false;
  TRANSFORM_SLANT(result -> value, slant.value);
  return true;
}
@
\fimcodigo

Changing the scale only in axis $x$ shrinks or expand the transform in
that axis by some factor $s$. This operation is done by the following
code:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_XSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE_X(result -> value, scale.value);
  return true;
}
@
\fimcodigo

We can also change the scale only in the axis $y$ by some factor $s$:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_YSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE_Y(result -> value, scale.value);
  return true;
}
@
\fimcodigo

Finally, we can change the scale in the complex plane, multiplying
each point by $(s, t)$, interpreting everything as complex
numbers. The result is a simultaneous rotation and scaling. This
transformer is implemented by the code below:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_ZSCALED){
  struct pair_variable scale;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE_Z(result -> value, scale.x, scale.y);
  return true;
}
@
\fimcodigo

Finally, the last transformer combines two transforms in a single
one. This is done multiplying the matrices that represent the
transform:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_TRANSFORMED){
  struct transform_variable b;
  if(!eval_transform_primary(mf, cx, last_transform -> next, end, &b))
    return false;
  MATRIX_MULTIPLICATION(result -> value, b.value);
  return true;
}
@
\fimcodigo

\subsecao{8.3.2 Transform Tertiary Expressions: Literals and Variables}

The remaining rules in the grammar for transform expressions are:

\alinhaverbatim
<Transform Primary> -> <Transform Variable> |
                       ( <Transform Tertiary> ) |
                       ( <Numeric Expression> , <Numeric Expression> ,
                         <Numeric Expression> , <Numeric Expression> ,
                         <Numeric Expression> , <Numeric Expression> )
\alinhanormal

In the first case, we have a single symbolic token with a transform
variable. In the other two cases, we have more than one token where
the first one is an open parenthesis. In one we have a single
transform expression in the parenthesis and in the other we have
comma-separated six numeric expressions expressing a transform
literal.

The function that evaluates primary transform expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin,
                            struct generic_token *end,
                            struct transform_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin,
                            struct generic_token *end,
                            struct transform_variable *result){
  if(begin == end && begin -> type == TYPE_SYMBOLIC){ // It's a variable?
    @<Primary Transform: Variable@>
  }
  else if(begin != end && begin -> type == TYPE_OPEN_PARENTHESIS &&
          end -> type == TYPE_CLOSE_PARENTHESIS){
    if(begin -> next == end){
      RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '(');
      return false;
    }
    struct generic_token *p = begin -> next;
    DECLARE_NESTING_CONTROL();
    bool has_comma = false;
    do{
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() && p -> type == TYPE_COMMA){
        RESET_NESTING_COUNT();
        has_comma = true;
        break;
      }
      if(p != end)
        p = p -> next;
      else
        p = NULL;
    } while(p != NULL);
    if(has_comma){
      @<Primary Transform: Literal@>
    }
    else{
      @<Primary Transform: Parenthesis@>
    }
  }
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_TRANSFORM);
  return false;
}
@
\fimcodigo

The above code identifies if we are dealing with one of the three
cases of transform primary expressions: a variable, a literal or a
subexpression. The first case is the easiest: we have a variable if
there is a single symbolic token. The other two are always delimited
by parenthesis, but we can distinguish between both because a
transform literal is composed by commas delimiting its values.

The simplest case is evaluating a transform variable:

\iniciocodigo
@<Primary Transform: Variable@>=
struct symbolic_token *v = (struct symbolic_token *) begin;
struct transform_variable *content = v -> var;
if(content == NULL){
  RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(v -> line), v -> value);
  return false;
}
if(content -> type != TYPE_T_TRANSFORM){
  RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(v -> line),
                                 v -> value, content -> type,
                                 TYPE_T_TRANSFORM);
  return false;
}
if(isnan(content -> value[0])){
  RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(v -> line), v -> value);
  return false;
}
memcpy(result -> value, content -> value, sizeof(float) * 9);
return true;
@
\fimcodigo

The next case is when we have a subexpression between parenthesis:

\iniciocodigo
@<Primary Transform: Parenthesis@>=
struct generic_token *end_expr;
for(end_expr = begin -> next; end_expr -> next != end;
    end_expr = end_expr -> next);
return eval_transform_expression(mf, cx, begin -> next, end_expr, result);
@
\fimcodigo

And finally, the last case, where we need to interpret six numeric
expressions to obtain a transform literal:

\iniciocodigo
@<Primary Transform: Literal@>=
int i;
struct generic_token *begin_numeric_expr, *end_numeric_expr;
struct numeric_variable numeric_result;
end_numeric_expr = begin_numeric_expr = begin -> next;
float values[6]; // Each one of the 6 values will be stored here
for(i = 0; i < 6; i ++){
  p = begin_numeric_expr;
  do{
    if(p != end){ // Ignoring last ')' 
      COUNT_NESTING(p);
    }
    if(IS_NOT_NESTED() && ((i < 5 && p -> type == TYPE_COMMA) ||
                            (i == 5 && p -> type == TYPE_CLOSE_PARENTHESIS))){
      break;
    }
    end_numeric_expr = p;
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(p == NULL){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_TRANSFORM);
    return false;
  }
  if(!eval_numeric_expression(mf, cx, begin_numeric_expr, end_numeric_expr,
                              &numeric_result))
    return false;
  values[i] = numeric_result.value;
  begin_numeric_expr = p -> next;
  end_numeric_expr = begin_numeric_expr;
}
// Storing in the right order inside the matrix:
result -> value[0] = values[2]; result -> value[1] = values[4];
result -> value[2] = 0.0;
result -> value[3] = values[3]; result -> value[4] = values[5];
result -> value[5] = 0.0;
result -> value[6] = values[0]; result -> value[7] = values[1];
result -> value[8] = 1.0;
return true;
@
\fimcodigo

The above code has two loops. The first one has as invariant the
property that in the beginning of each iteration, \monoespaco{p}
and \monoespaco{begin\_numeric\_expr} points to the first token in the
next numeric expression in the literal that we still did not
evaluate. The second loop will update \monoespaco{end\_numeric\_expr}
so that it will mark the end of the next non-evaluated numeric
expression. After the inner loop exits, we have the numeric expression
correctly delimited and we can evaluate it and store its value as part
of the transform. We repeat this siz times to read the entire
transform literal.

\subsubsecao{8.3.3. Transforms in Numeric Expressions}

Transforms can be placed in primary numeric expressions. The following
grammar rules allow them:

\alinhaverbatim
<Numeric Primary> -> <Transform Part><Transform Primary>
<Transform Part> -> xpart | ypart | xxpart | xypart | yxpart | yypart
\alinhanormal

The six operators above extract each one of the six numeric values
in a transform, in the same order that they are listed.

As \monoespaco{xpart} and \monoespaco{ypart} already were defined when
we were defining pair expressions, we just need to define the next
four new tokens for the new operators:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_XXPART,  // Symbolic token xxpart'
TYPE_XYPART,  // Symbolic token xypart'
TYPE_YXPART,  // Symbolic token yxpart'
TYPE_YYPART,  // Symbolic token yypart'
@
\fimcodigo

And the keywords associated with them:

\iniciocodigo
@<List of Keywords@>+=
"xxpart", "xypart", "yxpart", "yypart",
@
\fimcodigo

These four new operators are evaluated in the function that evaluates
primary numeric expressions:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin -> type >= TYPE_XXPART && begin -> type <= TYPE_YYPART){
  struct transform_variable t;
  if(!eval_transform_primary(mf, cx, begin -> next, end, &t))
    return false;
  if(begin -> type == TYPE_XXPART)
    result -> value = t.value[0];
  else if(begin -> type == TYPE_XYPART)
    result -> value = t.value[3];
  else if(begin -> type == TYPE_YXPART)
    result -> value = t.value[1];
  else if(begin -> type == TYPE_YYPART)
    result -> value = t.value[4];
  return true;
}
@
\fimcodigo

But what about \monoespaco{xpart} and \monoespaco{ypart}? They were
already treated when we were evaluating primary numeric expressions in
Subsection 8.2.4. But we need to augment the definition of this
operator present there to also deal with cases where the operand is
not a pair, but a transform. This is how we do this for
the \monoespaco{xpart} operator:

\iniciocodigo
@<Numeric Primary: X-Part in Non-Pair@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, begin -> next, end, &t))
  return false;
result -> value = t.value[6];
return true;
@
\fimcodigo

And the same must be done for the \monoespaco{ypart} operator:

\iniciocodigo
@<Numeric Primary: Y-Part in Non-Pair@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, begin -> next, end, &t))
  return false;
result -> value = t.value[7];
return true;
@
\fimcodigo

\subsubsecao{8.3.4. Transforms in Pair Expressions}

Transforms also appear in grammar rules about pair expressions. It is
needed to deal woth transform expressions in pair secondary
expressions:

\alinhaverbatim
<Pair Secondary> -> <Pair Secondary><Transformer>
<Transformer> -> (...) | transformed <Transform Primary>
\alinhanormal

This operator apply the linear transform in the right-side to the pair
in the left-side. We can implement it with the code below that augment
the already written code about transformers in Subsection 8.2.2. about
pair secondary expressions.

\iniciocodigo
@<Secondary Pair Operator: Additional Operators@>=
else if(last_mul -> type == TYPE_TRANSFORMED){
  struct pair_variable a;
  struct transform_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_transform_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = LINEAR_TRANSFORM_X(a.x, a.y, b.value);
  result -> y = LINEAR_TRANSFORM_Y(a.x, a.y, b.value);
  return true;
}
@
\fimcodigo


\subsecao{8.4. Path Assignments and Expressions}

To assign a path to a variable with the right type, we use the
following code:

\iniciocodigo
@<Assignment for Path Variables@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  if(!eval_path_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    if(!assign_path_variable(mf, (struct path_variable *) var -> var,
                             &result))
      return false;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &result, false);
}
@
\fimcodigo

The declaration for the assignment function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> permanent){
    disalloc = permanent_free;
    alloc = permanent_alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> length != -1 && disalloc != NULL)
    path_recursive_free(disalloc, target, false);
  return recursive_copy_points(mf, NULL, alloc, &target, source, false);
}
@
\fimcodigo

Copying a path recursively means allocating space for the new path and
copying the data. While copying the points, we should also check if
there are other subpaths that should be copyied recursively. To do
this, we use the following auxiliary function:


This function will make the allocation for the new variable if
necessary, will also get the pointers por the point array in the
destiny and will call another auxiliary function to walk recursively
over the destiny while copying the points:


The function that will walk over the origin recursively copying the
points:


Now we can examine the path expressions.

\subsubsecao{8.4.1. Joining Paths}

The grammar for path expressions begin with:

\alinhaverbatim
<Path Expression> -> <Pair Expression> | <Path Tertiary> |
                     <Path Subexpression><Direction Specifier> |
                     <Path Subexpression><Path Join> cycle
<Path Join> -> <Direction Specifier><Basic Join><Direction Specifier>
<Basic Join> -> & | .. | .. <Tension> .. | .. <Controls> .. | --
<Tension> -> tension <Tension Amount> |
             tension <Tension Amount> and <Tension Amount>
<Tension Amount> -> <Numeric Primary> | atleast <Numeric Primary>
<Controls> -> controls <Pair Primary> |
              controls <Pair Primary> and <Pair Primary>
<Direction Specifier> -> Empty |
                         { <Pair Expression } |
                         { <Numeric Expression> , <Numeric Expression> }
<Path Subexpression> -> <Path Expression> |
                        <Path Subexpression><Path Join><Path Tertiary>
\alinhanormal

This requires the register of these new types of tokens:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_CYCLE,          // Symbolic token 'cycle'
TYPE_AMPERSAND,      // Symbolic token '&'
TYPE_JOIN,           // Symbolic token '..'
TYPE_TENSION,        // Symbolic token 'tension'
TYPE_AND,            // Symbolic token 'and'
TYPE_ATLEAST,        // Symbolic token 'atleast'
TYPE_CONTROLS,       // Symbolic token 'controls'
TYPE_CURL,           // Symbolic token 'curl' (still not supported)
TYPE_STRAIGHT_JOIN,  // Symbolic token '--'
@
\fimcodigo

And for each one we register a new correspondent keyword:

\iniciocodigo
@<List of Keywords@>+=
"cycle", "&", "..", "tension", "and", "atleast", "controls", "curl", "--",
@
\fimcodigo

The first thing that we will define is how to count the number of
joins in a path expression. For this we will use the following
function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end);
@
\fimcodigo

The function works counting the number of ``\&'', ``--'' and also
counting the ``..'' that appear alone or that appear for the second
time in a join that specifies tension or control points:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end){
int count = 0;
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin;
  while(p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_AMPERSAND)
        count ++;
      else if(p -> type == TYPE_STRAIGHT_JOIN)
        count ++;
      else if(p -> type == TYPE_JOIN){
        struct generic_token *next = (struct generic_token *) p -> next;
        if(p == end || (next -> type !=  TYPE_TENSION &&
                        next -> type != TYPE_CONTROLS))
          count ++;
      }
    }
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }
  return count;
}
@
\fimcodigo

Now we can begin the expression evaluation.

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result);
@
\fimcodigo

Knowing the number of joins is the first step to discover the size of
our new variable and how should we allocate space for it. The number
of points is always the number of joins plus one:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result){
  int expected_length;
  int number_of_joins = count_path_joins(begin_expression, end_expression);
  expected_length = number_of_joins + 1;
  @<Path Expression: When There is No Joins@>
  @<Path Expression: Allocating Path Variable@>
  @<Path Expression: Iterating over Joins@>
  return true;
}
@
\fimcodigo

And what if the number of joins is zero? In this case we could have a
pair expression or a path tertiary expression. Anyway, we could have
in the end a direction specifier, which should be ignored in the case
of a single point or element without a join. We check if we have a
direction specifier checking if the last token is ``$\}$''. In this case,
we change the position of the end of expression for the last token
before the direction specifier:

\iniciocodigo
@<Path Expression: When There is No Joins@>=
if(number_of_joins == 0){
  if(end_expression -> type == TYPE_CLOSE_BRACES){
    struct generic_token *p = begin_expression;
    DECLARE_NESTING_CONTROL();
    while(p != end_expression){
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() &&
         ((struct generic_token *) p -> next) -> type == TYPE_OPEN_BRACES)
        break;
      p = (struct generic_token *) p -> next;
    }
    end_expression = p;
  }
  return eval_path_tertiary(mf, cx, begin_expression, end_expression,
                           result);
}
@
\fimcodigo

If there are one or more joins, then we need to allocate the new
points in our path variable. The number of allocated points is given
by variable \monoespaco{expected\_length}:

\iniciocodigo
@<Path Expression: Allocating Path Variable@>=
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points) *
                     expected_length);
if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
          begin_expression -> line);
#endif
    return false;
}
result -> length = 0; // Initialization
result -> number_of_points = 0;
result -> points[0].format = UNINITIALIZED_FORMAT;
result -> cyclic = false;
@
\fimcodigo

Now we will evaluate the joins. We need to iterate over all the tokens
finding the joins in the format:

$$
z_1{d} j {e}\_2
$$

Therefore, we need variables to store the begin and end of each part
while we perform the iteration. And then we create a loop where we
will iterate over each join in the format above:

\iniciocodigo
@<Path Expression: Iterating over Joins@>=
{
  struct generic_token *begin_z1, *end_z1 = NULL, *begin_z2, *end_z2;
  struct generic_token *begin_d = NULL, *end_d = NULL, *begin_e, *end_e;
  struct generic_token * begin_j, *end_j;
  struct path_points *z1_point = NULL, *z2_point = NULL;
  @<Path Expression: Additional Variables Declaration@>
  begin_z1 = begin_expression;
  end_z1 = begin_z1;
  while(begin_z1 != end_expression || result -> length < expected_length){
    @<Path Expression: Delimit Join Tokens@>
    @<Path Expression: Interpret Join Extremities@>
    @<Path Expression: Interpret Direction Specifiers@>
    @<Path Expression: Interpret the Join@>
    @<Path Expression: Determine Curve Shape@>
    @<Path Expression: End of Each Iteration@>
    begin_z1 = begin_z2;
    end_z1 = end_z2;
  }
}
@
\fimcodigo

We need to delimit the first element $z_1$ only in the first
iteration, when we are still in the beginning of the expression. In
the other iterations the element is already delimited in the beginning
as seen in the code above. To correctly delimit the token, we just
walk over the token list until we find the last token before ``$\{$'',
``\&'', ``\-\-'' or ``..'' assuming that we are not inside parenthesis or
brackets.

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>=
if(begin_z1 == begin_expression){
  DECLARE_NESTING_CONTROL();
  int next_type;
  end_z1 = begin_z1;
  while(end_z1 != end_expression){
    COUNT_NESTING(end_z1);
    next_type = ((struct generic_token *) end_z1 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z1 = (struct generic_token *) end_z1 -> next;
  }
}
@
\fimcodigo

Now we will delimit the first direction specifier. First we check if
we are in the end of an expression. If so, we interrupt the loop and
exit, as there are no more specifiers and we finished to read and
obtain the path. Otherwise, we read the next token to check if we have
a ``$\{$''. If not, there is no first direction specifier.  If so, then
we delimit it until finding the closing ``$\}$'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_z1 == end_expression)
  return true;
begin_d = (struct generic_token *) end_z1 -> next;
if(begin_d -> type != TYPE_OPEN_BRACES){
  begin_d = NULL;
  end_d = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_d = begin_d;
  while(end_d != end_expression){
    COUNT_NESTING(end_d);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_d) -> type == TYPE_CLOSE_BRACES)
      break;
    end_d = (struct generic_token *) end_d -> next;
  }
  if(begin_d == end_d){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_d -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Now we will delimit the join. If the join is ``\&'' or a ``--'', then
it is a single token. If the join begins with ``..'', then it could be
a single token if the next token is not ``\monoespaco{controls}'' or
``\monoespaco{tension}''. But if the next token is these specifiers,
then the join is delimited by the first ``..'' and the second ``..'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_d == NULL)
  begin_j = (struct generic_token *) end_z1 -> next;
else{
  if(end_d == end_expression)
    return true;
  begin_j = (struct generic_token *) end_d -> next;
}
end_j = begin_j;
if(begin_j -> type == TYPE_JOIN){
  struct generic_token *next_token;
  next_token = (struct generic_token *) begin_j -> next;
  if(next_token -> type == TYPE_CONTROLS || next_token -> type == TYPE_TENSION){
    DECLARE_NESTING_CONTROL();
    end_j = next_token;
    while(end_j != end_expression){
      COUNT_NESTING(end_j);
      if(IS_NOT_NESTED() && end_j -> type == TYPE_JOIN)
        break;
      end_j = (struct generic_token *) end_j -> next;
    }
  }
}
else if(begin_j -> type != TYPE_AMPERSAND &&
        begin_j -> type != TYPE_STRAIGHT_JOIN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, begin_j -> line);
#endif
  return false;
}
@
\fimcodigo

The next direction delimiter may exist or not, depending if the next
token is ``$\{$'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_j == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, end_j -> line);
#endif
  return false;
}
begin_e = (struct generic_token *) end_j -> next;
if(begin_e -> type != TYPE_OPEN_BRACES){
  begin_e = NULL;
  end_e = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_e = begin_e;
  while(end_e  != end_expression){
    COUNT_NESTING(end_e);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_e) ->  type == TYPE_CLOSE_BRACES)
      break;
    end_e = (struct generic_token *) end_e -> next;
  }
  if(begin_e == end_e){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_e -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Finally, the last join element is the next point or subpath joining
the previous one. This is always a tertiary path expression. This last
element will have its end delimited by an ampersand, opening braces or
by a join token:

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
{
  DECLARE_NESTING_CONTROL();
  int next_type;
  if(end_e == NULL)
    begin_z2 = (struct generic_token *) end_j -> next;
  else{
    if(end_e == end_expression)
      return true;
    begin_z2 = (struct generic_token *) end_e -> next;
  }
  end_z2 = begin_z2;
  while(end_z2 != end_expression){
    COUNT_NESTING(end_z2);
    next_type = ((struct generic_token *) end_z2 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z2 = (struct generic_token *) end_z2 -> next;
  }
}
@
\fimcodigo

Once we delimited each part of the join, now we need to interpret the
parts. First we will care about the extremity curve points. For this,
first we get the result of $z_1$, a path tertiary expression, and copy
it to our result. We need to do this only when we are in the beginning
of an expression, in the other cases we already interpreted this point
or subpath in the previous iteration:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>=
if(begin_z1 == begin_expression){
  bool ret;
  struct path_variable z1;
  ret = eval_path_tertiary(mf, cx, begin_z1, end_z1, &z1);
  if(!ret)
    return false;
  if(z1.length == 1 && z1.points[0].format != SUBPATH_FORMAT){
    result -> points[0].format = PROVISIONAL_FORMAT;
    result -> points[0].prov.x = z1.points[0].prov.x;
    result -> points[0].prov.y = z1.points[0].prov.y;
    result -> number_of_points ++;
  }
  else{
    result -> points[0].format = SUBPATH_FORMAT;
    if(!recursive_copy_points(mf, cx, temporary_alloc, (struct path_variable **)
                                           &(result -> points[0].subpath), &z1,
                                           true))
      return false;
    result -> number_of_points += ((struct path_variable *)
                                result -> points[0].subpath) -> number_of_points;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z1, false);
}
@
\fimcodigo

And we need to do the same with $z_2$, the other extremity. But in
this case, we need to recall that the next point may be
a \monoespaco{cycle} token. If so, we copy the first point. Otherwise,
we interpret the value like we did for $z_1$:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  struct path_points *p = result -> points;
  while(p[0].format == SUBPATH_FORMAT)
    p = ((struct path_variable *) p[0].subpath) -> points;
  memcpy(&(result -> points[result -> length]), p, sizeof(struct path_points));
  result -> length ++;
  result -> number_of_points ++;
  result -> cyclic = true;
}
else{
  bool ret;
  struct path_variable z2;
  ret = eval_path_tertiary(mf, cx, begin_z2, end_z2, &z2);
  if(!ret)
    return false;
  if(z2.length == 1 && z2.points[0].format != SUBPATH_FORMAT){
    result -> points[result -> length].format = PROVISIONAL_FORMAT;
    result -> points[result -> length].prov.x = z2.points[0].prov.x;
    result -> points[result -> length].prov.y = z2.points[0].prov.y;
    result -> number_of_points ++;
  }
  else{
    result -> points[result -> length].format = SUBPATH_FORMAT;
    if(!recursive_copy_points(mf, cx, temporary_alloc,
                         (struct path_variable **)
                         &(result -> points[result -> length].subpath), &z2,
                         true))
      return false;
    result -> number_of_points +=
        ((struct path_variable *)
            result -> points[result -> length].subpath) -> number_of_points;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z2, false);
}
@
\fimcodigo

After running the code above, our result variable that stores the
expression result already has the extremity points from this join. But
we still do not have the control points. But before compute them, we
will set the pointers \monoespaco{z1\_point}
and \monoespaco{z2\_point} to point to the current extremity points of
the current join. We read this information from the
variable \monoespaco{result} that we are filling:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>+=
z1_point = &(result -> points[result -> length - 2]);
while(z1_point -> format == SUBPATH_FORMAT){
  struct path_variable *p = (struct path_variable *) z1_point -> subpath;
  z1_point = &(p -> points[p -> length - 1]);
}
z2_point = &(result -> points[result -> length - 1]);
while(z2_point -> format == SUBPATH_FORMAT){
  struct path_variable *p = (struct path_variable *) z2_point -> subpath;
  z2_point = &(p -> points[0]);
}
@
\fimcodigo

Now we need to interpret both direction specifiers. They can be empty
(which is equivalent to have direction $(0, 0)$) or they can be a pair
specifying a direction vector.

We will store them in the variables \monoespaco{(w0\_x,
w0\_y)} and \monoespaco{(w1\_x, w1\_y)}.  We also
will store the previous direction specifier from last iteration and
also we will reserve space to store the next direction specifier if we
need to peek it ahead of time. This could be necessary to take in
consideration a broader picture when deciding the curve shape:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>=
float w0_x = NAN, w0_y = NAN, w1_x = NAN, w1_y = NAN;
float prev_w_x = NAN, prev_w_y = NAN;
float next_w_x = NAN, next_w_y = NAN;
@
\fimcodigo

During this iteration where we are delimiting and interpreting the
join operator and its points, we need to reinitialize such values. The
current specifiers are set as null, except that if the previous
iteration stored a next specifier, this specifier is our first one and
we do not need to read it again. After this, the next value is
erased. And finally, after this, we read the second direction
specifier from the tokens:

\iniciocodigo
@<Path Expression: Interpret Direction Specifiers@>=
w0_x = w0_y = w1_x = w1_y = NAN;
if(!isnan(next_w_x)){
  w0_x = next_w_x;
  w0_y = next_w_y;
}
else if(!eval_direction_specifier(mf, cx, begin_d, end_d, &w0_x, &w0_y))
  return false;
next_w_x = next_w_y = NAN;
if(!eval_direction_specifier(mf, cx, begin_e, end_e, &w1_x, &w1_y))
  return false;
@
\fimcodigo

The function that evaluates direction specifiers is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y);
@
\fimcodigo

And the function works checking for 4 different cases: when there is
no direction specifier, when it is a curl specification, when it is a
direction specified by two numbers and when it is a direction
specified by a pair:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y){
  @<Direction Specifier: Case 1@>
  @<Direction Specifier: Case 2@>
  @<Direction Specifier: Case 3@>
  return false;
}
@
\fimcodigo

When a specifier does not exist, we store nothing and return letting
the values as indefinide:

\iniciocodigo
@<Direction Specifier: Case 1@>=
if(begin == NULL || end == NULL){
  return true;
}
@
\fimcodigo

Now we will check if we have the case ``$\{ a , b\}$'' where $a$ and
$b$ are numbers. To check for this case, we will try to delimit $a$
and $b$ searching for the comma. We will interpret this case only if
the comma is found:

\iniciocodigo
@<Direction Specifier: Case 2@>=
DECLARE_NESTING_CONTROL();
struct generic_token *begin_a, *end_a, *begin_b = NULL, *end_b;
begin_a = (struct generic_token *) begin -> next;
end_a = begin_a;
while(end_a -> next != end){
  COUNT_NESTING(end_a);
  if(IS_NOT_NESTED() && end_a -> type == TYPE_COMMA){
    begin_b = (struct generic_token *) end_a -> next;
    break;
  }
  end_a = (struct generic_token *) end_a -> next;
}
if(begin_b != NULL){
  struct numeric_variable a, b;
  end_b = begin_b;
  while(end_b -> next != end)
    end_b = (struct generic_token *) end_b -> next;
  if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(a.value != 0.0 || b.value != 0.0){
    *w_x = a.value;
    *w_y = b.value;
  }
  return true;
}
@
\fimcodigo

And finally, the last case, where we have an element $\{a\}$, where
$a$ is a pair expression. To deal with this case, recall that in the
previous case we already delimited $a$. If a comma was not found, we
did not delimited $b$, but still delimited $a$. Therefore, we can
interpret the tokens as a pair expression:

\iniciocodigo
@<Direction Specifier: Case 3@>=
else{ // if in the previous case there was no comma
  struct pair_variable a;
  if(!eval_pair_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(a.x != 0.0 || a.y != 0.0){
    *w_x = a.x;
    *w_y = a.y;
  }
  return true;
}
@
\fimcodigo

Now finally we will interpret the join itself. As the direction
specifier can be represented in two ways, as a direction vector or as
a curl, the join can be represented by two numbers representing the
tension or two pairs $u$ and $v$ representing directly the control
points. We will declare then variables that will hold these values:

\iniciocodigo
@<Path Expression: Interpret the Join@>=
float tension0 = NAN, tension1 = NAN, u_x = NAN, u_y = NAN, v_x = NAN,
      v_y = NAN;
bool atleast0 = false, atleast1 = false; // If our tension is just an inferior limit
@
\fimcodigo

First we will deal with the simplest cases. If our join is a
concatenation, characterized by the ``\&'' token, we are concatenating
tow points or (more probably) two sub-paths. In this case we should
check is the two joining points occupy the same place (which means
having a distance lesser than 0.00002). If not, we should raise an
error. If so, we join both paths removing the second copy of the point
where the join is happening.

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
  double dif_x = z1_point -> prov.x - z2_point -> prov.x;
  double dif_y = z1_point -> prov.y - z2_point -> prov.y;
  if(hypot(dif_x * dif_x, dif_y * dif_y) > 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Concatenating discontinuous paths.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  v_x = u_x = z1_point -> prov.x;
  v_y = u_y = z1_point -> prov.y;
  // This will overwrite the second extremity point
  // and also the control points below in the case of a next iteration:
  result -> number_of_points --;
  z1_point -> point.x = NAN;
  z1_point -> point.y = NAN;
}
@
\fimcodigo

Another simple case is when we use the ``\monoespaco{--}'' join. In
this case, we make the control points evenly spaced between both
extremity points. This will create a straight line between them:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN){
  u_x = z1_point -> point.x + (1.0/3.0) *
        (z2_point -> point.x - z1_point -> point.x);
  u_y = z1_point -> point.y + (1.0/3.0) *
        (z2_point -> point.y - z1_point -> point.y);
  v_x = z1_point -> point.x + (2.0/3.0) *
        (z2_point -> point.x - z1_point -> point.x);
  v_y = z1_point -> point.y + (2.0/3.0) *
        (z2_point -> point.y - z1_point -> point.y);
}
@
\fimcodigo


If our join is composed just by the token ``..'', then it will be
defined as having a tension of exactly 1 and 1:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_JOIN){
  tension0 = 1.0;
  tension1 = 1.0;
  atleast0 = false;
  atleast1 = false;
}
@
\fimcodigo

The join could be specifying directly the control points in the form
``.. controls $c_0$ ..'' or ``.. controls $c_0$ and $c_1$ .. '', where
$c_0$ and $c_1$ are pair expressions. In this case we try to delimit
the values of $c_0$ and $c_1$ (if it exists) and use them directly as
control points. If $c_1$ does not exist, then we use as the second
control point a point equal $c_0$:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_c0, *end_c0, *begin_c1 = NULL, *end_c1 = NULL;
  struct pair_variable c0, c1;
  begin_c0 = (struct generic_token *) begin_j -> next;
  begin_c0 = (struct generic_token *) begin_c0 -> next;
  if(begin_c0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  end_c0 = begin_c0;
  while(end_c0 -> next != end_j){
    COUNT_NESTING(end_c0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_c0 -> next) -> type == TYPE_AND)
      break;
    end_c0 = (struct generic_token *) end_c0 -> next;
  }
  if(end_c0 -> next != end_j){
    begin_c1 = end_c0 -> next;
    begin_c1 = (struct generic_token *) begin_c1 -> next;
    if(begin_c1 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    end_c1 = begin_c1;
    while(end_c1 -> next != end_j)
      end_c1 = (struct generic_token *) end_c1 -> next;
  }
  if(!eval_pair_primary(mf, cx, begin_c0, end_c0, &c0))
    return false;
  u_x = c0.x;
  u_y = c0.y;
  if(begin_c1 != NULL){
    if(!eval_pair_primary(mf, cx, begin_c1, end_c1, &c1))
      return false;
     v_x = c1.x;
     v_y = c1.y;
  }
  else{
    v_x = c0.x;
    v_y = c0.y;
  }
}
@
\fimcodigo

The last join type have the format ``.. tension $t_0$ ..'' or
``.. tension $t_0$ and $t_1$ .. '' where $t_0$ and $t_1$ are primary
numeric expressions that should evaluate to a value greater or equal
than 3/4 and which can optionally be preceded by the token
``\monoespaco{atleast}''. If just $t_0$ is defined but not $t_1$, we
assume that $t_1$ have the same value than $t_0$. We can then
interpret this join with the code below:


\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_TENSION){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_t0, *end_t0, *begin_t1 = NULL, *end_t1 = NULL;
  struct numeric_variable t0, t1;
  begin_t0 = (struct generic_token *) begin_j -> next;
  begin_t0 = (struct generic_token *) begin_t0 -> next;
  if(begin_t0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  if(begin_t0 == end_j ||
     (begin_t0 -> type == TYPE_ATLEAST && begin_t0 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  else
    atleast0 = false;
  end_t0 = begin_t0;
  while(end_t0 -> next != end_j){
    COUNT_NESTING(end_t0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_t0 -> next) -> type == TYPE_AND)
      break;
    end_t0 = (struct generic_token *) end_t0 -> next;
  }
  if(end_t0 -> next != end_j){
    begin_t1 = end_t0 -> next;
    begin_t1 = (struct generic_token *) begin_t1 -> next;
    if(begin_t1 == end_j ||
       (begin_t1 -> type == TYPE_ATLEAST && begin_t1 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    if(begin_t1 -> type == TYPE_ATLEAST){
      atleast1 = true;
      begin_t1 = (struct generic_token *) begin_t1 -> next;
    }
    else
      atleast1 = false;
    end_t1 = begin_t1;
    while(end_t1 -> next != end_j)
      end_t1 = (struct generic_token *) end_t1 -> next;
  }
  if(!eval_numeric_primary(mf, cx, begin_t0, end_t0, &t0))
    return false;
  tension0 = t0.value;
  if(begin_t1 != NULL){
    if(!eval_numeric_primary(mf, cx, begin_t1, end_t1, &t1))
      return false;
    tension1 = t1.value;
  }
  else{
    tension1 = t0.value;
  }
  if(tension0 < 0.75 || tension1 < 0.75){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
          "METAFONT: Error: %s:%d: Improper tension. Should be >= 0.75\n",
          mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

After interpreting the join, either we have a pair of control points,
in which case we do not need to do anything more to determine the
curve shape, or we havetwo numbers representing the curve tension. In
this case, it will be important to take into consideration the
direction specifiers to choose the final curve shape.

However, the direction specifiers could be empty. In this case, there
are several rules that we should follow to choose the default direction.

%The first rule is that in the beginning and end of a non-cyclic path,
%we always will have an implicit ``\monoespaco{$\{$curl 1$\}$}''.
%The same happens before and after a concatenation. Therefore:

%$$
%z_0 .. z_1 .. z_2 = \{\monoespaco{curl}\ 1\}z_0 .. z_1 .. z_2\{\monoespaco{curl}\ 1\}
%$$

%And also:

%$$
%.. z_n \& z_{n+1} .. = .. z_n\{\monoespaco{curl}\ 1\} \& \{\monoespaco{curl}\ 1\}z_{n+1} ..
%$$

%This means that in the first iteration, if we are not in a cyclic
%path, we need to consider that the previous direction specifier
%is \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>=
%if(begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE)
%  prev_curl = 1.0;
%
%\fimcodigo

%If we are in a concatenation, if ee have no direction specifier, then
%we consider them as \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>+=
%if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
%  if(isnan(curl0) && isnan(w0_x))
%    curl0 = 1.0;
%  if(isnan(curl1) && isnan(w1_x))
%    curl1 = 1.0;
%}
%
%\fimcodigo

%And finally, if we are not in a cyclic path and we do not have a
%direction specifier after the second current point, we must check if
%we are in the last path join. We check this looking at the tokens and
%looking if there are a next join after the second current point and
%before the end of the expression. If this is the last join, we
%consider the last delimiter as \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>+=
%if(end_z1 == end_expression)
%  next_curl = 1.0;
%else if(end_expression -> type != TYPE_CYCLE &&
%        ((struct generic_token *) (end_z1 -> next)) -> type !=
%        TYPE_OPEN_BRACES){
%  bool last_join = true;
%  struct generic_token *p = (struct generic_token *) end_z1 -> next;
%  DECLARE_NESTING_CONTROL();
%  while(p != end_expression){
%    COUNT_NESTING(p);
%    if(IS_NOT_NESTED() &&
%       (p -> type == TYPE_AMPERSAND || p -> type == TYPE_JOIN)){
%      last_join = false;
%      break;
%    }
%    p = (struct generic_token *) p -> next;
%  }
%  if(last_join)
%    next_curl = 1.0;
%}
%
%\fimcodigo

%These rules by themselves do not do anything. The beginning and end
%points in a non-cyclic path are discontinuous, we do not need control
%points after them. Likewise, in a concatenation we have equal points
%joining. We do not need anything between them. However, these previous
%rules became relevant when combined with the next rules.

If there is a direction specifier after a point, but not before, we
copy the direction specifier. We do the same when there is a direction
specifier before, but not after it. Therefore:

$$
.. z_0 .. z_1\{d\} ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

And also:

$$
.. z_0 .. \{d\}z_1 ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

The cyclic nature of a path must be taken into consideration.

For the case where we want to copy the direction specifier in the left
side to the right side of a point, we need to preserve this value
between iterations. By our rules, it is important to preserve the
value only when we read it explicitly between braces. Then, when we
are in the end of each iteration, we preserve the specifier in these
cases, otherwise we erase it:

\iniciocodigo
@<Path Expression: End of Each Iteration@>=
if((begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE) ||
   (begin_j == end_j && begin_j -> type == TYPE_AMPERSAND) ||
   (begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN) ||
   (begin_e != NULL && end_e != NULL)){
  prev_w_x = w1_x;
  prev_w_y = w1_y;
}
else{
  prev_w_x = NAN;
  prev_w_y = NAN;
}
@
\fimcodigo

Now to apply the rule where we copy the specifier from the left of a
point to its right, we use the code:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(w0_x) && isnan(w0_y)){
  w0_x = prev_w_x;
  w0_y = prev_w_y;
}
@
\fimcodigo

Now we copy the direction specifier from the right to the left. We do
this only if we already do not have a defined specifier and if the
specifier to the right is given explicitly between braces:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(w1_x) && isnan(w1_y)               ){
  if(end_z2 -> next != NULL && end_z2 != end_expression &&
     ((struct generic_token *) (end_z2 -> next)) -> type ==
     TYPE_OPEN_BRACES){
    struct generic_token *next0, *next1;
    DECLARE_NESTING_CONTROL();
    next0 = (struct generic_token *) end_z2 -> next;
    next1 = next0;
    while(next1 != end_expression){
      COUNT_NESTING(next1);
      if(IS_NOT_NESTED() && next1 -> type == TYPE_CLOSE_BRACES)
        break;
      next1 = (struct generic_token *) next1 -> next;
    }
    if(next0 -> type == TYPE_OPEN_BRACES && next1 -> type == TYPE_CLOSE_BRACES){
      if(!eval_direction_specifier(mf, cx, next0, next1, &next_w_x,
                                   &next_w_y))
        return false;
      w1_x = next_w_x;
      w1_y = next_w_y;
    }
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
              mf -> file, begin_j -> line);
#endif
      return false;
    }
  }
}
@
\fimcodigo

But we also need to deal with the cyclic case. By the grammar rules,
there will be no direction specifier before the first point. But a
direction specifier can be placed before the token \monoespaco{cycle}
if it exists. And in this case, this specifier could be copied to the
right side of the first point. Likewise, the direction specifier can
be copied from the right side of the first point to the place before
the \monoespaco{cycle} token if we do not have an explicit specifier
there.

First the simplest case: there is an explicit direction specifier
after the first point in the beginning of a cyclic path. In this case,
we need to store it to use when choosing the last control points in
the curve. To store it, we will need the following new variables:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float first_w_x = NAN, first_w_y = NAN;
@
\fimcodigo

And then, in the first iteration over the joins, if we are in a cyclic
path and if exists an explicit specifier, we store it:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d != NULL && end_d != NULL){
  first_w_x = w0_x;
  first_w_y = w0_y;
}
@
\fimcodigo

After, when we arrive at the last iteration of a cyclic path, we will
take into account the stored value:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  if(!isnan(first_w_x) && isnan(w1_x)){
    w1_x = first_w_x;
    w1_y = first_w_y;
  }
}
@
\fimcodigo

To make copies in the opposite direction, when we are in the first
iteration, we need to look at the last join. First we walk over the
expression until the end (until finding \monoespaco{cycle}) always
storing the last direction specifier and the last join. If the
token \monoespaco{cycle} appear after the last specifier, then we need
to check its value and copy it.

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d == NULL && isnan(w0_x) && isnan(u_x)){
  struct generic_token *begin_last_spec = NULL, *end_last_spec = NULL,
                       *last_join = NULL, *second_last_join = NULL, *p;
  DECLARE_NESTING_CONTROL();
  p = end_z1 -> next;
  while(p != end_expression){
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_OPEN_BRACES){
        begin_last_spec = p;
      }
      else if(p -> type == TYPE_CLOSE_BRACES)
        end_last_spec = p;
      else if(p -> type == TYPE_JOIN || p -> type == TYPE_AMPERSAND ||
              p -> type == TYPE_STRAIGHT_JOIN){
        second_last_join = last_join;
        last_join = p;
      }
      else if(p -> type == TYPE_CYCLE)
        break;
      else
        COUNT_NESTING(p);
    }
    else
      COUNT_NESTING(p);
    p = (struct generic_token *) p -> next;
  }
  if(end_last_spec != NULL && end_last_spec -> next == p &&
     p -> type == TYPE_CYCLE){
    if(!eval_direction_specifier(mf, cx, begin_last_spec, end_last_spec,
                                 &w0_x, &w0_y))
      return false;
  }
  @<Code After Peeking the Last Join in Cyclic Path@>
}
@
\fimcodigo

The next rule applies when we have a join like:

\alinhaverbatim
.. z .. controls  u  and  v ..  = .. z{u-z} .. controls  u  and  v ..
\alinhanormal

And also:

\alinhaverbatim
.. controls u and v .. z =  .. controls u and v .. z{z-v} ..
\alinhanormal

But only if the result of subtracting the pairs $u-z$ and $z-v$ is
different than zero. If equal zero, we will raise an erros as we still
do not support this.

First the easiest case: the explicit control points appear before the
current join. In this case we already read these control points in the
previous iteration. We just need variables to store this control point:


\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float previous_point_x = NAN, previous_point_y = NAN;
@
\fimcodigo

If we have some value stored in these variables and if we do not have
an explicit direction specifier, then we generate our specifier with
the described rules. Just observe that we consider as equals points
whose distance is lesser or equal than 0.00002.

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_d == NULL && end_d == NULL && !isnan(previous_point_x) &&
   !isnan(previous_point_y) && isnan(w0_x)){
  w0_x = z1_point -> point.x - previous_point_x;
  w0_y = z1_point -> point.y - previous_point_y;
  if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

After possibly using the previous direction specifier, we do not need
it anymore and we can update the variables with current values for the
case that we need them in the next iteration:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  previous_point_x = v_x;
  previous_point_y = v_y;
}
else{
  previous_point_x = NAN;
  previous_point_y = NAN;
}
@
\fimcodigo

About the second direction specifier, if we still do not have a value,
we should check the next join and see if we find explicit control
points. If we find it, we read the first of these points, interpret it
and use its value like described in the rules above:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_e == NULL && end_e == NULL &&  isnan(w1_x) &&
   end_z2 != end_expression){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_point, *end_point;
  begin_point = (struct generic_token *) end_z2 -> next;
  while(begin_point != end_expression){
    COUNT_NESTING(begin_point);
    if(IS_NOT_NESTED() && (begin_point -> type == TYPE_JOIN ||
                          begin_point -> type == TYPE_AMPERSAND ||
                          begin_point -> type == TYPE_STRAIGHT_JOIN))
      break;
    begin_point = (struct generic_token *) begin_point -> next;
  }
  if(begin_point != end_expression &&
     begin_point -> type != TYPE_AMPERSAND &&
     begin_point -> type != TYPE_STRAIGHT_JOIN){
    begin_point = (struct generic_token *) begin_point -> next;
    if(begin_point != end_expression && begin_point -> type == TYPE_CONTROLS){
      begin_point = (struct generic_token *) begin_point -> next;
      end_point = begin_point;
      while(end_point != end_expression){
        struct generic_token *next = (struct generic_token *) end_point -> next;
        COUNT_NESTING(end_point);
        if(IS_NOT_NESTED() && next != NULL &&
           (next -> type == TYPE_AND || next -> type == TYPE_JOIN))
          break;
        end_point = (struct generic_token *) end_point -> next;
      }
      if(end_point != end_expression){
        struct pair_variable var;
        if(!eval_pair_primary(mf, cx, begin_point, end_point, &var))
          return false;
        w1_x = var.x - z2_point -> point.x;
        w1_y = var.y - z2_point -> point.y;
        if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                          "direction specifier.\n",  mf -> file,
                          begin_j -> line);
#endif
          return false;
        }
      }
    }
  }
}
@
\fimcodigo

Now let's deal with the cyclic case. If we are in the first iteration,
our path is cyclic and we have explicit control points, then we need
additional variables to store que explicit control point:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float first_point_x = NAN, first_point_y = NAN;
@
\fimcodigo

And we initialize the variable if necessary in the first iteration:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  first_point_x = u_x;
  first_point_y = u_y;
}
@
\fimcodigo

After, when we need to choose the shape of the join in the cyclic
extremity, we take into account the existance of this variable:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE && begin_d == NULL &&
   end_d == NULL && isnan(w1_x) && !isnan(first_point_x) && isnan(w1_x)){
  w1_x = first_point_x - z2_point -> point.x;
  w1_y = first_point_y - z2_point -> point.y;
  if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

And now the opposite direction. If we are in the first iteration in a
cyclic path, we peek the last join and check if we have explicit
control points to apply this rule. But in the previous rule we already
wrote code to peek between other things the last join. Therefore, we
can just append additional logic to the previous rule, after getting
the last join:


\iniciocodigo
@<Code After Peeking the Last Join in Cyclic Path@>=
if(last_join != NULL && last_join -> type == TYPE_JOIN){
  struct generic_token *p = (struct generic_token *) second_last_join -> next;
  if(p -> type == TYPE_CONTROLS){
    struct generic_token *p_end;
    p = (struct generic_token *) p -> next;
    p_end = p;
    while(p_end != end_expression){
      struct generic_token *next = (struct generic_token *) p_end -> next;
      COUNT_NESTING(p_end);
      if(IS_NOT_NESTED()){
        if(next -> type == TYPE_AND)
          p = (struct generic_token *) next -> next;
        else if(next -> type == TYPE_JOIN)
          break;
      }
      p_end = next;
    }
    if(p_end != end_expression){
      struct pair_variable var;
      if(!eval_pair_primary(mf, cx, p, p_end, &var))
        return false;
      w0_x = z1_point -> point.x - var.x;
      w0_y = z1_point -> point.y - var.y;
      if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                        "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
        return false;
      }
    }
  }
}
@
\fimcodigo

After applying the rules, we expect to have either defined control
points or direction specifiers well-defined. If we have neither, we
raise an error and exit:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  if(isnan(w0_x) || isnan(w0_y) || isnan(w1_x) || isnan(w1_y)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

If no error happened, we either already have our control points or we
need to discover the control points having a path segment as below:

$$
z_n\{w_n\}..\ {\hskip2mm \monoespaco{tension}\hskip2mm } \alpha {\hskip2mm \monoespaco{and}\hskip2mm } \beta .. \{w_{n+1}\}z_{n+1}
$$

To compute the control points given these informations, we regard the
points as complex numbers and compute:

$$
\theta = arg(w_n/(z_{n+1}-z_n))
$$

$$
\phi = arg((z_{n+1}-z_n)/w_{n+1})
$$

Next we compute the control points $u$ and $v$ with:


$$
u = z_{n} + e^{i\theta}(z_{n+1}-z_n)f(\theta, \phi)/\alpha
$$

$$
v = z_{n+1} - e^{-i\phi}(z_{n+1}-z_n)f(\phi, \theta)/\beta
$$

Except when the keyword ``atleast'' is used. In this case, if
necessary, we increase the value of $\alpha$ or $\beta$ in a way that
the control points lies inside the triangle defined by the two
extremity points and the angles given by each direction specifier. If
the triangle is invalid, we keep the original tension values.

The function $f$ used above is defined as:

$$
f(\theta, \phi) = {{2+\sqrt{2}(\sin\theta-{{1}\over{16}}\sin\phi)(\sin\phi-{{1}\over{16}}\sin\theta)(\cos\theta-\cos\phi)}\over{3(1+{1\over 2}(\sqrt 5 - 1)\cos\theta+{1\over 2}(3-\sqrt 5)\cos\phi)}}
$$

First we will define it as an auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
double compute_f(double theta, double phi);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
double compute_f(double theta, double phi){
  double n = 2 + sqrt(2) * (sin(theta) - 0.0625 * sin(phi)) *
             (sin(phi) - 0.0625 * sin(theta)) * (cos(theta) - cos(phi));
  double d = 3 * (1 + 0.5 * (sqrt(5) - 1) * cos(theta) + 0.5 * (3 - sqrt(5)) *
                  cos(phi));
  return n/d;
}
@
\fimcodigo

Now we can compute the control points if we already do not know
them. As we should regard the points as complex numbers, we will need
the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <complex.h>
@
\fimcodigo

And with the help of the C99 functions to deal with complex numbers,
we compute the formula for the control points:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  double complex u, v;
  double complex z0 = z1_point -> point.x + z1_point -> point.y * I;
  double complex z1 = z2_point -> point.x + z2_point -> point.y * I;
  double theta = carg((w0_x + w0_y * I) / (z1 - z0));
  double phi = carg((z1 - z0)/(w1_x + w1_y * I));
  u = z0 + (cexp(theta * I) * (z1 - z0) * compute_f(theta, phi)) / tension0;
  v = z1 - (cexp(-phi * I) * (z1 - z0) * compute_f(phi, theta)) / tension1;
  u_x = creal(u);
  u_y = cimag(u);
  v_x = creal(v);
  v_y = cimag(v);
  @<Adjust tension in case of 'atleast'@>
}
@
\fimcodigo

The first thing to compute is if we have a valid triangle. For this,
we first should check the internal angles. Given three pairs of
coordinates, where the first one is the vertex where we want to get
the angle, we can compute the angle there using the following
auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y){
  double v0_x, v0_y, v1_x, v1_y;
  v0_x = c0_x - v_x;
  v0_y = c0_y - v_y;
  v1_x = c1_x - v_x;
  v1_y = c1_y - v_y;
  if(fabs(v0_x) <= 0.00002 &&  fabs(v0_y) <= 0.00002)
    return INFINITY;
  if(fabs(v1_x) <= 0.00002 &&  fabs(v1_y) <= 0.00002)
    return INFINITY;
  return acos((v0_x * v1_x + v0_y * v1_y) /
                (hypot(v0_x * v0_x, v0_y * v0_y) *
                 hypot(v1_x * v1_x, v1_y * v1_y)));
}
@
\fimcodigo

Knowing how to measure the angles, we can check if the triangle is
valid. And with this we can write the function that checks if the
control points are inside the triangle. And if not, we correct its
coordinate. First we measure all the internal angles, then we get the
coordinates of the third vertex usinf the Law of Sines (the two other
vertices are known). The function is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y){
  double internal_angle0, internal_angle1, internal_angle2;
  double triangle_angle;
  double p2_x, p2_y;
  internal_angle0 = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + d0_x, p0_y + d0_y);
  internal_angle1 = get_angle(p1_x, p1_y, p0_x, p0_y, p1_x + d1_x, p1_y + d1_y);
  internal_angle2 = M_PI - internal_angle0 - internal_angle1;
  if(internal_angle0 + internal_angle1 >= M_PI - 0.00002)
    return; // Not a valid triangle
  { // Discover the third vertex coordinate:
    // First compute the triangle side that goes from p0 to the unknown vertex
    double known_side = hypot((p1_x - p0_x) * (p1_x - p0_x),
                              (p1_y - p0_y) * (p1_y - p0_y));
    double triangle_side = known_side * sin(internal_angle0) /
                           sin(internal_angle2);
    // Knowing the triangle side and the angle, we compute the coordinates:
    triangle_angle = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + 1.0, p0_y);
    p2_x = p0_x + triangle_side * cos(triangle_angle + internal_angle0);
    p2_y = p0_y + triangle_side * sin(triangle_angle + internal_angle0);
  }
  {
    @<Check if the point is inside the triangle@>
    @<If Not, Adjust the Tension@>
  }
}
@
\fimcodigo

How do we check that a point is inside a triangle? There are several
ways, what we will use is a technique that computes the signed area of
three triangles composed by the point and two of the vertex points
from the triangle, whose vertices we will pass always in the same
clockwise or counter-clockwise order. The signed area of a triangle is
its area, but the result is positive or negative, depending if we
passed the vertices in clockwise or counter-clockwise order. If all
the signed areas are positive, or if all them are negative, then the
point is inside the triangle. If not, the point is outside:

\iniciocodigo
@<Check if the point is inside the triangle@>=
bool s1, s2, s3; // O sinal das reas
s1 = ((*control_x - p1_x) * (p0_y - p1_y) -
      (p0_x - p1_x) * (*control_y - p1_y)) < 0;
s2 = ((*control_x - p2_x) * (p1_y - p2_y) -
      (p1_x - p2_x) * (*control_y - p2_y)) < 0;
s3 = ((*control_x - p0_x) * (p2_y - p0_y) -
      (p2_x - p0_x) * (*control_y - p0_y)) < 0;
if(s1 == s2 && s2 == s3)
  return;
@
\fimcodigo

An advantage of the above method is that the signed area that have a
different sign than others represents the side which is near the
target point. Therefore, if we did not exit the function, we can check
the closest side, get its line equation and compute the nearest point
in the line. If the point is in the triangle side, this is the new
point or our control point. Otherwise, we choose the nearest vertex to
the point.

\iniciocodigo
@<If Not, Adjust the Tension@>=
{
  double x0, y0, x1, y1;
  if(s1 != s2 && s1 != s3){
    x0 = p0_x; y0 = p0_y;
    x1 = p1_x; y1 = p1_y;
  }
  else if(s2 != s1 && s2 != s3){
    x0 = p1_x; y0 = p1_y;
    x1 = p2_x; y1 = p2_y;
  }
  else{
    x0 = p2_x; y0 = p2_y;
    x1 = p0_x; y1 = p0_y;
  }
  if(x1 < x0){ // x1 must be >= x0 (assuming this the logic becames simpler)
    double tmp;
    tmp = x1; x1 = x0; x0 = tmp;
    tmp = y1; y1 = y0; y0 = tmp;
  }
  if(x0 == x1){ // Vertical line (do not use line equation, or we divide by zero)
    *control_x = x0;
    if(*control_y > y0 && *control_y > y1){
      if(y0 > y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
    else if(*control_y < y0 && *control_y < y1){
      if(y0 < y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
  }
  else if(y0 == y1) // Horizontal line
    *control_y = y0;
  else{ // Use line equation
    // m0 x + b0 = y is the line that contains the triangle side
    double m0 = (y1 - y0) / (x1 - x0);
    double b0 = y1 - m0 * x1;
    // m1 x + b1 = y is the perpendicular line that crosses the point
    double m1 = - m0;
    double b1 = *control_y - m1 * *control_x;
    *control_x = (b1 - b0) / (m0 - m1);
    *control_y = m0 * *control_x + b0;
  }
  if(*control_x > x1){
    *control_x = x1;
    *control_y = y1;
  }
  else if(*control_x < x0){
    *control_x = x0;
    *control_y = y0;
  }
}
@
\fimcodigo

This ends our function to adjust control points if we are adealing
with the ``\monoespaco{atleast}'' keyword. Now we can just use this
function if we are dealing with this case:

\iniciocodigo
@<Adjust tension in case of 'atleast'@>=
if(atleast0)
  correct_tension(z1_point -> point.x, z1_point -> point.y,
                  z2_point -> point.x, z2_point -> point.y,
                  w0_x, w0_y, w1_x, w1_y, &u_x, &u_y);
if(atleast1)
  correct_tension(z1_point -> point.x, z1_point -> point.y,
                  z2_point -> point.x, z2_point -> point.y,
                  w0_x, w0_y, w1_x, w1_y, &v_x, &v_y);
@
\fimcodigo

And with this we get the control points and we can update its value in
the path variable that we are building. If we are in the last
iteration of a non-cyclic curve, then we also fill the last control
points turning them equal the last extremity point:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
z1_point -> format = FINAL_FORMAT;
z1_point -> point.u_x = u_x;
z1_point -> point.u_y = u_y;
z1_point -> point.v_x = v_x;
z1_point -> point.v_y = v_y;
if(result -> length >= expected_length && result -> cyclic == false){
  struct path_points *final_point =
                           &(result -> points[result -> length - 1]);
  while(final_point -> format == SUBPATH_FORMAT){
    struct path_variable *p = (struct path_variable *)
                                (final_point -> subpath);
    final_point = &(p -> points[p -> length - 1]);
  }
  final_point -> format = FINAL_FORMAT;
  final_point -> point.u_x = final_point -> point.x;
  final_point -> point.u_y = final_point -> point.y;
  final_point -> point.v_x = final_point -> point.x;
  final_point -> point.v_y = final_point -> point.y;
}
@
\fimcodigo

This finalizes how a curve should be built given its points and
subpaths. Now we will see how we read the points and subpaths.

\subsubsecao{8.4.2. Tertiary Path Expressions}

The grammar for tertiary path expressions is:

\alinhaverbatim
<Path Tertiary> -> <Pair Tertiary> | <Path Secondary>
\alinhanormal

And it is only this. Therefore, to interpret a tertiary path
expression, we should walk over the expression and check if we find a
tertiary pair expression. If so, we should interpret the entire
expression like a pair expression. Otherwise, we interpret as a
secondary path expression. If we interpret the expression like a pair,
we should convert the result from a pair to a path with a single
point.

Anyway, after interpreting the expression and obtain a path as result,
we return the result.

The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  struct generic_token *p, *prev = NULL;
  bool this_expression_is_pair = false;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      this_expression_is_pair = true;
      break;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(this_expression_is_pair){
    struct pair_variable pair;
    if(!eval_pair_expression(mf, cx, begin_expression, end_expression,
                            &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> number_of_points = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> format = FINAL_FORMAT;
    result -> points -> point.x = pair.x;
    result -> points -> point.y = pair.y;
    result -> points -> point.u_x = pair.x;
    result -> points -> point.u_y = pair.y;
    result -> points -> point.v_x = pair.x;
    result -> points -> point.v_y = pair.y;
    return true;
  }
  else
    return eval_path_secondary(mf, cx, begin_expression, end_expression,
                               result);
}
@
\fimcodigo

\subsubsecao{8.4.3. Secondary Path Expressions: Transformers}

The grammar for secondary path expressions is:

\alinhaverbatim
<Path Secondary> -> <Pair Secondary> | <Path Primary> |
                    <Path Secondary><Transformer>
\alinhanormal

The transformers are the same that were presented for pair expressions
plus the \monoespaco{transformed} operator introduced in the section
about transforms. The first thing that we should test in theses
expressions is if we have a transformer at the end of the
expression. If so, then we should apply the last rule in the grammar
above. If not, we should check if we have a secondary pair operator
(multiplication or division). If so, we apply the second rule,
treating the path secondary expression as a pair secondary. Otherwise
we apply the first rule and interpret the expression as a primery path
expression.

Applying a transformer to rotate, scale and others means applying the
transformation in each extremity point and each control point in the
path.

The declaration for the function that evaluates path secondary
expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

And the implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  bool have_transform = false, have_pair_operator = false;
  struct generic_token *p, *last_fraction = NULL, *transform_op = NULL,
                       *before_transform = NULL, *prev = NULL,
                       *prev_prev = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else if(p -> type == TYPE_DIVISION || p -> type == TYPE_MULTIPLICATION)
         have_pair_operator = true;
       else{
         have_transform = true;
         transform_op = p;
         before_transform = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(have_transform){
    if(transform_op -> next == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_path_secondary(mf, cx, begin_expression, before_transform, result))
      return false;
    @<Path Transform: Rotate@>
    @<Path Transform: Scale@>
    @<Path Transform: Shift@>
    @<Path Transform: Slant@>
    @<Path Transform: X-Scale@>
    @<Path Transform: Y-Scale@>
    @<Path Transform: Z-Scale@>
    @<Path Transform: Generic Transform@>
  }
  else if(have_pair_operator){
    struct pair_variable pair;
    if(!eval_pair_secondary(mf, cx, begin_expression, end_expression, &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> number_of_points = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> format = FINAL_FORMAT;
    result -> points[0].point.x = pair.x;
    result -> points[0].point.y = pair.y;
    result -> points[0].point.u_x = pair.x;
    result -> points[0].point.u_y = pair.y;
    result -> points[0].point.v_x = pair.x;
    result -> points[0].point.v_y = pair.y;
    return true;    
  }
  else
    return eval_path_primary(mf, cx, begin_expression, end_expression,
                             result);
}
@
\fimcodigo

In the code above, when we check if we have a transformer in the
expression, we always store the last transformer in the
variable \monoespaco{transform\_op} and the last token before the
transformer in the variable \monoespaco{before\_transform}. This allow
us to divide the expression in its parts and interpret the code to
obtain the path to be transformed, as is shown above.

If we have a rotation, to interpret the totation transformer after we
got the path to be rotated in the \monoespaco{result} variable, we can
use the code below:

\iniciocodigo
@<Path Transform: Rotate@>=
if(transform_op -> type == TYPE_ROTATED){
  struct numeric_variable a;
  double theta, sin_theta, cos_theta;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  theta = 0.0174533 * a.value; // Converting degrees to radians
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  path_rotate(result, sin_theta, cos_theta);
  return true;
}
@
\fimcodigo

The code above assumes that we have a recursive function that applies
the rotation once we pass it the sine and cosine of the rotation
angle. We will use the function below for this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].format == SUBPATH_FORMAT)
      path_rotate((struct path_variable *) (p -> points[i].subpath),
                  sin_theta, cos_theta);
    else{
      double x = p -> points[i].prov.x, y = p -> points[i].prov.y;
      p -> points[i].prov.x = x * cos_theta - y * sin_theta;
      p -> points[i].prov.y = x * sin_theta + y * cos_theta;
      x = p -> points[i].point.u_x;
      y = p -> points[i].point.u_y;
      p -> points[i].point.u_x = x * cos_theta - y * sin_theta;
      p -> points[i].point.u_y = x * sin_theta + y * cos_theta;
      x = p -> points[i].point.v_x;
      y = p -> points[i].point.v_y;
      p -> points[i].point.v_x = x * cos_theta - y * sin_theta;
      p -> points[i].point.v_y = x * sin_theta + y * cos_theta;
    }
  }
}
@
\fimcodigo

Now we will interpret the scaling operator. It shoult interpret a
numeric value and then multiply all points in the path by such value:

\iniciocodigo
@<Path Transform: Scale@>=
if(transform_op -> type == TYPE_SCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_xyscale(result, a.value, a.value);  
  return true;
}
@
\fimcodigo

The recursive function that applies this for every point in the path
is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y);
@
\fimcodigo

Notice that by the function signature we can pass different values to
stretch the path horizontally and vertically. This transformer
stretches the path always in the same proportion, but other
transformers will also use this function to stretch not preserving
proportions. Its implementation is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].format == SUBPATH_FORMAT)
      path_xyscale((struct path_variable *) (p -> points[i].subpath), x,
                   y);
    else{
      p -> points[i].point.x *= x;
      p -> points[i].point.y *= y;
      p -> points[i].point.u_x *= x;
      p -> points[i].point.u_y *= y;
      p -> points[i].point.v_x *= x;
      p -> points[i].point.v_y *= y;
    }
  }
}
@
\fimcodigo

The next transformer translate, or shift a given path. We first read a
pair and this pair sets how the path should be shifted in the $x$ and
$y$ axis:

\iniciocodigo
@<Path Transform: Shift@>=
if(transform_op -> type == TYPE_SHIFTED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_shift(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

And the recursive function that performs the shifting:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].format == SUBPATH_FORMAT)
      path_shift((struct path_variable *) (p -> points[i].subpath), x, y);
    else{
      p -> points[i].point.x += x;
      p -> points[i].point.y += y;
      p -> points[i].point.u_x += x;
      p -> points[i].point.u_y += y;
      p -> points[i].point.v_x += x;
      p -> points[i].point.v_y += y;
    }
  }
}
@
\fimcodigo

Now to the slanting transformer. This transformer shifts to the right
the points based on how above the origin they are in tha $y$ axis and
shifts to the left based on how below the origin they are in the $y$
axis:

\iniciocodigo
@<Path Transform: Slant@>=
if(transform_op -> type == TYPE_SLANTED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_slant(result, a.value);  
  return true;
}
@
\fimcodigo

And the function that slants recursively:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_slant(struct path_variable *p, float s);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_slant(struct path_variable *p, float s){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].format == SUBPATH_FORMAT)
      path_slant((struct path_variable *) (p -> points[i].subpath), s);
    else{
      p -> points[i].point.x += s * p -> points[i].point.y;
      p -> points[i].point.u_x += s * p -> points[i].point.u_y;
      p -> points[i].point.v_x += s * p -> points[i].point.v_y;
    }
  }
}
@
\fimcodigo


The next transformer change the horizontal size of the path while
preserving the vertical size. We need to read a numeric value and it
determines how much the path should be horizontally stretched:

\iniciocodigo
@<Path Transform: X-Scale@>=
else if(transform_op -> type == TYPE_XSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, a.value, 1.0);
  return true;
}
@
\fimcodigo

Here we are using a recursive function already defined. We do not need
to redefine it again. And we also can stretch the path vertically:

\iniciocodigo
@<Path Transform: Y-Scale@>=
else if(transform_op -> type == TYPE_YSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, 1.0, a.value);  
  return true;
}
@
\fimcodigo

The last but one transformer is the Z-scale which reads a pair,
interprets it as a complex number, interpret all points in the path as
complex numbers and multiply them:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

We interpret and make the transformation below, remembering that this
is the last transformation and that an error should be raised if we
need to apply a transformation and this is not the correct:


\iniciocodigo
@<Path Transform: Z-Scale@>=
else if(transform_op -> type == TYPE_ZSCALED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_zscale(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

And the recursive function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].format == SUBPATH_FORMAT)
      path_zscale((struct path_variable *) (p -> points[i].subpath),
                  x, y);
    else{
      float x0 = p -> points[i].point.x;
      float y0 = p -> points[i].point.y;
      p -> points[i].point.x = x0 * x - y0 * y;
      p -> points[i].point.y = x0 * y + y0 * x;
      x0 = p -> points[i].point.u_x;
      y0 = p -> points[i].point.u_y;
      p -> points[i].point.u_x = x0 * x - y0 * y;
      p -> points[i].point.u_y = x0 * y + y0 * x;
      x0 = p -> points[i].point.v_x;
      y0 = p -> points[i].point.v_y;
      p -> points[i].point.v_x = x0 * x - y0 * y;
      p -> points[i].point.v_x = x0 * y + y0 * x;
    }
  }
}
@
\fimcodigo

The last transformer is a generic linear transform, where we will get
a transform specifying how each point in the path should be
transformed. We deal with this case as below:

\iniciocodigo
@<Path Transform: Generic Transform@>=
else if(transform_op -> type == TYPE_TRANSFORMED){
  struct transform_variable a;
  if(!eval_transform_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_transform(result, a.value);
  return true;
}
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer\n",
          mf -> file, transform_op -> line);
#endif
  return false;
}
@
\fimcodigo

For this, we use the recursive function below:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M);
@
\fimcodigo

Which is defined as below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].format == SUBPATH_FORMAT)
      path_transform((struct path_variable *) (p -> points[i].subpath), M);
    else{
      float x0 = p -> points[i].point.x;
      float y0 = p -> points[i].point.y;
      p -> points[i].point.x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].point.y = LINEAR_TRANSFORM_Y(x0, y0, M);
      x0 = p -> points[i].point.u_x;
      y0 = p -> points[i].point.u_y;
      p -> points[i].point.u_x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].point.u_y = LINEAR_TRANSFORM_Y(x0, y0, M);
      x0 = p -> points[i].point.v_x;
      y0 = p -> points[i].point.v_y;
      p -> points[i].point.v_x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].point.v_x = LINEAR_TRANSFORM_Y(x0, y0, M);
    }
  }
}
@
\fimcodigo


\subsubsecao{8.4.4. Primary Path Expressions}

The grammar for primary path expressions is:

\alinhaverbatim
<Path Primary> -> <Pair Primary> | <Path Variable> |
                  ( <Path Expression> ) |
                  reverse <Path Primary> |
                  subpath <Pair Expression> of <Pair Primary> |
                  ...
\alinhanormal

This means that we need to register the new
tokens \monoespaco{reverse}, \monoespaco{subpath} and \monoespaco{of}:


\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_REVERSE,        // O token simblico 'reverse'
TYPE_SUBPATH,        // O token simblico 'subpath'
TYPE_OF,             // O token simblico 'of'
@
\fimcodigo

And for each one of them, we add its string to the list of reserved
words:

\iniciocodigo
@<List of Keywords@>+=
"reverse", "subpath", "of",
@
\fimcodigo

What the grammar rules say is that in the end of each path
expression,we will find a path variable, a parenthesis, some of these
new path operators or, in all other cases, a pair primary. Therefore,
we should first test these first cases and if we are not in one of
them, we are with a primary pair.

The function that will interpret primary path expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result){
  if(begin_expression -> type == TYPE_REVERSE){
    @<Primary Path: Reverse@>
  }
  else if(begin_expression -> type == TYPE_SUBPATH){
    @<Primary Path: Subpath@>
  }
  else if(begin_expression == end_expression &&
          begin_expression -> type == TYPE_SYMBOLIC){
    @<Primary Path: Variable@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Primary Path: Parenthesis@>
  }
  @<Primary Path: Other Expressions@>
  { // If we still did not return, then it is a primary pair
    @<Primary Path: Primary Pair@>
  }
  return false;
}
@
\fimcodigo

The first case: we must compute the reverse of a path. For this, we
need to reverse the order for all extremity points and move the
control points for its new posisiton.

Given the recursive nature of path variables, we need a recursive
function that given an already allocated path variable destiny, it
copies the source points content in the reverse order.

This auxiliary recursive function will need to know for each function
call the destiny pointer where the next point need to be copied. At
first, as we are copying in the reverse order, the pointer represent
the last possible position for points in the path variable.  After
copying each value, we decrement the pointer, copying values from
right to left.

To manipulate the original path and extract its points, the recursive
function must get as argument the current path variable, and the
current index in the point array in that variable. The function will
walk over the points from left to right.

Doing this we will get as result a variable with all its points in the
same array, without recursive path variables inside the initial path
variable. The function definition can be seen below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool aux_reverse(struct path_points **right_dst,
                 struct path_variable *pointer, int *index,
                 int *copied_points, int total_points){
  while(*copied_points < total_points){
    if(pointer -> points[*index].format != SUBPATH_FORMAT &&
       !isnan(pointer -> points[*index].point.x)){
      // Copy:
      memcpy(*right_dst, &(pointer -> points[*index]),
             sizeof(struct path_points));
      (*right_dst) --;
      (*copied_points) ++;
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].format == SUBPATH_FORMAT){
      int new_index = 0;
      aux_reverse(right_dst, (struct path_variable *)
                  (pointer -> points[*index].subpath),
                  &new_index, copied_points, total_points);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

This auxiliary function will help us to define the true function that
will reverse a path variable. The reversion function will be called
below, when we detect the reverse operator:

\iniciocodigo
@<Primary Path: Reverse@>=
struct path_variable tmp;
if(begin_expression -> next == NULL ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                      &tmp))
  return false;
result -> length = tmp.number_of_points;
result -> number_of_points = tmp.number_of_points;
result -> points =
     (struct path_points *)
     temporary_alloc(sizeof(struct path_points) * tmp.number_of_points);
reverse_path(&tmp, result);
if(temporary_free != NULL)
  path_recursive_free(temporary_free, &tmp, false);
return true;
@
\fimcodigo

Now wee need now to define the true function that makes the
reversion. The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst){
  int index = 0, i, copied_points = 0;
  struct path_points *right = &(dst -> points[dst -> length - 1]);
  struct path_variable *l = src;
  aux_reverse(&right, l, &index, &copied_points, dst -> length);
  for(i = 0; i < dst -> length - 1; i ++){
    dst -> points[i].point.u_x = dst -> points[i + 1].point.v_x;
    dst -> points[i].point.u_y = dst -> points[i + 1].point.v_y;
    dst -> points[i].point.v_x = dst -> points[i + 1].point.u_x;
    dst -> points[i].point.v_y = dst -> points[i + 1].point.u_y;
  }
  dst -> points[i].point.u_x = dst -> points[i].point.x;
  dst -> points[i].point.u_y = dst -> points[i].point.y;
  dst -> points[i].point.v_x = dst -> points[i].point.x;
  dst -> points[i].point.v_y = dst -> points[i].point.y;
  dst -> cyclic = src -> cyclic;
}
@
\iniciocodigo

The next step is compute the subpath. A subpath creates a new path
that is part of another known bigger path. For example:

\alinhaverbatim
subpath (0, 2) of p1 -- p2 -- p3;
\alinhanormal

The code above evaluates to the new path \monoespaco{p1 -- p2},
assuming that both \monoespaco{p1} and \monoespaco{p2} represent a
single point.

In the original METAFONT, we could pass non-integer point
positions. For example, we could select a subpath between the conrol
points 0.5 and 1.8. With such positions, METAFONT would generate new
intermediary control points betwwen the first and the second and
between the second and third as indicated. New extemity and control
points would be generated. But as this is a little messy computation,
here we will support only subpaths between integer positions.

In the case of a non-cyclic path, if we try to specify a subpath using
an index lesser than zero, this index will be considered zero. If we
try to use an index greater than the maximum allowed index, it will be
treated as the maximum index.

In the case of a cyclic path, negative indices are counted walking
over the cycle in the path opposite direction. And there is no maximum
allowed index. This way, you can create a subpath from a cyclic path
that is bigger than the original path. The cyclic nature also will
always be lost after the operation.

\iniciocodigo
@<Primary Path: Subpath@>=
DECLARE_NESTING_CONTROL();
struct pair_variable a;
struct path_variable b;
struct generic_token *of, *end_pair_expr = begin_expression;
struct generic_token *begin_subexpr;
if(begin_expression -> next == NULL ||  end_pair_expr -> type == TYPE_OF ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
of = (struct generic_token *) (end_pair_expr -> next);
while(of != NULL && of != end_expression){
  COUNT_NESTING(of);
  if(IS_NOT_NESTED() && of -> type == TYPE_OF)
    break;
  end_pair_expr = of;
  of = (struct generic_token *) (of -> next);
}
if(of == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_expression(mf, cx, (struct generic_token *) begin_expression -> next,
                         end_pair_expr, &a))
  return false;
begin_subexpr = of -> next;
if(!eval_path_primary(mf, cx, begin_subexpr, end_expression, &b))
  return false;
{
  int final_path_size, offset;
  result -> cyclic = false;
  if(a.x < 0 && !b.cyclic)
    a.x = 0;
  if(a.y < 0  && !b.cyclic)
    a.y = 0;
  if(a.x >= b.number_of_points  && !b.cyclic)
    a.x = b.number_of_points - 1;
  if(a.y >= b.number_of_points  && !b.cyclic)
    a.y = b.number_of_points - 1;
  final_path_size = a.y - a.x;
  if(final_path_size < 0)
    final_path_size *= -1;
  final_path_size ++;
  offset = (a.x <= a.y)?(a.x):(a.y);
  if(b.cyclic)
    offset = offset % (b.number_of_points - 1);
  else
    offset = offset % b.number_of_points;
  if(offset < 0)
    offset *= -1;
  result -> length = final_path_size;
  result -> number_of_points = final_path_size;
  result -> points = (struct path_points *)
                       temporary_alloc(final_path_size *
                                       sizeof(struct path_points));
  if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  copy_subpath(result -> points, &b, offset, final_path_size);
  // Adjust final control points if we lost the cyclcic property:
  result -> points[result -> length - 1].format = FINAL_FORMAT;
  result -> points[result -> length - 1].point.u_x =
                                result -> points[result -> length - 1].point.x;
  result -> points[result -> length - 1].point.u_y =
                                result -> points[result -> length - 1].point.y;
  result -> points[result -> length - 1].point.v_x =
                                result -> points[result -> length - 1].point.x;
  result -> points[result -> length - 1].point.v_y =
                                result -> points[result -> length - 1].point.y;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  if(a.x > a.y){
    struct path_variable c;
    c.length = result -> number_of_points;
    c.number_of_points = result -> number_of_points;
    c.points = (struct path_points *) temporary_alloc(sizeof(struct path_points) *
                                                      c.number_of_points);
    if(c.points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
              begin_expression -> line);
#endif
      return false;
    }
    reverse_path(result, &c);
    temporary_free(result -> points);
    result -> points = c.points;
  }
  return true;
}
@
\fimcodigo

We need now to present the function \monoespaco{copy\_subpath} that
will copy a path to another path as seen in the code above. This
function gets a pointer to the array where we will copy the points, a
path variable as origin, an offset representing the number of initial
points to be ignored and the number of points to be copied:


\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size);
@
\fimcodigo

The function definition is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size){
  struct path_points *dst_pointer = dst;
  while(size > 0){
    int index = 0;
    int initial_offset = offset, initial_size = size;
    recursive_copy_subpath(&dst_pointer, src, &index, &offset, &size);
    // If we copied the last point and we are copying a cyclic path:
    if(offset <= 0 && src -> cyclic &&
       initial_offset + initial_size >= src -> number_of_points){
      dst_pointer --; // The last point is redundant, it is equal the first.
      size ++;
    }
  }
}
@
\fimcodigo

And finally the function that will walk over the origin path to copy
it:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size){
  while(*size > 0){
    if(pointer -> points[*index].format != SUBPATH_FORMAT &&
       !isnan(pointer -> points[*index].point.x)){
      if(*offset > 0)
        (*offset) --;
      else{
        // Copy:
        memcpy(*dst, &(pointer -> points[*index]),
               sizeof(struct path_points));
        (*dst) ++;
        (*size) --;
      }
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].format == SUBPATH_FORMAT){
      int new_index = 0;
      recursive_copy_subpath(dst, (struct path_variable *)
                                  (pointer -> points[*index].subpath),
                             &new_index, offset, size);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

The next step is the path primary expression when we read a pair
variable or a path variable. In this case, we allocate the memory for
the result points and copy the variable content to the result:

\iniciocodigo
@<Primary Path: Variable@>=
{
  struct symbolic_token *v = (struct symbolic_token *) begin_expression;
  void *content = v -> var;
  if(((struct pair_variable *) content) -> type == TYPE_T_PAIR){
    result -> length = 1;
    result -> number_of_points = 1;
    result -> cyclic = false;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    result -> points[0].format = FINAL_FORMAT;
    result -> points[0].point.x = ((struct pair_variable *) content) -> x;
    result -> points[0].point.y = ((struct pair_variable *) content) -> y;
    result -> points[0].point.u_x = ((struct pair_variable *) content) -> x;
    result -> points[0].point.u_y = ((struct pair_variable *) content) -> y;
    result -> points[0].point.v_x = ((struct pair_variable *) content) -> x;
    result -> points[0].point.v_y = ((struct pair_variable *) content) -> y;
    return true;
  }
  else if(((struct path_variable *) content) -> type == TYPE_T_PATH)
    return recursive_copy_points(mf, cx, temporary_alloc, &result,
                                (struct path_variable *) content, false);
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Variable is not pair nor path!\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

The next primary path expression is when we have an expression between
parenthesis. And this expression is not a pair, it is another path
expression that need to be evaluated. First we check if there is
nothing between parenthesis and produce and error in this case. Next,
we check if we do not have a non-nested comma inside the
parenthesis. If so, we ignore the expression because we have a pair
primary. In all other cases, we evaluate whatever expression we have
inside the parenthesis as a path expression:

\iniciocodigo
@<Primary Path: Parenthesis@>=
struct generic_token *t = begin_expression -> next;
bool found_comma = false;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  if(IS_NOT_NESTED() && t -> type == TYPE_COMMA){
    found_comma = true;
    break;
  }
  t = t -> next;
}
if(!found_comma){
  return eval_path_expression(mf, cx, begin_expression -> next, t, result);
}
@
\fimcodigo

And finally, the last kind of primary expression for pairs is when we
have a pair primary expression. In this case, we just interpret the
expression, allocate the single point in our path and copy the result
of the expression to that point:

\iniciocodigo
@<Primary Path: Primary Pair@>=
struct pair_variable v;
if(!eval_pair_primary(mf, cx, begin_expression, end_expression, &v))
  return false;
result -> length = 1;
result -> number_of_points = 1;
result -> cyclic = false;
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points));
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = v.x;
result -> points[0].point.y = v.y;
result -> points[0].point.u_x = v.x;
result -> points[0].point.u_y = v.y;
result -> points[0].point.v_x = v.x;
result -> points[0].point.v_y = v.y;
return true;
@
\fimcodigo

\subsubsecao{8.4.5. Path in Numeric Expressions}

We can nuse the numeric expression with the
operator \monoespaco{length} to obtain the number of extremity points
in a path minus one. The syntax is:

\alinhaverbatim
<Numeric Primary> -> length <Path Primary>
\alinhanormal
%                       turningnumber <Caminho Primrio> |
%                       directiontime <Expresso de Par> of <Caminho Primrio>

We do not need a new type of token. The expression \monoespaco{length}
was already used to compute modulus for numbers and pairs. For the
case in which this operator gets a path, the implementation is even
simpler:

\iniciocodigo
@<Evaluate 'length'@>+=
else if(expr_type == TYPE_T_PATH){
  struct path_variable p;
  if(!eval_path_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) (p.number_of_points - 1);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &p, false);
  return true;
}
@
\fimcodigo

\subsubsecao{8.4.6. Path in Pair Expressions}

Given a path, we can extract pairs from it. The pair can be an
extremity point or some of the control points. The syntax for this is:

\alinhaverbatim
<Pair Primary> -> point <Numeric Expression> of <Path Primary> |
                     precontrol <Numeric Expression> of <Path Primary> |
                     postcontrol <Numeric Expression> of <Path Primary>
\alinhanormal

This requires adding the following new token types:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_POINT,             // O token simblico 'point'
TYPE_PRECONTROL,        // O token simblico 'precontrol'
TYPE_POSTCONTROL,       // O token simblico 'postcontrol'
@
\fimcodigo

And we add them also to the list of reserved words:

\iniciocodigo
@<List of Keywords@>+=
"point", "precontrol", "postcontrol",
@
\fimcodigo

All these operators require that we get a point in a given position
$n$ inside a path. For this, it will be helpful to have an auxiliary
function that will get a path variable and an index to return the
point in the path corresponding to that index. The function first will
check if the length and the total lenght in the path are the same. If
so, we will assume that we are in a path without recursive subpaths
and in this case, returning the correct point is easy and
fast. Otherwise, we will call a recursive function to get for us the
correct point:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n){
  if(v -> length == v -> number_of_points){
    struct path_points *ret = (struct path_points *) &(v -> points[n]);
    while(ret -> format == SUBPATH_FORMAT)
      ret = &(((struct path_variable *) (ret -> subpath)) -> points[0]);
    return ret;
  }
  else{
    int count = 0;
    return _get_point(v, n, &count);
  }
}
@
\fimcodigo

This auxiliar recursive fnction that will get the point for
recursively defined paths will walk over each point in the path in the
usual order and will return the current point when it walks over the
correct number of points. For this, it needs the path variable
pointer, the point index and also how many points it already visited:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count);
@
\fimcodigo

The function definition is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count){
  int i;
  for(i = 0; i < v -> length; i ++){
    if(v -> points[i].format != SUBPATH_FORMAT) {
      if(*count == n && !isnan(v -> points[i].point.x))
	return ((struct path_points *) &(v -> points[i]));
      else if(!isnan(v -> points[i].point.x))
	(*count) ++;
    }
    else{
      struct path_points *r =
	_get_point((struct path_variable *) (v -> points[i].subpath),
		   n, count);
      if(r != NULL)
	return r;
    }
  }
  return NULL;
}
@
\fimcodigo


For the first operator, \monoespaco{point}, it returns a given
extremity point from a path. In a non-cyclic path, indices lesser than
zero are interpreted as zero (the first index) and indices greater or
equal than the number of extremity points will be interpreted as the
last point's index. If the path is cyclic, we count the indices
following the cycle. In the original METAFONT language, non-integer
indices were allowed, but here we will interpret all indices as
integers, casting them to C int type.

The operator \monoespaco{postcontrol} is similar, but it gets the
first control point after the given extremity point pointed by the
index. And the operator \monoespaco{precontrol} gets the control point
before the given extremity point.

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>=
if(begin -> type == TYPE_POINT ||
   begin -> type == TYPE_PRECONTROL ||
   begin -> type == TYPE_POSTCONTROL){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_num, *end_num , *of = NULL, *begin_path, *end_path;
  struct numeric_variable a;
  struct path_variable b;
  begin_num = begin -> next;
  end_num = begin_num;
  int index;
  while(end_num != NULL && end_num -> next != end){
    COUNT_NESTING(end_num);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_num -> next) -> type == TYPE_OF){
      of = end_num -> next;
      break;
    }
    end_num = end_num -> next;
  }
  if(of == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'of' in 'point' expression\n",
            mf -> file, begin -> line);
#endif
    return false;
  }
  if(of -> next == NULL || of == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing path expression in "
            "'point' expression\n", mf -> file, begin -> line);
#endif
    return false;
  }
  begin_path = of -> next;
  end_path = end;
  if(!eval_numeric_expression(mf, cx, begin_num, end_num, &a))
    return false;
  if(!eval_path_primary(mf, cx, begin_path, end_path, &b))
    return false;
  if(b.cyclic){
    index = ((int)(a.value)) % (b.number_of_points - 1);
    if(begin -> type == TYPE_PRECONTROL)
      index = (index - 1) % (b.number_of_points - 1);
  }
  else{
    index = (int) (a.value);
    if(index < 0) index = 0;
    if(index >= b.number_of_points) index = b.number_of_points - 1;
    if(begin -> type == TYPE_PRECONTROL)
      index --;
  }
  if(begin -> type == TYPE_POINT){
    result -> x = get_point(&b, index) -> point.x;
    result -> y = get_point(&b, index) -> point.y;
  }
  else if(begin -> type == TYPE_PRECONTROL){
    if(index < 0){
      result -> x = get_point(&b, 0) -> point.x;
      result -> y = get_point(&b, 0) -> point.y;
    }
    else{
      result -> x = get_point(&b, index) -> point.v_x;
      result -> y = get_point(&b, index) -> point.v_y;
    }
  }
  else{
    result -> x = get_point(&b, index) -> point.u_x;
    result -> y = get_point(&b, index) -> point.u_y;
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  return true;
}
@
\fimcodigo

\subsecao{8.5. Pen Assignments and Expressions}

To assign a pen to a variable with the right type, we use the
following code:

\iniciocodigo
@<Assignment for Pen Variables@>=
else if(type == TYPE_T_PEN){
  int i;
  struct pen_variable result;
  if(!eval_pen_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    if(!assign_pen_variable(mf, (struct pen_variable *) var -> var,
                           &result))
      return false;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL && result.format !=  NULL)
    path_recursive_free(temporary_free, result.format, true);
  if(result.gl_vbo != 0 && result.referenced == NULL)
    glDeleteBuffers(1, &(result.gl_vbo));
}
@
\fimcodigo

The declaration for the function that makes the assignment:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool assign_pen_variable(struct metafont *mf,
                         struct pen_variable *target,
                         struct pen_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool assign_pen_variable(struct metafont *mf,
                         struct pen_variable *target,
                         struct pen_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  struct variable *next = target -> next;
  if(target -> permanent == 0){
    disalloc = permanent_free;
    alloc = permanent_alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> format != NULL && disalloc != NULL)
    path_recursive_free(disalloc, target -> format, true);
  if(target -> gl_vbo != 0)
    glDeleteBuffers(1, &(target -> gl_vbo));
  memcpy(target, source, sizeof(struct pen_variable));
  target -> type = TYPE_T_PEN;
  target -> next = next;
  if(! (source -> flags & (FLAG_CIRCULAR | FLAG_SQUARE | FLAG_NULL)))
    if(!recursive_copy_points(mf, cx, alloc, &(target -> format),
                              source -> format, true))
      return false;
  target -> gl_vbo = 0;
  target -> indices = 0;
  target -> referenced = NULL;
  // If we are assigning to 'currentpen', then we need to retriangulate
  // the pen, as will be described in Section 10:
  if(target == &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]))
    triangulate_pen(mf, target, target -> gl_matrix);
  return true;
}
@
\fimcodigo

\subsubsecao{8.5.1. Pen Tertiary Expression}

For now we have no tertiry operator for pen expressions:

\alinhaverbatim
<Pen Expression> -> <Pen Tertiary>
<Pen Tertiary> -> <Pen Secondary>
\alinhanormal

So the function that evaluates tertiary expression, for now, can just
call directly the funtion that evaluates secondary pen expressions and
use some lines to detect common errors:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result){
  if(begin_expression -> type != TYPE_SYMBOLIC &&
     begin_expression -> type != TYPE_NULLPEN &&
     begin_expression -> type != TYPE_OPEN_PARENTHESIS &&
     begin_expression -> type != TYPE_PENCIRCLE &&
     begin_expression -> type != TYPE_MAKEPEN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
    return false;
  }
  return eval_pen_secondary(mf, cx, begin_expression, end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.5.2. Pen Transformers}

The syntax for secondary pen expressions is:

\alinhaverbatim
<Pen Secondary> -> <Pen Primary> | <Pen Secondary> <Transformer>
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary>
                 transformed <Transform Primary>
\alinhanormal

Transformers are not new, they were already used in pair, transforms
and path expressions. But apply them over pens is a little different,
as instead of modifying each one of its points, we modify only its
OpenGL matrix transformation.

The declaration for the function that evaluates pen secondary
expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

And its implementation consists in trying to find the last transformer
in the expression. If it is not found, the function just calls another
function to evaluate primary expression. If a transformer is found,
then everything before it is evaluated as a secondary expression and
then we apply the transformer. Rotate a pen never requires the
retriangulation of that pen.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct pen_variable *pen){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_pen_primary(mf, cx, begin_expression, end_expression, pen);
  else{
    if(!eval_pen_secondary(mf, cx, begin_expression, before_last_transformer, pen))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Pen Secondary: Rotation@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Pen Secondary: Scaling@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Pen Secondary: Shift@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Pen Secondary: Slanting@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Pen Secondary: X-Scaling@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Pen Secondary: Y-Scaling@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Pen Secondary: Z-Scaling@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Pen Secondary: Generic Transform@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

First we will take care of rotation by an algle $\theta$. First we
perform the conversion between degrees used by WeaveFONT and radians,
used by the C sandard library. Rotating means applying the rotation
linear transform over the pen transform matrix:

\iniciocodigo
@<Pen Secondary: Rotation@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(pen -> gl_matrix, rotation);
return true;
@
\fimcodigo

To perform the scaling tranformation, we also apply such linear
transform over the pen matrix:

\iniciocodigo
@<Pen Secondary: Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(pen -> gl_matrix, a.value);
// Curved pens need retriangulation if the size increase:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

The shift transformer shifts each point in the pen adding a pair to
it.

\iniciocodigo
@<Pen Secondary: Shift@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SHIFT(pen -> gl_matrix, p.x, p.y);
return true;
@
\fimcodigo

The next transformer is the slanting operator. 

\iniciocodigo
@<Pen Secondary: Slanting@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(pen -> gl_matrix, a.value);
// Slant non-circular curved pens always require retriangulation:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT) &&
   !(pen -> flags & FLAG_CIRCULAR)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Scaling in the $x$-axis is analogous to the general scaling, but the pen
is stretched only in the $x$-axis:

\iniciocodigo
@<Pen Secondary: X-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(pen -> gl_matrix, a.value);
// Curved pens need retriangulation if the size increase:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Likewise, changing the scale only in the vertical axis, is done by
the code below:

\iniciocodigo
@<Pen Secondary: Y-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(pen -> gl_matrix, a.value);
// Curved pens need retriangulation if the size increase:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Scaling in $z$-index means interpreting the point and a pair
as complex numbers and multiply them:

$$
(x+yi)(a+bi) = ax + (bx)i + (ay)i + (by)i^2 = (ax - by) + (bx+ay)i
$$

We can perform the operation above with the following code:

\iniciocodigo
@<Pen Secondary: Z-Scaling@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(pen -> gl_matrix, p.x, p.y);
// Curved pens need retriangulation in this case:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Finally, the last transform is the generic one, which applies
whichever transform is stored in a transformer:

\iniciocodigo
@<Pen Secondary: Generic Transform@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression, &t))
  return false;
MATRIX_MULTIPLICATION(pen -> gl_matrix, t.value);
// Curved pens need retriangulation in this case:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

\subsubsecao{8.5.3. Variables, Null Pen, Circular Pen and Arbitrary Pen}

The grammar for pen primary expressions are defined as:

\alinhaverbatim
<Primrio de Caneta> -> <Varivel de Caneta> |
                        nullpen | ( <Expresso de Caneta> ) |
                        pencircle | makepen <Primrio de Caminho>
\alinhanormal

This requires three new reserved words:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_NULLPEN,        // The symbolic token 'nullpen'
TYPE_PENCIRCLE,      // The symbolic token 'pencircle'
TYPE_MAKEPEN,        // The symbolic token 'makepen'
@
\fimcodigo

And we add a string with their names in the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"nullpen", "pencircle", "makepen",
@
\fimcodigo

The function that will interpret the primary pen expressions:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Pen Primary: Variable@>
    }
    else if(begin_expression -> type == TYPE_NULLPEN){
      @<Pen Primary: Null Pen@>
    }
    else if(begin_expression -> type == TYPE_PENCIRCLE){
      @<Pen Primary: Circle Pen@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Pen Primary: Parenthesis@>
    }
    else if(begin_expression -> type == TYPE_MAKEPEN){
      @<Pen Primary: Custom Format@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

If the expression evaluates to a variable, we need to copy the
variable content to the result of the evaluation. If the evaluation
return a variable that points to other (the \monoespaco{currentpen}),
instead we copy the content of the referenced pen. But after the copy
we multiply the obtained matrix by the pointer matrix.

\iniciocodigo
@<Pen Primary: Variable@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct pen_variable *content = v -> var, *to_copy = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-pen variable in pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(content -> referenced != NULL)
  to_copy = content -> referenced;
memcpy(result, to_copy, sizeof(struct pen_variable));
if(to_copy -> format != NULL)
  if(!recursive_copy_points(mf, cx, temporary_alloc, &(result -> format),
                            to_copy -> format, true))
    return false;
if(to_copy != content)
  MATRIX_MULTIPLICATION(result -> gl_matrix, content -> gl_matrix);
return true;
@
\fimcodigo

If the expression evaluates to a null pen, we should just create a new
pen with the flag \monoespaco{FLAG\_NULL} active. This pen never will
be triangulated and never will produce any drawing:

\iniciocodigo
@<Pen Primary: Null Pen@>=
result -> format = NULL;
result -> flags = FLAG_NULL;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

If the expression evaluates to a circular pen, we generate a new pen
with circular and convex flags. We also initialize the transform
matrix as an identity matrix:

\iniciocodigo
@<Pen Primary: Circle Pen@>=
result -> format = NULL;
result -> flags = FLAG_CONVEX | FLAG_CIRCULAR;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

Evaluate parenthesis requires to evaluate as a pen expression every
token after the open parenthesis until the position before the closing
of the parenthesis:

\iniciocodigo
@<Pen Primary: Parenthesis@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_pen_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

The last case of pen expression is when the user chooses a custom
format for the pen. In this case, we should evaluate the path
expression and create a new pen with that given format:

\iniciocodigo
@<Pen Primary: Custom Format@>=
struct generic_token *p = begin_expression -> next;
result -> format =
        (struct path_variable *) temporary_alloc(sizeof(struct path_variable));
if(result -> format == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, p, end_expression, result -> format))
  return false;
if(!(result -> format -> cyclic)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr,
          "METAFONT: Error: %s:%d: Using 'makepen' with non-cyclic path.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
result -> flags = read_flags(result -> format); // To be implemented
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

To the functioon above work correctly, we need a function that walks
over the points in a path and return the flags that a pen with that
format would have:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int read_flags(struct path_variable *path);
@
\fimcodigo

We already know that the pen never will be circular, as perfect
circles cannot be expressed using Bezir curves. We will verify only
if the pen is straight or convex:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int read_flags(struct path_variable *path){
  int i, positive_cross_product = -1;
  int flag = FLAG_CONVEX | FLAG_STRAIGHT;
  for(i = 0; i < path -> number_of_points - 1; i ++){
    struct path_points *current, *next;
    current = get_point(path, i);
    next = get_point(path, i + 1);
    if(flag & FLAG_STRAIGHT){
      // It is straight if the auxiliary and control points are colinear.
      // They are colinear if they form a triangle with area zero (or
      // sufficiently next to zero):
      double area =  current -> point.x * (current -> point.u_y - next -> point.y) +
                     current -> point.u_x * (next -> point.y - current -> point.y) +
                     next -> point.x * (current -> point.y - current -> point.u_y);
      if(area > 0.00002)
        flag -= FLAG_STRAIGHT;
      area =  current -> point.x * (current -> point.v_y - next -> point.y) +
              current -> point.v_x * (next -> point.y - current -> point.y) +
              next -> point.x * (current -> point.y - current -> point.v_y);
      if((flag & FLAG_STRAIGHT) && area > 0.00002)
        flag -= FLAG_STRAIGHT;        
    }
    if(flag & FLAG_CONVEX){
      // It is convex only if the z component of the cross product of vectors
      // composed by the extremity and control points in the drawing order
      // is always non-negative or always non-positive
      int j;
      double d1_x, d1_y, d2_x, d2_y, z_cross_product;
      double p1_x, p1_y, p2_x, p2_y, p3_x, p3_y; // Pontos
      for(j = 0; j < 3; j ++){
        switch(j){
          case 0:
            p1_x = current -> point.x; p1_y = current -> point.y;
            p2_x = current -> point.u_x; p2_y = current -> point.u_y;
            p3_x = current -> point.v_x; p3_y = current -> point.v_y;
            break;
          case 1:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> point.x; p3_y = next -> point.y;
            break;
          default:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> point.u_x; p3_y = next -> point.u_y;
            break;
        }
        d1_x = p2_x - p1_x;
        d1_y = p2_y - p1_y;
        d2_x = p3_x - p2_x;
        d2_y = p3_y - p2_y;
        z_cross_product = d1_x * d2_y - d1_y * d2_x;
        if(z_cross_product > 0.004 || z_cross_product < -0.004){
          if(positive_cross_product == -1)
            positive_cross_product = (z_cross_product > 0);
          else if((z_cross_product > 0) != positive_cross_product){
            //flag -= FLAG_CONVEX;
            break;
          }
        }
      }
    }
  }
  return flag;
}
@
\fimcodigo

\subsubsecao{8.5.4. Pens in Path Expressions}

Primary pen expressions also can appear inside path primary
expressions. This happens when we try to extract a pen format as a
path. The grammar for this operation is:

\alinhaverbatim
<Path Primary> -> makepath <Pen Primary>
\alinhanormal

We need to register a new token for ``makepath'':

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_MAKEPATH,       // O token simblico 'makepath'
@
\fimcodigo

And we add the string with the token name to the list of reserved
words:

\iniciocodigo
@<List of Keywords@>+=
"makepath",
@
\fimcodigo

The operator ``makepath'' evaluates all tokens after itself as a pen
primary expression. After this, it takes the resulting pen and extract
its format as a path. Sometimes the pen variable will already have its
format stored as a path and we just need to extract and copy it. But
in some cases, if we have a \monoespaco{nullpen} or
a \monoespaco{circlepen}, or even if we have a square pen, we need to
generate a path with a correct format:

\iniciocodigo
@<Primary Path: Other Expressions@>=
else if(begin_expression -> type == TYPE_MAKEPATH){
  struct pen_variable tmp;
  if(begin_expression -> next == NULL ||
     begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_pen_primary(mf, cx, begin_expression -> next, end_expression,
                       &tmp))
    return false;
  if(tmp.flags & FLAG_NULL){ // nullpen: Avalia para ponto nico (0, 0)
    @<'makepath': 'nullpen'@>
  }
  else if(tmp.flags & FLAG_CIRCULAR){ // circlepen: Circle approximation
    @<'makepath': 'pencircle'@>
  }
  else if(tmp.flags & FLAG_SQUARE){ // Caneta quadrada
    @<'makepath': 'pensquare'@>
  }
  else{ // Caneta com formato personalizado
    @<'makepath': Formato Personalizado@>
  }
  @<'makepath': Apply Linear Transform@>
  return true;
}
@
\fimcodigo

As in the original METAFONT language, the \monoespaco{nullpen}
represents a single point in position $(0, 0)$ that never will be
drawn:

\iniciocodigo
@<'makepath': 'nullpen'@>=
result -> length = 1;
result -> number_of_points = 1;
result -> cyclic = false;
result -> points =
  (struct path_points *) temporary_alloc(sizeof(struct path_points));
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = 0.0;
result -> points[0].point.y = 0.0;
result -> points[0].point.u_x = 0.0;
result -> points[0].point.u_y = 0.0;
result -> points[0].point.v_x = 0.0;
result -> points[0].point.v_y = 0.0;
@
\fimcodigo

If we have a circular pen, then we use as a circle approximation the
same values that the original METAFONT uses in a macro to represent
its \monoespaco{fullcircle} path. The result is close enough to a
circle:

\iniciocodigo
@<'makepath': 'pencircle'@>=
result -> length = 9;
result -> number_of_points = 9;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 9);
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = 0.5; result -> points[0].point.y = 0.0;
result -> points[0].point.u_x = 0.5; result -> points[0].point.u_y = 0.13261;
result -> points[0].point.v_x = 0.44733; result -> points[0].point.v_y = 0.2598;
result -> points[1].format = FINAL_FORMAT;
result -> points[1].point.x = 0.35356; result -> points[1].point.y = 0.35356;
result -> points[1].point.u_x = 0.2598; result -> points[1].point.u_y = 0.44733;
result -> points[1].point.v_x = 0.13261; result -> points[1].point.v_y = 0.5;
result -> points[2].format = FINAL_FORMAT;
result -> points[2].point.x = 0.0; result -> points[2].point.y = 0.5;
result -> points[2].point.u_x = -0.13261; result -> points[2].point.u_y = 0.5;
result -> points[2].point.v_x = -0.2598; result -> points[2].point.v_y = 0.44733;
result -> points[3].format = FINAL_FORMAT;
result -> points[3].point.x = -0.35356; result -> points[3].point.y = 0.35356;
result -> points[3].point.u_x = -0.44733; result -> points[3].point.u_y = 0.2598;
result -> points[3].point.v_x = -0.5; result -> points[3].point.v_y = 0.13261;
result -> points[4].format = FINAL_FORMAT;
result -> points[4].point.x = -0.5; result -> points[4].point.y = 0.0;
result -> points[4].point.u_x = -0.5; result -> points[4].point.u_y = -0.13261;
result -> points[4].point.v_x = -0.44733; result -> points[4].point.v_y = -0.2598;
result -> points[5].format = FINAL_FORMAT;
result -> points[5].point.x = -0.35356; result -> points[5].point.y = -0.35356;
result -> points[5].point.u_x = -0.2598; result -> points[5].point.u_y = -0.44733;
result -> points[5].point.v_x = -0.13261; result -> points[5].point.v_y = -0.5;
result -> points[6].format = FINAL_FORMAT;
result -> points[6].point.x = 0.0; result -> points[6].point.y = -0.5;
result -> points[6].point.u_x = 0.13261; result -> points[6].point.u_y = -0.5;
result -> points[6].point.v_x = 0.2598; result -> points[6].point.v_y = -0.44733;
result -> points[7].format = FINAL_FORMAT;
result -> points[7].point.x = 0.35356; result -> points[7].point.y = -0.35356;
result -> points[7].point.u_x = 0.44733; result -> points[7].point.u_y = -0.2598;
result -> points[7].point.v_x = 0.5; result -> points[7].point.v_y = -0.13261;
result -> points[7].format = FINAL_FORMAT;
result -> points[8].point.x = 0.5; result -> points[8].point.y = 0.0;
result -> points[8].point.u_x = 0.5; result -> points[8].point.u_y = 0.13261;
result -> points[8].point.v_x = 0.44733; result -> points[8].point.v_y = 0.2598;
result -> cyclic = true;
@
\fimcodigo

If we have a square pen, we generate its true format filling its
extremity and control points:

\iniciocodigo
@<'makepath': 'pensquare'@>=
result -> length = 5;
result -> number_of_points = 5;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 5);
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = -0.5; result -> points[0].point.y = -0.5;
result -> points[0].point.u_x = (-0.5+(1.0/3.0));
result -> points[0].point.u_y = -0.5;
result -> points[0].point.v_x = (-0.5+(2.0/3.0));
result -> points[0].point.v_y = -0.5;
result -> points[1].format = FINAL_FORMAT;
result -> points[1].point.x = 0.5; result -> points[1].point.y = -0.5;
result -> points[1].point.u_x = 0.5;
result -> points[1].point.u_y = (-0.5+(1.0/3.0));
result -> points[1].point.v_x = 0.5;
result -> points[1].point.v_y = (-0.5+(2.0/3.0));
result -> points[2].format = FINAL_FORMAT;
result -> points[2].point.x = 0.5; result -> points[2].point.y = 0.5;
result -> points[2].point.u_x = (0.5-(1.0/3.0));
result -> points[2].point.u_y = 0.5;
result -> points[2].point.v_x = (0.5-(2.0/3.0));
result -> points[2].point.v_y = 0.5;
result -> points[3].format = FINAL_FORMAT;
result -> points[3].point.x = -0.5; result -> points[3].point.y = 0.5;
result -> points[3].point.u_x = -0.5;
result -> points[3].point.u_y = (0.5-(1.0/3.0));
result -> points[3].point.v_x = -0.5;
result -> points[3].point.v_y = (0.5-(2.0/3.0));
result -> points[4].format = FINAL_FORMAT;
result -> points[4].point.x = -0.5; result -> points[4].point.y = -0.5;
result -> points[4].point.u_x = (-0.5+(1.0/3.0));
result -> points[4].point.u_y = -0.5;
result -> points[4].point.v_x = (-0.5+(2.0/3.0));
result -> points[4].point.v_y = -0.5;
result -> cyclic = true;
@
\fimcodigo

Finally, if we have a pen with a custom format, then it already stores
its format as a path variable. We just need to copy it and then
deallocate the temporary pen evaluation:

\iniciocodigo
@<'makepath': Formato Personalizado@>=
if(!recursive_copy_points(mf, cx, temporary_alloc, &result, tmp.format, false))
  return false;
if(temporary_free != NULL){
  temporary_free(tmp.format -> points);
  temporary_free(tmp.format);
}
@
\fimcodigo

And finally, after obtaining the path, we need to apply all the linear
transformations stored in the transform matrix, applying any rotation,
shifting, slanting, scaling or other transformations stored there:

\iniciocodigo
@<'makepath': Apply Linear Transform@>=
{
  int i;
  for(i = 0; i < result -> length; i ++){
    float x0 = result -> points[i].point.x, y0 = result -> points[i].point.y;
    result -> points[i].point.x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].point.y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].point.u_x;
    y0 = result -> points[i].point.u_y;
    result -> points[i].point.u_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].point.u_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].point.v_x;
    y0 = result -> points[i].point.v_y;
    result -> points[i].point.v_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].point.v_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
  }
}
@
\fimcodigo

\subsecao{8.6. Picture Assignments and Expressions}

To make a picture assignment, we use the code below. It first
evaluates a picture expression and get a picture variable as
result. The picture variable has an initialized and filled OpenGL
texture. If our assignment has a single variable, we can just copy the
texture identifier and the other variable information. If we have more
than one variables as destiny in our assignment, then for the first
variable we just copy the texture identifier, and for the other we
will need to generate new textures and copy the content.

\iniciocodigo
@<Assignment for Picture Variables@>=
else if(type == TYPE_T_PICTURE){
  int i;
  struct picture_variable result;
  if(!eval_picture_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    if(i == 0){
      struct picture_variable *pic = (struct picture_variable *) var -> var;
      if(pic -> texture != 0)
        glDeleteTextures(1, &(pic -> texture));
      pic -> width = result.width;
      pic -> height = result.height;
      pic -> texture = result.texture;
      pic -> type = TYPE_T_PICTURE;
      // If assigning to 'currentpicture', additional code is executed
      if(pic ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
        // The code below will be defined in Subsection 11.2:
        @<Create new 'currentpicture'@>
      }
    }
    else 
      assign_picture_variable(mf, (struct picture_variable *) var -> var,
                              &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The function \monoespaco{assign\_picture\_variable} above needs to
generate a new texture in the destiny (removing the existing texture
if it exists) and copy the content of the origin texture in the
destiny. This means that we need to render the content of one texture
in the other.

To render something, we first need vertices. As all that we will
render will be rectangular textures, we will need only the following
vertices for all the rendering:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
const static float square[20] = {
  -1.0, -1.0, // First vertice
  0.0, 0.0,  // Texture coordinate
  1.0, -1.0, // Second vertice
  1.0, 0.0, // Texture
  1.0, 1.0, // Third vertice
  1.0, 1.0, // Texture
  -1.0, 1.0, // Fourth vertice
  0.0, 1.0}; // Texture
static GLuint vbo; // OpenGL Vertex Buffer Object
@
\fimcodigo

Each vertice above also stores information about the texture
coordinate. So we can sent to the GPU both informations at
once. Notice that we defined above a square with length 2 centered at
the origin. This is the correct size to render the vertices occupying
all the available space according with OpenGL conventions. We also
defined the vertices in counter-clockwise order, which means that we
are looking at the front side os the polycon according with OpenGL
conventions. This is necessary so that the polygon will be rendered
even if optimizations to avoid rendering the back of polygons are
active.

When initializing Weaver Metafont, we sent these vertices to the
graphics card:

\iniciocodigo
@<WEAVEFONT Initialization@>=
glGenBuffers(1, &vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// Sending vertices to the graphics card
glBufferData(GL_ARRAY_BUFFER, sizeof(square), square, GL_STATIC_DRAW);
@
\fimcodigo

And during finalization, we remove and erase these vertices:

\iniciocodigo
@<WEAVEFONT Finalization@>=
glDeleteBuffers(1, &vbo);
@
\fimcodigo

To render the vertices, we need a vertex shader running in the
GPU. Our vertex shader must be versatile enough to get as argument a
matrix with linear transformation to be done over the
vertices. Besides the matrix, the input will be the vertex coordinate,
and the associated texture coordinate. The output that will be passed to
the fragment shader os the final coordinate after the linear
transformation and the texture coordinate.

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "  texture_coordinate = vertex_data.zw;\n"
  "}\n";
@
\fimcodigo

The fragment shader get as input the vertex shader output and a
texture:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  vec4 texture = texture2D(texture1, texture_coordinate);\n"
  "  gl_FragColor = texture;"
  "}\n";
static GLuint program; // Store the program after compiling the above shaders
GLint uniform_matrix; // Stores the matrix position in the program above
GLint uniform_texture; // Stores the texture position in the above code
@
\fimcodigo

These simple shaders must be compiled during initialization. Let's
create a local auxiliary function to help us with the compilation:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source);
@
\fimcodigo

This function will return the compiled program's identifier given the
shader source code passed as argument. In case of error, it will
return zero.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source){
  GLuint vertex, fragment, prog;
  GLint status = GL_TRUE;
  // Creating vertex and fragment shader
  vertex = glCreateShader(GL_VERTEX_SHADER);
  fragment = glCreateShader(GL_FRAGMENT_SHADER);
  // Passing their source code
  glShaderSource(vertex, 1, &vertex_shader_source, NULL);
  glShaderSource(fragment, 1, &fragment_shader_source, NULL);
  // Compiling vertex shader:
  glCompileShader(vertex);
  glGetShaderiv(vertex, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont vertex shader compilation failed!\n");
    return 0;
  }
  // Compiling fragment shader:
  glCompileShader(fragment);
  glGetShaderiv(fragment, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont fragment shader compilation failed!\n");
    return 0;
  }
  // Creating the program:
  prog = glCreateProgram();
  // Linking the program:
  glAttachShader(prog, vertex);
  glAttachShader(prog, fragment);
  glBindAttribLocation(prog, 0, "vertex_data");
  glLinkProgram(prog);
  glGetProgramiv(prog, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr, "ERROR: Weaver Metafont shader linking failed!\n");
    return false;
  }
  // Finalization:
  glDeleteShader(vertex);
  glDeleteShader(fragment);
  return prog;
}
@
\fimcodigo


And we can use now this function to compile our default shader
program:

\iniciocodigo
@<WEAVEFONT Initialization@>+=
{
  program = compile_shader_program(vertex_shader, fragment_shader);
  uniform_matrix = glGetUniformLocation(program, "model_view_matrix");
  uniform_texture = glGetUniformLocation(program, "texture1");
}
@
\fimcodigo

During finalization we will delete the program:

\iniciocodigo
@<WEAVEFONT Finalization@>+=
glDeleteProgram(program);
@
\fimcodigo

To render the content of one texture in another, we will need to
create a new framebuffer with a new texture attached using a given
width and height. The function below will help us to achieve this. It
will create a new framebuffer with a new attached texture and activate
both. Everything that will be rendered after this, will be rendered in
the texture instead of the screen.

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height){
  glGenFramebuffers(1, new_framebuffer);
  glGenTextures(1, new_texture);
  glBindTexture(GL_TEXTURE_2D, *new_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
               GL_UNSIGNED_BYTE, NULL);
  glBindFramebuffer(GL_FRAMEBUFFER, *new_framebuffer);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                         *new_texture, 0);
  if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: OpenGL cannot create framebuffer!\n");
#endif
    glBindTexture(GL_TEXTURE_2D, 0);
    return false;
  }
  glBindTexture(GL_TEXTURE_2D, 0);
  return true;
}
@
\fimcodigo

We also need code to render a picture variable in the current
framebuffer using the defined shader program. The function that will
perform this is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background);
// XXX:
void print_picture(struct picture_variable *pic);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background){
  glColorMask(true, true, true, true);
  glViewport(0, 0, dst_width, dst_height);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *) 0);
  glEnableVertexAttribArray(0);
  glUseProgram(program);
  glUniformMatrix3fv(uniform_matrix, 1, true, matrix);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, pic -> texture);
  glUniform1i(uniform_texture, 0);
  if(clear_background){
    // Clearing the destiny to transparent white before drawing
    glClearColor(1.0, 1.0, 1.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
  }
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBindTexture(GL_TEXTURE_2D, 0);
}
// XXX:
void print_picture(struct picture_variable *pic){
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  GLuint framebuffer;
  GLuint texture;
  unsigned char data[100000];
  get_new_framebuffer(&framebuffer, &texture, pic -> width, pic -> height);
  render_picture(pic, model_view_matrix, pic -> width, pic -> height, true);
  // Ler dados do framebuffer:
  glFinish();
  glReadPixels(0, 0, pic -> width, pic -> height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    int i, j;
    for(i = pic -> width * (pic -> height - 1) * 4;
        i >= 0; i -= (pic -> width * 4)){
      for(j = 0; j < (pic -> width * 4); j += 4)
        printf("(%hu %hu %hu %hu)", (unsigned char) data[i + j], (unsigned char) data[i+j+1], (unsigned char) data[i+j+2], (unsigned char) data[i+j+3]);
        printf("\n");
    }
  }
}
@
\fimcodigo

Now let's declare the function that assigns the content of a source
variable to a target variable, generating a new texture and copying
the contents os one texture to the other:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source){
  GLuint temporary_framebuffer;
  GLint previous_framebuffer;
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(target -> texture != 0)
    glDeleteTextures(1, &(target -> texture));
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(target -> texture),
                      source -> width, source -> height);
  render_picture(source, model_view_matrix, source -> width, source -> height, true);
  // Finalization:
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glBindTexture(GL_TEXTURE_2D, 0);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  if(target ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
    // The code below will be defined on Subsection 11.2:
    @<Create new 'currentpicture'@>
  }
}
@
\fimcodigo

\subsubsecao{8.6.1. Picture Tertiary Expressions: Sum and Subtraction}

The tertiary picture expressions invoves sums and subtractions:

\alinhaverbatim
<Picture Expression> -> <Picture Tertiary>
<Picture Tertiary> -> <Picture Tertiary><'+' or '-'> <Picture Secondary>
<'+' or '-'> -> + | -
\alinhanormal

Pictures can be added or subtracted. The result of $p_1+p_2$
represents a new image composed by the pixels from the first image
plus the pixels in the second image. And $p_1-p_2$ means erasing from
the first image the pixels from the second.  The resulting image always
will have the biggest height and width from the operands. And the
pixel adding or subtracting will happen when the two images are
centered.

The function that evaluates picture tertiary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct picture_variable *result);
@
\fimcodigo

The function implementation tries to identify the last operator $+$ or
$-$ in the expression. If it does not exist, then we need to evaluate
the entire expression as a secondary expression. If it exists, then
the left side of the operator is evaluated as a tertiary expression
and the right side as a secondary expression. After this, the two
results are added or subtracted:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct picture_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_SUM || p -> type == TYPE_SUBTRACT) &&
       prev -> type != TYPE_SUM && prev -> type != TYPE_SUBTRACT){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL || before_last_operator == NULL){
    struct picture_variable a;
    struct picture_variable *sec = &a;
    @<Picture: Evaluate Secondary Expression in 'sec'@>
    return true;
  }
  else{
    struct picture_variable a, b;
    struct picture_variable *sec = &b;
    if(last_operator == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Incomplete picture expression "
                      "ending with '+' or '-'.\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_picture_expression(mf, cx, begin_expression, before_last_operator, &a))
      return false;
    @<Picture: Evaluate Secondary Expression in 'sec'@>
    @<Image Expression: Sum or Subtract@>
    if(a.texture != 0)
      glDeleteTextures(1, &(a.texture));
    if(b.texture != 0)
      glDeleteTextures(1, &(b.texture));
    return true;
  }
}
@
\fimcodigo

To add or subtract images, we first need to determine the final image
area. It will have the biggest width and height from the combined
images. After this, we create and initialize it as a transparent
image. Both in the sum as in the subtraction we begin drawing the
first operand to the destination. After this, in the case of a sum, we
just draw the second image blending with the initial image by
multiplying the new color $(y_R, y_G, y_B, y_A)$ by its alpha value
and adding with the previous color $(x_R, x_G, x_B, x_A)$ multiplied
by the complement of the alpha component of the new color:

$$(1-y_A)(x_R, x_G, x_B, x_A) + y_A(y_R, y_G, y_B, y_A)$$

The subtraction case is more complex and to understand it, we need to
understand the rules about how the textures are represented and how
Weaver Metafont deals with them. Weaver Metafont assumes that an empty
initialized picture of a given size has a fully transparent white
color (represented by $(1, 1, 1 ,0)$ following OpenGL convention). If
we put ink in a image, we are putting a fully opaque black color
(represented by $(0, 0, 0, 1)$ following OpenGL conventions). To
Weaver Metafont, white transparent is the neutral operator in a
subtraction: removing transparent white from a picture changes
nothing. And removint opaque black removes all the color. These rules
contrast with white being represented by 1 and black being represented
by 0 in OpenGL. Because of this, our blending equation to combine an
existing color $(x_R, x_G, x_B, x_A)$ with a new color $(y_R, y_G,
y_B, y_A)$ is:

$$
(max(x_R, 1-y_R), max(x_G, 1-y_G), max(x_B, 1-y_B), x_A-y_A)
$$

Unfortunately, it is not possible to compute the above equation using
only OpenGL blending equations. Open GL ES 3.0 and 4 supports the
usage of $max$ function, but when using it, the blending factors are
ignored. This means that it is possible to compute $max(x_R, y_R)$,
but not $max(x_R, 1- y_R)$. This inversion neeeds to be done in the
shader. The fragment shader that invert the colors, but not the image
alpha is:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char fragment_shader_inverse[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  vec4 texture = texture2D(texture1, texture_coordinate);\n"
  "  gl_FragColor = vec4(1.0 - texture.r, 1.0 - texture.g, 1.0 - texture.b, \n"
  "                      texture.a);\n"
  "}\n";
static GLuint inv_program; // The compiled program whose code is above
static GLint uniform_inv_texture; // Texture position in the program
static GLint uniform_inv_matrix; // Matrix position in the program
@
\fimcodigo

A new shader program to render the inverse RGB must be compiled during
initialization:

\iniciocodigo
@<WEAVEFONT Initialization@>+=
{
  inv_program = compile_shader_program(vertex_shader, fragment_shader_inverse);
  uniform_inv_matrix = glGetUniformLocation(program, "model_view_matrix");
  uniform_inv_texture = glGetUniformLocation(program, "texture1");
}
@
\fimcodigo

In the finalization, we destroy the program:

\iniciocodigo
@<WEAVEFONT Finalization@>+=
glDeleteProgram(inv_program);
@
\fimcodigo


\iniciocodigo
@<Image Expression: Sum or Subtract@>=
// Allocating and declaring data, creating transparent initial image
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
result -> width = ((a.width >= b.width)?(a.width):(b.width));
result -> height = ((a.height >= b.height)?(a.height):(b.height));
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Rendering image 'a'
model_view_matrix[0] = (double) a.width / (double) result -> width;
model_view_matrix[4] = (double) a.height / (double) result -> height;
render_picture(&a, model_view_matrix, result -> width, result -> height, true);
// Rendering image 'b'
model_view_matrix[0] = (double) b.width / (double) result -> width;
model_view_matrix[4] = (double) b.height / (double) result -> height;
if(last_operator -> type == TYPE_SUBTRACT){
  glEnable(GL_BLEND);
  // The factors in the blending equation
  glBlendFunc(GL_ONE, GL_ONE);
  // Max function for RGB and subtraction for A:
  glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  glUseProgram(inv_program);
  glUniformMatrix3fv(uniform_inv_matrix, 1, true, model_view_matrix);
  glUniform1i(uniform_inv_texture, 0);
  glBindTexture(GL_TEXTURE_2D, b.texture);
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBlendEquation(GL_FUNC_ADD);
  glDisable(GL_BLEND);
}
else{ // Sum:
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glBlendEquation(GL_FUNC_ADD);
  render_picture(&b, model_view_matrix, result -> width, result -> height, false);
  glDisable(GL_BLEND);
}
// Finalization
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glBindTexture(GL_TEXTURE_2D, 0);
glDeleteFramebuffers(1, &temporary_framebuffer);
@
\fimcodigo

\subsubsecao{8.6.2. Picture Secondary Expressions: Transformers}

A picture secondary expression has the following syntax:

\alinhaverbatim
<Picture Seconary> -> <Picture Primary> |
                      <Picture Secondary><Transformer>
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary> |
                 transformed <Transform Primary>
\alinhanormal

The same transformers that we can use in pairs, transforms, paths and
pens also can be used in images. But how we do apply them is a little
different. Like what we do for pens, we first store all the required
transformations in a matrix to accumulate transformations before
applying them. But contrary to pens, picture variables do not store
their transform matrix.

The matrix will exist only when evaluating secondary and tertiary
picture expressions. And they will be applied only after evaluating a
secondary expression in the tertiary expression. This way, if we had
the following code:

\alinhaverbatim
a = img totated 45 slanted 0.2 zscaled(2, 3)
\alinhanormal

Instead of making three potentially expensive transforms, we will
accumulate all the three transforms in a matrix. When we have no more
transforms, which is when we return from all secondary expression
evaluations to a tertiary evaluation, we finally apply the transforms
stored in the matrix. This means that the function that evaluates
picture secondary expressions will have two additional parameters: a
matrix pre-initialized as the identity matrix and a pointer to a
boolean variable pre-initialized to false. The boolean variable will
became true only if the matrix is changed during secondary evaluation.

\iniciocodigo
@<Picture: Evaluate Secondary Expression in 'sec'@>=
{
  float matrix[9];
  bool modified = false;
  INITIALIZE_IDENTITY_MATRIX(matrix);
  if(last_operator == NULL){
     if(!eval_picture_secondary(mf, cx, begin_expression, end_expression, sec,
                             matrix, &modified))
      return false;
  }
  else if(!eval_picture_secondary(mf, cx, last_operator -> next,
                                  end_expression, sec, matrix, &modified))
    return false;
  if(modified){
    if(!apply_image_transformation(mf, result, sec, matrix))
      return false;
    if(sec -> texture != 0)
      glDeleteTextures(1, &(sec -> texture));
  }
  else{
    result -> width = sec -> width;
    result -> height = sec -> height;
    result -> texture = sec -> texture;
  }
}
@
\fimcodigo

The function that evaluates secondary expressions for pictures is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct picture_variable *result,
                            float *matrix, bool *modified);
@
\fimcodigo

And its implementation involves looping over each token in the
expression until finding the last secondary transform operator. If we
do not find any, we evaluate everything as a primary
expression. Otherwise, we evaluate everything before the last operator
as a secondary expression and then we apply the transformation in the
matrix:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct picture_variable *result,
                            float *matrix, bool *modified){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_picture_primary(mf, cx, begin_expression, end_expression, result);
  else{
    if(!eval_picture_secondary(mf, cx, begin_expression,
                               before_last_transformer, result, matrix, modified))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Picture Secondary: Rotation@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Picture Secondary: Scaling@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Picture Secondary: Shifting@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Picture Secondary: Slanting@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Picture Secondary: X-Scaling@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Picture Secondary: Y-Scaling@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Picture Secondary: Z-Scaling@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Picture Secondary: Generic Transform@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Evaluating each different linear transformation means modifying the
secondary expression matrix, multiplying its previous value by a new
matrix. Exactly like we did for pens. Like described in code from
Subsection X.Y.

This is scale changing:

\iniciocodigo
@<Picture Secondary: Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

This is the code for rotation:

\iniciocodigo
@<Picture Secondary: Rotation@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(matrix, rotation);
*modified = true;
return true;
@
\fimcodigo

The code that shifts the image by coordinate $(x, y)$ in
pixels. Before performing the linear transform in the matrix, we
conver the pixels in OpenGL coordinates that depend on the picture
size:

\iniciocodigo
@<Picture Secondary: Shifting@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
p.x = 2.0 * (p.x / result -> width);
p.y = 2.0 * (p.y / result -> height);
TRANSFORM_SHIFT(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

The code that slants an image:

\iniciocodigo
@<Picture Secondary: Slanting@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

The code that scales an image only in the $x$-axis:

\iniciocodigo
@<Picture Secondary: X-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

The code that scales the image only in axis $y$:

\iniciocodigo
@<Picture Secondary: Y-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

The z-scaling which changes the scale in the complex plane:

\iniciocodigo
@<Picture Secondary: Z-Scaling@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

Finally, the generic transform that applies the linear transform
stored in a transformer:

\iniciocodigo
@<Picture Secondary: Generic Transform@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression,
                           &t))
  return false;
MATRIX_MULTIPLICATION(matrix, t.value);
*modified = true;
return true;
@
\fimcodigo

Now we just need to define how do we apply the linear transformation
over an image given the transform matrix, the origin picture variable
and the destiny picture variable. This is done with the help of the
following auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *org,
                                float *matrix);
@
\fimcodigo

Apply the image transformation means using the transformation matrix
to transform the original image to generate the new image in the
destiny. For this, we need the following steps:

1) First we need to discover the size in pixels for the final
image. To discover the values, we multiply the coordinates in the
origin by the transformation matrix. But in this case, we measure the
coordinates in pixels, not using OpenGL coordinates. If our image is a
square measuring 5, one of its vertices is $(-5/2, -5/2)$ and the
other will be $(5/2, 5/2)$. The resulting transformation will be the
coordinates in pixels, from which we obtain the final size in
pixels. We can ignore the translation in this step.

2) To take into account the translation, we should add twice the
translation distance in pixels to the image size. Recall that the
translation should not change the central pixel in the
image. Therefore, if we shift an original image composed by a single
black pixel by $(1, 1)$, we would obtain a new image $3 \times 3$,
with the black pixel in the upper corner. The image center now is a
white transparent pixel, which is the black pixel position before the
shift.

3) Changing the size and scale is done just rendering the image in a
texture with different size. So we do not need anymore the information
in the matrix about scaling. We remove this from tha matrix and also
correct the shifting coordinates, so that if the original image is
shifted a single pixel,in the final image we get it after changing a
simple pixel. This is done applying a correction over $x$ and $y$
positions in the matrix.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix){
  int i;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  // To compute the final size, we store the greatest and smallest
  // coordinates found in the picture vertices in both axisafter
  // the transformation. (Step 1):
  float min_x = INFINITY, min_y = INFINITY, max_x = -INFINITY, max_y = -INFINITY;
  float origin_coordinates[8];
  origin_coordinates[0] = -((float) origin -> width) / 2.0;
  origin_coordinates[1] = -((float) origin -> height) / 2.0;
  origin_coordinates[2] = ((float) origin -> width) / 2.0;
  origin_coordinates[3] = -((float) origin -> height) / 2.0;
  origin_coordinates[4] = ((float) origin -> width) / 2.0;
  origin_coordinates[5] = ((float) origin -> height) / 2.0;
  origin_coordinates[6] = -((float) origin -> width) / 2.0;
  origin_coordinates[7] = ((float) origin -> height) / 2.0;
  for(i = 0; i < 8; i += 2){
    float x = LINEAR_TRANSFORM_X(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    float y = LINEAR_TRANSFORM_Y(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    if(x > max_x) max_x = x;
    if(x < min_x) min_x = x;
    if(y > max_y) max_y = y;
    if(y < min_y) min_y = y;
  }
  // Adjusting the image size according with translation (Step 2):
  dst -> width = (int) (max_x - min_x) +
                 (int) (origin -> width * matrix[6]);
  dst -> height = (int) (max_y - min_y) +
                  (int) (origin -> height * matrix[7]);
  // Removing from the matrix scaling data and correcting the translation
  // (Step 3):
  {
    double x_correction = ((double) origin -> width) / (double) dst -> width;
    double y_correction = ((double) origin -> height) / (double) dst -> height;
    matrix[0] = matrix[0] * x_correction;
    matrix[3] = matrix[3] * x_correction;
    matrix[6] = matrix[6] * x_correction;
    matrix[1] = matrix[1] * y_correction;
    matrix[4] = matrix[4] * y_correction;
    matrix[7] = matrix[7] * y_correction;
  }
  // Generating framebuffer and initial texture
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(dst -> texture), dst -> width,
                    dst -> height);
  // Rendering:
  render_picture(origin, matrix, dst -> width, dst -> height, true);
  // Finalization:
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.3. Inverters, Identity and Empty Images}

The grammar for primary picture expressions is:

\alinhaverbatim
<Picture Primary> -> <Picture Variable> |
                     nullpicture <Pair Primary> |
                     ( <Picture Expression> ) |
                     <'+' or '-'> <Picture Primary> |
                     subpicture <Pair Primary> and <Pair Primary> of
                                <Picture Primary>
\alinhanormal

This means that we need to register a new token for ``nullpicture'' and
``subpicture'':

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_NULLPICTURE,        // Symbolic token 'nullpicture'
TYPE_SUBPICTURE,         // Symbolic token 'subpicture'
@
\fimcodigo

And this also requires adding these strings to the list of reserved
keywords:

\iniciocodigo
@<List of Keywords@>+=
"nullpicture", "subpicture",
@
\fimcodigo

The function that evaluates primary picture expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct picture_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct picture_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Primary Picture: Variable@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Primary Picture: Parenthesis@>
    }
    else if(begin_expression -> type == TYPE_NULLPICTURE){
      @<Primary Picture: 'nullpicture'@>
    }
    else if(begin_expression -> type == TYPE_SUM){
      @<Primary Picture: Identity@>
    }
    else if(begin_expression -> type == TYPE_SUBTRACT){
      @<Primary Picture: Inverse@>
    }
    else if(begin_expression -> type == TYPE_SUBPICTURE){
      @<Primary Picture: Subpicture@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

The first kind of primary expression is reading an image from a
variable. In this case, we need to copy the content of the variable
rendering it in the destiny:

\iniciocodigo
@<Primary Picture: Variable@>=
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct picture_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PICTURE){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-picture variable (%d) in "
                  "picture expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
// Preparing the rendering:
result -> width = content -> width;
result -> height = content -> height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Rendering
render_picture(content, identity_matrix, result -> width, result -> height, true);
// Finalization:
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

Dealing with parenthesis is exactly like what we did in other
expressions. We walk over the token list until we find the last token
before the closing parenthesis. The tokens between the two parenthesis
are evaluated as a new picture expression:

\iniciocodigo
@<Primary Picture: Parenthesis@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_picture_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

The next picture primary expression is creating an empty picture with
a given size. We first evaluate the tokens
after \monoespaco{nullpicture} token as a primary pair
expression. Then, we obtain the picture size from the pair and create
the texture:

\iniciocodigo
@<Primary Picture: 'nullpicture'@>=
struct generic_token *begin_pair_expression, *end_pair_expression;
struct pair_variable p;
unsigned char *data;
begin_pair_expression = begin_expression -> next;
end_pair_expression = end_expression;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing pair expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_primary(mf, cx, begin_pair_expression, end_pair_expression, &p))
  return false;
result -> width = p.x;
result -> height = p.y;
data = temporary_alloc(p.x * p.y * 4);
if(data == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
  return false;
}
// Making the new texture fully white
memset(data, 255, result -> width * result -> height * 4);
{ // And making it fully transparent:
  int i, size = result -> width * result -> height * 4;
  for(i = 3; i < size; i += 4)
    data[i] = 0;
}
glGenTextures(1, &(result -> texture));
glBindTexture(GL_TEXTURE_2D, result -> texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, result -> width, result -> height, 0,
             GL_RGBA, GL_UNSIGNED_BYTE, data);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glBindTexture(GL_TEXTURE_2D, 0);
if(temporary_free != NULL)
  temporary_free(data);
return true;
@
\fimcodigo

Now the antepenultimate case: when we have a token \monoespaco{+}
before the picture. In this case the operator is not doing
anything. It is an identity operator. So we just ignore it and
evaluate the next tokens as the resulting picture:

\iniciocodigo
@<Primary Picture: Identity@>=
struct generic_token *p = begin_expression -> next;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing image expression "
                  "after '+'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
return eval_picture_primary(mf, cx, p, end_expression, result);
@
\fimcodigo

For the operator \monoespaco{-}, which generates the inverse of a
picture, we will again render activating a blend equation. This time,
we will obtain the final color usaing opaque white $(1, 1, 1, 1)$ as
the initial color and we render subtracting from this the new
color. This is done choosing the blend factors to be one (GL\_ONE) e
usando subtraction as the operator (GL\_FUNC\_SUBTRACT):

\iniciocodigo
@<Primary Picture: Inverse@>=
struct picture_variable p;
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                  "'-'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_picture_primary(mf, cx, begin_expression -> next, end_expression, &p))
  return false;
// Preparing to render:
result -> width = p.width;
result -> height = p.height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Initializing the new texture to opaque white (1, 1, 1, 1)
glClearColor(1.0, 1.0, 1.0, 1.0);
glClear(GL_COLOR_BUFFER_BIT);
// Adjusting the blending equation to subtract the color from white opaque:
glEnable(GL_BLEND);
glBlendFuncSeparate(GL_ONE, GL_ONE, GL_ONE, GL_ONE);
glBlendEquationSeparate(GL_FUNC_REVERSE_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT);
// Rendering:
render_picture(&p, identity_matrix, result -> width, result -> height, false);
// Ending:
glDisable(GL_BLEND);
glDeleteTextures(1, &(p.texture));
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

FInally, the primary expression to compute subpictures. This
expression begins with token \monoespaco{subpicture}, get a primary
pair (offset in pixels), a token \monoespaco{and}, a second pair (with
subpicture size), a token \monoespaco{of} and a primary expression
with a picture (from where the subpicture will be extracted).

The first part for evaluate this expression is reading the two pairs
and the picture from the subexpressions. The second part is extract
the subpicture as requested:

\iniciocodigo
@<Primary Picture: Subpicture@>=
struct pair_variable pair_offset, subpicture_size;
struct picture_variable original_picture;
@<Subpicture: Extract Subexpressions@>
@<Subimagem: Extract Subpicture@>
return false;
@
\fimcodigo

Extract the subexpressions involves delimiting the begin and end for
each subexpression while searching for the auxiliary
tokens \monoespaco{of} and \monoespaco{and}. We also store an state to
check if we are reading the tokens in the right order, or if we are in
a malformed expressions where the tokens are present, but in the wrong
order, or without subexpressions:

\iniciocodigo
@<Subpicture: Extract Subexpressions@>=
{
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_pair1 = NULL, *end_pair1 = NULL,
                       *begin_pair2 = NULL, *end_pair2 = NULL,
                       *begin_pic = NULL, *end_pic = NULL,
                       *p = begin_expression -> next,
                       *last_token = begin_expression;
  int state = 0;
  begin_pair1 = p;
  while(p != end_expression && p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p -> type == TYPE_AND){
      if(state != 0 || last_token -> type == TYPE_SUBPICTURE){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair1 = last_token;
      state ++;
      begin_pair2 = p -> next;
    }
    else if(IS_NOT_NESTED() && p -> type == TYPE_OF){
      if(state != 1 || last_token -> type == TYPE_AND){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair2 = last_token;
      state ++;
      begin_pic = p -> next;
    }
    last_token = p;
    p = p -> next;
  }
  if(p == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
            mf -> file, p -> line);
#endif
    return false;
  }
  end_pic = p;
  if(!eval_pair_primary(mf, cx, begin_pair1, end_pair1, &pair_offset))
    return false;
  if(!eval_pair_primary(mf, cx, begin_pair2, end_pair2, &subpicture_size))
    return false;
  if(!eval_picture_primary(mf, cx, begin_pic, end_pic, &original_picture))
    return false;
}
@
\fimcodigo

Extract the subpicture requires generating a new texture with the size
indicated by the second pair and rendering the original image in the
new texture changing its size and offset according with what is stored
in the two pairs:

\iniciocodigo
@<Subimagem: Extract Subpicture@>=
{
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  float render_matrix[9];
  INITIALIZE_IDENTITY_MATRIX(render_matrix);
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                      subpicture_size.x, subpicture_size.y);
  result -> width = subpicture_size.x;
  result -> height = subpicture_size.y;
  // Initializing the new texture as transparent white (1, 1, 1, 0)
  glClearColor(1.0, 1.0, 1.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT);
  // Adjusting the size to render in the new texture
  render_matrix[0] = original_picture.width / subpicture_size.x;
  render_matrix[4] = original_picture.height / subpicture_size.y;
  // Adjusting the offset in the render matrix
  render_matrix[6] = -2.0 * (pair_offset.x +
                      0.5 * (subpicture_size.x - original_picture.width)) /
                      subpicture_size.x;
  render_matrix[7] = -2.0 * (pair_offset.y +
                      0.5 * (subpicture_size.y - original_picture.height)) /
                      subpicture_size.y;
  // Rendering:
  render_picture(&original_picture, render_matrix, result -> width, result -> height,
                 false);
  
  // Finalization:
  glDisable(GL_BLEND);
  glDeleteTextures(1, &(original_picture.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.4. Pictures in Numeric Expressions}

There are cases where we need to evaluate a picture expression inside
expressions of other types. We have three additional numeric
expressions:

\alinhaverbatim
<Numeric Primary> -> totalweight <Picture Primary> |
                     width <Picture Primary> |
                     height <Picture Primary>
\alinhanormal

The two last operators just return respectively the picture width and
height. The operator \monoespaco{totalweight} does is evaluate a
picture expression, get the resulting picture and return the sum of
its pixels weight. Each pixel weight is computed as the euclidean
distance between its RGB component and the color white, and then
normalizing the result dividing by $\sqrt{3}$. So the color white has
weight 0 and the black color has weight 1. The computed value is then
multiplied by the alpha component.

First we need a new token types for the three new operators:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_TOTALWEIGHT,        // Symbolic token 'totalweight'
TYPE_WIDTH,              // Symbolic token 'width'
TYPE_HEIGHT,             // Symbolic token 'height'
@
\fimcodigo

And we add their names to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"totalweight", "width", "height",
@
\fimcodigo

For the first operator, we will recover the pixels from a texture
first rendering the texture to a temporary framebuffer and then
reading the valuesd using function \monoespaco{glReadPixels} to get
the framebuffer content:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin -> type == TYPE_TOTALWEIGHT){
  struct picture_variable p;
  char *data;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  GLuint temporary_texture = 0;
  float identity_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(begin == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'totalweight'.\n", mf -> file, begin -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, begin -> next, end, &p))
    return false;
  data = temporary_alloc(p.width * p.height * 4);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Not enough memory!\n", mf -> file);
#endif
    return false;
  }
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(temporary_texture),
                    p.width, p.height);
  // Rendering:
  render_picture(&p, identity_matrix, p.width, p.height, true);
  // Reading framebuffer data:
  glReadPixels(0, 0, p.width, p.height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    int i, size = p.width * p.height * 4;
    double sum = 0.0;
    for(i = 0; i < size; i += 4){
      // If the values are equal, let's avoid rounding errors:
      if(data[i] == data[i+1] && data[i+1] == data[i+2]){
        sum += ((255 - (unsigned char) data[i]) / 255.0) *
               (((unsigned char) data[i+3]) / 255.0);
      }
      else{
        double r = (255 - (unsigned char) data[i]) / 255.0,
               g = (255 - (unsigned char) data[i+1]) / 255.0,
               b = (255 - (unsigned char) data[i+2]) / 255.0,
               a = ((unsigned char) data[i+3]) / 255.0;
        double v = sqrt(r*r + g*g + b*b) / sqrt(3.0);
        sum += (v * a);
      }
    }
    result -> value = sum;
  }
  // Ending:
  if(temporary_free != NULL)
    temporary_free(data);
  glDeleteTextures(1, &temporary_texture);
  glDeleteTextures(1, &(p.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

For the next two operators, \monoespaco{width}
and \monoespaco{height}, everything is simpler. We just need to get
the image and get their width and height respectively. For the width:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin -> type == TYPE_WIDTH){
  struct picture_variable p;
  if(begin == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'width'.\n", mf -> file, begin -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) p.width;
  return true;
}
@
\fimcodigo

And for the height:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin -> type == TYPE_HEIGHT){
  struct picture_variable p;
  if(begin == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'height'.\n", mf -> file, begin -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) p.height;
  return true;
}
@
\fimcodigo


\subsecao{8.7. Boolean Assignments and Expressions}

Like for all other expressions and assignments, we begin defining the
code to assign variables after evaluate an expression:

\iniciocodigo
@<Assignment for Boolean Variables@>=
else if(type == TYPE_T_BOOLEAN){
  int i;
  bool ret;
  struct boolean_variable result;
  ret = eval_boolean_expression(mf, cx, begin_expression, *end, &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    ((struct boolean_variable *) var -> var) -> value = result.value;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Now that we can assign the result of expressions, we can write the
code to proper evaluate the expressions.

\subsubsecao{8.7.1. Comparisons}

Comparisons are made using relations. They allow us to check if two
values are equal or not, and also which value is bigger or
smaller. The grammar rules to compare values are:

\alinhaverbatim
<Boolean Expression> -> <Boolean Tertiary> |
                        <Numeric Expression> <Relation> <Numeric Tertiary> |
                        <Pair Expression> <Relation> <Pair Tertiary>       |
                        <Boolean Expression> <Relation> <Boolean Tertiary> |
                        <Transform Expression> <Relation> <Transform Tertiary>
<Relation> -> < | <= | > | >= | = | <>
\alinhanormal

This mean that comparisons using these relations are in fact
quarternary expressions. They have a precedence order even smaller
that tertiary operators. For other types of expressions, we considered
a tertiary expression as synonym for expressions of that type. But for
boolean expressions, tertiary expressions are an inner type for
general boolean expressions.

The relations above require new token types to represent them:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_LT,                    // O token simblico '<'
TYPE_LEQ,                   // O token simblico '<='
TYPE_GT,                    // O token simblico '>'
TYPE_GEQ,                   // O token simblico '>='
TYPE_NEQ,                   // O token simblico '<>'
@
\fimcodigo

And we also add their names to the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"<", "<=", ">", ">=", "<>",
@
\fimcodigo

The declaration for the funtion that will evaluate boolean expressions
is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct boolean_variable *result);
@
\fimcodigo

This function shall check if we have one of the relation operators. If
not, the entire expression is evaluated as a tertiary booleana
expression. If we have one, we first need to take the rightmost
operator and evaluate it after evaluating the other two expressions
that produce its operands. But to evaluate an expression, we need to
know its type. We will assume that we have a function that, given an
tertiary expression, returns its type. We will call
it \monoespaco{get\_tertiary\_expression\_type}. We will define it
later, in Subsection 8.8. But for now we will just assume that the
function exists.

The implementation is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_LT || p -> type == TYPE_LEQ ||
        p -> type == TYPE_GT || p -> type == TYPE_GEQ ||
        p -> type == TYPE_NEQ || p -> type == TYPE_EQUAL)){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_tertiary(mf, cx, begin_expression, end_expression,
                                 result);
  else{
    int type;
    if(before_last_operator == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Relational operator without "
                      "l-value.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    type = get_tertiary_expression_type(mf, cx,  last_operator -> next,
                                        end_expression);
    switch(type){
    case TYPE_T_NUMERIC:
    {
      struct numeric_variable a, b;
      if(!eval_numeric_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_numeric_expression(mf, cx, last_operator -> next,
                                  end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_EQUAL:
        result -> value = a.value == b.value;
        return true;
      case TYPE_NEQ:
        result -> value = a.value != b.value;
        return true;
      }
      break;
    }
    case TYPE_T_PAIR:
    {
      struct pair_variable a, b;
      if(!eval_pair_expression(mf, cx, begin_expression,
                               before_last_operator, &a))
        return false;
      if(!eval_pair_expression(mf, cx, last_operator -> next,
                               end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y < b.y);
        return true;
      case TYPE_LEQ:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y <= b.y);
        return true;
      case TYPE_GT:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_GEQ:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_EQUAL:
        result -> value = (a.x == b.x && a.y == b.y);
        return true;
      case TYPE_NEQ:
        result -> value = (a.x != b.x || a.y != b.y);
        return true;
      }
      break;
    }
    case TYPE_T_TRANSFORM:
    {
      struct transform_variable a, b;
      int i, order[6] = {6, 7, 0, 3, 1, 4};
      if(!eval_transform_expression(mf, cx, begin_expression,
                                    before_last_operator, &a))
        return false;
      if(!eval_transform_expression(mf, cx, last_operator -> next,
                                    end_expression, &b))
        return false;
      switch(last_operator -> type){
        case TYPE_LT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] < b.value[order[i]]);
          return true;
        case TYPE_LEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] <= b.value[order[i]]);
          return true;
        case TYPE_GT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] > b.value[order[i]]);
          return true;
        case TYPE_GEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] >= b.value[order[i]]);
          return true;
        case TYPE_EQUAL:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = false;
              return true;
            }
          result -> value = (a.value[order[i]] == b.value[order[i]]);
          return true;
        case TYPE_NEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = true;
              return true;
            }
          result -> value = (a.value[order[i]] != b.value[order[i]]);
          return true;
      }          
      break;
    }
    case TYPE_T_BOOLEAN:
    {
      struct boolean_variable a, b;
      a.value = b.value = -1;
      if(!eval_boolean_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_boolean_tertiary(mf, cx, last_operator -> next,
                                end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_EQUAL:
        result -> value = (a.value == b.value);
        return true;
      case TYPE_NEQ:
        result -> value = (a.value != b.value);
        return true;
      }
      break;
    }
    default:
    }
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.2. Operation OR}

The boolean operator OR is the sole tertiary boolean operator. The
grammar for boolean tertiary expressions is:

\alinhaverbatim
<Boolean Tertiary> -> <Boolean Tertiary> or <Boolean Secondary> |
                      <Boolean Secondary>
\alinhanormal

To implement the operator, we need to define a new symbolic token
representing the \monoespaco{or} opeartor:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_OR,                    // Symbolic token 'or'
@
\fimcodigo

Which should be stored in the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"or",
@
\fimcodigo

Now we declare the function that evaluates secondary boolean
expressions:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result);
@
\fimcodigo

This function implementation follows the expected model from previous
similar functions. It walks over the list of tokens trying to find the
last non-nested \monoespaco{or} operator. Then, it applies the
operator over the results of the two subexpressions that delimits
it. If there ire no \monoespaco{or} operators, then the entire
expression is evaluated as a secondary boolean operator:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_OR){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_secondary(mf, cx, begin_expression, end_expression,
                                  result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_tertiary(mf, cx, begin_expression,
                             before_last_operator, &a))
      return false;
    if(!eval_boolean_secondary(mf, cx, last_operator -> next,
                               end_expression, &b))
      return false;
    result -> value =  (a.value || b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.3. Operator AND}

The boolean operator AND is the sole boolean secondary operator. The
grammar for secondary boolean expressions is:

\alinhaverbatim
<Boolean Secondary> -> <Boolean Secondary> and <Boolean Primary> |
                       <Boolean Primary>
\alinhanormal

The token \monoespaco{and} was aleready defined. We used it to
separate two control points when describing a path curve.

The function that evaluates secondary boolean operators is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result);
@
\fimcodigo

The function works exactly as the tertiary function that evaluates the
operator OR. The difference is that it works searching for AND
operators and applying the leftmost AND operator over the delimiting
subexpressions. If there are no AND operators, the entire expression
is evaluated as a primary boolean expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_AND){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_primary(mf, cx, begin_expression, end_expression,
                                result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_secondary(mf, cx, begin_expression,
                               before_last_operator, &a))
      return false;
    if(!eval_boolean_primary(mf, cx, last_operator -> next,
                             end_expression, &b))
      return false;
    result -> value = (a.value && b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.4. Boolean Literals, Variables, NOT and Simple Predicates}

The grammar for boolean primary expressions is:

\alinhaverbatim
<Boolean Primary> -> <Boolean Variable> | true | false |
                     cycle <Path Primary> | odd <Numeric Primary> |
                     not <Boolean Primary> |
                     ( <Boolean Expression> )
\alinhanormal

Most of these expressions have obvious meanings. A boolean variable is
evaluated to what vaue it has stored. The values \monoespaco{true}
and \monoespaco{false} evaluated to the boolean value correspinding to
their names. The \monoespaco{not} operator is the boolean
NOT. Parenthesis can be used to change the order of evaluation for
operators. The token \monoespaco{odd} checks if the following numeric
is odd after rounding it to the nearest
integer. And \monoespaco{cycle} checks if a path is cyclic.

The following new tokens are defined:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_TRUE,                    // O token simblico 'true'
TYPE_FALSE,                   // O token simblico 'false'
TYPE_ODD,                     // O token simblico 'odd'
TYPE_NOT,                     // O token simblico 'not'
@
\fimcodigo

Each of their names should be added to the list of reserved kyewords:

\iniciocodigo
@<List of Keywords@>+=
"true", "false", "odd", "not",
@
\fimcodigo

The function that evaluates boolean primaries is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result);
@
\fimcodigo

In boolean primary expressions, it is possible to determine which
grammar rule to follow just checking the first token. Therefore, this
function just checks the first token and apply the correct rule:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result){
  switch(begin_expression -> type){
    case TYPE_SYMBOLIC: // Varivel
      struct boolean_variable *var;
      var = ((struct symbolic_token *) begin_expression) -> var;
      if(var -> value == -1){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
                "'%s'.\n", mf -> file, begin_expression -> line,
                ((struct symbolic_token *) begin_expression) -> value);
#endif
        return false;
      }
      result -> value = var -> value;
      return true;
    break;
    case TYPE_TRUE: // Verdadeiro
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        return false;
      }
      result -> value = 1;
      return true;
    break;
    case TYPE_FALSE: // Falso
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        return false;
      }
      result -> value = 0;
      return true;
    break;
    case TYPE_CYCLE: // 'cycle'
      struct path_variable path;
      if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                            &path))
        return false;
      result -> value = path.cyclic;
      if(temporary_free != NULL)
        path_recursive_free(temporary_free, &path, false);
      return true;
    break;
    case TYPE_ODD: // 'odd'
      struct numeric_variable num;
      if(!eval_numeric_primary(mf, cx, begin_expression -> next, end_expression,
                               &num))
        return false;
      result -> value = (((int) round(num.value)) % 2);
      return true;
    break;
    case TYPE_NOT: // 'not'
      struct boolean_variable b;
      if(!eval_boolean_primary(mf, cx, begin_expression -> next, end_expression,
                              &b))
        return false;
      result -> value = !(b.value);
      return true;
    break;
    case TYPE_OPEN_PARENTHESIS: // '('
      if(end_expression -> type != TYPE_CLOSE_PARENTHESIS){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
        return false;
      }
      struct generic_token *last_token = begin_expression;
      while(last_token -> next != end_expression)
        last_token = last_token -> next;
      return eval_boolean_expression(mf, cx, begin_expression -> next,
                                     last_token, result);
    break;
    default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo


\subsecao{8.8. Identifying Expression Types}

Several times we have an expression and want to identify its type. For
example, in boolean expressions we can compare values from numeric,
pair, transform and boolean expressions. In a numeric expression we
can use \monoespaco{length} operator over numeric or pair
expressions. We can multiply between two numeric expressions or
between a numeric and a pair expression. Operators
like \monoespaco{xpart} works in pairs and transforms.

Notice that in none of the cases above we expect to identify a path,
picture or pen expression. Therefore, we will ignore these expressions
when trying to identiy the type.

Identify the type of some expression can be complex. But the most
common cases are simple and can be evaluated fast. We will use
different functions to evaluate the type for primary, secondary and
tertiary expressions:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr);
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr);
@
\fimcodigo

To identify primary expressions, first we can treat the simplest cases
(the expression have a single token) and then we deal with the more
complex cases. The rules that allow us to identify the types are:

1) A variable is an expression with the variable type.

2) The expression is boolean if it is the single
 token \monoespaco{true} or \monoespaco{false}. Or if it begins
 with \monoespaco{cycle}, \monoespaco{odd} or
\monoespaco{not}.

3) The expression is a pair if it begins
 with \monoespaco{point}, \monoespaco{precontrol}
 or \monoespaco{postcontrol}. Or if in the expression we have
 a \monoespaco{[}. And also if it begins with a numeric token and have
 parenthesis or the beginning of a primary pair.

4) The expresison is numeric if it has a ingle numeric token or the
token \monoespaco{normaldeviate}. Or if it is a numeric token followed
by \monoespaco{/}. Or if it begins
with \monoespaco{length}, \monoespaco{xpart}, \monoespaco{ypart},
\monoespaco{xxpart},
\monoespaco{xypart}, \monoespaco{yxpart}, \monoespaco{yypart}, \monoespaco{angle},
\monoespaco{sqrt}, \monoespaco{sind}, \monoespaco{cosd}, \monoespaco{log},
\monoespaco{mexp}, \monoespaco{floor}, \monoespaco{uniformdeviate}.

5) If we have a \monoespaco{+} ou \monoespaco{-}, we discover the type
ignoring this first token and checking the type of the remaining
expression.

6) If we begin and end with parenthesis, and have no comma, we should
evaluate the type of the tertiary expression inside the
parenthesis. If we have a single comma, we have a pair. If we have
five commas, we have a transform.

7) In the other cases, we have an unknown expression and some error
may be occurred.

The code that tries to encompass these rules (but not in the above
order) is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_SYMBOLIC){ // Case 1
      struct variable *var = (struct variable *)
                               ((struct symbolic_token *) begin_expr) -> var;
      return var -> type;
    }
    if(begin_expr -> type == TYPE_TRUE || begin_expr -> type == TYPE_FALSE ||
       begin_expr -> type == TYPE_NOT) // Case 2
      return TYPE_T_BOOLEAN;
    if(begin_expr -> type == TYPE_NUMERIC ||
       begin_expr -> type == TYPE_NORMALDEVIATE) // Case 4
      return TYPE_T_NUMERIC;
    else
      return -1;
  }
  else{
    if(begin_expr -> type == TYPE_CYCLE || begin_expr -> type == TYPE_ODD ||
       begin_expr -> type == TYPE_NOT) // Case 2
      return TYPE_T_BOOLEAN;
    // Pair expression (case 3):
    if(begin_expr -> type == TYPE_POINT ||
       begin_expr -> type == TYPE_PRECONTROL ||
       begin_expr -> type == TYPE_POSTCONTROL ||
       begin_expr -> type == TYPE_BOT || begin_expr -> type == TYPE_TOP ||
       begin_expr -> type == TYPE_LFT || begin_expr -> type == TYPE_RT)
      return TYPE_T_PAIR;    
    // Numeric expression (Case 4):
    if(begin_expr -> type == TYPE_LENGTH || begin_expr -> type == TYPE_XPART ||
       begin_expr -> type == TYPE_YPART || begin_expr -> type == TYPE_ANGLE ||
       begin_expr -> type == TYPE_XXPART || begin_expr -> type == TYPE_FLOOR ||
       begin_expr -> type == TYPE_XYPART || begin_expr -> type == TYPE_SIND ||
       begin_expr -> type == TYPE_YXPART || begin_expr -> type == TYPE_SQRT ||
       begin_expr -> type == TYPE_YYPART || begin_expr -> type == TYPE_LOG ||
       begin_expr -> type == TYPE_COSD ||   begin_expr -> type == TYPE_EXP ||
       begin_expr -> type == TYPE_UNIFORMDEVIATE) // Caso 4
      return TYPE_T_NUMERIC;
    // Case 5:
    if(begin_expr -> type == TYPE_SUM || begin_expr -> type == TYPE_SUBTRACT)
      return get_primary_expression_type(mf, cx, begin_expr -> next, end_expr);
    // Numeric token, it could be a numeric or pair expression:
    if(begin_expr -> type == TYPE_NUMERIC){
      struct generic_token *t = begin_expr;
      while(t != NULL && t != end_expr){
        if(t -> type == TYPE_OPEN_BRACKETS || t -> type == TYPE_PRECONTROL ||
           t -> type == TYPE_OPEN_PARENTHESIS || t -> type == TYPE_POINT ||
           t -> type == TYPE_POSTCONTROL)
          return TYPE_T_PAIR;
        t = t -> next;
      }
      return TYPE_T_NUMERIC;
    }
    
    // The remaining cases not encompassed by the more general rules 
    // are expressions that begins with parenthesis but do not end
    // with them: (1+1)[p1, p1] and also: normaldeviate[p1, p2]
    if((begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
        end_expr -> type != TYPE_CLOSE_PARENTHESIS) ||
       begin_expr -> type == TYPE_NORMALDEVIATE)
      return TYPE_T_PAIR;
    if(begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
       end_expr -> type == TYPE_CLOSE_PARENTHESIS &&
       begin_expr -> next != end_expr){
      DECLARE_NESTING_CONTROL();
      int number_of_commas = 0;
      struct generic_token *t = begin_expr -> next;
      while(t != NULL && t -> next != end_expr){
        COUNT_NESTING(t);
        if(IS_NOT_NESTED() && t -> type == TYPE_COMMA)
          number_of_commas ++;
        t = t -> next;
      }
      if(number_of_commas == 0)
        return get_tertiary_expression_type(mf, cx, begin_expr -> next, t);
      else if(number_of_commas == 1)
        return TYPE_T_PAIR;
      else if(number_of_commas == 5)
        return TYPE_T_TRANSFORM;
    }
    return -1;
  }
}
@
\fimcodigo

Now the secondary expressions. The rules that we will use are:

1) If we have a single token, we evaluate everything as a primary
expression.

2) If we have \monoespaco{and}, the expression is boolean.

3) If we have a transformer (\monoespaco{transformed}, \monoespaco{rotated},
\monoespaco{scaled}, \monoespaco{shifted}, \monoespaco{slanted},
\monoespaco{xscaled}, \monoespaco{yscaled}, \monoespaco{zscaled}), we ignore it
and all the tokens after it and re-evaluate the expression. In this case
we will have a transform or a pair.

4) In case of multiplications and divisions, the most important is the
operator more at the right. In the case of multiplication, if one of
the operands is a pair, then we have a pair expression. If both are
numeric, we have a numeric expression. In the case of division, the
left operand type is the operation type. A token \monoespaco{/} is a
division when it is not delimited by numeric tokens. If it is, then we
have a fraction, not a division operator. Except when one of the
tokens is already part of some fraction: in this case, we have a
division operator. Therefore, 1/3 is a fraction, not a division. But
1/3/1/3 is a single division that divide two fractions.

5) In the other cases, if we cannot identify the type, we try again
interpreting the entire expression as a primary expression.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  struct generic_token *last_fraction = NULL;
  struct generic_token *before_last_op = NULL, *prev_prev = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_AND)
        return TYPE_T_BOOLEAN;
      if(t -> type == TYPE_TRANSFORMED || t -> type == TYPE_ROTATED ||
         t -> type == TYPE_SCALED || t -> type == TYPE_SHIFTED ||
         t -> type == TYPE_SLANTED || t -> type == TYPE_XSCALED ||
         t -> type == TYPE_YSCALED || t -> type == TYPE_ZSCALED){
        if(prev == NULL)
          return -1;
        return get_secondary_expression_type(mf, cx, begin_expr, prev);
      }
      if(t -> type == TYPE_MULTIPLICATION || t -> type == TYPE_DIVISION){
        if(t -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
           t != end_expr &&
           ((struct generic_token *) t -> next) -> type != TYPE_NUMERIC &&
           last_fraction != prev_prev)
          last_fraction = t;
        else{
          last_op = t;
          before_last_op = prev;
        }
      }
    }
    prev_prev = prev;
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL){
    int s = get_primary_expression_type(mf, cx, last_op -> next, end_expr) +
            get_secondary_expression_type(mf, cx, begin_expr, before_last_op);
    if(s == 2 * TYPE_T_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(s == TYPE_T_NUMERIC + TYPE_T_PAIR)
      return TYPE_T_PAIR;
    else return -1;
  }
  else return get_primary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

Finally, the tertiary expressions. In this case, the rules are:

1) If we have a single token, evaluate its type as a primary expression.

2) If we have an \monoespaco{or} or a relation
(\monoespaco{<}, \monoespaco{<=}, \monoespaco{>}, \monoespaco{>=},
\monoespaco{=}, \monoespaco{<>}), then it is a boolean expression.
Technically, the relations are not tertiary expressions, but
quarternary ones. But we can deal with them here, as we are not
evaluating the expression value, where it is mandatory to follow
precedence rules.

3) If we have a pyhtagoric sum or subtraction,
(\monoespaco{++}, \monoespaco{+-+}), it is a numeric expression.

4) In the case of a sum or subtraction, the expression type is the
same that its operands type.

5) I other cases, we try again to check the type, but interpreting the
expression as a secondary expression.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_OR || t -> type == TYPE_LT ||
           t -> type == TYPE_GT || t -> type == TYPE_GEQ ||
           t -> type == TYPE_LEQ || t -> type == TYPE_EQUAL ||
           t -> type == TYPE_NEQ)
        return TYPE_T_BOOLEAN;
      if(t -> type == TYPE_PYTHAGOREAN_SUM ||
         t -> type == TYPE_PYTHAGOREAN_SUBTRACT)
        return TYPE_T_NUMERIC;
      if(IS_VALID_SUM_OR_SUB(prev, t) && t != end_expr)
        last_op = t;
    }
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL)
    return get_secondary_expression_type(mf, cx, last_op -> next, end_expr);
  else return get_secondary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

\secao{9. Compound Statements: Conditional Statement}

A conditional statement is a \monoespaco{if}, it ensures that some
piece of code will be evaluated only if some conditions are true. The
complete gramamr for these statements is:

\alinhaverbatim
<Conditional Block> -> if <Boolean Expression> :
                          <List of Statements>
                         <Alternatives>
                       fi
<Alternativas> -> <Empty> |
                  elseif <Boolean Expression>:
                    <List of Statements>
                  <Alternatives> |
                  else: <List of Statements>
\alinhanormal

We need to declare two new kinds of tokens:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_ELSEIF,  // Symbolic token 'elseif'
TYPE_ELSE,    // Symbolic token 'else'
TYPE_COLON,   // Symbolic token ':'
@
\fimcodigo

Which should be associated with the following reserved words:

\iniciocodigo
@<List of Keywords@>+=
"elseif", "else", ":",
@
\fimcodigo

In Section 6, we introduced the first compound statement: the one that
begins with \monoespaco{begingroup} and ends
with \monoespaco{endgroup}. The conditional statement
using \monoespaco{if} is also a compound statement, which can contain
other inner statements.

Remember thar the code is first read in teh
function \monoespaco{eval\_list\_of\_statement}, which splits the
tokens using semicolons as delimiters and give each part to the
function \monoespaco{eval\_statement}. This second function evaluates
the given code, but it can also change the pointer that delimits the
last evaluated token, which is used to determine the next tokens to be
evaluated. It's in this function that our \monoespaco{if} will be
evaluated.

Like in the \monoespaco{begingroup} case, seen in Section 6, when we
find a \monoespaco{if} in the first position in the list of tokens to
be evalueated, we increase the nesting level and correct the position
of the end pointer, ensuring that the next tokens to be evaluated will
be the right ones. Here we do the same, but the logic to choose the
right pointer is more complex and involves evaluating boolean
expressions.

Given a \monoespaco{if}, we first evaluate the boolean expression next
to it. If true, the position for the pointer will be the colon after
the expression. Otherwise, we walk over the tokens trying to find
a \monoespaco{elseif}, \monoespaco{else} or \monoespaco{fi}. In the
first case, we treat like we did with the \monoespaco{if}, checking
and evaluating the boolean expression next to it to decide if we place
the pointer in its colon. In the second case, we place the pointer in
the colon next to \monoespaco{else}. And in the last case, we found
the end of the compound statement and no true boolean expression. We
place the pointer in the \monoespaco{fi}, and doing this, we skip all
the statements inside the \monoespaco{if}.

However, the code that we ignore and do not evaluate because it is
inside a block with a false boolean expression in a conditional
statement also need to be checked for some critical syntax errors. For
example, we could have tokens \monoespaco{endgroup}
or \monoespaco{endchar} inside a \monoespaco{if} that were not
preceded by a \monoespaco{begingroup} or \monoespaco{beginchar}. These
errors could indicate that the user wrote an
incorrect \monoespaco{if}, perhaps placing the \monoespaco{fi} in the
wrong place. Therefore, these errors should not be ignorated. While we
walk over the non-evaluated tokens in a \monoespaco{if}, we still
would run code to update the nesting level when we find tokens
like \monoespaco{begingroup}, \monoespaco{if}, \monoespaco{beginchar}
and their corresponding closing tokens.

The code that evaluates our \monoespaco{if} statement is:

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_IF){
  struct generic_token *begin_bool, *end_bool;
  struct boolean_variable b;
  int current_nesting_level;
  // Beginning the nesting
  begin_nesting_level(mf, cx, begin);
  current_nesting_level = cx -> nesting_level;
  // Delimiting boolean expression
  begin_bool = begin -> next;
  end_bool = begin_bool;
  while(end_bool != *end && end_bool -> next -> type != TYPE_COLON)
    end_bool = end_bool -> next;
  if(end_bool == *end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Error delimiting boolean "
                    "condition.\n", mf -> file, end_bool -> line);
#endif
    return false;
  }
  // Evaluating boolean expression:
  if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
    return false;
  if(b.value == 1){ // True: Code inside this 'if' must be evaluated
    *end = end_bool -> next;
    return true;
  }
  else{ // False: We skip code in this 'if'
    struct generic_token *t = end_bool -> next;
    while(t -> next != NULL){
      if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
        // We found the 'fi' corresponding to this 'if'
        if(!end_nesting_level(mf, cx, t))
          return false;
        *end = t;
        return true;
      }
      else if(t -> type == TYPE_ELSE &&
              cx -> nesting_level == current_nesting_level){
        // We found the 'else' corresponding to this 'if'
        *end = t -> next;
        if((*end) -> type != TYPE_COLON){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Expected ':' after "
                  "'else'.\n", mf -> file,
                  (*end) -> line);
#endif
          return false;
        }
        return true;
      }
      else if(t -> type == TYPE_ELSEIF &&
              cx -> nesting_level == current_nesting_level){
        // We found the 'elseif' corresponding to our 'if'
        begin_bool = t -> next;
        end_bool = begin_bool;
        while(end_bool != *end && end_bool -> next -> type != TYPE_COLON)
          end_bool = end_bool -> next;
        if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
          return false;
        if(b.value == 1){ // True: Code in 'elseif' must be evaluated
          *end = end_bool -> next;
          return true;
        }
      }
      // Other tokens that change our nesting level:
      else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
              t -> type == TYPE_BEGINCHAR)
        begin_nesting_level(mf, cx, t);
      else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
              t -> type == TYPE_ENDCHAR)
        if(!end_nesting_level(mf, cx, t))
          return false;
      t = t -> next;
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'if' statement.\n", mf -> file,
          begin -> line);
#endif  
  return false;
}
@
\fimcodigo

Find the correct code to be evaluated is the above code
responsability. If we find a \monoespaco{elseif} or \monoespaco{else}
in the beginning of a new statement, one of two things is happening:
we either are dealing with a syntax error, where these tokens do not
have a corresponding \monoespaco{if}, or we are inside
some \monoespaco{if} where we already evaluated the right conditional
code and found the other conditional expression with code that should
not be evaluated. In the second case, we should ignore the following
tokens until we find the \monoespaco{fi} corresponding to
our \monoespaco{f}:

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_ELSEIF || begin -> type == TYPE_ELSE){
  int current_nesting_level;
  struct generic_token *t;
  if(cx -> end_token_stack == NULL ||
     cx -> end_token_stack -> type != TYPE_FI){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Token 'elseif' or 'else' should "
          "have a corresponding 'if'.\n", mf -> file,
          begin -> line);
#endif  
    return false;
  }
  current_nesting_level = cx -> nesting_level;
  t = begin;
  while(t != NULL){
    if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
      // We found the 'fi' corresponding to our 'if'
      if(!end_nesting_level(mf, cx, t))
        return false;
      *end = t;
      return true;
    }
    else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
            t -> type == TYPE_BEGINCHAR)
      begin_nesting_level(mf, cx, t);
    else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
            t -> type == TYPE_ENDCHAR)
      if(!end_nesting_level(mf, cx, t))
        return false;
    t = t -> next;
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'else' or 'elseif' statement.\n", mf -> file,
          begin -> line);
#endif
  return false;
}
@
\fimcodigo

Finally, we also can find a \monoespaco{fi} in the beginning of a new
statement to be evaluated. In this case, we lower the nesting level
and mark as the end of our evaluated tokens this \monoespaco{fi}
token:

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_FI){
  if(!end_nesting_level(mf, cx, begin))
    return false;
  *end = begin;
  return true;
}
@
\fimcodigo

\secao{10. The \monoespaco{pickup} Command}

Npw we can begin defining our first command. The syntax for
command \monoespaco{pickup} is:

\alinhaverbatim
<Command> -> <'pickup' Command>
<'pickup' Command> -> pickup <Pen Variable, 'nullpen' or 'pencircle'>
                             <Optional Transformers>
<Pen Variable or 'nullpen'> -> nullpen | pencircle | <Pen Variable>
<Optional Transformers> -> <Empty> |
                           <Transformer><Optional Transformers>
\alinhanormal

The command requires a new token and reserver keyword:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_PICKUP,  // Symbolic token 'pickup'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"pickup",
@
\fimcodigo

What this command does is store a new value in the
variable \monoespaco{currentpen}, which we will use to make drawings
(which we will define in the following Section).

\subsecao{10.1. Extremity Points in Pens}

When we pick a pen, we will store internally 4 values related to the
pen. Two of them will store the biggest and smallest values in the
axis $x$ when the pen is rendered and the two others will store the
smallest and biggest values in the axis $y$. Storing these values will
be useful to better adjust the points that we will draw. For example,
we could want to draw with our pen the nearest possible to the left
lower corner of the image, without the pen drawing outside the image
area. Such control requires to know the pen size. Because of this, we
will store globally such information
in \monoespaco{pen\_lft}, \monoespaco{pen\_rt}, \monoespaco{pen\_top}
e \monoespaco{pen\_bot}. We store globally in \monoespaco{struct
metafont} because \monoespaco{currentpen} has a global scope:

\iniciocodigo
@<Attributes (struct metafont)@>+=
float pen_lft, pen_rt, pen_top, pen_bot;
@
\fimcodigo

These values begin as zero, because \monoespaco{currentpen} begins as
a \monoespaco{nullpen}:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> pen_lft = mf -> pen_rt = mf -> pen_top = mf -> pen_bot = 0.0;
@
\fimcodigo

An operation very common in this Section will be update these 4
variables in a pen when we are preparing their points. Assume that we
will be able to iterate over the points in their perimeter. For each
point, we will check if it is at the left of \monoespaco{pen\_lft}, at
the right of \monoespaco{pen\_rt}, above \monoespaco{pen\_top} or
below \monoespaco{pen\_bot}. In these cases, we need to update the
information about the extremity points in the pen.

To reduce our code size, we will create the macro below that will
declare the temporary variables where we store the biggest and
smallest value in axis $x$ and $y$ that we found in a pen perimeter:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define DECLARE_PEN_EXTREMITIES() float _max_x = -INFINITY, _min_x = INFINITY,\
                                  _max_y = -INFINITY, _min_y = INFINITY;
@
\fimcodigo

Given a new perimeter point, we will use the macro below to get its
coordinate $(x, y)$, multiply by its transform matrix and check if we
found a point with the biggest or smallest value in axis $x$ or $y$:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define CHECK_PEN_EXTREMITIES(x, y, matrix) {\
   float _x, _y;\
   _x = LINEAR_TRANSFORM_X(x, y, matrix);\
   _y = LINEAR_TRANSFORM_Y(x, y, matrix);\
   if(_x < _min_x) _min_x = _x;\
   if(_x > _max_x) _max_x = _x;\
   if(_y < _min_y) _min_y = _y;\
   if(_y > _max_y) _max_y = _y;\
  }
// If the matrix is the identity, we can use this:
#define CHECK_PEN_EXTREMITIES_I(x, y) {\
   if(x < _min_x) _min_x = x;\
   if(x > _max_x) _max_x = x;\
   if(y < _min_y) _min_y = y;\
   if(y > _max_y) _max_y = y;\
  }

@
\fimcodigo

After checking all the points in the pen perimeter, we can update
which are its extremity coordinates:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define UPDATE_PEN_EXTREMITIES() {\
  mf -> pen_lft = _min_x;\
  mf -> pen_rt = _max_x;\
  mf -> pen_top = _max_y;\
  mf -> pen_bot = _min_y;\
}
@
\fimcodigo

The previous macros is enough if we will iterate over each point in
the pen perimeter. Doing this, we can
call \monoespaco{CHECK\_PEN\_EXTREMITIES} in all points and then we
get who has the biggest and smallest value in each axis. But in cases
when we will not iterate over each point, we will need more functions
to deduce their values. For example, if we are using
a \monoespaco{pickup} command over \monoespaco{pencircle} with a
linear transform stored in a matrix. The function below can be used to
get this pen extremity points:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix);
@
\fimcodigo

A default \monoespaco{pencircle}, with no linear transform is a
circular pen with radius $1/2$. Which means that every pen coordinate
$(x, y)$ follows the formula:

$$
x^2+y^2= 0.25
$$

Or, equivalently:

$$
x=\pm\sqrt{0.25-y^2}
$$

$$
y=\pm\sqrt{0.25-x^2}
$$

Given a linear transform defined by matrix $N$, we get new values
$(x,y)$ using th formulas:

$$
f_x(x) = M_{11}x \pm M_{21}\sqrt{0.25-x^2} + M_{31}
$$

$$
f_y(y) = M_{22}y \pm M_{12}\sqrt{0.25-y^2} + M_{32}
$$

When $M_{11}=0$, the most extreme points in axis $x$ will be $(-0.5,
0)$ and $(0.5, 0)$ after passing by the linear transform defined by
our matrix. When $M_{21}=0$, the most extreme points in axis $x$ will
be $(0, -0.5)$ and $(0, 0.5)$ after applying the linear transform. The
same logic applies for the axis $y$ if $M_{22}=0$ or $M_{12}=0$. In
all these cases, we get the biggest and smallest values maximizing or
minimizing a single coordinate.

For all other cases, finding the maximum and minimum values in these
functions requires getting the derivative of the function and
equalizing to zero:

$$
f_x'(x)=M_{11} \pm (M_{21}x)/(\sqrt{0.25-x^2})=0
$$

$$
f_y'(y)=M_{22} \pm (M_{12}y)/(\sqrt{0.25-y^2})=0
$$

As there is no closed formula to compute the soluction directly, we
need to employ an interactive method to find the solution. We will
first try the Newton Method. To use this method, we need to compute
the second order derivative for the functions:

$$
f_x''(x)= \pm (M_{21}\sqrt{0.25-x^2}+(M_{21}x^2)/(\sqrt{0.25-x^2}))
$$

$$
f_y''(y)= \pm (M_{12}\sqrt{0.25-x^2}+(M_{12}x^2)/(\sqrt{0.25-x^2}))
$$

And using these values, by the Newton method, if we have a good guess
$x_n$ or $y_n$ for the solution, we can find an even better guess
$x_{n+1}$ or $y_{n+1}$ computing:

$$
x_{n+1} = x_{n} - (f'_x(x_n)/f''_x(x_n))
$$

$$
y_{n+1} = y_{n} - (f'_y(y_n)/f''_y(y_n))
$$

The problem of Newton Method in this function is that it is defined
only in the interval between -0.5 and +0.5. If the value that we are
searching is near the extremity, it is possible that we step outside
the function Domain. If this happens, we will change to another
method. We will use the slowerBissection Method. For this method,
notice that $f'(-0.5)$ and $f'(+0.5)$ has opposite signals. The root
of this functions is in this interval. Next, we make the interval
slower computing $f'$ in the middle of the interval and checking the
signal. And we repeat until we find the value or the interval becames
too small.

After reviewing the theory, we finally can write the function that
gets the extremity points for \monoespaco{pencircle}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix){
  DECLARE_PEN_EXTREMITIES();
  int i, index[4] = {0, 3, 4, 1};
  for(i = 0; i < 2; i ++){ // i=0 computes axis x, i=1 computes axis y
    // Primeiro os casos mais simples:
    if((i == 0 && matrix[3] == 0.0) ||
       (i == 1 && matrix[4] == 0.0)){
      CHECK_PEN_EXTREMITIES(-0.5, 0.0, matrix);
      CHECK_PEN_EXTREMITIES(0.5, 0.0, matrix);
    }
    else if((i == 0 && matrix[0] == 0.0) ||
            (i == 1 && matrix[1] == 0.0)){
      CHECK_PEN_EXTREMITIES(0.0, 0.5, matrix);
      CHECK_PEN_EXTREMITIES(0.0, -0.5, matrix);
    }
    else{
      // Newton Method
      float x0 = INFINITY, x1 = 0.0;
      do{
        x0 = x1;
        x1 = x0 - ((matrix[index[2*i]]+(matrix[index[2*i+1]]*
                  x0/sqrt(0.25-x0*x0))) /
             (matrix[index[2*i+1]]*sqrt(0.25-x0*x0)+
                  ((matrix[index[2*i+1]]*x0*x0)/
             (sqrt(0.25-x0*x0)))));
        if(x1 <= -0.5 || x1 >= 0.5){
          // Failed, using Bissection Method
          float y1;
          x0 = -0.5;
          x1 = 0.5;
          y1 = matrix[3-i*2] * sqrt(0.25-x1*x1) +
               (matrix[index[3-i*2]]*x1/sqrt(0.25-x1*x1));
          while(x0 != x1){
            float x2 = (x0+x1)/2;
            float y2 = matrix[index[3-i*2]] * sqrt(0.25-x2*x2) +
                       (matrix[index[3-i*2]]*x2/sqrt(0.25-x2*x2));
            if(y2 == 0.0 || x0 == x2 || x1 == x2)
              x0 = x1 = x2;
            else if(y2 > 0){
              if(y1 > 0)
                x1 = x2;
              else
                x0 = x2;
            }
            else{
              if(y1 > 0)
                x0 = x2;
              else
                x1 = x2;
            } 
          }
        }
      } while(x0 != x1);
      if(i == 0){
        CHECK_PEN_EXTREMITIES(x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(x0, -sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, -sqrt(0.25-x0*x0), matrix);
      }
      else{
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), -x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), -x0, matrix);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo

We also could want to find the extremity points in a pen defined as a
list of Bzier Curves:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix);
@
\fimcodigo

Curiously, in this case, the formulas are simpler. A cubic Bzier
Curve like the ones that we use have the following formula, with $t$
ranging between 0 and 1 and with $z_1$, $z_4$ being the extremity
points and with $z_2$ and $z_3$ being the control points:

$$
z(t) = (1-t)^3z_1+3(1-t)^2tz_2+3(1-t)t^2z_3+t^3z_4
$$

The function derivative is:

$$
z'(t) = (-3z_1+9z_2-9z_3+3z_4)t^2+(6z_1-12z_2+6z_3)t+(-3z_1+3z_2)
$$

Discovering in which points we have a zero requires just using
Bhaskara formula.

Finding the extremity points will be done iterating over the extremity
points and computing the roots of $z'(t)$. If we find a root between 0
and 1, we check the value if it is an extremity point. The points
$z_1, z_2, z_3, z_4$ that we use are the stored ones in the pen, after
applying the linear transform of the corresponding matrix:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix){
  int i, j, length = p -> length;
  DECLARE_PEN_EXTREMITIES();
  for(i = 0; i < length; i ++){
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    CHECK_PEN_EXTREMITIES(p -> points[i].point.x, p -> points[i].point.y, matrix);
    x0 = LINEAR_TRANSFORM_X(p -> points[i].point.x, p -> points[i].point.y, matrix);
    y0 = LINEAR_TRANSFORM_Y(p -> points[i].point.x, p -> points[i].point.y, matrix);
    u_x = LINEAR_TRANSFORM_X(p -> points[i].point.u_x, p -> points[i].point.u_y, matrix);
    u_y = LINEAR_TRANSFORM_Y(p -> points[i].point.u_x, p -> points[i].point.u_y, matrix);
    v_x = LINEAR_TRANSFORM_X(p -> points[i].point.v_x, p -> points[i].point.v_y, matrix);
    v_y = LINEAR_TRANSFORM_Y(p -> points[i].point.v_x, p -> points[i].point.v_y, matrix);    
    x1 = LINEAR_TRANSFORM_X(p -> points[(i+1)%length].point.x, p -> points[i].point.y,
                            matrix);
    y1 = LINEAR_TRANSFORM_Y(p -> points[(i+1)%length].point.y, p -> points[i].point.y,
                            matrix);
    // Bhaskara Formula (axis x)
    float a, b, c, deltah, t;
    a = (-3*x0+9*u_x-9*v_x+3*x1);
    b = (6*x0-12*u_x+6*v_x);
    c = (-3*x0+3*u_x);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(deltah)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
    // Bhaskara Formula (axis y)
    a = (-3*y0+9*u_y-9*v_y+3*y1);
    b = (6*y0-12*u_y+6*v_y);
    c = (-3*y0+3*u_y);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(b * b - 4 * a * c)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo


\subsecao{10.2. Triangulation}

Now let's deal with the triangulation code. Video cards and OpenGL
works drawing triangles in the screen. Therefore, each pen should be
transformed in a set of triangles before drawing them. This was
mentioned in Subsection 7.5. about pen variables. But the code for
triangulation still needs to be defined.

To recap, these are the relevant variables stored inside
a \monoespaco{struct pen\_variable} that we will use during
triangulation:

* \monoespaco{struct path\_variable *format}: A cyclic path with the
  pen shape.

* \monoespaco{GLuint gl\_vbo}: References que vertices stored in the
  video card. Will store 0 if the pen was not triangulated.

* \monoespaco{float triang\_resolution}: An internal measure of the
 detail level in our triangulation. Relevant to know if we need to
 retriangulate to generate a more precise representation if our pen has
 curves and now will be rendered in a different size.


* \monoespaco{int flags}: Stores information if the above shape is
  null, is concave or convex, it is a polycon or a shape with curves,
  if it is a square or a circle. Besides these flags that were already
  presented,we will also define and use here two other flags:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define FLAG_ORIENTATION      32
#define FLAG_COUNTERCLOCKWISE 64
@
\fimcodigo

The second flag above will store if we are storing the shape of the
pen in the counterclockwise order (if the flag is set) or in the
clockwise order (if the flag is not set). But this information is
initialized and is reliable only if the first flag above is set.

We will use the following function to check the pen orientation:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen);
@
\fimcodigo

The function works checking if we already have the information stored
in the flag and returning it if so. Otherwise, it tries to discover
the orientation. This is done searching for the vertex with the
smallest $y$ coordinate (and biggest $x$ in case of tie) Let $A$ be
this vertex, $P$ the previous vertex and $N$ the next. The signal of
the scalar product between $AP$ and $AN$ inform the orientation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen){
  int i, index = 0;
  int size = pen -> format -> length;
  float smallest_y = INFINITY, biggest_x = -INFINITY;
  if(pen -> flags & FLAG_ORIENTATION)
    return (pen -> flags & FLAG_COUNTERCLOCKWISE);
  if(pen -> format == NULL || size <= 0)
    return true;
  for(i = 0; i < size; i ++){
    if(pen -> format -> points[i].point.y < smallest_y ||
       (pen -> format -> points[i].point.y == smallest_y &&
        pen -> format -> points[i].point.y > biggest_x)){
      smallest_y = pen -> format -> points[i].point.y;
      biggest_x = pen -> format -> points[i].point.x;
      index = i;
    }
  }
  {
    int n = (index - 1) % size, p = (index + 1) % size;
    if(n < 0)
      n += size;
    if(p < 0)
      p += size;
    while(pen -> format -> points[index].point.x ==
                                    pen -> format -> points[n].point.x &&
          pen -> format -> points[index].point.y ==
                                    pen -> format -> points[n].point.y)
      n = (n + 1) % size;
    while(pen -> format -> points[index].point.x ==
                                    pen -> format -> points[p].point.x &&
          pen -> format -> points[index].point.y ==
                                       pen -> format -> points[p].point.y)
      p = (p - 1) % size;
    float ap_x = pen -> format -> points[p].point.x -
                 pen -> format -> points[index].point.x;
    float ap_y = pen -> format -> points[p].point.y -
                 pen -> format -> points[index].point.y;
    float an_x = pen -> format -> points[n].point.x -
                 pen -> format -> points[index].point.x;
    float an_y = pen -> format -> points[n].point.y -
                 pen -> format -> points[index].point.y;
    float prod = ap_x * an_x + ap_y * an_y;
    pen -> flags += FLAG_ORIENTATION;
    pen -> flags += FLAG_COUNTERCLOCKWISE * (prod > 0);
    return (prod > 0);
  }
}
@
\fimcodigo

The function that will perform the triangulation is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix){
  @<Triangulation: Null Pen@>
  @<Triangulation: Square Pen@>
  @<Triangulation: Convex Polygon@>
  @<Triangulation: Circle@>
  @<Triangulation: Convex Shape@>
  @<Triangulation: Concave Shape@>
}
@
\fimcodigo

The simplest case is when we have a null pen created
by \monoespaco{nullpen}. These pens never will draw anything, so they
do not need to be triangulated. They are considered points at the $(0,
0)$ coordinate, but a transform matrix can shift the point to some
other position. We deal with this simplest case below:

\iniciocodigo
@<Triangulation: Null Pen@>=
if((pen -> flags & FLAG_NULL)){
  pen -> indices = 0;
  DECLARE_PEN_EXTREMITIES();
  CHECK_PEN_EXTREMITIES(0, 0, transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

The next case is when we need to triangulate a square pen. This kind
of pen do not need to be triangulated because during initialization we
will create a single triangulation that will be used for all square
pen. The vertices will be stored here:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static GLuint pensquare_vbo;
@
\fimcodigo

The triangulation code thet will be run in the initialization:

\iniciocodigo
@<WEAVEFONT Initialization@>+=
{
  float square_vertices[8] = {-0.5, -0.5,
                               +0.5, -0.5,
                               +0.5, +0.5,
                               -0.5, +0.5};
  glGenBuffers(1, &pensquare_vbo);
  glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  glBufferData(GL_ARRAY_BUFFER, 8 * sizeof(float), square_vertices,
               GL_STATIC_DRAW);
}
@
\fimcodigo

And in the finalization we can remove the vertices:

\iniciocodigo
@<WEAVEFONT Finalization@>+=
glDeleteBuffers(1, &pensquare_vbo);
@
\fimcodigo

So, when asked to triangulate a square pen, we do not need to
triangulate it. Nevertheless, we still need to compute the extremity
points:

\iniciocodigo
@<Triangulation: Square Pen@>=
if((pen -> flags & FLAG_SQUARE)){
  float square_vertices[8] = {-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5};
  pen -> indices = 4;
  DECLARE_PEN_EXTREMITIES();
  int i;
  for(i = 0; i < 4; i ++)
    CHECK_PEN_EXTREMITIES(square_vertices[2 * i], square_vertices[2 * i + 1],
                          transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

The next simplest case is when we have a convex polygon. For them, we
can use a very simple algorithm. We choose any vertex as the pivot and
perform a triangulation creating triangles that always use this vertex
and each other adjacent pair of vertices in our shape. It's the fan
triangulation:

\imagem{images/triangulacao_leque.eps}

To use this, we can just pass all the pen vertices in the same order
that they are stored and later, when drawing them, we will tell OpenGL to use
fan triangulation:

\iniciocodigo
@<Triangulation: Convex Polygon@>=
if((pen -> flags & FLAG_STRAIGHT) && (pen -> flags & FLAG_CONVEX)){
  int i, index, increment;
  DECLARE_PEN_EXTREMITIES();
  GLsizei size = sizeof(float) * 2 * pen -> format -> length;
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  if(is_pen_counterclockwise(pen)){
    index = 0;
    increment = 1;
  }
  else{
    index = pen -> format -> length - 1;
    increment = -1;
  }
  for(i = 0; i < pen -> format -> length; i ++){
    data[2 * i] = pen -> format -> points[index].point.x;
    data[2 * i + 1] = pen -> format -> points[index].point.y;
    CHECK_PEN_EXTREMITIES(data[2 * i], data[2 * i + 1], transform_matrix);
    index += increment;
  }
  if(pen -> gl_vbo == 0){
    glGenBuffers(1, &(pen -> gl_vbo));
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
    glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
    pen -> indices = pen -> format -> length;
  }
  if(temporary_free != NULL)
    temporary_free(data);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

Now let's deal with the next case for triangulation: circles. A
circular pen is created using expression \monoespaco{pencircle}. For
this kind of pen, we must generate its vertices during triangulation:
we will not use the stored vertices. But how many vertices should be
generated? If the circle have a single pixel as diameter, perhaps 4
vertices in the perimeter is enough, nobody would notice that this is
a square instead of a circle. But if the circle becames bigger, we
would need more vertices to correctly approximate its shape.

The number of required vertices is given by the circle circumference,
in pixels: we need $2\pi r$ vertices in the perimeter. The angle
between them is given by the formula $L=\theta r$ to compute the arc
length in the circle. If we want 1 pixel as arc, then, the angle
between them is $1/r$ in radians, where $r$ is the radius.

We will use the same fan triangulation as before. But we will use as
axis the center of the circle. Therefore, we will store $2\pi r +1$
vertices.

The radius will be approximated as half the biggest side of the square
where our circle is inscribed. We compute this after performing the
linear transformation in the square using the circle transform
matrix. Therefore, we will get a suitable upper bound for the radius,
considering that our circle could have been transformed in a ellipse
after the linear transformation.

This biggest side of the rectangle where our circle is inscribed after
the linear transformation is also how we compute the resolution of a
circle triangulation. If our circle is already triangulated and we
need to draw using a smaller circle, then we do not need to
triangulate it again. But if we need to draw a bigger circle, then we
need to triangulate, even if we already had a triangulation before.

The code to triangulate the circle is:

\iniciocodigo
@<Triangulation: Circle@>=
if((pen -> flags & FLAG_CIRCULAR)){
  float radius;
  // Get extremity points:
  pencircle_extremity_points(mf, transform_matrix);
  // Checking resolution (radius):
  {
    float side1, side2;
    side1 = abs(mf -> pen_rt - mf -> pen_lft);
    side2 = abs(mf -> pen_top - mf -> pen_bot);
    radius = ((side1 >= side2)?(side1):(side2))/ 2.0;
  }
  // Need to retriangulate only if radius is bigger than already triangulated:
  if(pen -> gl_vbo != 0){
    if(radius > pen -> triang_resolution)
      glDeleteBuffers(1, &(pen -> gl_vbo));
    else
      return true;
  }
  pen -> triang_resolution = radius;
  GLsizei size = sizeof(float) * 2 * (((int) (2 * M_PI * radius)) + 4);
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    int i;
    float angle = 0.0;
    data[0] = 0.0;
    data[1] = 0.0; // Circle center
    for(i = 2; i < (size / sizeof(float)); i ++){
      data[i] = 0.5 * sin(angle);
      i ++;
      data[i] = 0.5 * cos(angle);
      angle += 1/radius;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
  pen -> indices = (size / (2 * sizeof(float)));
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

Now we will deal with the last possible shape for a convex pen: when
the pen is not a polygon, it has curves. In this case, like in the
circle, we need to consider the size of our shape, including the
matrix transformation, to decide how many vertices we should use to
approximate correctly our curve. But this time, we need to do this
iterating over the extremity points and control points that form the
shape of our pen.

For each pair of extremity points $(A, D)$, with the control points
$(B, C)$, we will use the sum of the distances $AB$, $BC$ and $CD$ to
decide the number of vertices. This estimation should produce
reasonable values, except when our curve crosses itself. However, we
do not support pens with non-simple forms, therefore we should not
care about this unsupported case.

The sum of all the distances, when we iterate over the pen curves is
how we measure the pen triangulation resolution. If we are
triangulating an already triangulated pen and the resolution is lesser
or equal than the current triangulation, we do not need to triangulate
the pen again.

If the sum of the distances $AB+BC+CD$ is equal the distance $AD$,
then we have a straight line. In this case, we just need to consider
the vertices for the extremity points, not the intermediate points.

After deciding the number of vertices that should be generated, if we
need intermediate points between the extremities, then we can use the
following formula, where we change the $t$ value between 0 and 1 (with
values 0 and 1 corresponding to the extremity points):

$$
P(t) = (1-t)^3A + 3(1-t)^2tB + 3(1-t)t^2C + t^3D
$$

Naturally, we should walk over the points in the counterclockwise
orientation, which non necessarily is the stored orientation. When
measuring the distances, we should also consider the linear transform
stored in the transform matrix, but when generating the vertices we
should ignore the transform, as it will be performed by the video card
when rendering the pen.

The code to triangulate a pen in this case is:

\iniciocodigo
@<Triangulation: Convex Shape@>=
if((pen -> flags & FLAG_CONVEX)){
  bool counterclockwise = is_pen_counterclockwise(pen);
  int i, number_of_vertices = 1;
  // Get extremity points:
  path_extremity_points(mf, pen -> format, transform_matrix);
  for(i = 0; i < pen -> format -> length - 1; i ++){
    int distance = 0;
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    float dx, dy;
    x0 = LINEAR_TRANSFORM_X(pen -> format -> points[i].point.x,
                            pen -> format -> points[i].point.y, transform_matrix);
    y0 = LINEAR_TRANSFORM_Y(pen -> format -> points[i].point.x,
                            pen -> format -> points[i].point.y, transform_matrix);
    u_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].point.u_x,
                            pen -> format -> points[i].point.u_y, transform_matrix);
    u_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].point.u_x,
                            pen -> format -> points[i].point.u_y, transform_matrix);
    dx = u_x - x0;
    dy = u_y - y0;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    v_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].point.v_x,
                            pen -> format -> points[i].point.v_y, transform_matrix);
    v_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].point.v_x,
                            pen -> format -> points[i].point.v_y, transform_matrix);
    dx = v_x - u_x;
    dy = v_y - u_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    x1 = LINEAR_TRANSFORM_X(pen -> format -> points[i + 1].point.x,
                            pen -> format -> points[i + 1].point.y,
                            transform_matrix);
    y1 = LINEAR_TRANSFORM_Y(pen -> format -> points[i + 1].point.x,
                            pen -> format -> points[i + 1].point.y,
                            transform_matrix);
    dx = x1 - v_x;
    dy = y1 - v_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = x1 - x0;
    dy = y1 - y0;
    if(distance == (int) round(sqrt(dx * dx + dy * dy)))
      number_of_vertices ++; // Linha reta
    else
      number_of_vertices += distance;
  }
  if(pen -> gl_vbo != 0){
    if(number_of_vertices <= pen -> triang_resolution)
      return true; // No need to triangulate again
    else
      glDeleteBuffers(1, &(pen -> gl_vbo)); // Need to retriangulate
  }
  pen -> triang_resolution = number_of_vertices;
  float *data = (float *) temporary_alloc(number_of_vertices * 2 *
                                          sizeof(float));
    if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    struct path_points *p0, *p1;
    int v;
    if(counterclockwise)
      p0 = &(pen -> format -> points[0]);
    else
      p0 = &(pen -> format -> points[pen -> format -> length - 1]);
    data[0] = p0 -> point.x;
    data[1] = p0 -> point.y;
    v = 2;
    for(i = 0; i < pen -> format -> length - 1; i ++){
      float b_x, b_y, c_x, c_y, dx, dy, x0, y0, x1, x2, y1, y2;
      int distance = 0;
      if(counterclockwise){
        p1 = &(pen -> format -> points[1 + i]);
        b_x = p0 -> point.u_x;
        b_y = p0 -> point.u_y;
        c_x = p0 -> point.v_x;
        c_y = p0 -> point.v_y;
      }
      else{
        p1 = &(pen -> format -> points[pen -> format -> length - 2 - i]);
        b_x = p1 -> point.v_x;
        b_y = p1 -> point.v_y;
        c_x = p1 -> point.u_x;
        c_y = p1 -> point.u_y;
      }
      x0 = LINEAR_TRANSFORM_X(p0 -> point.x, p0 -> point.y, transform_matrix);
      y0 = LINEAR_TRANSFORM_Y(p0 -> point.x, p0 -> point.y, transform_matrix);
      x2 = LINEAR_TRANSFORM_X(b_x, b_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(b_x, b_y, transform_matrix);
      dx = x2 - x0;
      dy = y2 - y0;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(c_x, c_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(c_x, c_y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(p1 -> point.x, p1 -> point.y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(p1 -> point.x, p1 -> point.y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      dx = x2 - x0;
      dy = y2 - y0;
      if(distance == (int) round(sqrt(dx * dx + dy * dy))){
        data[v++] = p1 -> point.x;
        data[v++] = p1 -> point.y;
      }
      else{
        int j;
        float dt = 1.0 / ((float) distance);
        for(j = 1; j <= distance; j ++){
          float t = dt * j;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> point.x + 3*(1-t)*(1-t)*t * b_x +
                      3*(1-t)*t*t * c_x + t * t * t * p1 -> point.x;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> point.y + 3*(1-t)*(1-t)*t * b_y +
                      3*(1-t)*t*t * c_y + t * t * t * p1 -> point.y;
        }
      }
      p0 = p1;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, number_of_vertices * 2 *
                                sizeof(float), data, GL_STATIC_DRAW);
  pen -> indices = number_of_vertices;
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

For now, we will not support concave shapes, but this may change in
the future:

\iniciocodigo
@<Triangulation: Concave Shape@>=
if(!(pen -> flags & FLAG_CONVEX)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Concave pens still not supported.\n");
#endif
  return false;
}
return false;
@
\fimcodigo

\subsecao{10.3. Reading the \monoespaco{pickup} Command}

Now we will define what will happen when we read
the \monoespaco{pickup} command.

1) First we read the next token. If it is a \monoespaco{nullpen}, we
transform \monoespaco{currentpen} in a null pen, and if it is
a \monoespaco{pencircle}, we transform in a circular pen. If it is a
pen variable, we set \monoespaco{currentpen} to point to that given
variable. In either case, we reset \monoespaco{currentpen} to an
identity matrix. IN the other cases, or if the variable is not
initialized, we return an error.

\iniciocodigo
@<Statement: Command@>=
else if(begin -> type == TYPE_PICKUP){
  struct generic_token *end_expression = *end;
  struct generic_token *next_token = begin -> next;
  if(begin == *end ||
     (next_token -> type != TYPE_NULLPEN &&
      next_token -> type != TYPE_SYMBOLIC &&
      next_token -> type != TYPE_PENCIRCLE)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Expected 'nullpen' or pen "
                    "variable after 'pickup'. Not an arbitrary "
                    "expression.\n",
            mf -> file, next_token -> line);
#endif
    return false;
  }
  if(mf -> internal_pen_variables[0].gl_vbo != 0)
    glDeleteBuffers(1, &(mf -> internal_pen_variables[0].gl_vbo));
  if(next_token -> type == TYPE_NULLPEN){
    mf -> internal_pen_variables[0].flags = FLAG_NULL;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else if(next_token -> type == TYPE_PENCIRCLE){
    mf -> internal_pen_variables[0].flags = FLAG_CONVEX | FLAG_CIRCULAR;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else{
    struct pen_variable *var = ((struct symbolic_token *) next_token) -> var;
    if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-initialized variable after "
                      "after 'pickup' command.\n",
              mf -> file, next_token -> line);
#endif
      return false;
    }
    if(var -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable '%s' is not a "
                      "pen variable.\n",
              mf -> file, next_token -> line,
              ((struct symbolic_token *) next_token) -> value);
#endif
      return false;
    }
    mf -> internal_pen_variables[0].referenced = var;
  }
  INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[0].gl_matrix);
  @<'pickup' Command: Continue@>
  return true;
}
@
\fimcodigo

After gettting the pen basis form, now we read the linear transforms
specific to be applied to the \monoespaco{currentpen}. While we are
not in the end of the expression, we read the next token, which should
describe a linear transform
like \monoespaco{shifted}, \monoespaco{rotated} or something like
this. Based in the transform, we read and evaluate the following
tokens as a numeric, pair or transform expression. And finally perform
the given transform in the \monoespaco{currentpen} matrix. We keep
doing this until we find no more new transforms to be performed.

\iniciocodigo
@<'pickup' Command: Continue@>=
while(next_token != end_expression){
  struct generic_token *begin_subexpr, *end_subexpr;
  DECLARE_NESTING_CONTROL();
  next_token = next_token -> next;
  if(next_token == NULL || next_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                      "command format.\n",
              mf -> file, next_token -> line);
#endif
    return false;
  }
  begin_subexpr = next_token -> next;
  end_subexpr = begin_subexpr;
  while(end_subexpr != end_expression){
    struct generic_token *next = end_subexpr -> next;
    COUNT_NESTING(end_subexpr);
    if(IS_NOT_NESTED() &&
       (next -> type == TYPE_ROTATED || next -> type == TYPE_SCALED ||
        next -> type == TYPE_SHIFTED || next -> type == TYPE_SLANTED ||
        next -> type == TYPE_XSCALED || next -> type == TYPE_YSCALED ||
        next -> type == TYPE_ZSCALED || next -> type == TYPE_TRANSFORMED))
      break;
    end_subexpr = next;
  }
  switch(next_token -> type){
    struct numeric_variable a;
    struct pair_variable p;
    struct transform_variable t;
  case TYPE_ROTATED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_ROTATE(mf -> internal_pen_variables[0].gl_matrix,
                     a.value * 0.0174533);
    break;
  case TYPE_SCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_SHIFTED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SHIFT(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    break;
  case TYPE_SLANTED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SLANT(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Slant non-circular curved pens always require retriangulation:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT) &&
         !(v -> flags & FLAG_CIRCULAR)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_XSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_X(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_YSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_Y(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_ZSCALED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SCALE_Z(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_TRANSFORMED:
    if(!eval_transform_expression(mf, cx, begin_subexpr, end_subexpr, &t))
      return false;
    MATRIX_MULTIPLICATION(mf -> internal_pen_variables[0].gl_matrix, t.value);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  default:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                    "command format.\n",
            mf -> file, next_token -> line);
#endif
    return false;  
  }
  next_token = end_subexpr;
}
@
\fimcodigo

After getting the new current pen shape, if it is a pointer for an
existing pen or not, and its linear transform represented as a matrix,
we just need to triangulate the current pen if needed. For this, we
need to obtain the final transform matrix: if the current pen is a
pointer for another pen, then the final transform matrix is obtained
multiplicating the \monoespaco{currentpen} matrix by the pointed pen
matrix. Otherwise, the final transform matrix is just the current pen
matrix, After getting the final transform matrix, we just pass it to
the triangulation function:

\iniciocodigo
@<'pickup' Command: Continue@>+=
{
  float final_transform_matrix[9];
  if(mf -> internal_pen_variables[0].referenced == NULL){
    memcpy(final_transform_matrix, mf -> internal_pen_variables[0].gl_matrix,
           9 * sizeof(float));
    if(!triangulate_pen(mf, &(mf -> internal_pen_variables[0]),
                        final_transform_matrix))
      return false;
  }
  else{
    memcpy(final_transform_matrix,
           mf -> internal_pen_variables[0].referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(final_transform_matrix,
                          mf -> internal_pen_variables[0].gl_matrix);
    if(!triangulate_pen(mf, mf -> internal_pen_variables[0].referenced,
                        final_transform_matrix))
      return false;
  }
}
@
\fimcodigo

\subsecao{10.4. Operators \monoespaco{bot}, \monoespaco{top}, \monoespaco{lft},
\monoespaco{rt}}

We defined most pair operators in Subsection 8.2, but there are still
4 missing operators that we will define here. Their grammar is:

\alinhaverbatim
<Pair Primary> -> bot <Pair Primary> | top <Pair Primary> |
                  lft <Pair Primary> | rt <Pair Primary>
\alinhanormal

This requires 4 new tokens for such operators:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_BOT,  // Symbolic token 'bot'
TYPE_TOP,  // Symbolic token 'top'
TYPE_LFT,  // Symbolic token 'lft'
TYPE_RT,   // Symbolic token 'rt'
@
\fimcodigo

And we also need to add the token names to the list of reserved
keywords:

\iniciocodigo
@<List of Keywords@>+=
"bot", "top", "lft", "rt",
@
\fimcodigo

These operators shift a pair for a distance that depends on the
current pen size. If we have a point $(x_0, y_0)$,
then \monoespaco{bot (x0, y0)} represents $(x_0, y_0)$ shifted down,
such that it is now positioned below the pen when we center it in
point $(x_0, y_0)$. Assuming that the pen coordinates are centered on
the origin, then its lower points are negative in axis $y$. Therefore,
we can do it adding the initial point with the lowest $y$ value in the
pen:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin -> type == TYPE_BOT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> y += mf -> pen_bot;
  return true;
}
@
\fimcodigo

The operator \monoespaco{top} shifts up a quantity equal to the
biggest coordinate $y$ in the current pen perimeter. This means that
\monoespaco{top (x0, y0)} will be positioned such that it will be above
the pen when the pen is placed in $(x_0, y_0)$:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin -> type == TYPE_TOP){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> y += mf -> pen_top;
  return true;
}
@
\fimcodigo

The operator \monoespaco{lft} shifts left a quantity equal the
smallest coordinate $x$ in the current pen
perimeter. Therefore, \monoespaco{lft (x0, y0)} will be positioned at
left of the pen if the pen is centered in $(x_0, y_0)$. As in a pen
centered in the origin the leftmost points will have a negative $x$
coordinate, we just need to add to the $x$ coordinate of the point the
leftmost $x$ coordinate in the pen:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin -> type == TYPE_LFT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> x += mf -> pen_lft;
  return true;
}
@
\fimcodigo

The last operator, \monoespaco{rt}, shifts right the pair $(x_0, y_0)$
a quantity equivalent to the rightmost coordinate in the pen
perimeter, such that the point coordinate will be placed at
right of the pen when centered in $(x_0, y_0)$:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin -> type == TYPE_RT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> x += mf -> pen_rt;
  return true;
}
@
\fimcodigo


\secao{11. The \monoespaco{draw} and \monoespaco{erase} Command}

Finally we can begin specifying two of the most important command in
the language. The command that uses a pen to draw a path in a picture
and the command that erases a path in a picture. The command syntax
is:

\alinhaverbatim
<Command> -> <'draw' Command> | <'erase' Command> | ...
<'draw' Command> -> draw <Path Expression>
<'erase' Command> -> erase <Path Expression>
\alinhanormal

Which requires a new token type and a new reserved word:

\iniciocodigo
@<WEAVEFONT: Symbolic Token Definition@>+=
TYPE_DRAW,  // Symbolic token 'draw'
TYPE_ERASE, // Symbolic token 'erase'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"draw", "erase",
@
\fimcodigo


\subsecao{11.1. Preparing Framebuffer}

To draw or erase with a pen in the
picture \monoespaco{currentpicture}, we need a framebuffer associated
with this picture. This is not much different than when we define
several operations over picture variables. In several of them, we
created a new framebuffer, stored the previous framebuffer, changed to
the new framebuffer, rendered, erased the new framebuffer and changed
to the old one. But for the \monoespaco{currentpicture} framebuffer,
we will keep a single variable to store it:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static GLuint currentpicture_fb;
@
\fimcodigo

Which is initialized as zero:

\iniciocodigo
@<WEAVEFONT Initialization@>+=
currentpicture_fb = 0;
@
\fimcodigo

Before rendering to \monoespaco{currentpicture}, we should execute the
following code to check if the framebuffer is initialized and if not,
initializes it:

\iniciocodigo
@<Prepare 'currentpicture' for Drawing@>=
{
  if(currentpicture_fb == 0){
    int width, height;
    GLuint texture;
    width = mf ->
             internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].width;
    height = mf ->
            internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].height;
    texture = mf ->
           internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].texture;
    glGenFramebuffers(1, &currentpicture_fb);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
                 GL_UNSIGNED_BYTE, NULL);
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                           texture, 0);
  }
  else
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
}
@
\fimcodigo

If for some reason we change the contents
of \monoespaco{currentpicture}, we must remove the old framebuffer:

\iniciocodigo
@<Create new 'currentpicture'@>=
{
  if(currentpicture_fb != 0){
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glBindTexture(GL_TEXTURE_2D, 0);
    glDeleteFramebuffers(1, &currentpicture_fb);
  }
  currentpicture_fb = 0;
}
@
\fimcodigo

Before rendering to \monoespaco{currentpicture}, we do not store the
old framebuffer. And after the rendering, we do not restore the old
framebuffer. This is different than what de do when we render in other
picture variabes using picture operators. We do it this way because
rendering to \monoespaco{currentpicture} should be a much more common
operation. Because of this, we will try to keep as the current
framebuffer the framebuffer associated
with \monoespaco{currentpicture}.

But before beginning to evaluate code, we store the previous
framebuffer that the program was using before calling our code. It
will be stored in the variable below:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static GLint previous_fb;
@
\fimcodigo

And here is where we save the previous framebuffer before evaluating
the code in \monoespaco{eval\_list\_of\_expressions}. We also save the
previous viewport, as we can change this value too when rendering a
glyph:

\iniciocodigo
@<Before Evaluating Code@>=
GLint _viewport[4];
glGetIntegerv(GL_VIEWPORT, _viewport);
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_fb);
@
\fimcodigo

And this restores the old framebuffer and viewport after code
evaluation:

\iniciocodigo
@<After Evaluating Code@>=
glBindFramebuffer(GL_FRAMEBUFFER, previous_fb);
glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);
@
\fimcodigo

\subsecao{11.2. Drawing Shaders}

Drawing and erasing will require two new shaders (one for each
operation) that we will define. The previous shaders were defined to
perform operations between picture variables, and all them required a
texture. But for our pen, instead of a texture, we will need to pass a
drawing color. For now, the color will always be opaque black, but if
this changes in the future, our shader code will be ready.

Our vertex shader code is presented below:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char pen_vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "}\n";
@
\fimcodigo

It is identical the previous vertex shader, except by the fact that
this one does not receive nor try to extract values from a
texture. The two new fragment shader is:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char pen_erase_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, \n"
  "                      color.a);\n"
  "}\n";
static const char pen_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = color;"
  "}\n";
static GLuint pen_program, pen_erase_program; // The program after compilation
static GLint pen_uniform_matrix, pen_erase_uniform_matrix; // Matrix
static GLint pen_uniform_color, pen_erase_uniform_color; // Color
@
\fimcodigo

During initialization, we compile these shaders and get the uniform
locations:

\iniciocodigo
@<WEAVEFONT Initialization@>+=
{
  pen_program = compile_shader_program(pen_vertex_shader, pen_fragment_shader);
  pen_uniform_matrix = glGetUniformLocation(pen_program, "model_view_matrix");
  pen_uniform_color = glGetUniformLocation(pen_program, "color");
  pen_erase_program = compile_shader_program(pen_vertex_shader,
                                            pen_erase_fragment_shader);
  pen_erase_uniform_matrix = glGetUniformLocation(pen_erase_program,
                                                  "model_view_matrix");
  pen_erase_uniform_color = glGetUniformLocation(pen_erase_program, "color");
}
@
\fimcodigo

And in the finalization we destroy these programs:

\iniciocodigo
@<WEAVEFONT Finalization@>+=
glDeleteProgram(pen_program);
glDeleteProgram(pen_erase_program);
@
\fimcodigo

\subsecao{11.3. Drawing Paths}

After finishing preparing the triangulation, the framebuffer and
shaders, we finally can write code for drawing.

\iniciocodigo
@<Statement: Command@>=
else if(begin -> type == TYPE_DRAW){
  struct path_variable path;
  // Avaliar a expresso de caminho
  if(!eval_path_expression(mf, cx, begin -> next, *end, &path))
    return false;
  if(!drawing_commands(mf, cx, &path, 0))
    return false;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &path, false);
  return true;
}
else if(begin -> type == TYPE_ERASE){
  struct path_variable path;
  // Avaliar a expresso de caminho
  if(!eval_path_expression(mf, cx, begin -> next, *end, &path))
    return false;
  if(!drawing_commands(mf, cx, &path, 1))
    return false;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &path, false);
  return true;
}
@
\fimcodigo

The above code identifies a \monoespaco{draw} command and extract the
path to be drawn. The code that performs the drawing is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool drawing_commands(struct metafont *mf, struct context *cx,
                      struct path_variable *path, unsigned int flags);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
#define ERASE_FLAG 1
bool drawing_commands(struct metafont *mf, struct context *cx,
                      struct path_variable *path, unsigned int flags){
  int i, j;
  float transform_matrix[9];
  struct pen_variable *currentpen = &(mf -> internal_pen_variables[0]);
  struct picture_variable *currentpicture =
                                        &(mf -> internal_picture_variables[0]);
  // Prepare the pen, currentpicture and OpenGL parameters
  if(currentpen -> referenced != NULL){
    memcpy(transform_matrix, currentpen -> referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(transform_matrix, currentpen -> gl_matrix);
    currentpen = currentpen -> referenced;
  }
  else
    memcpy(transform_matrix, currentpen -> gl_matrix, 9 * sizeof(float));
  @<Prepare 'currentpicture' for Drawing@>
  glEnable(GL_BLEND);
  if(flags & ERASE_FLAG){
    glBlendFunc(GL_ONE, GL_ONE);
    glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  }
  else{
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glBlendEquation(GL_FUNC_ADD);
  }
  // Drawing loop
  for(i = 0; i < path -> length - 1; i ++){
    int distance = 0;
    float dx, dy, dt;
    dx = path -> points[i].point.u_x - path -> points[i].point.x;
    dy = path -> points[i].point.u_y - path -> points[i].point.y;
    distance += (int) ceil(sqrt(dx * dx + dy * dy));
    dx = path -> points[i].point.v_x - path -> points[i].point.u_x;
    dy = path -> points[i].point.v_y - path -> points[i].point.u_y;
    distance += (int) ceil(sqrt(dx * dx + dy * dy));
    dx = path -> points[(i+1) % (path -> length)].point.x - path -> points[i].point.v_x;
    dy = path -> points[(i+1) % (path -> length)].point.y - path -> points[i].point.v_y;
    distance += (int) ceil(sqrt(dx * dx + dy * dy));
    dt = 1 / ((float) distance);
    for(j = 0; j <= distance; j ++){
      float t = dt * j;
      float x = (1-t)*(1-t)*(1-t) * path -> points[i].point.x +
                3*(1-t)*(1-t)*t * path -> points[i].point.u_x +
                3*(1-t)*t*t * path -> points[i].point.v_x +
                t*t*t * path -> points[(i + 1) % (path -> length)].point.x;
      float y = (1-t)*(1-t)*(1-t) * path -> points[i].point.y +
                3*(1-t)*(1-t)*t * path -> points[i].point.u_y +
                3*(1-t)*t*t * path -> points[i].point.v_y +
                t*t*t * path -> points[(i + 1) % (path -> length)].point.y;
      drawpoint(mf, currentpen, currentpicture, x, y, transform_matrix,
                flags & ERASE_FLAG);
    }
  }
  // When the path has a single point and the loop above do not run:
  if(path -> length == 1)
    drawpoint(mf, currentpen, currentpicture, path -> points[0].point.x,
              path -> points[0].point.y, transform_matrix, flags & ERASE_FLAG);
  // Finalization
  glDisable(GL_BLEND);
  return true;
}
@
\fimcodigo


The above code first gets the relevant variables
(\monoespaco{currentpen}, \monoespaco{currentpicture}).

Then we get the correct pen that we should use,
triangulate it and we initialize OpenGL parameters for this kind of
draw, some of them we defined in previous Subsections. One of the two
single places where we differentiate between
commands \monoespaco{draw} and \monoespaco{erase} appears
here. Depending on the command, we change the OpenGL blending
function. The blending follows the same logic than we used when adding
and subtracting images.

After this, we have the drawing loop, where the path is drawn, point
by point using the function \monoespaco{drawpoint} that we still did
not define. To get each individual point, we use the Bezier curve
formula $z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' +
3(1-t)t^2z_3'+t^3z_4$. And to know how many intermediate points we
should draw between two extremity points, we add the distance between
all four points that compose the curve: the two extremity points and
two control points.

Now we just need to define \monoespaco{drawpoint}. Its header is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing);
@
\fimcodigo

The pen knows all the coordinates of its triangulated vertices, and
stores them in pixels. The picture stores its own width and height in
pixels. But to render using OpenGL, we should convert this to OpenGL
coordinates, where the destiny texture will always have width and
height equal 2. This means that we need to create a new matrix to
perform this last linear transformation.

Let $h$ be the picture height in pixels and $w$ its width. This means
that 1 horizontal pixel is $2/w$ and 1 vertical pixel is $2/h$. Then,
we just need to multiply the transform matrix stored in the pen by a
diagonal matrix with $2/w$ and $2/h$ as the two first elements in the
diagonal (the other diagonals will be 1).

Next, after performing the conversion for OpenGL coordinates, we
should not use pixels anymore. But we need to shif each vertex by $(x,
y)$, the coordinate passed as argument for the \monoespaco{drawpoint}
function. Their values are $2x/w$ and $2y/h$ in OpenGL
coordinates. But we also need another shifting to make a correction
because we store the coordinates assuming that the origin is the lower
left corner of the image, while OpenGL assumes that the origin is the
center of the image.

However, in fact, we have another detail: it is not entirely true that
we always assume that our origin is the left lower corner of the
image. We could also assume that this origin is shifted vertically
using an internal value $d$ stored here:

\iniciocodigo
@<Attributes (struct metafont)@>+=
int current_depth;
@
\fimcodigo

Its initial value is zero:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> current_depth = 0;
@
\fimcodigo

This value $d$ stores in pixels how much our axis $x$ is shifted
vertically. Therefore, in OpenGL coordinates, we should convert it to
$2d/h$. If it is zero, then the origin indeed will be the lower left
corner of the picture before converting to OpenGL origin. Otherwise,
we shift the origin according with $d$ value.

The multiplication that converts the pen transform matrix to OpenGL
coordinates is given below:

$$
\left[{{a \atop c}\atop
      {0\atop e}}{{b \atop d}\atop {0 \atop
      f}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{2/w \atop 0}\atop
      {0\atop 2x/w-1}}{{0 \atop 2/h}\atop {0 \atop
      2d/h+2y/w-1}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=
\left[{{2a/w \atop 2c/w}\atop
      {0\atop (2e+2x)/w-1}}{{2b/h \atop 2d/h}\atop {0 \atop
      (2f+2d+2y)/h-1}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
$$


All this is done by the function \monoespaco{drawpoint} before
drawing. After getting the correct matrix, we can render the result,
using different shader programs if we are drawing or erasing:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing){
  float gl_matrix[9];
  gl_matrix[0] = (2 * matrix[0]) /  pic -> width;  // 2a/w
  gl_matrix[1] = (2 * matrix[1]) /  pic -> height; // 2b/h
  gl_matrix[2] = 0.0;
  gl_matrix[3] = (2 * matrix[3]) /  pic -> width;  // 2c/w
  gl_matrix[4] = (2 * matrix[4]) /  pic -> height; // 2d/h
  gl_matrix[5] = 0.0;
  gl_matrix[6] = 2 * (matrix[6] + x) /  pic -> width - 1.0;
  gl_matrix[7] = 2 * (matrix[7] + mf -> current_depth + y) / pic -> height -
                 1.0;
  gl_matrix[8] = 1.0;
  glViewport(0, 0, pic -> width, pic -> height);
  // Se a caneta for quadrada, usamos a triangulao padro de quadrado.
  // Se no for, usamos a triangulao da prpria caneta.
  if(pen -> flags & FLAG_SQUARE)
    glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  else 
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, (void *) 0);
  if(erasing){
    glUseProgram(pen_erase_program);
    glUniformMatrix3fv(pen_erase_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_erase_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  else{
    glUseProgram(pen_program);
    glUniformMatrix3fv(pen_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  glEnableVertexAttribArray(0);
  glDrawArrays(GL_TRIANGLE_FAN, 0, pen -> indices);
}
@
\fimcodigo

\secao{12. Compound Statement: Character Definition}

Now we are in the part that is the main objective of the language:
defining new characters for typographical fonts, or defining a new
image to be used as static illustration or an animation.

The syntax for this is:

\alinhaverbatim
<Compound> -> <Character Definition>
<Character Definition> -> beginchar ( <String Token> ,
                                      <Numeric Expression> ,
                                      <Numeric Expresison> ,
                                      <Numeric Expression> )
                           <'beginchar' Body>
                           endchar
<'beginchar' Body> -> <Statement, except 'beginchar'>
<Statement, except 'beginchar'> -> <Simple> | <Compound, except 'beginchar'>
<Compound, except 'beginchar'> -> <Compound Block> | <Conditional>
\alinhanormal

The token \monoespaco{beginchar} begins a new character definition
and \monoespaco{endchar} ends the definition. The string token is the
character name. For typographical fonts, it must be the UTF-8
character that it is being represented. For animations and
illustrations, the value will be ignored and can be any string. The
numeric values after the string are teh character width, height and
depth. The depth is its height below the baseline, for characters like
``p'' or ``q'', with parts extending below the line.

The language WEAVEFONT has two modes of operation: it can be loading
or running. The mode changes how we deal with the code in
a \monoespaco{beginchar} statement. If loading, the code inside
the \monoespaco{beginchar} body will not be interpreted and
executed. Instead, this code will be stored in an adequate place to be
interpreted later, when we need to render the character. When running,
then the language will interpret and execute the code because we need
to render such character.

\subsecao{12.1 Unicode and UTF-8}

But where should we store the code for each character when in the
loading mode? For this, we will define the following structure that
will hold information about a single glyph or image. It will store the
code, the glyph dimensions, the OpenGL texture and an extra variable
that says if we need to render the glyph, or we could just use the
already rendered texture:

\iniciocodigo
@<General Declarations (metafont.h)@>=
struct _glyph;
@
\fimcodigo

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct _glyph{
  struct generic_token *begin, *end;
  int width, height, depth;
  int italic_correction;
  struct kerning *kern;
  GLuint texture;
  bool need_rendering;
};
#define INITIALIZE_GLYPH(a) {a.begin = NULL; \
                            a.end = NULL; \
                            a.width = 0; \
                            a.height = 0;\
                            a.depth = 0; \
                            a.italic_correction = 0; \
                            a.kern = NULL; \
                            a.texture = 0; \
                            a.need_rendering = true; \
                            }

@
\fimcodigo

The ``kerning'' present above a a linked list which stores the
addictional spacing that should be placed before the next character,
based on which is the next character.

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct kerning{
  char next_char[5];
  int kern;
  struct kerning *next;
};
@
\fimcodigo


The list of all glyphs and a pointer to the first defined glyph will
be stored here:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct _glyph *glyphs[332];
struct _glyph *first_glyph;
int number_of_glyphs;
@
\fimcodigo

The number 332 is enough to store all existing 327 Unicode blocks plus
some other regions that currently are not in use, but could still be
standardized in future years. Each block can store between 1 and
thousands of different glyphs, typically, belonging to the same
writting system. Initially all these blocks will be initialized as
empty, but when we find new character definitions for glyphs belonging
to them, we will need to allocate them:

\iniciocodigo
@<Initialization (struct metafont)@>+=
memset(mf -> glyphs, 0, sizeof(struct _glyph *) * 332);
mf -> first_glyph = NULL;
mf -> number_of_glyphs = 0;
@
\fimcodigo

The function that allocates and returns the struct of a new or an
existing glyph is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *utf8,
                                bool create_if_not_exist);
@
\fimcodigo

The function first converts the UTF-8 representation to UTF-32, making
the value identical to the Unicode code point. After this, we check a
table where we store the biggest value stored in each block
sequentially. We use the table to check which block doest the glyph
belong, its position inside the block and the block size. If the block
does not exist and the last parameter is true, we allocate the
block. In the end, we return the glyph associated with the UTF-8
character (the glyph can be unitialized). Or NULL if it was not
possible to get glyph (the block does not exist and we asked to not
allocate it, the UTF-8 code is invalid, the Unicode point does not
exist or is not supported or we had no memory enough to allocate the
block).


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
static const uint32_t greatest_point[332] = {
  // Basic Multilingual Plane  (164 blocks)
0x7f, 0xff, 0x17f, 0x24f, 0x2af, 0x2ff, 0x36f, 0x3ff, 0x4ff, 0x52f,
0x58f, 0x5ff, 0x6ff, 0x74f, 0x7ff, 0x7bf, 0x7ff, 0x83f, 0x85f, 0x86f,
0x89f, 0x8ff, 0x97f, 0x9ff, 0xa7f, 0xaff, 0xb7f, 0xbff, 0xc7f, 0xcff,
0xd7f, 0xdff, 0xe7f, 0xeff, 0xfff, 0x109f, 0x10ff, 0x11ff, 0x137f, 0x139f,
0x13ff, 0x167f, 0x169f, 0x16ff, 0x171f, 0x173f, 0x175f, 0x177f, 0x17ff, 0x18af,
0x18ff, 0x194f, 0x197f, 0x19df, 0x19ff, 0x1a1f, 0x1aaf, 0x1aff, 0x1b7f, 0x1bbf,
0x1bff, 0x1c4f, 0x1c7f, 0x1c8f, 0x1cbf, 0x1ccf, 0x1cff, 0x1d7f, 0x1dbf, 0x1dff,
0x1eff, 0x1fff, 0x206f, 0x209f, 0x20cf, 0x20ff, 0x214f, 0x218f, 0x21ff, 0x22ff,
0x23ff, 0x243f, 0x245f, 0x24ff, 0x257f, 0x259f, 0x25ff, 0x26ff, 0x27bf, 0x27ef,
0x27ff, 0x28ff, 0x297f, 0x29ff, 0x2aff, 0x2bff, 0x2c5f, 0x2c7f, 0x2cff, 0x2d2f,
0x2d7f, 0x2ddf, 0x2dff, 0x2eff, 0x2fdf, 0x2fff, 0x303f, 0x309f, 0x30ff, 0x312f,
0x318f, 0x319f, 0x31bf, 0x31ef, 0x31ff, 0x32ff, 0x33ff, 0x4dbf, 0x4dff, 0x9fff,
0xa48f, 0xa4cf, 0xa4ff, 0xa63f, 0xa69f, 0xa69f, 0xa6ff, 0xa71f, 0xa7ff, 0xa82f,
0xa83f, 0xa87f, 0xa8df, 0xa8ff, 0xa92f, 0xa95f, 0xa97f, 0xa9df, 0xa9ff, 0xaa5f,
0xaa7f, 0xaadf, 0xaaff, 0xab2f, 0xab6f, 0xabbf, 0xabff, 0xd7af, 0xd7ff, 0xdb7f,
0xdbff, 0xdfff, 0xf8ff, 0xfaff, 0xfb4f, 0xfdff, 0xfe0f, 0xfe1f, 0xfe2f, 0xfe4f,
0xfe6f, 0xfeff, 0xffef, 0xffff,
  // Supplementary Multilingual Plane (151 blocks)
0x1007f, 0x100ff, 0x1013f, 0x1018f, 0x101cf, 0x101ff, 0x1029f, 0x102df,
0x102ff, 0x1032f, 0x1034f, 0x1037f, 0x1039f, 0x103df, 0x1044f, 0x1047f,
0x104af, 0x104ff, 0x1052f, 0x1056f, 0x105bf, 0x1077f, 0x107bf, 0x1083f,
0x1085f, 0x1087f, 0x108af, 0x108ff, 0x1091f, 0x1093f, 0x1099f, 0x109ff,
0x10a5f, 0x10a7f, 0x10a9f, 0x10aff, 0x10b3f, 0x10b5f, 0x10b7f, 0x10baf,
0x10c4f, 0x10cff, 0x10d3f, 0x10e7f, 0x10ebf, 0x10eff, 0x10f2f, 0x10f6f,
0x10faf, 0x10fdf, 0x10fff, 0x1107f, 0x110cf, 0x110ff, 0x1114f, 0x1117f,
0x111df, 0x111ff, 0x1124f, 0x112af, 0x112ff, 0x1137f, 0x1147f, 0x114df,
0x115ff, 0x1166f, 0x1167f, 0x116cf, 0x1174f, 0x1184f, 0x118ff, 0x1195f,
0x119ff, 0x11a4f, 0x11aaf, 0x11abf, 0x11aff, 0x11b5f, 0x11c6f, 0x11cbf,
0x11d5f, 0x11daf, 0x11eff, 0x11f5f, 0x11fbf, 0x11fff, 0x123ff, 0x1247f,
0x1254f, 0x12fff, 0x1342f, 0x1345f, 0x1467f, 0x16a3f, 0x16a6f, 0x16acf,
0x16aff, 0x16b8f, 0x16e9f, 0x16f9f, 0x16fff, 0x187ff, 0x18aff, 0x18cff,
0x18d7f, 0x1afff, 0x1b0ff, 0x1b12f, 0x1b16f, 0x1b2ff, 0x1bc9f, 0x1bcaf,
0x1cfcf, 0x1d0ff, 0x1d1ff, 0x1d24f, 0x1d2df, 0x1d2ff, 0x1d35f, 0x1d37f,
0x1d7ff, 0x1daaf, 0x1dfff, 0x1e02f, 0x1e08f, 0x1e14f, 0x1e2bf, 0x1e2ff,
0x1e4ff, 0x1e7ff, 0x1e8df, 0x1e95f, 0x1ecbf, 0x1ed4f, 0x1eeff, 0x1f02f,
0x1f09f, 0x1f0ff, 0x1f1ff, 0x1f2ff, 0x1f5ff, 0x1f64f, 0x1f67f, 0x1f6ff,
0x1f77f, 0x1f7ff, 0x1f8ff, 0x1f9ff, 0x1fa6f, 0x1faff, 0x1fbff,
  // Unused
  0x1ffff,
  // Supplementary Ideographic Plane
  0x2a6df, 0x2b73f, 0x2b81f, 0x2ceaf, 0x2ebef, 0x2fa1f,
  // Unused
  0x2ffff,
  // Tertiary Ideographic Plane
  0x3134f, 0x323af,
  // Unused
  0xdffff,
  // Supplementary Special-purpose Plane (unused middle region)
  0xe007f, 0xe00ff, 0xe01ef,
  // Unused
  0xeffff,
  // Supplementary Private Use Area-A
  0xfffff,
  // Supplementary Private Use Area-B
  0x10ffff
};
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *c,
                                bool create_if_not_exist){
  uint32_t code_point;
  int block, block_size, index;
  // UTF-8 -> UTF-32
  if(c[0] < 128)
    code_point = c[0];
  else if(c[0] >= 192 && c[0] <= 223 && c[1] >= 128 && c[1] <= 159){
    code_point = c[1] - 128;
    code_point += (c[0] - 192) * 64;
  }
  else if(c[0] >= 224 && c[0] <= 239 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159){
    code_point = c[2] - 128;
    code_point += (c[1] - 128) * 64;
    code_point += (c[0] - 224) * 4096;
  }
  else if(c[0] >= 240 && c[0] <= 247 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159 && c[3] >= 128 && c[3] <= 159){
    code_point = c[3] - 128;
    code_point += (c[2] - 128) * 64;
    code_point += (c[1] - 128) * 4096;
    code_point += (c[0] - 240) * 262144;
  }
  else return NULL; // Invalid  UTF-8 string
  if(code_point > greatest_point[331])
    return NULL; // Unicode point not existent or not supported
  for(block = 0; code_point > greatest_point[block]; block ++);
  if(block == 0){
    block_size = greatest_point[block] + 1;
    index = code_point;
  }
  else{
    block_size = greatest_point[block] - greatest_point[block - 1];
    index = code_point - greatest_point[block - 1] - 1;
  }
  if(mf -> glyphs[block] == NULL){
    int i;
    if(!create_if_not_exist)
      return NULL;
    mf -> glyphs[block] = permanent_alloc(sizeof(struct _glyph) * block_size);
    if(mf -> glyphs[block] == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s: No memory to allocate "
                      "Unicode block.\n", mf -> file);
#endif
      return NULL;
    }
    for(i = 0; i < block_size; i ++)
      INITIALIZE_GLYPH(mf -> glyphs[block][i]);
  }
  return &(mf -> glyphs[block][index]);
}
@
\fimcodigo

But if we allocate glyphs in the above function, this means that
during finalization, we need to iterate over all glyphs and deallocate
them and their internal data:

\iniciocodigo
@<Finalizao (struct metafont)@>+=
{
  int block, block_size, index;
  // Walking over all blocks:
  for(block = 0; block < 332; block ++){
    if(mf -> glyphs[block] != NULL){
      // Get the block size
      if(block == 0)
        block_size = greatest_point[block] + 1;
      else
        block_size = greatest_point[block] - greatest_point[block - 1];
      // Walking over all glyphs:
      for(index = 0; index < block_size; index ++){
        struct kerning *kern = mf -> glyphs[block][index].kern;
        if(mf -> glyphs[block][index].texture != 0)
          glDeleteTextures(1, &(mf -> glyphs[block][index].texture));
        while(kern != NULL && permanent_free != NULL){
          struct kerning *to_be_erased;
          to_be_erased = kern;
          kern = kern -> next;
          permanent_free(to_be_erased);          
        }
      }
      if(permanent_free != NULL)
        permanent_free(mf -> glyphs[block]);
    }
  }
}
@
\fimcodigo


When the language finds a \monoespaco{beginchar} token while in the
loading mode, it will read the next string token and interpret it as a
UTF-8 code. Based on tis value, the above function is executed to
return the correct glyph and allocate it if necessary. If a glyph for
that charactere already is fully initialized, an error will be raised:
this would mean that the same glyph was defined twice. Otherwise, all
the code between \monoespaco{beginchar} and \monoespaco{endchar} will
be stored in the glyph and this will turn the glyph in a fully
initialized one (but not a renderized one). The string token used to
identify the glyph will also be update to point to the newly created
glyph using its internal variables. An error also should be raised if
we find another \monoespaco{beginchar} inside the
initial \monoespaco{beginchar}:

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_BEGINCHAR && mf -> loading){
  DECLARE_NESTING_CONTROL();
  struct _glyph *glyph;
  struct generic_token *t = begin -> next;
  if(t -> type != TYPE_OPEN_PARENTHESIS || begin == *end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing '(' "
                    "after 'beginchar'.\n", mf -> file,
                    begin -> line);
#endif
    return false;
  }
  if(t != *end)
    t = t -> next;
  if(t -> type != TYPE_STRING){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing UTF-8 string "
                    "after 'beginchar('.\n", mf -> file,
            begin -> line);
#endif
    return false;
  }
  {
    struct string_token *str = (struct string_token *) t;
    glyph = get_glyph(mf, (unsigned char *) str -> value, true);
    if(glyph == NULL)
      return false;
    if(mf -> first_glyph == NULL)
      mf -> first_glyph = glyph;
    if(glyph -> begin != NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Glyph \"%s\" is defined "
                      "twice.\n", mf -> file,
              begin -> line,
              str -> value);
#endif
      return false;
    }
    glyph -> begin = begin;
    str -> glyph = glyph;
  }
  {
    int number_of_commas = 0;
    struct generic_token *prev = t;
    while(t != NULL && t != *end){
      COUNT_NESTING(t);
      if(IS_NOT_NESTED()){
        if(t -> type == TYPE_COMMA && prev -> type != TYPE_COMMA)
          number_of_commas ++;
      }
      prev = t;
      t = t -> next;
      if(IS_NOT_NESTED() && t -> type == TYPE_CLOSE_PARENTHESIS)
        break;
    }
    if(t == NULL || number_of_commas != 3 ||
       t -> type != TYPE_CLOSE_PARENTHESIS){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Malformed 'beginchar' "
                      "compound command.\n", mf -> file,
              begin -> line);
#endif
      return false;
    }
    t = t -> next;
    while(t != NULL && t -> type != TYPE_ENDCHAR){
      if(t -> type == TYPE_BEGINCHAR){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Nested 'beginchar'.\n",
                mf -> file, t -> line);
#endif
        return false;
      }
      t = t -> next;
    }
    if(t == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'endchar' "
                      "after'beginchar' command.\n", mf -> file,
              begin -> line);
#endif
      return false;
    }
    glyph -> end = t;
    *end = t;
  }
  mf -> number_of_glyphs ++;
  return true;
}
@
\fimcodigo

If we are in loading mode, and we read a \monoespaco{endchar} token,
this is always an error: it means that we have an \monoespaco{endchar}
without a previous \monoespaco{beginchar}. Tokens that end character
definition are treated in the same loop than \monoespaco{beginchar}
when in loading mode:

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_ENDCHAR && mf -> loading){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Found 'endchar' token "
                  "without previous 'beginchar'.\n", mf -> file,
          begin -> line);
#endif
  return false;
}
@
\fimcodigo

After, when not in loading mode, we will read all this code
between \monoespaco{beginchar} and \monoespaco{endchar} again. And it
will be important to know and memorize which glyph we are
rendering. So we will create a variable to store this information in
the context struct:

\iniciocodigo
@<Attributes (struct context)@>+=
struct _glyph *current_glyph;
@
\fimcodigo

Finally, let's write code to handle \monoespaco{beginchar} when in
running mode. First we read the string token in the statement. As we
already executed this code in the loading mode, this string token
points to some corresponding glyph, which was already allocated and
initialized. We just need to render it.

The next step will be getting the numeric values in
the \monoespaco{beginchar} header, where we get information about the
width, height and depth and use these values to
reinitialize \monoespaco{currentpicture}. We will use the read values
multiplied by 2, rendering the glyph with twice the size that we will
use in the screen. This way, we get more precise results, rendering in
the screen each pixel as a result multisampled from 4 other
pixels. But we will not use this technique if the
macro \monoespaco{W\_WEAVEFONT\_DISABLE\_MULTISAMPLE} is
defined. Finally, the current pen is modified to be equal
a \monoespaco{nullpen}.

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_BEGINCHAR){
  DECLARE_NESTING_CONTROL();
  begin_nesting_level(mf, cx, begin);
  struct generic_token *t, *begin_expr, *end_expr;
  struct string_token *str;
  struct numeric_variable width, height, depth;
  // First we get the current glyph
  t = begin -> next;
  t = t -> next;
  str = (struct string_token *) t;
  cx -> current_glyph = str -> glyph;
  memset(cx -> current_character, 0, 5);
  memcpy(cx -> current_character, str -> value, 4);
  // Reading the values in the header
  t = t -> next;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(!IS_NOT_NESTED() || t -> type != TYPE_COMMA);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &width))
    return false;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(!IS_NOT_NESTED() || t -> type != TYPE_COMMA);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &height))
    return false;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(!IS_NOT_NESTED() || t -> type != TYPE_CLOSE_PARENTHESIS);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &depth))
    return false;
  *end = t;
  { // Initializing currentpicture = nullpicture(width, height + depth):
    unsigned char *data;
    struct numeric_variable *vars;
    size_t size;
    struct picture_variable *pic = &(mf -> internal_picture_variables[0]);
     if(pic -> texture != 0)
       glDeleteTextures(1, &(pic -> texture));
     vars = ((struct numeric_variable *) mf -> internal_numeric_variables);
#ifdef W_WEAVEFONT_DISABLE_MULTISAMPLE
    mf -> current_depth = round(depth.value);
    pic -> width = round(width.value);
    pic -> height = (round(height.value) + round(depth.value));
    vars[INTERNAL_NUMERIC_W].value = round(width.value);
    vars[INTERNAL_NUMERIC_H].value = round(height.value);
    vars[INTERNAL_NUMERIC_D].value = round(depth.value);
#else
    mf -> current_depth = 2 * round(depth.value);
    pic -> width = 2 * round(width.value);
    pic -> height = 2 * (round(height.value) + round(depth.value));
    vars[INTERNAL_NUMERIC_W].value = 2 * round(width.value);
    vars[INTERNAL_NUMERIC_H].value = 2 * round(height.value);
    vars[INTERNAL_NUMERIC_D].value = 2 * round(depth.value);
#endif
    size = pic -> width * pic -> height * 4;
    data = temporary_alloc(size);
    if(data == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
      return false;
    }
    // Making a new white texture
    memset(data, 255, size);
    { // And turning it transparent
      int i;
      for(i = 3; i < size; i += 4)
        data[i] = 0;
    }
    glGenTextures(1, &(pic -> texture));
    glBindTexture(GL_TEXTURE_2D, pic -> texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, pic -> width, pic -> height, 0,
                 GL_RGBA, GL_UNSIGNED_BYTE, data);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glBindTexture(GL_TEXTURE_2D, 0);
    if(temporary_free != NULL)
      temporary_free(data);
    @<Create new 'currentpicture'@>
  }
  { // Setting currentpen = nullpen:
    mf -> internal_pen_variables[0].format = NULL; // A caneta 'currentpen'
    mf -> internal_pen_variables[0].type = TYPE_T_PEN;
    mf -> internal_pen_variables[0].flags = FLAG_NULL;
    mf -> internal_pen_variables[0].referenced = NULL;
    if(mf -> internal_pen_variables[0].gl_vbo != 0)
      glDeleteBuffers(1, &(mf -> internal_pen_variables[0].gl_vbo));
    mf -> internal_pen_variables[0].gl_vbo = 0;
    mf -> internal_pen_variables[0].indices = 0;
    mf -> pen_lft = mf -> pen_rt = mf -> pen_top = mf -> pen_bot = 0.0;
  }
  return true;
}
@
\fimcodigo

Finally, when we read an \monoespaco{endchar} token not in the loading
mode, this means that we finished to render a new glyph. Then we copy
the rendered picture from \monoespaco{currentpicture} to the new glyph
and get the new glyph dimensions reading
the \monoespaco{currentpicture} size and also the current depth
stored. If we are using multisampling, we adjust the final glyph size
to half the stored value, so that it will always be rendered with half
the actual texture size. Finally, we mark the glyph as already rendered
and erase all \monoespaco{currentpicture} content:

\iniciocodigo
@<Statement: Compound@>+=
else if(begin -> type == TYPE_ENDCHAR){
  struct picture_variable *currentpicture =
                                        &(mf -> internal_picture_variables[0]);
  end_nesting_level(mf, cx, begin);
  cx -> current_glyph -> texture = currentpicture -> texture;
  cx -> current_glyph -> width = round(currentpicture -> width);
  cx -> current_glyph -> depth = round(mf -> current_depth);
  cx -> current_glyph -> height = round(currentpicture -> height -
                                        mf -> current_depth);
  cx -> current_glyph -> texture = currentpicture -> texture;
#ifndef W_WEAVEFONT_DISABLE_MULTISAMPLE
  cx -> current_glyph -> width /= 2;
  cx -> current_glyph -> depth /= 2;
  cx -> current_glyph -> height /= 2;
#endif
  cx -> current_glyph -> need_rendering = false;
  currentpicture -> width = -1;
  currentpicture -> height = -1;
  currentpicture -> texture = 0;
  *end = begin;
  return true;
}
@
\fimcodigo

\secao{13. API Functions to Use the Fonts}

A WEAVEFONT code can have its global variables changed and this will
change the rendering of the next glyphs, without needing to change the
source code or reload the code. To read and update numeric global
variables, we will export the following functions:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
bool _Wwrite_numeric_variable(struct metafont *mf, char *name, float value);
float _Wread_numeric_variable(struct metafont *mf, char *name);
@
\fimcodigo

This function will change the given global variable assigning the
given value to it and also will mark all glyphs as needing to be
rendered again. If a numeric global variable with such name does not
exist, the function returns false. Otherwise, it returns true:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
bool _Wwrite_numeric_variable(struct metafont *mf, char *name, float value){
  struct named_variable *var = (struct named_variable *) mf -> named_variables;
  while(var != NULL){
    if(!strcmp(name, var -> name)){
      struct numeric_variable *n = (struct numeric_variable *) var -> var;
      if(n -> type != TYPE_T_NUMERIC)
        return false;
      n -> value = value;
      {
        int i, j;
        for(i = 0; i < 332; i ++){
          struct _glyph *g = mf -> glyphs[i];
          int size = ((i == 0)?(greatest_point[0] + 1):
                               (greatest_point[i] - greatest_point[i - 1]));
          if(g != NULL){
            for(j = 0; j < size; j ++)
                g[j].need_rendering = true;
          }
        }
      }
      return true;
    }
    var = var -> next;
  }
  return false;
}
@
\fimcodigo

The code to read a gloabal numeric variable is similar. If such
variable does not exist, we return NAN:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
float _Wread_numeric_variable(struct metafont *mf, char *name){
  struct named_variable *var = (struct named_variable *) mf -> named_variables;
  while(var != NULL){
    if(!strcmp(name, var -> name)){
      struct numeric_variable *n = (struct numeric_variable *) var -> var;
      if(n -> type != TYPE_T_NUMERIC)
        return NAN;
      return n -> value;
    }
    var = var -> next;
  }
  return NAN;
}
@
\fimcodigo

The function that reads a file with WEAVEFONT code and creates a new
metafont is:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
struct metafont *_Wnew_metafont(char *filename){
  struct metafont *mf;
  struct context *cx;
  struct generic_token *first, *last;
  bool ret;
  mf = init_metafont(filename);
  lexer(mf, filename, &first, &last);
  cx = init_context(mf);
  ret = eval_program(mf, cx, first, last);
  destroy_context(mf, cx);
  if(!ret){
    _Wdestroy_metafont(mf);
    return NULL;
  }
  return mf;
}
@
\fimcodigo

If we want to render a character and get information about its
dimensions in pixels (width, height, depth, italic correction and
kerning), we can execute the following function:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
bool _Wrender_glyph(struct metafont *mf, char *glyph,
                    char *next_glyph, GLuint *texture,
                    int *width, int *height, int *depth,
                    int *italcorr, int *kerning);
@
\fimcodigo

And the implementation:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
bool _Wrender_glyph(struct metafont *mf, char *glyph,
                    char *next_glyph, GLuint *texture,
                    int *width, int *height, int *depth,
                    int *italcorr, int *kerning){
  struct _glyph *current;
  struct kerning *k;
  struct context *cx = NULL;
  MUTEX_WAIT(mf -> mutex);
  current = get_glyph(mf, (unsigned char *) glyph, false);
  if(current == NULL || current -> begin == NULL || current -> end == NULL){
    MUTEX_SIGNAL(mf -> mutex);
    return false;
  }
  if(current -> need_rendering){
    cx = init_context(mf);
    if(cx  == NULL){
      MUTEX_SIGNAL(mf -> mutex);
      return false;
    }
    if(!eval_list_of_statements(mf, cx, current -> begin, current -> end)){
      destroy_context(mf, cx);
      MUTEX_SIGNAL(mf -> mutex);
      return false;
    }
  }
  *texture = current -> texture;
  *width = current -> width;
  *height = current -> height;
  *depth = current -> depth;
  *italcorr = current -> italic_correction;
  k = current -> kern;
  *kerning = 0;
  while(k != NULL && next_glyph != NULL){
    if(!strcmp(k -> next_char, next_glyph)){
      *kerning = k -> kern;
      break;
    }
    k = k -> next;
  }
  if(cx != NULL)
    destroy_context(mf, cx);
  MUTEX_SIGNAL(mf -> mutex);
  return true;
}
@
\fimcodigo


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim
