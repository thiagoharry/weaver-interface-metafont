\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}

\secao{1. Introduction}

The original METAFONT is a language made to describe typographical
fonts. It was created on 1984 by Donald Knuth and differs from other
formats for allowing a designer to create different fonts merely by
changing basic parameters in the base description of the font. This
way, a designer should not create a single typographic font, but a
meta-font from which new fonts could be obtained changing these basic
parameters.

The original specification for the METAFONT language can be found in
[KNUTH, 1989], but the implementation described here will not be
compatible with that language. Instead, a new language will be
defined, strongly based on the original METAFONT, but with a different
grammar. The new language will have similar objectives, but it will be
focused on defining typographical fonts that could be interpreted and
rendered on the fly.

As this article defines a subsystem for Weaver Game Engine, and more
specifically a subsystem for the user interface modulus, our objective
here will be define the following function that will interpret a file
with METAFONT source code and load as user interface using the letters
read as texture:

\iniciocodigo
@<Function Declaration (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
@
\fimcodigo

And we will need the header for Weaver user interfaces:

\iniciocodigo
@<Include General Headers (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

But besides loading the typographical fonts to a texture, we also want
to create a font structure that could be used to render text for other
functions:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Before acalling any of these function, it is necessary to call a
initialization function that sets which functions will be called in
some contexts and also sets how many pixels correspond to ``1pt'':

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
void Winit_metafont(void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *),
                    void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    uint64_t (*rand)(void), int pt);
@
\fimcodigo

The functions passed as parameters are respectivelly the one that
allocates memory temporarily , other to free what was allocated by it,
a function to make more permanent allocation, the function that frees
what was allocated by it, a function that returns 64 random bits and
finally how many pixels are ``1pt''. The disallocation functions can
be set to NULL.

\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{metafont.h}.

We can show the structure of the file \monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif  
@<Include General Headers (metafont.h)@>
//@<General Macros (metafont.h)@>
@<Data Structures (metafont.h)@>
@<Function Declaration (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Function Declaration
(weaver.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{metafont.c} file related
with this header, its structure is:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Local Headers (metafont.c)@>
@<Local Macros (metafont.c)@>
@<Local Data Structures (metafont.c)@>
@<Local Variables (metafont.c)@>
@<Local Function Declaration (metafont.c)@>
@<Auxiliary Local Functions (metafont.c)@>
@<API Functions Definition (metafont.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\secao{2. Initialization}

First we will define the initialization function. What it will do is
set some static variables with some functions that we will use in the
program. It also will set in a variable how many pixels correspond to
1pt. The variables that will store these information are:

\iniciocodigo
@<Local Variables (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

And the initialization function that sets these variables:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
void Winit_metafont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
}
@
\fimcodigo


\secao{3. Lexer}

The first thing to be created for a language is its lexer. It will
read the source code in a file and will output a list of tokens, where
tokens are the most basic unit in the language. A token is like a
word.

METAFONT recognizes three kind of tokens: numeric, strings and
symbolic. In practice we will subdivide the symbolic tokens in several
kind of subtokens to store and read them in a more efficient way.

A numeric token will be represented internally as a floating point
number. This is different than specified in the original METAFONT,
where a custom numeric representation was used. As here we are
interested in more speed, we will choose floating point numbers
because they have nowadays more hardware support. This is how a
numeric token is represented:

\iniciocodigo
@<Local Data Structures (metafont.c)@>=
#define TYPE_NUMERIC 1
struct numeric_token{
  int type;   // Should be equal 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

And this is how we will represent string tokens:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_STRING 2
struct string_token{
  int type;   // Should be equal 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

We will store only the first 5 bytes of each given string, even if in
the source code the string is bigger. This is so because unlike in the
original METAFONT, our only use for strings are saying wich Unicode
character each glyph should represent. For this we need only 5 bytes
(at most 4 for the character and a final byte 0). But we could use
them to associate a glyph with ligatures like ``ff'', which also fits
in these 5 bytes.

In the case of symbolic tokens, we need to store their entire name to
know which symbolic token we have. We shoul allocate dynamically
a string to store its name:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_SYMBOLIC 3
struct symbolic_token{
  int type;   // Should be equal 'TYPE_SYMBOLIC'
  void *next, *var;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char *value;
};
@
\fimcodigo

We also added in this token a pointer \monoespaco{var}, because the
token can represent a variable, and therefore could need to point to
the memory region with its content.

But this could consume much more memory than needed. Some symbols are
very common and are embedded in the language. These symbols could use
less space. For example, parenthesis, semicolon and commas. We can
represent them with the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_OPEN_PARENTHESIS  4 // '('
#define TYPE_CLOSE_PARENTHESIS 5 // ')'
#define TYPE_COMMA             6 // ','
#define TYPE_SEMICOLON         7 // ';'
@<METAFONT: Symbolic Token Definition@>
// (...)
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

We can define later more reserved symbolic tokens. We just need to
define them to an unique number greater than 6. Any token whose type
is a number greater or equal than 3 is a symbolic token.

Every token have a pointer to a next token. THis happens because
usually they will be part of a linked list. To deallocate the memory
occupied by a token list given a deallocation function and the given
list, we can use the following function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Now the funtion that represents our lexer. It will get as argument an
allocation function and a string with a path for the file with
METAFONT source code. It will return a linked list of tokens:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Lexer: Rule 1@>
    @<Lexer: Rule 2@>
    @<Lexer: Rule 3@>
    @<Lexer: Rule 4@>
    @<Lexer: Rule 5@>
    @<Lexer: Rule 6@>
    // No rule applied: error
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, we used the struct \monoespaco{FILE}, this means that we need to
include the header with data about input/output to be able to read
files:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

The rules to read tokens consist in reading each line in the source
code applying the following rules for each character in the line:

1) If the next character is a space or a period and is not followed by
a period or a decimal digit, then ignore this character and go to the
next one.

\iniciocodigo
@<Lexer: Rule 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

As we are using \monoespaco{isdigit} function, we need to insert the
following header that declares this function:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) If the character is a percent sign, ignore it and also ignore all
other following characters in this line. Percentage sign is how we
start comments in the language.

\iniciocodigo
@<Lexer: Rule 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) If the next character is a decimal digit or a period, then the next
token in numeric. It will be interpreted from the biggest sequence of
decimal digests and a single optional period representing the decimal
dot present in the input.

\iniciocodigo
@<Lexer: Rule 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

4) If the next character is a double quote, the next token will be a
string. Its content will be all other chacarters until the next double
quote that should be in the same line. If we have a double quote
opening a string, but the same line do not have another double quote
to close the string, this is an error.

\iniciocodigo
@<Lexer: Rule 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


5) If the next character is a parenthesis, semicolon or a comma, the
next token will be symbolic and composed by that single character.

\iniciocodigo
@<Lexer: Rule 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Otherwise, the next token will be symbolic and will be composed by
the longest sequence of 12 families of characteres:

\iniciocodigo
@<Lexer: Rule 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer is read according with subrules 6-a to 6-l
  @<Lexer: Rule A@>
  @<Lexer: Rule B@>
  @<Lexer: Rule C@>
  @<Lexer: Rule D@>
  @<Lexer: Rule E@>
  @<Lexer: Rule F@>
  @<Lexer: Rule G@>
  @<Lexer: Rule H@>
  @<Lexer: Rule I@>
  @<Lexer: Rule J@>
  @<Lexer: Rule K@>
  @<Lexer: Rule L@>
  // Depending on buffer content, generates next token
  @<Lexer: New Reserved Symbolic Token@>
  @<Lexer: New Generic Symbolic Token@>
}
@
\fimcodigo

a) The first family of letters are the uppercase and lowercase
alphabetic letters, digits and underline. A digit cannot be the first
character in the sequence, otherwise it would be considered part of a
numeric token.

\iniciocodigo
@<Lexer: Rule A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) The second family is composed by the symbols for greater, equal and
lesser, colon and ``|''.

\iniciocodigo
@<Lexer: Rule B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acute and grave accents.

\iniciocodigo
@<Lexer: Rule C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Plus and minus.

\iniciocodigo
@<Lexer: Rule D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Slash, backslash and multiplication symbol.

\iniciocodigo
@<Lexer: Rule E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Opening brackets

\iniciocodigo
@<Lexer: Rule F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Hash sign, ampersand, at sign and dollar sign.

\iniciocodigo
@<Lexer: Rule G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Circumflex accent and tilde.

\iniciocodigo
@<Lexer: Rule H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Opening brackets.

\iniciocodigo
@<Lexer: Rule I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Closing brackets.

\iniciocodigo
@<Lexer: Rule J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Opening and closing braces.

\iniciocodigo
@<Lexer: Rule K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Lexer: Rule L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo


After reading the characters for our new symbolic token, we check if
we have a reserved symbolic token: a token representing a language
keyword. We can check this using function \monoespaco{strcmp}
comparing the buffer with some keywords. We will store a list of
keywords here:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static char* list_of_keywords[] = {
@<List of Keywords@>
  NULL};
@
\fimcodigo

Therefore, to know if we are dealing with a token that represents a
reserved keyword, we check if it is in this NULL terminated list. If
so, we create a token whose type is chosen according with the position
in this list:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // Token types for keywords begin in 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(dealloc, first_token);
      return NULL;
    }
    @<Change Type in Token Creation for Special Cases@>
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(first_token == NULL)
      first_token = last_token = new_token;
    else{
      ((struct generic_token *) last_token) -> next = new_token;
      last_token = new_token;
    }
    continue;
  }
}
@
\fimcodigo

To use function \monoespaco{strcmp} we need the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <string.h>
@
\fimcodigo


If we do not have a reserved symbolic token, and if we have something
in our buffer, then we generate a new generic symbolic token:

\iniciocodigo
@<Lexer: New Generic Symbolic Token@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Set Pointer to Internal Variable@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

\secao{4. METAFONT Programs}

When we evaluate a METAFONT program, we need two additional
structures. The first one, which we will call \monoespaco{struct
metafont} will contain all the final information extracted from the
typographical font and that will be needed to render each glyph. The
second structure, which we will call \monoespaco{struct context}
represents the current state in our parser and represents information
that we need to know to interpret correctly the token list. This
second structure can be discarded after we read all the tokens from
our font.

The first thing that our parser needs to know is that a METAFONT
program is a list (possibly empty) of statements ended by a symbolic
token \monoespaco{end} or \monoespaco{dump}:

\alinhaverbatim
<Program> -> <List of Statements> end | <List of Statements> dump
\alinhanormal

for us, there will be no difference between these two kind of programs
and symbols \monoespaco{end} and \monoespaco{dump} will be
equivalent. In the original METAFONT, one of them ends programs that
define typographical fonts and the other ends the description of a
base file (something like a basic standard library).

We will define then a new kind of symbolic token to represent this
end-of-file marking:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>=
#define TYPE_END             8 // The symbolic token 'end'
#define TYPE_DUMP            9 // The symbolic token 'dump'
@
\fimcodigo

And let's add both the keywords \monoespaco{end} and \monoespaco{dump}
in ourt list of keywords:

\iniciocodigo
@<List of Keywords@>=
"end", "dump",
@
\fimcodigo

But to simplify, we will not use \monoespaco{TYPE\_DUMP},
only \monoespaco{TYPE\_END} to make the code simpler in the parser:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>=
if(token_type == TYPE_DUMP)
  token_type = TYPE_END;
@
\fimcodigo


The first parser function to be defined is the one that recognizes an
entire program. It basically checks if the program is ended correctly
and if not, generates an error. If the program is ended correctly, it
passes for the next parser function that evaluates list of statements,
marking the beginning and end of such list:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  struct generic_token *previous = NULL;
  while(end != NULL && end -> type != TYPE_END){
    previous = end;
    end = (struct generic_token *) (end -> next);
  }
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file,
                    (previous == NULL)?(1):(previous -> line));
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, previous);
}
@
\fimcodigo

The context struct still will not be entirely defined. We will show
its content while each attribute becames necessary:

\iniciocodigo
@<Data Structures (metafont.h)@>=
struct context{
  @<Attributes (struct context)@>
};
@
\fimcodigo


And as seen above, one of the contents in \monoespaco{struct metafont}
is the file name from where the font was read. We also will store the
functions that will be use to allocate and disallocate the structure
and its elements:

\iniciocodigo
@<Data Structures (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Attributes (struct metafont)@>
};
@
\fimcodigo

Both data structures will have a function that initializes them and
also finalizes them:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct context *cx);
@
\fimcodigo

The structure \monoespaco{metafont} needs to store more informations,
as it could be allocated both using permanent or temporary memory
allocations. Meanwhile, the context always will be temporary and will
be allocated with temporary functions.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Initialization (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Initialization (struct context)@>
  return cx;
}
@
\fimcodigo

And this is the definition for the functions that frees the memory
occupied by these structures:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalization (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct context *cx){
  if(temporary_free != NULL){
    @<Finalization (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo


\secao{5. List of Statements}

A list of potentially empty statements delimited by a semicolon:

\alinhaverbatim
<List of Statements> -> <Empty> | <Statement> ; <List of Statements>
\alinhanormal

The function that will evaluate and interpret a list of statements is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

This function will iterate over each declaration and execute for all
them, in the order thay appear, the function that evaluates individual
statements. For this, the function will find all semicolons and use
them to detect where each statement begins and where they end:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
        if(!ret)
          return false;
      begin = end -> next;
    }
  }
  return ret;
}
@
\fimcodigo

The function above iterates over each statement, ignoring empty
statements. For each non-empty statement, it assures that the
pointers \monoespaco{begin} and \monoespaco{end} delimit the
individual statement. During the iteration we always ensure that we do
not go outside the region delimited by \monoespaco{begin\_token\_list}
and \monoespaco{end\_token\_list}.

\secao{6. Compound Statements}

An individual statement in the language can be composed by many other
statements. The syntax for this is:

\alinhaverbatim
<Statement> -> <Empty> | <Compound> | <Declaration> | <Assignment> |
               <Definition> | <Command>
<Compound> -> begingroup <List of Statements> <Non-Title> endgroup
\alinhanormal

We already know what is a list of statements and already have a
function to eval them. The non-title declaration, for now, will be
treated as any other statement, because we still do not support title
statements (they are isolated strings). Therefore, a compund statement
is just a list of statements delimited by
tokens \monoespaco{begingroup} and \monoespaco{endgroup}.

Then we need to take into account the existance of these two new kind
of special symbolic tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_BEGINGROUP            10 // O token simbólico 'begingroup'
#define TYPE_ENDGROUP              11 // O token simbólico 'endgroup'
@
\fimcodigo

And we add them to the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"begingroup", "endgroup",
@
\fimcodigo

And now the function that will evaluate individual statements. As
seen, there are 8 different kinds of statements:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Statement: Empty@>
  @<Statement: Compound@>
  @<Statement: Declaration@>
  @<Statement: Assignment@>
  //@<Statement: Definition@> 
  //@<Statement: Command@>
  // If we are here, we could not identify the statement:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

In the case of an empty statement, probably we will not need to deal
with them. The function \monoespaco{eval\_list\_of\_statements}
silently ignore them before calling this function. But just in case an
empty statement appear by different means, we will explicitly accept
them with the code below:

\iniciocodigo
@<Statement: Empty@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Now let's deal with the compound statement. The first thing to recall
is that it will be important for the language to know in which nesting
level we are to know the scope of each declared variable. Because of
this, our context will store the current nesting
level. Each \monoespaco{begingroup} should increase by 1 the nesting
level and each \monoespaco{endgroup} should decrease by 1. We declare
the nesting level below:

\iniciocodigo
@<Attributes (struct context)@>=
  int nesting_level;
@
\fimcodigo

This should be initialized as zero:

\iniciocodigo
@<Initialization (struct context)@>=
  cx -> nesting_level = 0;
@
\fimcodigo


The second thing to recall is that if we are in a compound statement,
this means that the end of the declaration pointer could be wrong.
For example, supose that the
function \monoespaco{eval\_list\_of\_statements} evaluated the
following tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;]
\alinhanormal

The function correctly would consider the beginning of the first
statement the token \monoespaco{begingroup}. But wrongly would
consider the token \monoespaco{T2} as the end of this statement.
Because it works in a naive logic, always considering the semicolons
as the delimiters for statements, not considering that statements
could contain semicolons. The end of the first statement should be the
token \monoespaco{endgroup} instead.

Instead of increasing the complexity of
function \monoespaco{eval\_list\_of\_statements} making it aware of
compound statements, we will make the
function \monoespaco{eval\_statements} correct the pointers, making
the pointers to delimit correctly the statement. Only after correcting
the pointers, we can pass the list of statements from the compouns
statement to be evaluated:

\iniciocodigo
@<Statement: Compound@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  struct generic_token *t = begin_token_list, *previous = NULL;
  int nesting_level = 0;
  while(t != NULL){
    if(t -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(t -> type == TYPE_ENDGROUP){
      nesting_level --;
      if(nesting_level == 0)
        break;
    }
    previous = t;
    t = (struct generic_token *) (t -> next);
  }
  *end_token_list = t; // Now the statement is correctly delimited
  if(*end_token_list == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed 'begingroup'.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(previous == begin_token_list) // Empty compound statement
    return true;
  else{
    bool ret;
    cx -> nesting_level ++;
    ret = eval_list_of_statements(mf, cx, ((struct generic_token *)
                                         begin_token_list) -> next,
                                  previous);
    cx -> nesting_level --;
    return ret;
  }
}
@
\fimcodigo


\secao{7. Variable Declarations}

The syntax to declare variables is:

\alinhaverbatim
<Declaration> -> <Type> <List of Declarations>
<Type> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<List of Declarations> -> <Tag> | <Tag> , <List of Declarations>
\alinhanormal

A ``tag'' is basically a symbolic token without a predefined meaning
in the language. For example, ``\monoespaco{tag}'' is a tag, but
``\monoespaco{begingroup}'' is not.

To interpret a declaration, we will introduce the following special
tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_T_BOOLEAN               12 // Symbolic token 'boolean'
#define TYPE_T_PATH                  13 // Symbolic token 'path'
#define TYPE_T_PEN                   14 // Symbolic token 'pen'
#define TYPE_T_PICTURE               15 // Symbolic token 'picture'
#define TYPE_T_TRANSFORM             16 // Symbolic token 'transform'
#define TYPE_T_PAIR                  17 // Symbolic token 'pair'
#define TYPE_T_NUMERIC               18 // Symbolic token 'numeric'
@
\fimcodigo

And then we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


When a variable is declared, we need to do two things:

1) If the variable do not exist in the current nesting level, we
should allocate a new structure to store its content. If it already
exist in the current nesting level, an error is returned. A default
value depending of its type if stored in the variable. But it should
not be used before being initialized.

2) We iterate over the following tokens in the list of tokens until
the end of the list or until the current nesting level ends. When we
find a symbolic token with the variable name, we update its pointer to
the newly allocated variable.


As each variable type has its own information and content, the
specifics about how the variable is created can be different. What all
variables have in common is the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
// Generic variable
struct variable{
  int type;
  int nesting_level;
  void *next;  
};
@
\fimcodigo

All variables first store their type, then their nesting level, and
finally, a ponter for the next variable. Depending on the variable
type, more information could be stored after the pointer for the next
variable.

If we are dealing with a global variable, we could want to preserve
and store its name, just in case if later the user would want to
change the variable content indentifying it by the name. In this case,
we would want to use the following structure to store the name with
the variable:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

And the metafont structure will have pointers for these global
variables, with names and without:

\iniciocodigo
@<Attributes (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

These pointers are initialized with NULL:

\iniciocodigo
@<Initialization (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

To disallocate a list of global variables, we just iterate over the
linked list that they create. Some variables, which are more complex,
could need additional operations before removing them, but we will
deal with them later:

\iniciocodigo
@<Finalization (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

And to disallocate a list with preserved names, we act in a similar
way:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *v = (struct named_variable *)
                                 (mf -> named_variables);
  struct named_variable *next;
  while(v != NULL){
    next = (struct named_variable *) (v -> next);
    mf -> free(v -> name);
    mf -> free(v -> var);
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

In the case of variables that are not global, they will be stored in
contexts, not in the metafont struct. After all, their duration always
will be temporary:

\iniciocodigo
@<Attributes (struct context)@>=
  void *variables;
@
\fimcodigo

The list of variables is initialized as empty:

\iniciocodigo
@<Initialization (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

And we finalize it exactly as the list of global variables:

\iniciocodigo
@<Finalization (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

And now let's interpret the variable declaration:

\iniciocodigo
@<Statement: Declaration@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // Todos os tipos de declaração
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insert Declared Variable@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

Inserting a new variable follows the logic below:

\iniciocodigo
@<Insert Declared Variable@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

The function that inserts a new global variable without its name is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

It will allocate a new variable and store it in the local pointed
by \monoespaco{target}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Initializing New Variable@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Inserting a named variable is done with the following function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

The function works in a similar way, first allocating the structure
with the variable nam and then placing the variable there:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));

  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL)
    mf -> named_variables = named;
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

Anf finally, the function that search in a list of tokens for symbolic
tokens with the same name that the allocated new variable and updating
each one to make them point to the newly allocated variable position:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

The function will walk in the linked list starting in the token next
to the declared variable. And t will stop only when there is no more
tokens or when the variable do not exist anymore because we are not
more in its nesting level (it happens when we find
the \monoespaco{endgroup} which ends the current nesting level):

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo



\subsecao{7.1. Numeric Variables}

A numeric variable will be stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparing numeric variables with generic variables, the difference is
that we have an additional floating point variable in the structure
called \monoespaco{value}. It will store the numeric value. When we
create a numeric variable, we initialize it with NaN, which represents
an unknown value:

\iniciocodigo
@<Initializing New Variable@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

Using the macro \monoespaco{NAN} requires the mathematical header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

In the case of numeric variables, nothing additional is needed when we
deallocate them, as they have no additional structure besides a single
floating-point number.

However, besides the variables declared by the users, our version of
the Metafont language will have some additional internal
variables. They always will be present and do not need to be
declared. We will have exactly three of
them: \monoespaco{pt}, \monoespaco{cm} and \monoespaco{mm}. Basically
they will store how many pixels correspond to 1pt, 1cm and 1mm
respectively.

Such internal numeric variables will be declared in the metafont
struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

During the initialization we will allocate space for the three
variables and fill their values:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   pt;
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   28.3465 * pt; // 1cm = 28.3465pt
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   2.83465 * pt; // 1mm = 2.83465pt
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;    

  }
}
@
\fimcodigo

We also will create the following macros to access each one of these
variables more easily:

\iniciocodigo
@<Local Macros (metafont.c)@>=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

To finalize the metafont structure, we need to deallocate these
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

When our lexer creates a new symbolic token which is not a reserved
word, it should check if this token have the same name than an
internal variable. If so, we can then set correctly the pointer to the
variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\secao{8. Assignments}

Assignments are how we initialize variables, how we modify their
values and how we store the result of expressions.

The syntax for an assignment is:

\alinhaverbatim
<Assignment> -> <Variable> = <Right Side> |
                <Variable> := <Right Side> |
<Right Side> -> <Expression> | <Assignment>
\alinhanormal

This means that we can chain assignments, for example, in the code
below, all variables, if numeric, will store the value 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

If in the beginning of a statement we find a variable, then certainly
we are dealing with an assignment.

We will begin teaching our lexer that both tokens ``\monoespaco{=}''
and ``\monoespaco{:=}'' are equivalent, represent the same thing and
have an special meaning:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_ASSIGNMENT            19 // Symbolic token '='
#define TYPE_ASSIGNMENT2           20 // Symbolic token ':='
@
\fimcodigo

Both types are added to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"=", ":=",
@
\fimcodigo

But to simplify the code, we will transform the second type in the
first and consider only the first kind of assignment:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>+=
else if(token_type == TYPE_ASSIGNMENT2)
  token_type = TYPE_ASSIGNMENT;
@
\fimcodigo


Now that we have this new kind of token, the code to evaluate
assignments is described below. What it does is walk over the tokens
in the assignment detecting all variables that should pass by the
assignment. While it does it, it checks if all them are declared, if
all them have the same type, if we are assigning to something that is
not a variable, if we forget the assignment symbol, or if we are
missing an expression after the assignment. If one of these things are
detected, an error is generated.

The part that we still will not show is how we evaluate the expression
after the last assignment symbol and how in the end we update the
value for each variable to be equal what was evaluated. How we do
these things change depending on the variable types, each type have
its own expressions and its own way of storing the value in the
variables. These details will be shown in the next subsections.

\iniciocodigo
@<Statement: Assignment@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  struct generic_token *begin_expression;
  int type = 0; // Tipo das variáveis na atribuição
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment.\n", mf -> file,
              var -> line);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;    
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;    
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Assignment for Numeric Variables@>
  return true;
}
@
\fimcodigo

\subsecao{8.1. Numeric Assignments and Expressions}

How do we assign numeric variables given the code above? We use the
following code:

\iniciocodigo
@<Assignment for Numeric Variables@>=
if(type == TYPE_T_NUMERIC){
  int i;
  bool ret;
  struct numeric_variable result;
  ret = eval_numeric_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                               &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_numeric_variable((struct numeric_variable *) var -> var,
                            &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The function that makes the assignment is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source);
@
\fimcodigo

And its simple implementation is given below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source){
  target -> value = source -> value;
}
@
\fimcodigo

Now we will write how to interpret numeric expressions.

\subsubsecao{8.1.1. Sum and Subtraction: Normal and Pythagorean}

The rules for numeric expressions begins as:

\alinhaverbatim
<Numeric Expression> -> <Numeric Tertiary>
<Numeric Tertiary> -> <Numeric Secundary> |
                      <Numeric Tertiary> <T-Op> <Numeric Secundary>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

The symbols \monoespaco{+} and \monoespaco{-} represent the usual
addition and subtraction. The symbol \monoespaco{++} should not be
confused with C language increment and means the pythagorean sum:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

This can be easily computed in C using the
function \monoespaco{hypot} from the standard math library.

The symbol \monoespaco{+-+} is the ``pythagorean subtraction'' defined
below:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

We will compute the pythagorean subtraction using the last definition,
as the multiplication of two square roots. This is the computation
that minimizes errors involving overflows and underflows.

The four operators above are the ones with smaller precedence. These
operations will be done only after all other mathematical operations.

Now we will improve our lexer making it identify and create the new
tokens for these operators. We also will create new token types for
``['' and ``]'', as we will need to identify these tokens in our
parser:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_SUM                   21 // Symbolic token '+'
#define TYPE_SUBTRACT              22 // Symbolic token '-'
#define TYPE_PYTHAGOREAN_SUM       23 // Symbolic token '++'
#define TYPE_PYTHAGOREAN_SUBTRACT  24 // Symbolic token '+-+'
#define TYPE_OPEN_BRACKET          25 // Symbolic token '['
#define TYPE_CLOSE_BRACKET         26 // Symbolic token ']'
@
\fimcodigo

And we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"+", "-", "++", "+-+", "[", "]",
@
\fimcodigo

Now let's evaluate numeric expressions, which means evaluating
tertiary numeric expressions. The function is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

The tertiary numeric expressions is where we solve additions and
subtractions. By the syntax rules, what we need to do is walk over the
tokens in the expression until find the last tertiary operator that is
not delimited by parenthesis or brackets. Everything in the left side
should be recursively evaluated as another tertiary
expression. Everything in the right side should be interpreted as a
secundary numeric expression. Finally, if we did not find any tertiary
operator, the entire expression is evaluated as a secundary numeric
expression.

However, there are some exceptions, cases in which the
symbols \monoespaco{+} and \monoespaco{-} should not be treated as a
sum or subtraction. This happens if they are in the beginning of the
numeric expression, or if before them there is a comma, an opening
bracket, a multiplication or division symbol, a
token \monoespaco{length} or if before it there is another tertiary
operator. The code below also need to consider these exceptions:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secundary,
                       *last_sum = NULL, *p, *prev = NULL;
  int nesting_parenthesis = 0, nesting_brackets = 0;
  struct numeric_variable a, b;
  p = begin_expression;
  do{
    if(p -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_OPEN_BRACKET)
      nesting_brackets ++;
    else if(p -> type == TYPE_CLOSE_BRACKET)
      nesting_brackets --;
    else if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
            (p -> type == TYPE_PYTHAGOREAN_SUM ||
             p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
             ((p -> type == TYPE_SUM || p -> type == TYPE_SUBTRACT) && 
              (prev != NULL && prev -> type != TYPE_COMMA &&
               prev -> type != TYPE_OPEN_BRACKET &&
               prev -> type != TYPE_LENGTH &&
               prev -> type != TYPE_MULTIPLICATION &&
               prev -> type != TYPE_DIVISION &&
               prev -> type != TYPE_SUM &&
               prev -> type != TYPE_SUBTRACT &&
               prev -> type != TYPE_PYTHAGOREAN_SUM &&
               prev -> type != TYPE_PYTHAGOREAN_SUBTRACT)))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secundary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_numeric_secundary(mf, cx, begin_secundary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM)
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT)
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM)
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Negative square root "
                " in pythagorean subtraction.\n", mf -> file,
                var -> line);
#endif
        return false;
      }
    }
    return true;
  }
  else
    return eval_numeric_secundary(mf, cx, begin_expression,
                                  end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.2. Multiplication and Division}

The rules to deal with secundary numeric expressions are:

\alinhaverbatim
<Numeric Secundary> -> <Numeric Primary> |
                       <Numeric Secundary> <S-Op> <Numeric Primary>
<S-Op> -> * | /
\alinhanormal

The operators \monoespaco{*} and \monoespaco{/} are respectively the
multiplication and division.

Let's add these operators as reserved tokens and define their types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_MULTIPLICATION        27 // Symbolic token '*'
#define TYPE_DIVISION              28 // Symbolic token '/'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"*", "/",
@
\fimcodigo

The function that will evaluate numeric secundary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

And its definition is very similar with the function that evaluates
tertiary expressions, except that this function computes
multiplication and division. However, there is an additional rule that
we should be aware: the token ``/'' will be considered division only
if it is not delimited by two numeric tokens. If so, then it
represents a fraction and it should be computed with a higher
precedence than what we deal here:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_secundary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL;
  int nesting_parenthesis = 0, nesting_brackets = 0;
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin_expression;
  do{
    if(p -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_OPEN_BRACKET)
      nesting_brackets ++;
    else if(p -> type == TYPE_CLOSE_BRACKET)
      nesting_brackets --;
    else if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
            (p -> type == TYPE_MULTIPLICATION ||
             (p -> type == TYPE_DIVISION &&
             (prev -> type != TYPE_NUMERIC || p == end_token_list ||
              ((struct generic_token *) p -> next) -> type !=
               TYPE_NUMERIC)))){
      last_mul = p;
      end_secundary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secundary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secundary(mf, cx, begin_expression, end_secundary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end_token_list, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION)
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){
      if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.\n",
                mf -> file, last_mul -> line);
#endif
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else
    return eval_numeric_primary(mf, cx, begin_expression,
                                end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.3. Modulus and Intermediary Values}

The rules for primary numeric expressions are:

\alinhaverbatim
<Numeric Primary> -> <Numeric Atom> |
                     <Numeric Atom> [ <Numeric Expression> ,
                                      <Numeric Expression> ] |
                     length <Numeric Primary> | (...) |
                     <Numeric Operator> <Numeric Primary>
<Numeric Operator> -> sqrt | sind | cosd | mlog | mexp | floor |
                       uniformdeviate |
                       <Scalar Multiplication Operator>
<Scalar Multiplication Operator> -> + | - |
                       <Primary Numeric Token Before Variable>
<Primary Numeric Token> -> <Numeric Token> / <Numeric Token> |
                           <Numeric Token>
\alinhanormal

The operator \monoespaco{length}, when appearing before a numeric
primery means that we want its modulus. If it appears before another
kind of primary expression, it could mean different things. The
bracket operator means:

$$
a[b, c] = a(b+c)
$$

It allow us to write an an alternate way that the half between the
numbers $a$ and $b$ (their mean) is $.5[a, b]$.

The new modulus operator should be added to the list of reserved
words. We will add also the other new operators from the list of
numeric operators. The brackets are already in this list:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_LENGTH         29 // Symbolic token 'length'
#define TYPE_SQRT           30 // Symbolic token 'sqrt'
#define TYPE_SIND           31 // Symbolic token 'sind'
#define TYPE_COSD           32 // Symbolic token 'cosd'
#define TYPE_LOG            33 // Symbolic token 'log'
#define TYPE_EXP            34 // Symbolic token 'exp'
#define TYPE_FLOOR          35 // Symbolic token 'floor'
#define TYPE_UNIFORMDEVIATE 36 // Symbolic token 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

The function that evaluates a primary numeric expression is this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result);
@
\fimcodigo


We can decide which syntax rule should be applied while evaluating the
primary numeric expression using seven different interpretation rules:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result){
  @<Numeric Primary: Rule 1@>
  @<Numeric Primary: Rule 2@>
  @<Numeric Primary: Rule 3@>
  //@<Numeric Primary: Rule 4@>
  //@<Numeric Primary: Rule 5@>
  //@<Numeric Primary: Rule 6@>
  //@<Numeric Primary: Rule 7@>
  return true;
}
@

The rules are:

1) If the expression have a single token, it is a numeric
atom. However, as this case is the most common, we can deal with it
without calling further recursive functions. We just copy the content
present in this token to the result of the expression and return:

\iniciocodigo
@<Numeric Primary: Rule 1@>=
if(begin_expression == end_expression){
  if(begin_expression -> type == TYPE_NUMERIC){
    result -> value = ((struct numeric_token *)begin_expression) -> value;
    return true;
  }
  else if(begin_expression -> type == TYPE_SYMBOLIC){
    struct numeric_variable *var = (struct numeric_variable *)
                                     ((struct symbolic_token *)
                                      begin_expression) -> var;
    if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-declared "
              "variable '%s'.\n", mf -> file, begin_expression -> line,
              ((struct symbolic_token *) begin_expression) -> value);
#endif
      return false;
    }
    if(var -> type != TYPE_T_NUMERIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric "
              "variable '%s' in numeric expression.\n", mf -> file,
              begin_expression -> line,
              ((struct symbolic_token *) begin_expression) -> value);
#endif
      return false;
    }
    if(isnan(var -> value)){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-initialized "
              "variable '%s' in numeric expression.\n", mf -> file,
              begin_expression -> line,
              ((struct symbolic_token *) begin_expression) -> value);
#endif
      return false;
    }
    result -> value = var -> value;
    return true;
  }
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric "
            "token in numeric expression.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;

  }
}
@
\fimcodigo

2) If we find the operator \monoespaco{length}, we just check if the
following expression is numeric, and if so, we compute its modulus. If
the type is not numeric, we will define later how to proceed. This
assumes that we have a function that identifies correctly the type of
a given primary expression.

\iniciocodigo
@<Numeric Primary: Rule 2@>=
else if(begin_expression -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx,
                                             (struct generic_token *)
                                             begin_expression -> next,
                                             end_expression);
  if(expr_type == TYPE_T_NUMERIC){
    bool ret;
    struct numeric_variable num;
    ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                               begin_expression -> next,
                               end_expression, &num);
    if(!ret)
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  //@<Avalia 'length'@>
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "primary expression after 'length'.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;
  }
}
@
\fimcodigo

But how can we identify if we are facing a numeric priumary expression
or an expression of different kind? Well, reading its tokens. We still
cannot define a function that does this completely, as we still did
not define how are functions of different types. But for now we will
present the more simplist definition that if the expression is
composed by a single token, if numeric, the expression is numeric, and
if it is a variable, the expression have the same type than the
variable. This captures the simplest case:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(begin_expr -> type == TYPE_SYMBOLIC){
      struct symbolic_token *p = (struct symbolic_token *) begin_expr;
      if(p -> var == NULL)
        return 0; // Unknown
      else{
        struct variable *v = (struct variable *) (p -> var);
        return v -> type;
      }
    }
  }
  else{
    //@<Discover Primary Expression Type@>
  }
  return TYPE_T_NUMERIC;
  //return 0; // Unknown
}
@
\fimcodigo

3) If we find some of the numeric operators, we have a numeric
operator followed by a numeric primary expression.

The first numeric operator is the square root:

\iniciocodigo
@<Numeric Primary: Rule 3@>=
else if(begin_expression -> type == TYPE_SQRT){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value < 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Square root "
            "of negative number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;  
}
@
\fimcodigo

Next we have the operator \monoespaco{sind}, which interprets the next
number in degrees (because of this it has the letter ``d'' in the end)
and computes the sine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SIND){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = sinf(num.value * 0.0174533);
  return true;  
}
@
\fimcodigo

Computing the cosine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_COSD){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the logarithm in $e$ basis:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_LOG){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value <= 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Computing logarithm of "
            "non-positive number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }    
  result -> value = logf(num.value);
  return true;  
}
@
\fimcodigo

And the exponential which means $exp x = e^x$:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_EXP){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = expf(num.value);
  return true;  
}
@
\fimcodigo

The floor of a given value:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_FLOOR){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = floorf(num.value);
  return true;  
}
@
\fimcodigo

About the operator \monoespaco{uniformdeviate}, it generates a number
uniform and random between 0 and the value passed as operand. We can
compute this generating a number between 0 and 1 and then multiply
this value with the operand.

Generating a floating point number between 0 and 1 following a
distribution near to uniform can be done generating a random 64-bit
number and then multiplying it with $2^{-64}$. Not all possible
floating-point numbers could be represented generating them this
way. Numbers smaller than $2^{-64}$ would be ignored and the rounding
would make some numbers near 1 more probable, but we also would have
less density in the range near 1. However, despithe these drawbacks,
the result would be sufficiently precise for our purposes:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_UNIFORMDEVIATE){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = ldexpf((float) random_bits, -64);
    result -> value = multiplicand * num.value;  
  }
  return true;  
}
@
\fimcodigo

If the next operator is the symbol \monoespaco{+}, this means a
multiplication by 1. This operation can be ignored:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUM){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  return true;  
}
@
\fimcodigo

But if the operator is a symbol \monoespaco{-}, hen this means a
multiplication by -1:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUBTRACT){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  result -> value *= -1; 
  return true;  
}
@
\fimcodigo


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim
