\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\twelvebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Usuário Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém uma implementação de um interpretador para
 uma linguagem baseada no METAFONT. Esta linguagem é projetada para
 permitir a definição de fontes tipográficas flexíveis e
 parametrizadas que podem ser interpretadas e renderizadas rapidamente
 à medida que são lidas. Por causa disso, nós sacrificamos alguma
 flexibilidade da linguagem METAFONT original para sermos capazes de
 criar resultados mais rápidos. A implementação será usada pelo Motor
 de Jogos Weaver como um módulo e usará OpenGL moderno para renderizar
 as fontes.}

\secao{1. Introdução}

A linguagem METAFONT original é uma linguagem feita para descrever
fontes tipográficas. Ela foi criada em 1984 por Donald Knuth e difere
de outros formatos de fontes tipográficas por permitir a criação de
fontes à partir da modificação de parâmetros definidos na descrição
básica da fonte. Desta forma, o projetista de uma fonte não deve criar
uma simples fonte tipográfica, mas uma meta-fonte, a qual pode por sua
vez gerar muitas outras fontes tipográficas diferentes mediante a
simples modificação dos parâmetros.

A especificação original da linguagem METAFONT pode ser encontrada em
[KNUTH, 1989], mas a implementação aqui não será compatível com a
linguagem original. Ao invés disso uma nova linguagem será definida,
mas ela terá objetivos similares.

Como este artigo define um subsistema do Motor de Jogos Weaver, e mais
especificamente um subsistema de interface de usuário, nosso objetivo
aqui será definir a seguinte função que irá interpretar um arquivo com
código METAFONT e irá gerar uma interface de usuário com as letras
lidas como textura:

\iniciocodigo
@<Declaração de Função (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
                        void (*permanent_free)(void *),
                        void *(*temporary_alloc)(size_t),
                        void (*temporary_free)(void *),
                        void (*before_loading_interface)(void),
                        void (*after_loading_interface)(void),
                        char *source_filename,
                        struct user_interface *target);
@
\fimcodigo

E nós precisamos inserir o cabeçalho Weaver de interface de usuário:

\iniciocodigo
@<Inclui Cabeçalhos Gerais (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

Mas além de simplesmente carregar as fontes tipográficas lidas para um
arquivo, é importante poder gerar também uma estrutura de dados
representando a fonte lida, para que ela depois possa ser usada por
uma função que renderiza texto:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Antes de chamar qualquer uma das funções acima, será importante chamar
a seguinte função de inicialização que especifica ãlgumas das funções
que devem ser usadas, e além disso nos informa quantos píxels
correspontem à unidade de medida de ``1pt'':

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
bool _Winit_metafont(void *(*temporary_alloc)(size_t),
                     void (*temporary_free)(void *),
                     void *(*permanent_alloc)(size_t),
                     void (*permanent_free)(void *),
                     uint64_t (*rand)(void), int pt);
@
\fimcodigo

As funções passadas como argumento para tal inicializador são
respectivamente uma para fazer alocações temporárias de memória, outra
para desalocar o que foi alocado com ela (pode ser NULL), outra para
fazer alocações mais permanentes, outra para desalocar o que foi
alocado com ela (pode ser NULL também), uma para gerar 64 bits
aleatórios e por fim a medida de quantos píxels correspondem a 1pt. A
função retorna verdadeiro se a inicialização foi bem-sucedida.

Após terminar o uso de nossas funções, deve-se chamar a função abaixo
que finaliza e desaloca qualquer coisa que tenha sido gerada pela
função de inicialização:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
void _Wfinish_metafont(void);
@
\fimcodigo



\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{metafont.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
#if !defined(_WIN32)
#include <sys/param.h> // Necessário no BSD, mas causa problema no Windows
#endif
@<Inclui Cabeçalhos Gerais (metafont.h)@>
//@<Macros Gerais (metafont.h)@>
@<Estrutura de Dados (metafont.h)@>
@<Declaração de Função (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (metafont.h)'', o mesmo nome apresentado no
trecho de código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{metafont.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Cabeçalhos Locais (metafont.c)@>
@<Macros Locais (metafont.c)@>
@<Estrutura de Dados Locais (metafont.c)@>
@<Variáveis Locais (metafont.c)@>
@<Declaração de Função Local (metafont.c)@>
@<Funções Auxiliares Locais (metafont.c)@>
@<Definição de Funções da API (metafont.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{2. Inicialização e Finalização}

Primeiro vamos definir a função de inicialização. O que ela fará será
armazenar em uma série de variáveis estáticas várias das funções que
iremos usar no programa, além de nos informar quantos píxels
correspondem a 1 pt. As variáveis que armazenarão tais informações são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

E a função de inicialização consiste em preencher tais variáveis:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>=
bool _Winit_metafont(void *(*t_alloc)(size_t),
                     void (*t_free)(void *),
                     void *(*p_alloc)(size_t),
                     void (*p_free)(void *),
                     uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
  @<Inicialização de Weaver Metafont@>
  return true;
}
@
\fimcodigo

A função de finalização também existe e à medida que adicionarmos mais
coisas à inicialização, poderemos precisar adicionar código
correspondente à finalização:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>=
void _Wfinish_metafont(void){
  @<Finalização de Weaver Metafont@>
}
@
\fimcodigo

\secao{3. Analisador Léxico}

A primeira coisa a criar para uma linguagem é seu analisador
léxico. Ele irá ler o código-fonte da linguagem presente em um arquivo
e irágerar uma lista de ``tokens'', sendo cada token a unidade mais
básica da linguagem, basicamente uma palavra.

METAFONT reconhece três tipos de tokens: numéricos, strings e
simbólicos. Na prática nós iremos dividir os tokens simbólicos em
diferentes tipos de subtokens para podermos armazená-los e lê-los de
maneira mais eficiente.

Um token numérico será representado internamente como um número em
ponto flutuante. Nisso iremos diferir do METAFONT original que usava
uma representação própria de números. Em nome de operações mais
rápidas, usaremos a forma moderna de representar números. Então essa é
a aparência de um token numérico:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>=
#define TYPE_NUMERIC 1
struct numeric_token{
  int type;   // Deve ser igual a 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

E isso é como representaremos tokens de strings:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_STRING 2
struct string_token{
  int type;   // Deve ser igual a 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

Nós iremos armazenar apenas os primeiros 5 bytes de cada string que
encontrarmos, mesmo que no código-fonte a string seja maior. Isso será
feito porque ao contrário do METAFONT original, a única utilidade para
strings aqui será indicar qual caractere Unicode deve estar associado
a cada glifo definido. Para isso nós precisamos de apenas 5 bytes (no
máximo 4 para o caractere mais o byte 0 final). E também podemos usar
eles para associar certos glifos a ligaduras como ``ff'', que também
cabe em 5 bytes.

Já no caso de tokens simbólicos, precisamos armazenar todo o seu
conteúdo para podermos saber qual token temos, e vamos alocar
dinamicamente de acordo com o tamanho do símbolo:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_SYMBOLIC 3
struct symbolic_token{
  int type;   // Deve ser igual a 'TYPE_SYMBOLIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  void *var;
  char *value;
};
@
\fimcodigo

Também colocamos neste token o ponteiro \monoespaco{var}, já que ele
pode corresponder a uma variável, e por isso pode precisar apontar
para a região da memória com o conteúdo da variável.

Mas isso pode consumir mais espaço na memória do que é
necessário. Alguns símbolos são muito comuns e são definidos por
padrão na própria linguagem e podem usar menos espaço que isso. Por
exemplo, parênteses e vírgulas. Podemos representar eles com a
seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_OPEN_PARENTHESIS  4 // '('
#define TYPE_CLOSE_PARENTHESIS 5 // ')'
#define TYPE_COMMA             6 // ','
#define TYPE_SEMICOLON         7 // ';'
@<METAFONT: Definição de Token Simbólico@>
// (...)
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

Podemos definir posteriormente muitos outros tipos de tokens
simbólicos reservados. Basta definirmos eles associando a um número
único maior do que 6. Qualquer token cujo tipo é um número igual ou
maior que 3 é simbólico.

Todo token possui um ponteiro para um próximo token. Isso ocorre
porque eles geralmente formarão uma lista encadeada de tokens. Para
desalocar a memória ocupada por uma lista de tokens dada uma função de
desalocação e apagá-los, pode-se usar a seguinte função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Agora a função que fará a análise léxica. Ela receberá como argumento
a estrutura da fonte, uma função de alocação de memória e uma string
com caminho para arquivo com código-fonte METAFONT. Ela retornará uma
lista encadeada de tokens:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Análise Léxica: Regra 1@>
    @<Análise Léxica: Regra 2@>
    @<Análise Léxica: Regra 3@>
    @<Análise Léxica: Regra 4@>
    @<Análise Léxica: Regra 5@>
    @<Análise Léxica: Regra 6@>
    // Nenhuma regra aplicada: erro
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, como usamos o tipo \monoespaco{FILE}, precisamos inserir o
cabeçalho de entrada e saída padrão para podermos abrir e ler
arquivos:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

As regras para ler os tokens consiste em ler cada linha do código
fonte aplicando as seguintes regras para cada novo caractere lido:

1) Se o próximo caractere é um espaço ou um ponto que não é sucedido
por um dígito decimal ou um novo ponto, ignore-o e siga em frente.

\iniciocodigo
@<Análise Léxica: Regra 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

Como estamos usando a função \monoespaco{isdigit}, devemos inserir o
seguinte cabeçalho que a declara:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) Se o próximo caractere é o símbolo de porcentagem, ignore-o e
ignore todos os outros caracteres seguintes na linha. Este símbolo
marca o começo de comentários na linguagem.

\iniciocodigo
@<Análise Léxica: Regra 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) Se o próximo caractere é um dígito decimal ou um ponto seguido por
um dígito decimal, então o próximo token será numérico. E é formado
pela maior sequência possível de ser lida envolvendo dígitos decimais
e opcionalmente um único ponto representando o ponto decimal.

\iniciocodigo
@<Análise Léxica: Regra 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


4) Se o próximo caractere é uma aspa dupla, então o próximo token deve
ser uma string e será composto pela sequência de caracteres até a
próxima aspa dupla, que deve estar na mesma linha. Se existir uma aspa
dupla iniciando uma string, mas não existir outra para finalizar a
string na mesma linha, um erro será gerado.

\iniciocodigo
@<Análise Léxica: Regra 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

5) Se o próximo caractere for um parêntese, ponto-e-vírgula ou uma
vírgula, então o próximo token será um token simbólico formado por
este único caractere.

\iniciocodigo
@<Análise Léxica: Regra 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Caso contrário, o próximo token será simbólico e formado pela
sequência mais longa dentre 12 famílias de caracteres:

\iniciocodigo
@<Análise Léxica: Regra 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer é lido de acordo com as subregras 6-a a 6-l
  @<Análise Léxica: Regra A@>
  @<Análise Léxica: Regra B@>
  @<Análise Léxica: Regra C@>
  @<Análise Léxica: Regra D@>
  @<Análise Léxica: Regra E@>
  @<Análise Léxica: Regra F@>
  @<Análise Léxica: Regra G@>
  @<Análise Léxica: Regra H@>
  @<Análise Léxica: Regra I@>
  @<Análise Léxica: Regra J@>
  @<Análise Léxica: Regra K@>
  @<Análise Léxica: Regra L@>
  // De acordo com conteúdo do buffer, gera o próximo token
  @<Análise Léxica: Gera Token Simbólico Reservado@>
  @<Análise Léxica: Gera Token Simbólico Genérico@>
}
@
\fimcodigo


a) A primeira família de letras são as letras de A a Z maiúsculas e
minúsculas além do ``underline'' e dígitos. Um dígito não pode ser o
primeiro caractere da sequência, ou ele seria interpretado como um
token numérico.


\iniciocodigo
@<Análise Léxica: Regra A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) A segunda família são os símbolos de maior, menor, igual, dois
pontos e a barra vertical.

\iniciocodigo
@<Análise Léxica: Regra B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acento agudo e grave.

\iniciocodigo
@<Análise Léxica: Regra C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Mais e menos.

\iniciocodigo
@<Análise Léxica: Regra D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Barra, barra invertida e símbolo de multiplicação.

\iniciocodigo
@<Análise Léxica: Regra E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Ponto de interrogação e exclamação.

\iniciocodigo
@<Análise Léxica: Regra F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Cerquilha, ``e'' comercial, arroba e cifrão.

\iniciocodigo
@<Análise Léxica: Regra G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Acento circunflexo e til.

\iniciocodigo
@<Análise Léxica: Regra H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Abrir colchetes.

\iniciocodigo
@<Análise Léxica: Regra I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Fechar colchetes.

\iniciocodigo
@<Análise Léxica: Regra J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Abrir e fechar chaves.

\iniciocodigo
@<Análise Léxica: Regra K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Análise Léxica: Regra L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

Depois de ler todos os caracteres do próximo token, primeiro vemos se
estamos diante de um token simbólico reservado. Estes são tokens
simbólicos com o que seriam palavras-chave da linguagem. Podemos
identificá-los porque iremos armazenar uma lista de palavras-chave
reservadas da linguagem aqui:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static char* list_of_keywords[] = {
@<Lista de Palavras Reservadas@>
  NULL};
@
\fimcodigo

Sendo assim, sabemos que temos um token que corresponde a uma
palavra-chave reservada se ele estiver presente nesta lista terminada
em NULL. Se for o caso, geramos um token especial com um tipo
dependendo de sua posição na lista:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Reservado@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // O tipo de tokens reservados começa no 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(dealloc, first_token);
      return NULL;
    }
    @<Muda Tipo na Geração de Tokens em Casos Especiais@>
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(first_token == NULL)
      first_token = last_token = new_token;
    else{
      ((struct generic_token *) last_token) -> next = new_token;
      last_token = new_token;
    }
    continue;
  }
}
@
\fimcodigo

Para usar a função \monoespaco{strcmp}, precisamos do seguinte
cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <string.h>
@
\fimcodigo

Se não for um token simbólico reservado, e se existir algo copiado
para o nosso buffer, então geramos um novo token simbólico genérico:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Genérico@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Preenche Ponteiro para Variável Interna@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


\secao{4. Programas METAFONT}

Quando avaliamos um programa METAFONT, vamos precisar de duas
extruturas adicionais. A primeira delas, a qual chamaremos
de \monoespaco{struct metafont} irá conter as informações finais da
fonte tipográfica que foi lida e que terá tudo que for necessário para
que tal fonte possa ser usada para renderizar cada um dos glifos. A
segunda estrutura, a qual chamaremos de \monoespaco{struct context}
representa o estado atual do analisador sintático e representa
informações que devemos saber para poder continuar interpretando
corretamente uma lista de tokens. Essa segunda estrutura pode ser
descartada depois de terminarmos de ler os tokens de nossa fonte.

A primeira coisa que nosso analisador sintático precisa saber é que
todo programa METAFONT é uma sequência de declarações (possivelmente
vazia) finalizada por um token simbólico que
representa \monoespaco{end} ou \monoespaco{dump}:

\alinhaverbatim
<Programa> -> <Lista de Declarações> end | <Lista de Declarações> dump
\alinhanormal

Para nós não haverá nenhuma diferença entre \monoespaco{end}
e \monoespaco{dump}. No METAFONT original, o primeiro era usado para
finalizar o programa de uma fonte tipográfica e o segundo para
finalizar a descrição de um arquivo-base (algo como uma biblioteca
padrão básica).

Vamos definir então um novo tipo de token simbólico que será uma
abreviação deste símbolo de finalização, seja qual ele for:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>=
#define TYPE_END             8 // O token simbólico 'end'
#define TYPE_DUMP            9 // O token simbólico 'dump'
@
\fimcodigo

E vamos adicionar tanto a palavra-chave \monoespaco{end}
como \monoespaco{dump} na lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>=
"end", "dump",
@
\fimcodigo

Mas para simplificar, não iremos usar o \monoespaco{TYPE\_DUMP}, ele
será sempre transformado em \monoespaco{TYPE\_END} para facilitar o
nosso código no analisador sintático:

\iniciocodigo
@<Muda Tipo na Geração de Tokens em Casos Especiais@>=
if(token_type == TYPE_DUMP)
  token_type = TYPE_END;
@
\fimcodigo

A primeira função de análise sintática que definiremos é a que
reconhece um programa inteiro. Ela basicamente checa se o programa é
corretamente finalizado e se não o for, retorna erro. Caso ele esteja
corretamente finalizado, ela passa o programa para a próxima função de
análise sintática que interpreta lista de declarações, marcando o
começo e o fim da lista de declarações:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  struct generic_token *previous = NULL;
  while(end != NULL && end -> type != TYPE_END){
    previous = end;
    end = (struct generic_token *) (end -> next);
  }
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file,
                    (previous == NULL)?(1):(previous -> line));
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, previous);
}
@
\fimcodigo

A estrutura de contexto ainda não será definida inteiramente. Iremos
mostrar o conteúdo dela à medida que for necessário:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>=
struct context{
  @<Atributos (struct context)@>
};
@
\fimcodigo

E como indicado acima, um dos conteúdos de \monoespaco{struct
metafont} é o arquivo de onde saiu a fonte que ele representa. Também
vamos armazenar o que é necessário para alocar e desalocar a estrutura
e seus elementos:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Atributos (struct metafont)@>
};
@
\fimcodigo

Ambas as estruturas de dados terão uma função que as inicializa e as
finaliza:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct context *cx);
@
\fimcodigo

A estrutura \monoespaco{metafont} precisa armazenar mais informações,
e também pode tanto ser alocada com a função permanente ou temporária
de alocação. Já o contexto sempre será temporário, e por isso sempre
será alocado e desalocado com as funções temporárias de memória.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Inicialização (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Inicialização (struct context)@>
  return cx;
}
@
\fimcodigo

Já a definição das funções que finalizam e desalocam as estruturas:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalização (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct context *cx){
  if(temporary_free != NULL){
    @<Finalização (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo

O quão rápido executa o nosso código de inicialização e finalização
comparado ao METAFONT original? Para responder isso, foi feito um
``benchmark'' comparando a execução de um programa vazio formado só
pela palavra ``end'' ao ser interpretado pelo programa METAFONT
original e pela nossa implementação do Weaver Metafont. O teste foi
feito em um Ubuntu 20.04.4 rodando em um Intel(R) Core(TM) i5-3210M
CPU @ 2.50GHz com 4GB de RAM. O resultado é apresentado abaixo:


\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#&\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Versão\hidewidth&&\omit\hidewidth
Tempo (s)\hidewidth&&
\omit\hidewidth Versão\hidewidth&&Tempo (s)&\cr\linha
&&METAFONT&&0,121&&Weaver Metafont&&0.001&\cr\linha}}

A diferença de valores se dá provavelmente devido ao fato do METAFONT
original necessariamente imprimir mensagens na tela e ter uma lista
muito maior de variáveis internas que precisam ser inicializadas. Além
disso, o programa original foi feito em uma versão primitiva de Pascal
onde não havia uma maneira padronizada de se lidar com strings,
números em ponto flutuante, etc. Tudo isso exigiu do METAFONT original
uma burocracia muito maior na inicialização e finalização para
preparar rotinas que lidam com tais tarefas básicas. Nada disso é
necessário em nossa implementação que já conta com um ambiente padrão
mais rico e com mais capacidades. Tudo o que temos que fazer é apenas
alocar memória necessária e realizar algumas inicializações mais
básicas.

\secao{5. Listas de Declarações}

Uma lista de declarações é uma série de declarações (potencialmente
vazias) sempre separadas por ponto-e-vírgula:

\alinhaverbatim
<Lista de Declarações> -> <Vazio> | <Declaração> ; <Lista de Declarações>
\alinhanormal

A função que iremos usar para avaliar e interpretar uma lista de
declarações é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

O que esta função fará será iterar sobre cada declaração e executar em
cada uma delas na ordem, a função de avaliação de declaração
individual. Para isso seu trabalho será ver onde cada declaração é
delimitada por cada ponto-e-vírgula e passar os limites de cada
declaração para essa próxima função de avaliação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
      if(!ret)
        return false;
      begin = end -> next;
    }
  }
  return ret;
}
@
\fimcodigo

A função acima itera sobre cada declaração, passando direto por
declarações vazias, e para cada declaração não-vazia, faz com que os
ponteiros \monoespaco{begin} e \monoespaco{end} a delimitem. Durante a
iteração avançamos os ponteiros para os próximos tokens, mas cuidamos
para nunca sair de dentro da região delimitada
por \monoespaco{begin\_token\_list} e \monoespaco{end\_token\_list}.

\secao{6. Declaração Composta}

Uma declaração individual na linguagem pode na verdade ser composta
por muitas outras declarações. A sintaxe para isso é:

\alinhaverbatim
<Declaração> -> <Vazia> | <Composta> | <Declaração de Variável> |
                <Atribuição> | <Definição> | <Comando>
<Composta> -> begingroup <Lista de Declarações> <Não-Título> endgroup
\alinhanormal

Já sabemos o que é uma lista de declarações e já temos uma função que
as avalia. Já a declaração não-título, por enquanto iremos tratar como
sendo qualquer tipo de declaração. Pois nossa versão da linguagem
ainda não suporta declarações de título (seriam strings
isoladas). Desta forma, para nós, uma declaração composta é apenas uma
lista de declarações delimitada por tokens \monoespaco{begingroup}
e \monoespaco{endgroup}.

Por isso vamos ter que levar em conta a existência destes dois tipos
novos de tokens simbólicos no nosso analisador léxico:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_BEGINGROUP            10 // O token simbólico 'begingroup'
#define TYPE_ENDGROUP              11 // O token simbólico 'endgroup'
@
\fimcodigo

E adicionamos eles à nossa lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"begingroup", "endgroup",
@
\fimcodigo

E agora a função que irá avaliar uma declaração individual. Como
visto, há 8 tipos diferentes de declarações:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Declaração: Vazia@>
  @<Declaração: Composta@>
  @<Declaração: Declaração de Variável@>
  @<Declaração: Atribuição@>
  //@<Declaração: Definição@>
  //@<Declaração: Comando@>
  // Se estamos aqui, não identificamos o tipo de declaração:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

No caso da declaração vazia, geralmente não precisaremos lidar com
ela. A função \monoespaco{eval\_list\_of\_statements} silenciosamente
as ignora antes de passar para cá. Mas só para o caso de uma delas
aparecer por outros motivo, vamos explicitamente aceitá-las como
válidas abaixo:

\iniciocodigo
@<Declaração: Vazia@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Agora vamos à declaração composta. A primeira coisa a lembrarmos é que
será importante para a linguagem saber em qual nível de aninhamento
estamos para saber o escopo de eventuais variáveis declaradas. Por
causa disso, o contexto de nossa análise deve memorizar o nível de
aninhamento atual. Cada \monoespaco{begingroup} aumenta esse nível em
1 e cada \monoespaco{endgroup} diminui o nível em 1. Declaremos o
nível de aninhamento atual abaixo:

\iniciocodigo
@<Atributos (struct context)@>=
  int nesting_level;
@
\fimcodigo

Isso deve ser inicializado em zero:

\iniciocodigo
@<Inicialização (struct context)@>=
  cx -> nesting_level = 0;
@
\fimcodigo

A segunda coisa a lembrarmos é que se estivermos em uma declaração
composta, isso significa que o ponteiro para o fim da declaração pode
estar errado. Por exemplo, suponha que a função
\monoespaco{eval\_list\_of\_statements} avaliou os seguintes tokens
abaixo:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;]
\alinhanormal

Corretamente a função marcou o começo da primeira declaração
em \monoespaco{begingroup}, mas erroneamente ela
marcou \monoespaco{T2} como o fim da primeira declaração porque ela
funciona de maneira ingênua, tratando os ponto-e-vírgula como
separador de declarações, sem levar em conta as declarações compostas
que podem conter ponto-e-vírgula dentro delas. O fim da primeira
declaração deveria ser ao invés de \monoespaco{T2}, o
token \monoespaco{endgroup}.

Ao invés de aumentar a complexidade da
função \monoespaco{eval\_list\_of\_statements} fazendo ela levar em
conta declarações compostas, ao invés disso vamos fazer com que a
função \monoespaco{eval\_statements} seja capaz de corrigir o ponteiro
passado, mudando ele para a verdadeira posição. Somente depois disso
podemos passar a lista de declarações dentro do bloco para ser
avaliada:

\iniciocodigo
@<Declaração: Composta@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  struct generic_token *t = begin_token_list, *previous = NULL;
  int nesting_level = 0;
  while(t != NULL){
    if(t -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(t -> type == TYPE_ENDGROUP){
      nesting_level --;
      if(nesting_level == 0)
        break;
    }
    previous = t;
    t = (struct generic_token *) (t -> next);
  }
  *end_token_list = t; // Agora a declaração está demarcada corretamente
  if(*end_token_list == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed 'begingroup'.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(previous == begin_token_list) // Declaração composta vazia
    return true;
  else{
    bool ret;
    cx -> nesting_level ++;
    ret = eval_list_of_statements(mf, cx, ((struct generic_token *)
                                         begin_token_list) -> next,
                                  previous);
    cx -> nesting_level --;
    return ret;
  }
}
@
\fimcodigo

\secao{7. Declaração de Variáveis}

A sintaxe para declarar variáveis é:

\alinhaverbatim
<Declaração de Variável> -> <Tipo> <Lista de Declaração>
<Tipo> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<Lista de Declaração> -> <Tag> | <Tag> , <Lista de Declaração>
\alinhanormal

Uma ``tag'' é basicamente um token simbólico sem um significado
pré-definido na linguagem. Por exemplo, ``\monoespaco{tag}'' é uma tag,
mas ``\monoespaco{begingroup}'' não é.

Para interpretar a declaração de variáveis, vamos então introduzir no
nosso analisador léxico os seguintes tokens especiais:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_T_BOOLEAN               12 // O token simbólico 'boolean'
#define TYPE_T_PATH                  13 // O token simbólico 'path'
#define TYPE_T_PEN                   14 // O token simbólico 'pen'
#define TYPE_T_PICTURE               15 // O token simbólico 'picture'
#define TYPE_T_TRANSFORM             16 // O token simbólico 'transform'
#define TYPE_T_PAIR                  17 // O token simbólico 'pair'
#define TYPE_T_NUMERIC               18 // O token simbólico 'numeric'
@
\fimcodigo

E adicionamos todos à lsita de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


Quando uma variável é declarada, devemos fazer duas coisas:

1) Se a variável não existir no nível de aninhamento atual, devemos
alocar uma estrutura da memória para armazenar seu conteúdo. Se ela já
existir, um erro é gerado. A variável é inicialmente preenchida com um
valor padrão que depende de seu tipo. Ela não poderá ser usada antes
de ser inicializada.

2) Devemos percorrer a lista de tokens e procurar por ocorrências
desta variável mais adiante no mesmo nível de aninhamento, ou em
aninhamento inferior. E devemos atualizar o ponteiro destes tokens
para que apontem para a região de memória recém-alocada para esta
variável.

Como cada variável possui diferentes informações e conteúdo,
dependendo de seu tipo, o modo pelo qual cada uma delas é criada pode
diferir. O que todas as variáveis tem em comum é a seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
// Variável genérica
struct variable{
  int type;
  int nesting_level;
  void *next;
};
@
\fimcodigo

Todas armazenam primeiro o seu tipo, depois o nível de aninhamento em
que estão e um ponteiro para a próxima. Mas dependendo do tipo da
variável haverá mais informações após o ponteiro para a próxima.

Se estivermos diante de uma variável global, podemos querer preservar
e armazenar o nome da variável para o caso de querermos depois
modificar o seu valor dado o seu nome. Então vamos usar a seguinte
estrutura que armazena o nome e a variável:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

E a estrutura de dados da fonte possui ponteiros para as variáveis
globais com nome armazenado e as sem nome armazenado:

\iniciocodigo
@<Atributos (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

Tais ponteiros para variáveis são inicializados como NULL:

\iniciocodigo
@<Inicialização (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

Para desalocar a lista de variáveis globais, basta percorrer a lista
encadeada que elas formam. Algumas variáveis mais complexas precisarão
de operações adicionais para serem removidas, mas trataremos delas
posteriormente.

\iniciocodigo
@<Finalização (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável Global 'v'@>
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

Já desalocar a lista de variáveis globais com nomes preservados é
feito de maneira semelhante:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) (named -> var);
    next = (struct named_variable *) (named -> next);
    mf -> free(named -> name);
    @<Finaliza Variável Global 'v'@>
    mf -> free(v);
    mf -> free(named);
    named = next;
  }
}
@
\fimcodigo

No caso das variáveis que não são globais, elas serão armazenadas no
contexto, não na estrutura da fonte. Afinal, a duração delas será
sempre temporária:

\iniciocodigo
@<Atributos (struct context)@>=
  void *variables;
@
\fimcodigo

A lista de variáveis é inicializada como vazia:

\iniciocodigo
@<Inicialização (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

E finalizamos ela assim como finalizamos a lista de variáveis globais:

\iniciocodigo
@<Finalização (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável Local 'v'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

Agora vamos à interpretação da declaração de variável:

\iniciocodigo
@<Declaração: Declaração de Variável@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // Todos os tipos de declaração
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insere Variável Declarada@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

A inserção de uma nova variável segue a seguinte lógica:

\iniciocodigo
@<Insere Variável Declarada@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

A função que insere uma nova variável sem o nome é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

Ela aloca uma nova variável e a coloca no local indicado
por \monoespaco{target}:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    case TYPE_T_PAIR:
      var_size = sizeof(struct pair_variable);
      break;
    case TYPE_T_PATH:
      var_size = sizeof(struct path_variable);
      break;
    case TYPE_T_PEN:
      var_size = sizeof(struct pen_variable);
      break;
    case TYPE_T_PICTURE:
      var_size = sizeof(struct picture_variable);
      break;
    case TYPE_T_TRANSFORM:
      var_size = sizeof(struct transform_variable);
      break;
    case TYPE_T_BOOLEAN:
      var_size = sizeof(struct boolean_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Inicialização de Nova Variável@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Já inserir uma variável nova com o nome é feito com a seguinte função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

Ela funciona de maneira similar, apenas alocando a estrutura do nome e
colocando a nova variável ali:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));
  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL){
    mf -> named_variables = named;
  }  
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

E finalmente, a função que percorre uma lista de tokens procurando por
tokens simbólicos com o mesmo nome da variável alocada e fazendo o
ponteiro deles apontar para onde a variável está:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

A função percorre todos os tokens que vem depois do token com o nome
da nova variável e só para quando percorre a lista inteira ou quando
sai do nível de aninhamento atual para um onde a variável não existe
mais (quando acha um \monoespaco{endgroup} encerrando o nível de
aninhamento da variável):

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Variáveis Numéricas}

Uma variável numérica será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparando uma variável numérica com uma variável genérica, a
diferença é a variável de ponto-flutuante \monoespaco{value} que
armazena o valor numérico. Durante a criação da variável, o valor é
inicializado como NaN, que para nós representa uma variável com valor
desconhecido:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

O uso da macro \monoespaco{NAN} requer que usemos o cabeçalho
matemático:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

No caso das variáveis numéricas, nada a mais é necessário durante a
finalização, já que não há nada muito complexo além de um número em
ponto flutuante nelas.

Entretanto, além de variáveis declaradas pelo usuário, a nossa versão
da linguagem Metafont irá possuir algumas variáveis internas numéricas
próprias. Elas sempre estarão presentes e não precisam ser
declaradas. Iremos ter ao todo três
delas: \monoespaco{pt}, \monoespaco{cm} e \monoespaco{mm}. Basicamente
elas irão armazenar quantos pixels correspondem a 1pt, 1cm e 1mm
respectivamente.

Tais variáveis numéricas internas serão armazenadas na estrutura
metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

Na inicialização alocamos espaço para as três variáveis e as preenchemos:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   pt;
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   28.3465 * pt; // 1cm = 28.3465pt
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   2.83465 * pt; // 1mm = 2.83465pt
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;

  }
}
@
\fimcodigo

Criamos as seguintes macros para acessar cada uma destas variáveis
mais facilmente:

\iniciocodigo
@<Macros Locais (metafont.c)@>=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

Para finalizar a estrutura metafont, devemos desalocar tais variáveis
internas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL)
  mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

Quando o nosso analisador léxico gera um novo token simbólico que não
é uma palavra reservada, ele já deve checar se este token tem o nome
de uma variável interna. Se tiver, o ponteiro para ela já é preenchido
corretamente:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\subsecao{7.2. Variáveis de Pares}

Uma variável de par serve para armazenar coordenadas de um ponto. Ela
será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct pair_variable{
  int type; // Deve ser 'TYPE_T_PAIR'
  int nesting_level;
  void *next;
  float x, y;
};
@
\fimcodigo

A diferença é que elas possuem espaço para dois valores em ponto
flutuante ao invés de um. Inicialmente vamos representar o primeiro
deles como NaN, para representar uma variável não-inicializada:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Variáveis de Transformação}

Se um variável de par é uma tupla de dois valores numéricos, uma
variável de transformação é uma tupla com seis valores
diferentes. Sejam os valores $(a, b, c, d, e, f)$, o que eles
representam é uma transformação linear na qual o par $(x, y)$ é
transformado em $(x', y')$ da seguinte forma:

$$\left[x\; y\; 0\; 1\right]\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=\left[x'\;\;
      y'\;\; 0\;\; 1\right]
$$

Ou: $(x', y') = (a+cx+dy, b+ex+fy)$.

A ordem em que os elementos são representados pode parecer estranha,
mas é feito assim como compatibilidade com a linguagem METAFONT
original criada por Knuth.

Uma variável de transformação então simplesmente deve armazenar os
seis valores diferentes:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct transform_variable{
  int type; // Deve ser 'TYPE_T_TRANSFORM'
  int nesting_level;
  void *next;
  float value[6];
};
@
\fimcodigo

Uma transformação com valores não-inicializados possui seu primeiro
valor marcado como NAN:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_TRANSFORM)
  ((struct transform_variable *) var) -> value[0] = NAN;
@
\fimcodigo

Existe uma variável de transformação interna que sempre estará
presente sem precisar ser declarada. É a
variável \monoespaco{identity}, que representa a ausência de uma
transformação. É uma transformação que não irá mudar o ponto. Ela é
representada pela tupla $(0, 0, 1, 0, 0, 1)$ e sua transformação na
forma matricial é representada pela multiplicação por uma matriz
identidade.

As variáveis internas de transformação serão armazenadas na estrutura
Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct transform_variable *internal_transform_variables;
@
\fimcodigo

Na inicialização o espaço para armazenar as variáveis internas será
alocado e as variáveis internas são inicializadas:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_transform_variables =
  (struct transform_variable *)
    mf -> alloc(sizeof(struct transform_variable));
if(mf -> internal_transform_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL; //ERRO: Sem memória suficiente
}
// A transformação 'identity':
mf -> internal_transform_variables[0].type = TYPE_T_TRANSFORM;
mf -> internal_transform_variables[0].value[0] = 0.0;
mf -> internal_transform_variables[0].value[1] = 0.0;
mf -> internal_transform_variables[0].value[2] = 1.0;
mf -> internal_transform_variables[0].value[3] = 0.0;
mf -> internal_transform_variables[0].value[4] = 0.0;
mf -> internal_transform_variables[0].value[5] = 1.0;
@
\fimcodigo

A variável \monoespaco{identity} deve ser registrada como tendo a
primeira posição:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_TRANSFORM_IDENTITY 0
@
\fimcodigo

E durante a leitura do código-fonte, podemos já ajustar corretamente
todas as referências para esta variável colocando o valor correto de
seu endereço nos tokens lidos:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>+=
else if(!strcmp(buffer, "identity"))
  new_token -> var =
          &(mf -> internal_transform_variables[INTERNAL_TRANSFORM_IDENTITY]);
@
\fimcodigo

\subsecao{7.4. Variáveis de Caminhos}

Uma variável de caminho armazena uma sequência de pontos e uma
sequência de pontos de controle formando uma sequência de Curvas de
Beziér cúbicas.

Uma Curva de Beziér cúbica é definida por dois pontos de extremidade
($z_1$ e $z_4$) e dois pontos de controle ($z_2'$ e $z_3'$). Os dois
pontos de extremidade fazem parte da curva. Para obter todos os outros
pontos que fazem parte da curva à partir de quatro pontos $(z_1, z_2',
z_3', z_4)$, usa-se o seguinte procedimento:

1) Obtenha o ponto intermediário $z_{12}'$, que fica na metade do
caminho entre $z_1$ e $z_2'$, o ponto intermediário $z_{23}'$, que
fica no meio do caminho entre $z_2'$ e $z_3'$ e o ponto intermediário
$z_{34}'$, que fica no meio do caminho entre $z_3'$ e $z_4$.

2) Obtenha agora os dois pontos intermediários novos: $z_{123}'$, que
fica no meio do caminho entre $z_{12}'$ e $z_{23}'$ e o ponto
$z_{234}'$ que fica entre os pontos $z_{23}'$ e $z_{34}'$.

3) O novo ponto que faz parte da curva gerado é o ponto $z_{1234}$,
que fica no meio do caminho entre $z_{123}'$ e $z_{234}'$.

4) Gere os outros pontos da curva aplicando este procedimento
recursivamente sobre $(z_1, z_{12}', z_{123}', z_{1234})$ e sobre
$(z_{1234}, z_{234}', z_{34}', z_4)$.

É possível também obter uma fórmula para tais curvas. Dado dois pontos
de extremidade e dois de controle, todos os pontos intermediários
podem ser obtidos usando a fórmula abaixo, variando $t$ entre 0 e 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

A estrutura de dados que armazena a sequência de Curvas de Beziér
Cúbicas é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct path_points{
  float x, y; // Ponto de extremidade
  float u_x, u_y, v_x, v_y;   // Pontos de controle
  void *subpath;
};
struct path_variable{
  int type; // Deve ser 'TYPE_T_PATH'
  int nesting_level;
  void *next;
  bool cyclic;
  int length, total_length;
  struct path_points *points;
};
@
\fimcodigo

Basicamente seus pontos estarão apontados pelo
ponteiro \monoespaco{points}, um vetor de estrutura que terá um número
de elementos igual a \monoespaco{length}. Cada estrutura representará
um ponto $(x, y)$ ou então terá um ponteiro para outra variável de
caminho que contém um subcaminho (sempre que \monoespaco{subpath} não
for nulo, e nesta caso ignoraremos $x$ e $y$). Essa outra variável de
caminho pode conter recursivamente muitos pontos. Para armazenar a
quantidade total de pontos que o caminho contém recursivamente,
usamos \monoespaco{total\_length}. Enquanto a
variável \monoespaco{length} armazena apenas o tamanho do
array \monoespaco{points}.

Os pontos de controle definidos
por \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
e \monoespaco{v\_y} são os pontos de controle entre o ponto ou
subcaminho atual e o próximo, se houver. Caso seja um caminho cíclico,
os pontos de controle do último ponto ou subcaminho determinam como
ele será ligado ao primeiro ponto. Se não for cíclico, os pontos de
controle do último ponto são ignorados.

O modo como representaremos uma variável de caminho não-inicializada é
mantendo seu tamanho (\monoespaco{length}) como sendo igual a -1:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
  ((struct path_variable *) var) -> points = NULL;
}
@
\fimcodigo

Quando vamos remover uma variável global, se ela for do tipo caminho e
estiver inicializada, precisamos remover a lista de pontos alocada:

\iniciocodigo
@<Finaliza Variável Global 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && mf -> free != NULL)
    path_recursive_free(mf -> free, path, false);
}
@
\fimcodigo

Se a variável não for global fazemos o mesmo, mas usando uma função de
desalocação para variáveis temporárias:


\iniciocodigo
@<Finaliza Variável Local 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL)
    path_recursive_free(temporary_free, path, false);
}
@
\fimcodigo

Como um caminho pode conter subcaminhos e cada um deles também pode
ter seus próprios subcaminhos, em tais casos usamos uma função
recursiva para desalocar memória. Dada a função de desalocação e um
ponteiro para uma variável de caminho, nós desalocamos todos os seus
subcaminhos e depois a desalocamos. A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer);
@
\fimcodigo

E sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].subpath != NULL)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath, true);
    }
    free_func(path -> points);
    if(free_first_pointer)
      free_func(path);
  }
}
@
\fimcodigo

\subsecao{7.5. Variáveis de Caneta}

Uma variável de caneta armazena a estrutura utilizada para desenhar
formas no METAFONT. As canetas especificam o diâmetro e formato das
linhas e pontos a serem desenhados. Elas são armazenadas na seguinte
estrutura:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
struct pen_variable;
@
\fimcodigo

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct pen_variable{
  int type; // Deve ser 'TYPE_T_PEN'
  int nesting_level;
  void *next;
  struct path_variable *format; // O formato como caminho cíclico
  int flags;
  struct pen_variable *referenced;
  GLuint gl_vbo; // Os vértices OpenGL após triangulação
  int number_of_vertices; // Quantos vértices são
  float gl_matrix[16]; // Matriz de transformação OpenGL
};
@
\fimcodigo

Aqui vamos dar uma breve explicação do que são cada uma destas
variáveis e por que elas são necessárias:

As variáveis \monoespaco{type}, \monoespaco{nesting\_level}
e \monoespaco{next} são comuns a todos os tipos de variáveis e não
apresentam novidade. Servem para que saibamos qual tipo de dado está
sendo armazenado na variável, qual o seu escopo e qual a próxima
variável caso ela esteja em uma lista encadeada.

A variável \monoespaco{format} especifica o formato de nossa caneta
como um caminho cíclico. No METAFONT original, era necessário que além
de cíclico, o caminho seja convexo. Para nós, será necessário apenas
que o caminho seja cíclico e simples. O que significa que o perímetro
do caminho não pode ter ter intersecções e cruzar consigo mesmo. Caso
isso não seja respeitado, o resultado será indefinido e não iremos
garantir que as canetas gerem o resultado esperado.

Não importa o quão complexo seja o formato da caneta, para que ele
possa ser desenhado na tela via OpenGL, ele deve ser convertido para
um conjunto de triângulos em um processo chamado de
triangulação. Detalhes sobre como triangular, ou mesmo se precisamos
triangular serão definidos pela variável \monoespaco{flags}. As flags
possíveis são:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define FLAG_CONVEX   1
#define FLAG_STRAIGHT 2
#define FLAG_CIRCULAR 4
#define FLAG_SQUARE   8
#define FLAG_NULL    16
@
\fimcodigo


A flag \monoespaco{FLAG\_CONVEX} armazena se estamos diante de um
formato convexo. Se esse for o caso, fazer a triangulação será um
processo muito simples. Poderemos usar um algoritmo muito mais simples
e rápido que fará tudo em O(n) quando precisarmos.

A flag \monoespaco{FLAG\_STRAIGHT} armazena se o formato de nossa caneta
é formado apenas por linhas retas, sem curvas. Se isso for verdade,
então quer dizer que uma vez que ele seja triangulado, nunca mais
precisaremos fazer isso novamente, mesmo que a caneta depois seja
ampliada ou reduzida. Se ela é formada só por linhas retas, os
triângulos são capazes de represerntar seu formato com perfeição, não
estamos usando nenhum tipo de aproximação. Por isso, não precisamos
gerar a triangulação novamente para poder mostrar mais detalhes
quando, por exempolo, a caneta se torna maior.

A flag \monoespaco{FLAG\_CIRCULAR} armazena se nós sabemos que a caneta
tem um formato circular. Neste caso, seremos capazes de fazer a
triangulação sem olhar para os pontos da variável de caminho
representando o formato.

A flag \monoespaco{FLAG\_SQUARE} armazena se a caneta é uma caneta
quadrada. Neste caso também não precisamos dos pontos da variável de
caminho e podemos usar uma triangulação já feita antes sem precisar
triangular novamente.

A flag \monoespaco{FLAG\_NULL} armazena se esta é uma caneta
nula. Neste caso ela nunca precisa ser triangulada, pois ela
representa um único ponto sem largura nem altura.

A variável \monoespaco{referenced} será não-nula quando estamos
lidando com uma caneta temporária que não está armazenada em uma
variável e quando ela referencia uma outra caneta que está armazenada
em uma variável. Em tais casos, estaremos usando o formato, a
triangulação e a lista de vértices da variável referenciada sempre que
for possível, ao invés de ter que gerar tais coisas novamente. Isso
também significa que caso a variável seja desalocada, não devemos
destruir o seu formato, e nem pedir para o OpenGL jogar fora a lista
de vértices.

As variáveis \monoespaco{gl\_vbo} e \monoespaco{number\_of\_vertices}
representam os vértices caso a caneta já tenha tido a sua triangulação
feita.

A variável \monoespaco{gl\_matrix} armazena a matriz de transformação
OpenGL. Como as canetas possuem um formato bem-definido e não serão
depois subdivididos ou concatenados como podem ser os subcaminhos,
então podemos representar eventuais transformações lineares nela por
meio dessa matriz ao invés de ter que computar novos valores para seus
pontos.

Uma variável de caneta declarada, mas ainda não inicializada terá seu
formato igual ao ponteiro nulo, será não-circular e como ela ainda não
foi triangulada, terá seu ID de vértices OpenGL igual a zero.

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PEN){
  ((struct pen_variable *) var) -> format = NULL;
  ((struct pen_variable *) var) -> gl_vbo = 0;
  ((struct pen_variable *) var) -> flags = false;
  ((struct pen_variable *) var) -> referenced = NULL;
}
@
\fimcodigo

O que significa que ao remover uma variável global e ela for de
caminho, devemos fazer a desalocação do formato e jogar fora os
vértices:

\iniciocodigo
@<Finaliza Variável Global 'v'@>=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> referenced == NULL){
    if(pen -> format != NULL && mf -> free != NULL)
      path_recursive_free(mf -> free, pen -> format, true);
    if(pen -> gl_vbo != 0)
      glDeleteBuffers(1, &(pen -> gl_vbo));
  }
}
@
\fimcodigo

Se a variável for local ao invés de global, nós fazemos o mesmo usando
uma função diferente de desalocação:

\iniciocodigo
@<Finaliza Variável Local 'v'@>+=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> referenced == NULL){
    if(pen -> format != NULL && temporary_free != NULL)
      path_recursive_free(temporary_free, pen -> format, true);
    if(pen -> gl_vbo != 0)
      glDeleteBuffers(1, &(pen -> gl_vbo));
  }
}
@
\fimcodigo

Além das variáveis de caneta definidas pelo usuário, iremos suportar a
existência de duas outras variáveis interna de caneta. Uma delas será
chamada de \monoespaco{currentpen} e irá representar a caneta atual
com a qual iremos escrever e desenhar. A outra será uma caneta de
formato perfeitamente quadrado que estará já inicializada à disposição
do usuário e que deixamos já alocada para fins de melhor performance.

Tais variáveis serão armazenadas na estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct pen_variable *internal_pen_variables;
@
\fimcodigo

Na inicialização iremos alocar espaço para ambas e inicializaremos
elas. A variável \monoespaco{currentpen} por padrão começará sendo um
círculo de diâmetro 1 e a \monoespaco{pensquare} será um quadrado de
lado 1:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_pen_variables = (struct pen_variable *)
                                 mf -> alloc(2 * sizeof(struct pen_variable));
if(mf -> internal_pen_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL;
}
mf -> internal_pen_variables[0].format = NULL; // A caneta 'currentpen'
mf -> internal_pen_variables[0].type = TYPE_T_PEN;
mf -> internal_pen_variables[0].flags = FLAG_CONVEX | FLAG_CIRCULAR;
mf -> internal_pen_variables[0].referenced = NULL;
mf -> internal_pen_variables[0].gl_vbo = 0;
mf -> internal_pen_variables[0].number_of_vertices = 0;
mf -> internal_pen_variables[1].format = NULL; // A caneta 'pensquare'
mf -> internal_pen_variables[1].type = TYPE_T_PEN;
mf -> internal_pen_variables[1].flags = FLAG_CONVEX | FLAG_STRAIGHT |
                                        FLAG_SQUARE;
mf -> internal_pen_variables[1].referenced = NULL;
mf -> internal_pen_variables[1].gl_vbo = 0;
mf -> internal_pen_variables[1].number_of_vertices = 0;
{ // Inicializando a matriz de transformação de ambas
  int i, j;
  for(j = 0; j < 2; j ++)
    for(i = 0; i < 16; i++)
      if(i % 5 == 0)
        mf -> internal_pen_variables[j].gl_matrix[i] = 1.0;
      else
        mf -> internal_pen_variables[j].gl_matrix[i] = 0.0;
}
@
\fimcodigo

As seguintes macros nos permitirão acessar mais fácil a posição de
cada variável interna:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_PEN_CURRENTPEN 0
#define INTERNAL_PEN_PENSQUARE  1
@
\fimcodigo

Para finalizar a estrutura metafont, devemos desalocar as variáveis
internas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL){
  if(mf -> internal_pen_variables[1].format != NULL){
    mf -> free(mf -> internal_pen_variables[1].format -> points);
    mf -> free(mf -> internal_pen_variables[1].format);
  }
  mf -> free(mf -> internal_pen_variables);
}
@
\fimcodigo

E ao ler um código-fonte, devemos ajustar corretamente os ponteiros
das variáveis que apontam para tais variáveis internas:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
else if(!strcmp(buffer, "currentpen"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]);
else if(!strcmp(buffer, "pensquare"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_PENSQUARE]);
@
\fimcodigo

\subsecao{7.6. Variáveis de Imagens}

Uma variável de imagem armazena uma imagem renderizada, possivelmente
por meio de pincéis e comandos de desenho do Weaver Metafont. Ao
contrário do METAFONT original, o Weaver Metafont requer que cada
imagem tenha um tamanho bem-definido. Todas elas terão uma altura e
largura. E além disso terão um índice representando uma textura
OpenGL, onde estará a iamgem renderizada:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct picture_variable{
  int type; // Deve ser 'TYPE_T_PICTURE'
  int nesting_level;
  void *next;
  int width, height;
  GLuint texture;
};
@
\fimcodigo

Uma variável de imagem que foi declarada, mas ainda não inicializada
terá altura e largura negativa, e seu índice de textura será zero:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PICTURE){
  ((struct picture_variable *) var) -> width = -1;
  ((struct picture_variable *) var) -> height = -1;
  ((struct picture_variable *) var) -> texture = 0;
}
@
\fimcodigo

Ao remover uma variável global, se ela for de imagem, pedir via OpenGL
que a textura seja destruída caso exista:

\iniciocodigo
@<Finaliza Variável Global 'v'@>=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

Se a variável for local ao invés de global, nós fazemos o mesmo:

\iniciocodigo
@<Finaliza Variável Local 'v'@>+=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

Existirá uma variável interna de imagem no Weaver Metafont chamada
de \monoespaco{currentpicture}. No início de todo programa esta
variável estará pré-declarada. Para criar uma lista de variáveis
internas de imagem, a declaramos na estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct picture_variable *internal_picture_variables;
@
\fimcodigo

E na inicialização deixamos a variável \monoespaco{currentpicture}
declarada, mas deixada como não-inicializada:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_picture_variables = (struct picture_variable *)
                                   mf-> alloc(sizeof(struct picture_variable));
if(mf -> internal_picture_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL;
}
// A imagem 'currentpicture':
mf -> internal_picture_variables[0].type = TYPE_T_PICTURE;
mf -> internal_picture_variables[0].width = -1;
mf -> internal_picture_variables[0].height = -1;
mf -> internal_picture_variables[0].texture = 0;
@
\fimcodigo

Para deixar consistente com as outras variáveis internas, criamos esta
macro para nos referir à posição dela:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_PICTURE_CURRENTPICTURE 0
@
\fimcodigo

No momento em que chegar a hora de desalocar as variáveis internas,
devemos eliminar a textura dela também caso ela tenha sido
inicializada:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> internal_picture_variables[0].texture != 0)
  glDeleteTextures(1, &(mf -> internal_picture_variables[0].texture));
if(mf -> free != NULL)
  mf -> free(mf -> internal_picture_variables);
@
\fimcodigo

E à medida que lemos um código fonte, devemos ajustar corretamente as
variáveis chamadas ``\monoespaco{currentpicture}'' para apontar para a
variável interna:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
else if(!strcmp(buffer, "currentpicture"))
  new_token -> var =
          &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE]);
@
\fimcodigo

\subsecao{7.7. Variáveis Booleanas}

A mais simples de todas as variáveis, uma variável booleana armazena
somente verdadeiro ou falso. O formato de sua estrutura é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct boolean_variable{
  int type; // Deve ser 'TYPE_T_BOOLEAN'
  int nesting_level;
  void *next;
  short value;
};
@
\fimcodigo

O valor \monoespaco{value} armazenado pela variável será 0 se for
falso ou 1 se for verdadeiro. No caso de ser uma variável
não-inicializada, armazenaremos -1:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_BOOLEAN)
  ((struct boolean_variable *) var) -> value = -1;
@
\fimcodigo


\secao{8. Atribuições}

Atribuições são como fazemos com que as variáveis sejam inicializadas,
como modificamos seus valores e como armazenamos nelas o resultado de
expressões.

A sintaxe de uma atribuição é:

\alinhaverbatim
<Atribuição> -> <Variável> = <Lado Direito> |
                <Variável> := <Lado Direito>
<Lado Direito> -> <Expressão> | <Atribuição>
\alinhanormal

Isso significa que podemos realizar atribuições encadeadas, por
exemplo, todas as variáveis abaixo, se forem numéricas, passarão a
valer 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

Se no começo de uma declaração nós encontramos uma variável, então
certamente estamos diante de uma atribuição.

Vamos começar então ensinando ao nosso analizador léxico que ambos os
tokens ``\monoespaco{=}'' e ``\monoespaco{:=}'' são equivalentes,
representam a mesma coisa e tem significado especial:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_ASSIGNMENT            19 // O token simbólico '='
#define TYPE_ASSIGNMENT2           20 // O token simbólico ':='
@
\fimcodigo

Ambos os tipos de atribuição vão para a lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"=", ":=",
@
\fimcodigo

Mas vamos tratar ambos como sinônimos e transformar o segundo tipo no
primeiro para simplificar o código:

\iniciocodigo
@<Muda Tipo na Geração de Tokens em Casos Especiais@>+=
else if(token_type == TYPE_ASSIGNMENT2)
  token_type = TYPE_ASSIGNMENT;
@
\fimcodigo

Agora que temos este novo tipo de token, o código para avaliar uma
atribuição segue em seguida. O que ele faz é percorrer a atribuição
detectando todas as variáveis que deverão passar pela
atribuição. Enquanto faz isso, o código checa se todas estão
declaradas, se todas possuem o mesmo tipo, se tentamos atribuir para
algo que não é uma variável, se não colocamos um símbolo de atribuição
ou se está faltando uma expressão depois do último símbolo de
atribuição. Em qualquer um destes casos, um erro é gerado.

A parte que ainda não está sendo mostrada no código abaixo, mas será
definida nas próximas subseções é como avaliar a expressão após o
último símbolo de atribuição e como efetivamente fazemos a
atribuição. Isso porque o modo de fazer isso depende do tipo das
variáveis. DEpendendo do tipo delas, esperaremos encontrar um tipo
diferente de expressão, e realizar o armazenamento de tais variáveis
também será diferente. Estes detalhes veremos nas próximas subseções.

\iniciocodigo
@<Declaração: Atribuição@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  struct generic_token *begin_expression;
  int type = 0; // Tipo das variáveis na atribuição
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment (type: %d).\n",
              mf -> file,
              var -> line, var -> type);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Atribuição de Variável Numérica@>
  @<Atribuição de Variável de Par@>
  @<Atribuição de Variável de Transformação@>
  @<Atribuição de Variável de Caminho@>
  @<Atribuição de Variável de Caneta@>
  @<Atribuição de Variável de Imagem@>
  return true;
}
@
\fimcodigo

\subsecao{8.1. Atribuições e Expressões Numéricas}

Como então realizar a atribuição de variáveis numéricas dado o código
acima? Usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável Numérica@>=
if(type == TYPE_T_NUMERIC){
  int i;
  bool ret;
  struct numeric_variable result;
  ret = eval_numeric_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_numeric_variable((struct numeric_variable *) var -> var,
                            &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

A função que efetivamente faz a atribuição é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source);

@
\fimcodigo

E a sua implementação bastante simples é essa:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source){
  target -> value = source -> value;
}
@
\fimcodigo

Agora passemos para definir como interpretar expressões numéricas.

\subsubsecao{8.1.1. Soma e Subtração: Normal e Pitagórica}

As regras iniciais de expressões numéricas seguem abaixo:

\alinhaverbatim
<Expressão Numérica> -> <Terciário Numérico>
<Terciário Numérico> -> <Secundário Numérico> |
                        <Terciário Numérico> <T-Op> <Secundário Numérico>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

Os símbolos de \monoespaco{+} e \monoespaco{-} corespondem à adição e
subtração. O símbolo \monoespaco{++} corresponde à soma pitagórica:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

Isso pode ser facilmente calculado em C usando a função da biblioteca
padrão matemática \monoespaco{hypot}.

Já o símbolo \monoespaco{+-+} corresponde à ``subtração pitagórica''
definida abaixo:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

Na subtração pitagórica, nós vamos usar a última definição envolvendo
a multiplicação de duas raízes quadradas em nossa implementação, pois
é a forma de cálculo que minimiza erros e presença de overflows e
underflows.

Os quatro operadores acima serão aqueles com a menor precedência. Tais
operações de soma e subtração serão feitas apenas depois que todas as
outras operações forem feitas.

Vamos agora aperfeiçoar o nosso analisador léxico para identificar e
gerar os tokens destes quatro operadores. Temos que criar tipos novos,
um para cada operador. Vamos aproveitar e criar tipos novos para
``['', ``]'', ``{'' e ``}'', pois vamos também precisar no nosso
analisador sintático:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_SUM                   21 // O token simbólico '+'
#define TYPE_SUBTRACT              22 // O token simbólico '-'
#define TYPE_PYTHAGOREAN_SUM       23 // O token simbólico '++'
#define TYPE_PYTHAGOREAN_SUBTRACT  24 // O token simbólico '+-+'
#define TYPE_OPEN_BRACKETS         25 // O token simbólico '['
#define TYPE_CLOSE_BRACKETS        26 // O token simbólico ']'
#define TYPE_OPEN_BRACES           27 // O token simbólico '{'
#define TYPE_CLOSE_BRACES          28 // O token simbólico '}'
@
\fimcodigo

E os adicionamos na lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo


Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo


As expressões numéricas começam nas expressões terciárias numéricas
onde aparecem essas somas e subtrações. Pelas regras de sintaxe, o que
temos que fazer é percorrer toda a expressão até chegar ao último
símbolo de soma ou subtração que não estiver delimitado por
parênteses, colchetes ou chaves.

Para ajudar com isso, as seguintes macros vão declarar variáveis para
armazenar o aninhamento de delimitadores como parênteses e chaves, vão
checar se o aninhamento está aumentando ou diminuindo e verificar se
estamos dentro de um aninhamento ou não:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define DECLARE_NESTING_CONTROL() int nesting_parenthesis = 0, \
                                      nesting_brackets = 0, \
                                      nesting_braces = 0;
#define COUNT_NESTING(p) if(p -> type == TYPE_OPEN_PARENTHESIS)           \
                               nesting_parenthesis ++;                    \
                             else if(p -> type == TYPE_CLOSE_PARENTHESIS) \
                               nesting_parenthesis --;                    \
                             else if(p -> type == TYPE_OPEN_BRACKETS)     \
                               nesting_brackets ++;                       \
                             else if(p -> type == TYPE_CLOSE_BRACKETS)    \
                               nesting_brackets --;                       \
                             else if(p -> type == TYPE_OPEN_BRACES)       \
                               nesting_braces ++;                         \
                             else if(p -> type == TYPE_CLOSE_BRACES)      \
                               nesting_braces --;
#define IS_NOT_NESTED() (nesting_parenthesis == 0 && nesting_brackets == 0 && \
                         nesting_braces == 0)
#define RESET_NESTING_COUNT() nesting_parenthesis = 0; \
                              nesting_brackets = 0; \
                              nesting_braces = 0;
@
\fimcodigo

Tudo que estiver do lado esquerdo
deve ser avaliado recursivamente como outra expressão terciária
numérica. Já o que estiver à direita será interpretado como uma
expressão secundária numérica. Por fim, se nenhum símbolo de soma e
subtração for encontrada, a expressão inteira será avaliada como uma
expressão secundária numérica.

Contudo, existem exceções, casos nos quais não devemos considerar os
tokens \monoespaco{+} e \monoespaco{-} como soma e subtração. Isso
ocorre quando tais símbolos estiverem no começo da expressão numérica,
ou então caso sejam precedidos por vírgula, abrir de colchetes,
símbolo de multiplicação, divisão, outro operador terciário ou então
um dos tokens seguintes que veremos mais
adiante: \monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}.

Se nós temos um token anterior (\monoespaco{prev}) e um atual
(\monoespaco{cur}), podemos checar se ele representa uma adição ou
subtração válida com a macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_OF &&                    \
          prev -> type != TYPE_POINT &&                 \
          prev -> type != TYPE_PRECONTROL &&            \
          prev -> type != TYPE_POSTCONTROL &&           \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo

O código abaixo interpreta as expressões numéricas terciárias e trata
a execução de operadores terciários, identificando-os corretamente com
ajuda da macro:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_PYTHAGOREAN_SUM ||
                          p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
                          IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_numeric_secondary(mf, cx, begin_secondary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM)
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT)
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM)
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Negative square root "
                " in pythagorean subtraction.\n", mf -> file,
                last_sum -> line);
#endif
        return false;
      }
    }
    return true;
  }
  else
    return eval_numeric_secondary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.2. Multiplicação e Divisão}

As regras para lidar com expressões secundárias são:

\alinhaverbatim
<Secundário Numérico> -> <Primário Numérico> |
                         <Secundário Numérico> <S-Op> <Primário Numérico>
<S-Op> -> * | /
\alinhanormal

Os operadores \monoespaco{*} e \monoespaco{/} são respectivamente a
multiplicação e divisão.

Vamos adicionar estes operadores à lista de palavras-chave reservadas
e definir seus tipos:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_MULTIPLICATION        29 // O token simbólico '*'
#define TYPE_DIVISION              30 // O token simbólico '/'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"*", "/",
@
\fimcodigo

A função que irá avaliar expressões secundárias é:

Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct numeric_variable *result);
@
\fimcodigo

E a sua definição é muito semelhante à da função que avalia expressões
terciárias, exceto que ela lida com o cálculo de multiplicação e
divisão.

Entretanto, deve-se levar em conta que o token de divisão só deve ser
tratado neste estágio se aquilo que estiver antes e depois dele não
forem dois tokens numéricos. See forem, estamos diante de uma fração e
elas serão tratadas com um nível de precedência ainda maior. Por outro
lado, se já consideramos o token retrasado como uma fração, então
neste caso sim, o símbolo será de divisão, mesmo que esteja cercado de
tokens numéricos. Assim o código \monoespaco{1/3/1/3} é interpretado
como a divisão de duas frações $(1/3)/(1/3)$:


\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
                          p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_token_list &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ // Multiplicação ou divisão válida
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secondary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secondary(mf, cx, begin_expression, end_secondary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end_token_list, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION)
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){
      if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.\n",
                mf -> file, last_mul -> line);
#endif
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else
    return eval_numeric_primary(mf, cx, begin_expression,
                                end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.3. Módulo,
    Funções Trigonométricas, Exponenciais, Piso e Valores Aleatórios
    Uniformes}

As regras de expressões numéricas primárias é:

\alinhaverbatim
<Primário Numérico> -> <Átomo Numérico> |
                       length <Primário Numérico> | (...) |
                       <Operador Numérico> <Primário Numérico>
<Operador Numérico> -> sqrt | sind | cosd | log | exp | floor |
                       uniformdeviate |
                       <Operador de Multiplicador Escalar>
<Operador de Multiplicador  Escalar> -> + | - |
                       <Token Numérico Primário antes de var>
<Token Numérico Primário> -> <Token Numérico> / <Token Numérico> |
                             <Token Numérico não sucedido por ``/ num''>
\alinhanormal

O operador \monoespaco{length}, quando sucedido por um primário
numérico significa que queremos o módulo do valor. Ele pode ter outros
significados se sucedido por outro tipo de expressão primária.

O novo operador de módulo precisa ser adicionado à lista de palavras
reservadas. Vamos adicionar também os outros operadores da lista de
operadores numéricos. Os colchetes Já pertencem à esta lista:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_LENGTH         31 // O token simbólico 'length'
#define TYPE_SQRT           32 // O token simbólico 'sqrt'
#define TYPE_SIND           33 // O token simbólico 'sind'
#define TYPE_COSD           34 // O token simbólico 'cosd'
#define TYPE_LOG            35 // O token simbólico 'log'
#define TYPE_EXP            36 // O token simbólico 'exp'
#define TYPE_FLOOR          37 // O token simbólico 'floor'
#define TYPE_UNIFORMDEVIATE 38 // O token simbólico 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

A função que interpreta uma expressão numéria primária será esta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result);
@
\fimcodigo

Podemos decidir qual regra deve ser aplicada na avaliação da expressão
numérica primária por meio de sete regras de interpretação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result){
  @<Primário Numérico: Regra 1@>
  @<Primário Numérico: Regra 2@>
  @<Primário Numérico: Regra 3@>
  @<Primário Numérico: Operadores Adicionais@>
  @<Primário Numérico: Regra 4@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

As regras são:

1) Se a expressão for composta por um único token, se começar com
``('' e terminar com ``)'' ou se for composta por três tokens, um
numérico, um \monoespaco{/} e outro numérico, então toda a expressão é
um átomo numérico:

\iniciocodigo
@<Primário Numérico: Regra 1@>=
if(begin_expression == end_expression ||
   (begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
    end_expression -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin_expression -> type == TYPE_NUMERIC &&
     begin_expression -> next != end_expression &&
     ((struct generic_token *) begin_expression -> next) -> type ==
       TYPE_DIVISION &&
     ((struct generic_token *) begin_expression -> next) -> next ==
       end_expression &&
     end_expression -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin_expression, end_expression,
                          result);
}
@
\fimcodigo

2) Se encontramos o operador \monoespaco{length}, apenas checamos se a
expressão depois dele é numérica, e se for, calculamos o seu
módulo. Se for de outro tipo, será definido depois como iremos
calcular. Isso assume que temos uma função que identifica o tipo de
uma expressão.

\iniciocodigo
@<Primário Numérico: Regra 2@>=
else if(begin_expression -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx,
                                             (struct generic_token *)
                                             begin_expression -> next,
                                             end_expression);
  if(expr_type == TYPE_T_NUMERIC){
    bool ret;
    struct numeric_variable num;
    ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                               begin_expression -> next,
                               end_expression, &num);
    if(!ret)
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Avalia 'length'@>
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "primary expression after 'length'.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;
  }
}
@
\fimcodigo

Mas como vamos reconhecer se estamos diante de uma expressão primária
que é numérica ou se estamos diante de uma que é de outro tipo?
Basicamente lendo seus tokens. Ainda não podemos definir uma função
que faz isso completamente, pois ainda temos que ver como são as
expressões primárias de outros tipos. Mas por hora vamos apresentar a
definição mais simplória de que se a expressão é composta por um único
token, se for numérico, a expressão é numérica, e se for uma variável,
é do tipo que foi declarada a variável. Isso captura o caso mais
simples de uso desta função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(begin_expr -> type == TYPE_SYMBOLIC){
      struct symbolic_token *p = (struct symbolic_token *) begin_expr;
      if(p -> var == NULL)
        return 0; // Desconhecido
      else{
        struct variable *v = (struct variable *) (p -> var);
        return v -> type;
      }
    }
  }
  else{ // TODO: Código temporário. Usar detecção mais completa
    struct generic_token *aux, *aux2;
    aux = (struct generic_token *) begin_expr -> next;
    aux = (struct generic_token *) aux -> next;
    aux2 = (struct generic_token *) aux -> next;
    aux2 = (struct generic_token *) aux2 -> next;
    if(begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
       end_expr -> type == TYPE_CLOSE_PARENTHESIS &&
       aux != NULL &&  aux -> type == TYPE_COMMA){
      if(aux2 -> type  == TYPE_COMMA)
        return TYPE_T_TRANSFORM;
      else
        return TYPE_T_PAIR;

}
    //@<Descobre Tipo de Expressão Primária@>
  }
  return TYPE_T_NUMERIC;
  //return 0; // Desconhecido
}
@
\fimcodigo

3) Se encontrarmos algum dos operadores numéricos, temos um operador
numérico seguido de um primário numérico.

O primeiro dos operadores numéricos é o de raíz quadrada:

\iniciocodigo
@<Primário Numérico: Regra 3@>=
else if(begin_expression -> type == TYPE_SQRT){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value < 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Square root "
            "of negative number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;
}
@
\fimcodigo

Em seguida, temos o \monoespaco{sind}, que interpreta o próximo número
em graus (``degrees'', por isso a letra ``d'' no fim) e calcula seu
seno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SIND){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = sinf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

O cálculo do cosseno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_COSD){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Em seguida calculamos o logaritmo na base $e$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_LOG){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value <= 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Computing logarithm of "
            "non-positive number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = logf(num.value);
  return true;
}
@
\fimcodigo

E a exponencial correspondente à $exp x = e^x$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_EXP){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = expf(num.value);
  return true;
}
@
\fimcodigo

O piso de um valor:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_FLOOR){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = floorf(num.value);
  return true;
}
@
\fimcodigo

Com relação ao operador \monoespaco{uniformdeviate}, o que ele faz é
gerar um número uniforme e aleatório entre 0 e o valor passado para o
operador. O modo que usaremos para fazer isso é gerar um número
aleatório em ponto flutuante entre 0 e 1, para em seguida
multiplicá-lo pelo operando.

Gerar um número em ponto flutuante entre 0 e 1 seguindo uma
distribuição próxima à uniforme, basicamente podemos gerar um inteiro
aleatório de 64 bits e multiplicá-lo por $2^{-64}$. Nem todos os valores
em ponto flutuante podem ser gerados desta forma, estaremos ignorando
valores menores que $2^{-64}$ e o arredondamento fará com que alguns
números mais próximos de 1 sejam mais comuns, embora a densidade
destes números mais comuns também seja menor. Entretanto, o resultado
será suficientemente próximo para nossos propósitos:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_UNIFORMDEVIATE){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;
  }
  return true;
}
@
\fimcodigo

O próximo operador numérico é o símbolo de \monoespaco{+}. Este
símbolo significa uma multiplicação por 1, e pode ser ignorado:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SUM){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  return true;
}
@
\fimcodigo

Já se tivermos um símbolo de \monoespaco{-}, então isso significa uma
multiplicação por -1:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SUBTRACT){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  result -> value *= -1;
  return true;
}
@
\fimcodigo


4) Nos demais casos, temos uma multiplicação escalar em que o escalar
é um token numérico primário, que não é sucedido
por \monoespaco{+}, \monoespaco{-} ou por outro token numérico. Para
lidar com isso, teremos que identificar o começo e o fim do token
numérico primário. Pelas regras ele é um único token numérico, ou
então três tokens (dois tokens numéricos separados pelo
token \monoespaco{/} representando uma fração). Depois de realizar a
separação, a primeira parte é multiplicada pela segunda (que é
interpretada como primário numérico):

\iniciocodigo
@<Primário Numérico: Regra 4@>=
else{
  bool ret;
  float token_value;
  struct generic_token *after_token;
  if(begin_expression -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  token_value = ((struct numeric_token *) begin_expression) -> value;
  after_token = (struct generic_token *) (begin_expression -> next);
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    after_token = (struct generic_token *) (after_token -> next);
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = (struct generic_token *) (after_token -> next);
  }
  ret = eval_numeric_primary(mf, cx, after_token, end_expression, result);
  if(!ret)
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Números Isolados e Valores Aleatórios Normais}

As regras finais para as expressões numéricas que iremos tratar são:

\alinhaverbatim
<Átomo Numérico> -> <Variável Numérica> |
                    <Token Numérico Primário> |
                    normaldeviate |
                    ( <Expressão Numérica> )
\alinhanormal

O único token novo a ser tratado é \monoespaco{normaldeviate}:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_NORMALDEVIATE  39 // O token simbólico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"normaldeviate",
@
\fimcodigo

Este operador serve para gerar um novo número aleatório com uma
distribuição normal com média 0 e desvio padrão 1.

A função que interpreta átomos numéricos é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result);
@
\fimcodigo

Vamos decidir qual regra aplicar para interpretar o átomo primeiro com
base nele ser um único token ou não. E depois, aplicamos diferentes
regras em cada caso:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result){
  if(begin_expression == end_expression){
    @<Átomo Numérico: Regra 1@>
    @<Átomo Numérico: Regra 2@>
    @<Átomo Numérico: Regra 3@>
  }
  else{
    @<Átomo Numérico: Regra 4@>
    @<Átomo Numérico: Regra 5@>
  }
  return false;
}
@

1) Se temos um único token e ele é um token numérico, basta retornar o
seu valor:

\iniciocodigo
@<Átomo Numérico: Regra 1@>=
if(begin_expression -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin_expression) -> value;
  return true;
}
@
\fimcodigo

2) Se temos um único token e ele é uma variável, retornamos o conteúdo
da variável. Mas temos que checar se ela foi declarada, se é numérica
e se foi inicializada:

\iniciocodigo
@<Átomo Numérico: Regra 2@>=
if(begin_expression -> type == TYPE_SYMBOLIC){
  struct numeric_variable *var;
  var = ((struct symbolic_token *) begin_expression) -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric variable "
            "'%s' in numeric expression.\n", mf -> file,
            begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(isnan(var -> value)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

3) Por fim, se temos um único token e ele é \monoespaco{normaldeviate},
então temos que gerar um número aleatório de uma distribuição
normal. Dado que temos uma função que gera números aleatórios, podemos
fazer isso procedendo da seguinte forma:

a) Geramos dois números aleatórios e uniformes entre -1 e 1, os quais
chamaremos de $u$ e $v$. Isso pode ser feito obtendo 64 bits,
multiplicando os 63 primeiros por $2^{-63}$ e usando o último bit para
definir o sinal. O resultado é suficientemente próximo de uniforme
para nossos propósitos.

b) Se $u^2+v^2 \geq 1$, isso significa que eles correspondem a pontos
fora de um círculo de raio 1. Neste caso, os descartamos e voltamos ao
passo 1. Também voltamos ao passo um se ambos forem zero, pois neste
caso o método não funcionaria.

c) Isso permite gerar dois valores que terão uma distribuição
uniforme:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

Um dos valores pode ser retornado. O outro pode ser armazenado na
estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Inicialmente a estrutura não tem nenhum valor destes armazenado, vamos
armazenar nela só depois de usarmos o método acima:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

Então, quando precisarmos gerar um valor aleatório de uma distribuição
normal, sempre verificamos se existe um valor pré-obtido, e se não nós
geramos os dois valores:

\iniciocodigo
@<Átomo Numérico: Regra 3@>=
if(begin_expression -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    random_bits = random_func();
    do{
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Agora os casos em que o átomo numérico tem mais de um token. O
primeiro caso é quanto o primeiro token é ``('' e o último é
``)''. Neste caso, a parte interna aos parênteses é interpretada como
uma expressão numérica:

\iniciocodigo
@<Átomo Numérico: Regra 4@>=
if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
   end_expression -> type == TYPE_CLOSE_PARENTHESIS){
   bool ret;
   struct generic_token *p = begin_expression;
   while(p -> next != end_expression)
     p = (struct generic_token *) p -> next;
   if(p == begin_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.",
            mf -> file, begin_expression -> line);
#endif
     return false;
   }
   ret = eval_numeric_expression(mf, cx, (struct generic_token *)
                                         begin_expression -> next, p,
                                         result);
   if(!ret)
     return false;
   return true;
}
@
\fimcodigo

5) Finalmente, o caso em que o átomo numérico é uma fração composta
por um token numérico, \monoespaco{/} e outro token numérico. O
resultado deve ser obtido dividindo ambos os tokens numéricos:

\iniciocodigo
@<Átomo Numérico: Regra 5@>=
if(begin_expression -> type == TYPE_NUMERIC &&
   end_expression -> type == TYPE_NUMERIC &&
   ((struct generic_token * ) begin_expression -> next) -> type ==
   TYPE_DIVISION){
  result -> value = ((struct numeric_token *) begin_expression) -> value /
           ((struct numeric_token *) end_expression) -> value;
  return true;
}
@
\fimcodigo


\subsecao{8.2. Atribuições e Expressões de Pares}

Para realizar a atribuição de pares a variáveis do tipo certo, usamos
o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Par@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pair_variable((struct pair_variable *) var -> var, &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

A declaração da função faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source){
  target -> x = source -> x;
  target -> y = source -> y;
}
@
\fimcodigo

Vamos agora à avaliação de expressões de pares.

\subsubsecao{8.2.1. Soma e Subtração}

As regras gramaticais para as expressões de pares começam com:

\alinhaverbatim
<Expressão de Par> -> <Terciário de Par>
<Terciário de Par> -> <Secundário de Par> | (...) |
                      <Terciário de Par> <PT-Op> <Secundário de Par>
<PT-Op> -> + | -
\alinhanormal

A soma e subtração é tratada exatamente como se espera de uma soma e
subtração de vetores.

A função que avalia expressões de pares é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result);
@
\fimcodigo

O método de avaliar as expressões de pares terciárias não é diferente
do que já fizemos com as expressões numéricas. Apenas temos menos
operadores terciários aqui.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct pair_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_pair_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_pair_secondary(mf, cx, begin_secondary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM){
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else
    return eval_pair_secondary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo


\subsubsecao{8.2.2. Transformações, Multiplicação e Divisão Escalar}

A gramática para expressões de pares secundárias é:

\alinhaverbatim
<Secundário de Par> -> <Primário de Par> |
                       <Par Secundário><Mul ou Div><Numérico Primário> |
                       <Secundário Numérico> * <Primário de Par> |
                       <Secundário de Par><Transformador>
<Mul ou Div> -> * | /
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> | (...)
\alinhanormal

Vamos adicionar as sete novas palavras-chave representando
transformadores:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_ROTATED  40 // O token simbólico 'rotated'
#define TYPE_SCALED   41 // O token simbólico 'scaled'
#define TYPE_SHIFTED  42 // O token simbólico 'shifted'
#define TYPE_SLANTED  43 // O token simbólico 'slanted'
#define TYPE_XSCALED  44 // O token simbólico 'xscaled'
#define TYPE_YSCALED  45 // O token simbólico 'yscaled'
#define TYPE_ZSCALED  46 // O token simbólico 'zscaled'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo

A declaração da função que avaliará expressões secundárias de pares:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct pair_variable *result);
@
\fimcodigo


Interpretar uma expressão secundária aqui é similar ao que fizemos
para as expressões numéricas. Também devemos percorrer a lista de
tokens até achar a operação secundária mais à direita, ignorando
aquilo que está aninhado entre parênteses e colchetes. Deve-se seguir
as mesmas regras para determinar se o \monoespaco{/} é mesmo uma
divisão ou se é uma fração. Mas como aqui temos um total de nove
operadores secundários, incluindo os transformadores, devido à
quantidade, vamos mostrar separadamente cada um deles ao invés de
colocá-los todos neste bloco de código abaixo:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct pair_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             // O operador 'transformed' não foi ainda definido. Será visto na
             // Subsubseção 8.3.4.
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ //  Divisão ou operadores válidos
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secondary != NULL){
    bool ret;
    begin_primary = (struct generic_token *) (last_mul -> next);
    @<Operador Secundário de Pares: Multiplicação@>
    @<Operador Secundário de Pares: Divisão@>
    @<Operador Secundário de Pares: Rotação@>
    @<Operador Secundário de Pares: Escala@>
    @<Operador Secundário de Pares: Deslocamento@>
    @<Operador Secundário de Pares: Inclinação@>
    @<Operador Secundário de Pares: X-Escala@>
    @<Operador Secundário de Pares: Y-Escala@>
    @<Operador Secundário de Pares: Z-Escala@>
    @<Operador Secundário de Pares: Operadores Adicionais@>
  }
  else
    return eval_pair_primary(mf, cx, begin_expression,
                             end_expression, result);
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O primeiro operador é o de multiplicação. Note que podemos ter dois
tipos de multiplicação: um par por um numérico ou um numérico por um
par. Para identificar qual dos dois tipos se aplica, devemos examinar
o tipo da expressão à direita do operador. Ela é uma expressão
primária e nós temos uma função que descobre o tipo de expressões
primárias:

\iniciocodigo
@<Operador Secundário de Pares: Multiplicação@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end_expression) ==
     TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    ret = eval_numeric_secondary(mf, cx, begin_expression, end_secondary,
                                 &a);
    if(!ret)
      return false;
    ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary,
                              &a);
    if(!ret)
      return false;
    ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }
}
@
\fimcodigo

Se temos uma divisão, então sempre será um par dividido por um
numérico. Devemos gerar erro em caso de divisão por zero:

\iniciocodigo
@<Operador Secundário de Pares: Divisão@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.",
            mf -> file, last_mul -> line);
#endif
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

Se temos uma rotação, rotacionamos nosso par no sentido anti-horário
em relação à origem, interpretando o ângulo em graus, não radianos:

\iniciocodigo
@<Operador Secundário de Pares: Rotação@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  theta = 0.0174533 * b.value;
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

Se temos uma mudança de escala, isso é sinônimo a uma multiplicação:

\iniciocodigo
@<Operador Secundário de Pares: Escala@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Um deslocamento é igual a uma soma, mas tem uma ordem de precedência
maior:

\iniciocodigo
@<Operador Secundário de Pares: Deslocamento@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

O operador de inclinação desloca mais à direita um ponto quanto mais
acima do eixo $x$ ele está e mais à esquerda quanto mais abaixo do
eixo $x$ ele está:

\iniciocodigo
@<Operador Secundário de Pares: Inclinação@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Mudança de escala no eixo $x$ multiplica um escalar apenas pelo
primeiro valor do par:

\iniciocodigo
@<Operador Secundário de Pares: X-Escala@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Assim como no eixo $y$ multiplica o escalar só pelo segundo valor do
par:

\iniciocodigo
@<Operador Secundário de Pares: Y-Escala@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Por fim, a mudança de escala $z$ înterpreta dois pares como números
complexos e os multiplica:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Operador Secundário de Pares: Z-Escala@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Valores Intermediários de Pares, Literais e Variáveis}

As regras gramaticais finais para a expressão de pares é:

\alinhaverbatim
<Primário de Par> -> <Variável de Par> |
                     ( <Expressão Numérica> , <Expressão Numérica> ) |
                     ( <Expressão de Par> ) |
                     (...) |
                     <Átomo Numérico>[<Expressão de Par,
                                      <Expressão de Par]  |
                     <Operador de Multiplicação Escalar><Primário de Par>
\alinhanormal

A novidade é a construção do tipo $a[b, c]$ onde $b$ e $c$ são
pares. Ela representa um valor intermediário entre os
pontos. Basicamente é avaliado como $a(b+c)$, de modo que $.5[b,c]$
representa o meio do caminho entre os dois pontos.

As outras regras são análogas às que já vimos na gramática de
expressões numéricas.

A função que avaliará expressões de pares primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result);
@
\fimcodigo

E cada uma das cinco regras gramaticais acima será testada
separadamente para sabermos qual regra devemos aplicar ao encontrar
uma expressão primária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result){
  if(begin_expression == end_expression){
    @<Primário de Par: Regra 1@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Primário de Par: Regra 2@>
    @<Primário de Par: Regra 3@>
  }
  @<Primário de Par: Outras Regras a Definir Depois@>
  @<Primário de Par: Regra 4@>
  @<Primário de Par: Regra 5@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

A primeira regra será aplicada quando temos um único token na
expressão. O único caso em que isso ocorre é quando a expressão é uma
variável de par:

\iniciocodigo
@<Primário de Par: Regra 1@>=
struct symbolic_token *tok = (struct symbolic_token *) begin_expression;
struct pair_variable *var;
if(tok -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable token "
          "in pair expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
var = (struct pair_variable *) tok -> var;
if(var == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
          "'%s'.\n", mf -> file, begin_expression -> line, tok -> value);
#endif
  return false;
}
if(var -> type != TYPE_T_PAIR){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Non-pair variable "
          "'%s' in pair expression.\n", mf -> file,
          begin_expression -> line, tok -> value);
#endif
  return false;
}
result -> x = var -> x;
result -> y = var -> y;
return true;
@
\fimcodigo

Se a expressão é delimitada por parênteses, nós tanto podemos estar
diante de uma representação literal de um par ($(a, b)$) como podemos
estar diante de parênteses com uma expressão de par completa dentro
dele, ao invés de um literal. Podemos diferenciar os dois casos pela
vírgula interna no parênteses, a qual está no mesmo escopo que $a$ e
$b$, não deve estar dentro de outros parênteses e colchetes.

\iniciocodigo
@<Primário de Par: Regra 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression (empty parenthesis).\n ", mf -> file,
              begin_expression -> line);
#endif
    return false;
  }
  begin_a = (struct generic_token *) begin_expression -> next;
  end_a = begin_a;
  DECLARE_NESTING_CONTROL();
  bool literal = true;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    bool ret;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    ret = eval_numeric_expression(mf, cx, begin_a, end_a, &a);
    if(!ret)
      return false;
    ret = eval_numeric_expression(mf, cx, begin_b, end_b, &b);
    if(!ret)
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

No código acima nós identificamos se estamos diante de um literal pela
presença da vírgula e nós identificamos isso marcando na variável
booleana \monoespaco{literal}. Portanto, se esta variável não for
verdadeira, imediatamente após o último \monoespaco{if} acima,
executamos o \monoespaco{else} como a próxima regra:

\iniciocodigo
@<Primário de Par: Regra 3@>=
else{
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
}
@
\fimcodigo

Se o último token for um \monoespaco{]}, então temos uma construção do
tipo $a[b,c]$. Nossa tarefa é separar essas três partes $a$, $b$ e
$c$, interpretá-las e retornar $a(b+c)$:

\iniciocodigo
@<Primário de Par: Regra 4@>=
if(end_expression -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  DECLARE_NESTING_CONTROL();
  begin_a = begin_expression;
  end_a = begin_a;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type ==
        TYPE_OPEN_BRACKETS)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_b = (struct generic_token *) end_a -> next;
  begin_b = (struct generic_token *) begin_b -> next;
  if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_b = begin_b;
  while(end_b != end_expression){
    COUNT_NESTING(end_b);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_b -> next) -> type == TYPE_COMMA)
      break;
    if(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_c = (struct generic_token *) end_b -> next;
  begin_c = (struct generic_token *) begin_c -> next;
  if(begin_c == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_c = begin_c;
  while(end_c -> next != end_expression)
    end_c = (struct generic_token *) end_c -> next;
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c))
    return false;
  result -> x = (b.x + c.x) * a.value;
  result -> y = (b.y + c.y) * a.value;
  return true;
}
@
\fimcodigo

A última regra é quando temos um operador de multiplicação escalar e
um par. O operador pode ser um token
de \monoespaco{+}, \monoespaco{-}, um único token numérico, ou então
uma fração:

% Primario par

\iniciocodigo
@<Primário de Par: Regra 5@>=
else{
  bool ret;
  if(begin_expression -> type == TYPE_SUM)
    return eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
  else if(begin_expression -> type == TYPE_SUBTRACT){
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin_expression -> type == TYPE_NUMERIC){
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin_expression) -> value;
    tok = (struct generic_token *) begin_expression -> next;
    if(tok -> type == TYPE_DIVISION){
      tok = (struct generic_token *) begin_expression -> next;
      if(tok == end_expression || tok -> next == end_expression ||
         tok -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "expression.\n ", mf -> file, begin_expression -> line);
#endif
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = (struct generic_token *) tok -> next;
    }
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pares em Expressões Numéricas}

Subexpressões numéricas podem aparecer dentro de expressões de
pares. Por exemplo, em $a[b,c]$ onde $a$ é um átomo numérico. Da mesma
forma, subexpressões de pares podem aparecer em expressões
numéricas. Mas não definimos os casos quando definimos as expressões
numéricas porque então não tínhamos ainda definido como avaliar
expressões de pares. Existem quatro operadores numéricos primários que
envolvem avaliar pares:

\alinhaverbatim
<Primário Numérico> -> length <Par Primário> | xpart <Par Primário> |
                       ypart <Par Primário> | angle <Par Primário>
\alinhanormal

Isso requer definir os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_XPART  47 // O token simbólico 'xpart'
#define TYPE_YPART  48 // O token simbólico 'ypart'
#define TYPE_ANGLE  49 // O token simbólico 'angle'
@
\fimcodigo

Correspondentes às seguintes palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

O primeiro caso, que não precisou de um token
novo, \monoespaco{length} já era usado para obter o módulo de números
e havíamos avisado que ele poderia ser usado para outros tipos. No
caso de pares, ele mede a norma euclideana deles:

\iniciocodigo
@<Avalia 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) hypot(p.x * p.x, p.y * p.y);
  return true;
}
@
\fimcodigo

O operador \monoespaco{xpart} simplesmente retorna o primeiro valor de
um par. Entretanto, devemos ter um cuidado adicional: este operador
pode ser usado em outro contexto como ainda será visto na Sub-subseção
8.3.3. Então devemos primeiro nos certificar que o que vem depois do
operador é um par. Em caso afirmativo, retornamos seu primeiro valor:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin_expression -> type == TYPE_XPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, (struct generic_token *)
                                                      begin_expression -> next,
                                                      end_expression);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                  begin_expression -> next, end_expression,
                                  &p))
      return false;
    result -> value = p.x;
    return true;
  }
  else{
    @<Primário Numérico: X-Part em Não-Par@>
  }
}
@
\fimcodigo

Enquanto o operador \monoespaco{ypart} retorna o segundo valor de um
par. Neste caso também devemos ter o mesmo cuidado de verificar se o
operando que temos depois é mesmo um par ou de algum outro tipo:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type == TYPE_YPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, (struct generic_token *)
                                                      begin_expression -> next,
                                                      end_expression);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                  begin_expression -> next, end_expression,
                          &p))
      return false;
    result -> value = p.y;
    return true;
  }
  else{
    @<Primário Numérico: Y-Part em Não-Par@>
  }
}
@
\fimcodigo

Por fim, o último operador, \monoespaco{angle} retorna o ângulo de um
par. É o ângulo do segmento que conecta a origem ao par em relação ao
segmento que conecta a origem à $(1,0)$. Um erro deve ser gerado se
tentar medir o ângulo de $(0,0)$:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin_expression -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Measuring the angle "
            "of (0,0).\n ", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = (float) asin(p.y / (hypot(p.x * p.x, p.y * p.y)));
  result -> value *= 57.2958; // Radianos para graus
  return true;
}
@
\fimcodigo

\subsecao{8.3. Atribuições e Expressões de Transformação}

Um dos momentos em que esperamos ter que avaliar uma expressão de
transformação quando formos fazer uma atribuição para uma variável de
transformação. Neste caso, devemos avaliar a expressão e realizar a
atribuição para todas as variáveis que estiverem do lado esquerdo da
expressão de atribuição:

\iniciocodigo
@<Atribuição de Variável de Transformação@>=
else if(type == TYPE_T_TRANSFORM){
  int i;
  struct transform_variable result;
  if(!eval_transform_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    memcpy(((struct transform_variable *) var -> var) -> value, result.value,
           sizeof(float) * 6);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Vamos agora ver como avaliar as expressões de transformação.

\subsubsecao{8.3.1. Transformações sobre Transformadores}

A regra gramatical para avaliar uma expressão de transformação começam
como:

\alinhaverbatim
<Expressão de Transformação> -> <Terciário de Transformação>
<Terciário de Transformação> -> <Secundário de Transformação>
<Secundário de Transformação> -> <Secundário de Transformação> <Transformador> |
                                 <Primário de Transformação>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário>
                   transformed <Primário de Transformação>
\alinhanormal

Temos aqui um novo tipo de token, representando o último tipo de
transformador que não havíamos definido na subseção anterior sobre
expressões de pares:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_TRANSFORMED  50 // O token simbólico 'transformed'
@
\fimcodigo

Ele corresponde à seguinte palavra reservada:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"transformed",
@
\fimcodigo

Com relação às regras gramaticais, elas dizem que não existem no
momento operadores terciários de transformação. De qualquer forma,
vamos definir a função que avalia expressões, e avalia operadores
terciários apenas como uma função que chama o avaliador de operadores
secundários. Tanto para manter a uniformidade das funções que avaliam
expressões como para deixar essa função pronta para ser modificada
caso versões futuras da linguagem venham a trazer operadores
terciários de transformação.

A declaração da função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expression,
                               struct generic_token *end_expression,
                               struct transform_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expression,
                               struct generic_token *end_expression,
                               struct transform_variable *result){
  return eval_transform_secondary(mf, cx, begin_expression, end_expression,
                                  result);
}
@
\fimcodigo

Já a função que avalia expressões secundárias de transformação é esta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin_expression,
                              struct generic_token *end_expression,
                              struct transform_variable *result);
@
\fimcodigo

A função funciona percorrendo a lista de tokens da expressão,
ignorando tokens dentro de parênteses, colchetes e chaves. Toda vez
que encontra o último operador secundário, ele é armazenado em uma
variável. Depois de percorrer todos os tokens, se não achamos um
operador secundário, nós passamos a expressão inteira para o avaliador
de expressões primárias. Se encontramos um, tudo que vem antes dele é
avaliado como expressão secundária e o resultado passa pelo operador,
que será operador transformador.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin_expression,
                              struct generic_token *end_expression,
                              struct transform_variable *result){
  struct generic_token *p, *last_transform = NULL, *last_token = NULL,
                       *end_secondary = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() &&
       (p -> type == TYPE_ROTATED || p -> type == TYPE_SCALED ||
        p -> type == TYPE_SHIFTED || p -> type == TYPE_SLANTED ||
        p -> type == TYPE_XSCALED || p -> type == TYPE_YSCALED ||
        p -> type == TYPE_ZSCALED || p -> type == TYPE_TRANSFORMED)){
      last_transform = p;
      end_secondary = last_token;
    }
    last_token = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(last_transform == NULL)
    return eval_transform_primary(mf, cx, begin_expression, end_expression,
                                  result);
  else{
    struct transform_variable a;
    if(end_secondary == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Transform expression began "
              "with transformer.",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_transform_secondary(mf, cx, begin_expression, end_secondary, &a))
      return false;
    @<Aplica Operador Secundário de Transformação@>
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer "
            "in transform expression.",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Vamos agora aplicar os diferentes transformadores sobre as nossas
variáveis e resultados de transformação. O primeiro tipo de
transformador é a rotação, que é equivalente a multiplicar a
transformação $(a, b, c, d, e, f)$ como abaixo:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{\cos(\theta) \atop -\sin(\theta)}\atop
      {0\atop 0}}{{\sin(\theta) \atop \cos(\theta)}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=
\left[{{c\cdot \cos(\theta) - e\cdot \sin(\theta) \atop
        d\cdot \cos(\theta) - f\cdot \sin(\theta)} \atop
      {0\atop a\cdot \cos(\theta) - b\cdot \sin(\theta)}}
      {{c\cdot \sin(\theta) + e\cdot \cos(\theta) \atop
      d\cdot \sin(\theta) + f\cdot \cos(\theta)}\atop
      {0 \atop a\cdot \sin(\theta) + b\cdot \cos(\theta)}}
      {{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

Sendo assim, aplicar a rotação sobre o transformador é feito com o
código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>=
if(last_transform -> type == TYPE_ROTATED){
  double cos_theta, sin_theta;
  struct numeric_variable theta;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                           &theta))
    return false;
  // 1 grau = 0,0174533 radianos
  sin_theta = sin(theta.value * 0.0174533);
  cos_theta = cos(theta.value * 0.0174533);
  // a' = a cos(t) - b sin(t)
  result -> value[0] = a.value[0] * cos_theta - a.value[1] * sin_theta;
  // b' = a sin(t) + b cos(t)
  result -> value[1] = a.value[0] * sin_theta + a.value[1] * cos_theta;
  // c' = c cos(t) - e sin(t)
  result -> value[2] = a.value[2] * cos_theta - a.value[4] * sin_theta;
  // d' = d cos(t) - f sin(t)
  result -> value[3] = a.value[3] * cos_theta - a.value[5] * sin_theta;
  // e' = c sin(t) + e cos(t)
  result -> value[4] = a.value[2] * sin_theta + a.value[4] * cos_theta;
  // f' = d sin(t) + f cos(t)
  result -> value[5] = a.value[3] * sin_theta + a.value[5] * cos_theta;
  return true;
}
@
\fimcodigo

Já mudar a escala de um transformador, ampliando ele $s$ vezes, é
equivalente a fazer a multiplicação de matrizes abaixo:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{s \atop 0}\atop
      {0\atop 0}}{{0 \atop s}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=
\left[{{cs \atop ds} \atop  {0\atop as}}
      {{es \atop fs}\atop   {0 \atop bs}}{{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

Então o código que aplica essa mudança de escala sobre transformações
é:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                           &scale))
    return false;
  result -> value[0] = a.value[0] * scale.value;
  result -> value[1] = a.value[1] * scale.value;
  result -> value[2] = a.value[2] * scale.value;
  result -> value[3] = a.value[3] * scale.value;
  result -> value[4] = a.value[4] * scale.value;
  result -> value[5] = a.value[5] * scale.value;
  return true;
}
@
\fimcodigo

A próxima transformação é realizar uma translação, ou deslocamento
$(x, y)$ sobre uma transformação. Isso equivale a multiplicar pela
matriz:

$$\left[{{c \atop d}\atop {0\atop a}}
        {{e \atop f}\atop {0 \atop b}}
        {{0\atop 0}\atop{1 \atop 0}}
        {{0 \atop 0}\atop{0\atop 1}}\right]
\left[{{1 \atop 0}\atop {0\atop x}}
      {{0 \atop 1}\atop {0 \atop y}}
      {{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
      =
\left[{{c \atop d}\atop {0\atop a+x}}
        {{e \atop f}\atop {0 \atop b+y}}
        {{0\atop 0}\atop{1 \atop 0}}
        {{0 \atop 0}\atop{0\atop 1}}\right]
$$

Então mantemos a maioria dos valores como estão, mas somamos os dois
primeiros elementos com o da coordenada $(x, y)$ de deslocamento:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SHIFTED){
  struct pair_variable shift;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end_expression,
                        &shift))
    return false;
  result -> value[0] = a.value[0] + shift.x;
  result -> value[1] = a.value[1] + shift.y;
  result -> value[2] = a.value[2];
  result -> value[3] = a.value[3];
  result -> value[4] = a.value[4];
  result -> value[5] = a.value[5];
  return true;
}
@
\fimcodigo

Agora vamos tratar o transformador que inclina a nossa transformação
uma quantia $s$. Isso é o equivalente a multiplicar pela matriz:

$$\left[{{c \atop d}\atop {0\atop a}}
        {{e \atop f}\atop {0 \atop b}}
        {{0\atop 0}\atop{1 \atop 0}}
        {{0 \atop 0}\atop{0\atop 1}}\right]
\left[{{1 \atop s}\atop {0\atop
      0}}{{0 \atop 1}\atop {0 \atop 1}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right] =
\left[{{c+se \atop d+sf}\atop {0\atop a+sb}}
        {{e \atop f}\atop {0 \atop b}}
        {{0\atop 0}\atop{1 \atop 0}}
        {{0 \atop 0}\atop{0\atop 1}}\right]
$$

Então o resultado terá metade dos valores iguais à transformação
anterior e metade deles modificados pela inclinação:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SLANTED){
  struct numeric_variable slant;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &slant))
    return false;
  // a' = a + sb
  result -> value[0] = a.value[0] + a.value[1] * slant.value;
  result -> value[1] = a.value[1];
  // c' = c + se
  result -> value[2] = a.value[2] + a.value[4] * slant.value;
  // d' = d + sf
  result -> value[3] = a.value[3] + a.value[5] * slant.value;
  result -> value[4] = a.value[4];
  result -> value[5] = a.value[5];
  return true;
}
@
\fimcodigo

A mudança de escala somente no eixo $x$ estica ou comprime a
transformação neste eixo. É equivalente à seguinte multiplicação:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{s \atop 0}\atop
      {0\atop 0}}{{0 \atop 1}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=
\left[{{cs \atop ds} \atop  {0\atop as}}
      {{e \atop f}\atop   {0 \atop b}}{{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

O que é obtido pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_XSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  // a' = as
  result -> value[0] = a.value[0] * scale.value;
  result -> value[1] = a.value[1];
  // c' = cs
  result -> value[2] = a.value[2] * scale.value;
  // d' = ds
  result -> value[3] = a.value[3] * scale.value;
  result -> value[4] = a.value[4];
  result -> value[5] = a.value[5];
  return true;
}
@
\fimcodigo

Podemos também fazer a mudança de escala somente no eixo $y$ usando o
fator de mudança $s$:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{1 \atop 0}\atop
      {0\atop 0}}{{0 \atop s}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=
\left[{{c \atop d} \atop  {0\atop a}}
      {{es \atop fs}\atop   {0 \atop bs}}{{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

O que é obtido pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_YSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  result -> value[0] = a.value[0];
  // b' = bs
  result -> value[1] = a.value[1] * scale.value;
  result -> value[2] = a.value[2];
  result -> value[3] = a.value[3] * scale.value;
  // e' = es
  result -> value[4] = a.value[4] * scale.value;
  // f' = fs
  result -> value[5] = a.value[5] * scale.value;
  return true;
}
@
\fimcodigo

Por fim, há a mudança de escala no plano complexo, que envolve
multiplicar os pontos por um par $(s, t)$, interpretado como um número
complexo. Isso obtém ao mesmo tempo tanto rotação como mudança de
escala. É feito pela multiplicação de matriz:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{s \atop -t}\atop {0\atop
      0}}{{t \atop s}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
=
\left[{{cs-dt \atop ds-ft} \atop  {0\atop as-bt}}
      {{ct+es \atop dt+fs}\atop   {0 \atop at+bs}}{{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

Esse transformador é implementado pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_ZSCALED){
  struct pair_variable scale;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  // a' = as - bt
  result -> value[0] = a.value[0] * scale.x - a.value[0] * scale.y;
  // b' = at + bs
  result -> value[1] = a.value[0] * scale.y + a.value[0] * scale.y;
  // c' = cs - dt
  result -> value[2] = a.value[2] * scale.x - a.value[3] * scale.y;
  // d' = ds - ft
  result -> value[3] = a.value[3] * scale.x - a.value[5] * scale.y;
  // e' = ct + es
  result -> value[4] = a.value[2] * scale.y + a.value[4] * scale.x;
  // f' = dt + fs
  result -> value[5] = a.value[3] * scale.y + a.value[5] * scale.x;
  return true;
}
@
\fimcodigo

Por fim, o último tipo de transformador. Quando temos duas
transformações e as multiplicamos para combiná-las em uma só:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{c' \atop d'}\atop
      {0\atop a'}}{{e' \atop f'}\atop {0 \atop
      b'}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
=
\left[{{cc'+ed' \atop dc'+fd'} \atop  {0\atop ac'+bd'+a'}}
      {{ce'+ef' \atop de'+ff'}\atop   {0 \atop ae'+bf'+b'}}
      {{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

Essa combinação de transformações é implementada pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_TRANSFORMED){
  struct transform_variable b;
  if(!eval_transform_primary(mf, cx, last_transform -> next, end_expression,
                            &b))
    return false;
  // a'' = ac'-bd'+a'
  result -> value[0] = a.value[0] * b.value[2] + a.value[1] * b.value[3] +
                       b.value[0];
  // b'' = ae'+bf'+b'
  result -> value[1] = a.value[0] * b.value[4] + a.value[1] * b.value[5] +
                       b.value[1];
  // c'' = cc'+ed'
  result -> value[2] = a.value[2] * b.value[2] + a.value[4] * b.value[3];
  // d'' = dc'+fd'
  result -> value[3] = a.value[3] * b.value[2] + a.value[5] * b.value[3];
  // e'' = ce'+ef'
  result -> value[4] = a.value[2] * b.value[4] + a.value[4] * b.value[5];
  // f'' = de'+ff'
  result -> value[5] = a.value[3] * b.value[4] + a.value[5] * b.value[5];
  return true;
}
@
\fimcodigo

\subsecao{8.3.2 Expressões Terciárias de Transformação: Literais e Variáveis}

Continuando a gramática das expressões de transformadores, as próximas
regras são:

\alinhaverbatim
<Primário de Transformação> -> <Variável de Transformação> |
                               ( <Terciário de Transformação> ) |
                               ( <Expressão Numérica> , <Expressão Numérica> ,
                                 <Expressão Numérica> , <Expressão Numérica> ,
                                 <Expressão Numérica> , <Expressão Numérica> )
\alinhanormal

No primeiro caso, temos só um token simbólico com uma variável de
transformação. Nos dois outros casos, o primeiro Token é o abrir de
parênteses. No primeiro, há só uma expressão entre parênteses que
avaliará para um transformador. No segundo, temos seis expressões
numéricas que formarão os valores de nosso transformador.

A função que avaliará as expressões primárias de transformação é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct transform_variable *result);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct transform_variable *result){
  if(begin_expression == end_expression &&
     begin_expression -> type == TYPE_SYMBOLIC){
    @<Transformação Primária: Variável@>
  }
  else if(begin_expression != end_expression &&
          begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS &&
          begin_expression -> next != end_expression){
    struct generic_token *p = begin_expression -> next;
    DECLARE_NESTING_CONTROL();
    bool has_comma = false;
    do{
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() && p -> type == TYPE_COMMA){
        RESET_NESTING_COUNT();
        has_comma = true;
        break;
      }
      if(p != end_expression)
        p = (struct generic_token *) p -> next;
      else
        p = NULL;
    } while(p != NULL && p != end_expression);
    if(has_comma){
      @<Transformação Primária: Literal@>
    }
    else{
      @<Transformação Primária: Parênteses@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transform primary "
          "expression.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O caso mais simples é quando estamos só lendo uma variável:

\iniciocodigo
@<Transformação Primária: Variável@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct transform_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not allocated variable: "
          "%s.\n", mf -> file, v -> line, v -> value);
#endif
  return false;
}
memcpy(result -> value, content -> value, sizeof(float) * 6);
return true;
@
\fimcodigo

O próximo caso que trataremos é quando temos uma subexpressão entre
parênteses. Devemos apenas avaliar ela após descartar os parênteses
delimitadores:

\iniciocodigo
@<Transformação Primária: Parênteses@>=
struct generic_token *end_expr;
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis in transform "
          "expression.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
for(end_expr = begin_expression -> next; end_expr -> next != end_expression;
    end_expr = end_expr -> next);
return eval_transform_expression(mf, cx, begin_expression -> next, end_expr,
                                 result);
@
\fimcodigo

E finalmente, quando temos um literal de transformação formado por
seis expressões numéricas separadas por vírgulas:

\iniciocodigo
@<Transformação Primária: Literal@>=
int i;
struct generic_token *begin_numeric_expr, *end_numeric_expr;
struct numeric_variable numeric_result;
begin_numeric_expr = begin_expression -> next;
end_numeric_expr = begin_numeric_expr;
for(i = 0; i < 6; i ++){
  p = begin_numeric_expr;
  do{
    if(p != end_expression){
      COUNT_NESTING(p);
    }
    if(IS_NOT_NESTED() && ((i < 5 && p -> type == TYPE_COMMA) ||
                            (i == 5 && p -> type == TYPE_CLOSE_PARENTHESIS))){
      break;
    }
    end_numeric_expr = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(p == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Invalid transform literal in "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_numeric_expression(mf, cx, begin_numeric_expr, end_numeric_expr,
                              &numeric_result))
    return false;
  result -> value[i] = numeric_result.value;
  begin_numeric_expr = p -> next;
  end_numeric_expr = begin_numeric_expr;
}
return true;
@
\fimcodigo

\subsubsecao{8.3.3. Transformações em Expressões Numéricas}

Transformações podem aparecer dentro de expressões primárias
numéricas. Existem as seguintes regras gramaticais adicionais que as
prevêem:

\alinhaverbatim
<Primário Numérico> -> <Parte de Transformação><Primário de Transformação>
<Parte de Transformação> -> xpart | ypart | xxpart | xypart | yxpart | yypart
\alinhanormal

Os seis operadores acima servem para extrair cada um dos seis valores
numéricos que compõe uma transformação. A ordem em que aparecem acima
é a mesma ordem na qual eles extraem o elemento da transformação.

Como \monoespaco{xpart} e \monoespaco{ypart} já havia aparecido quando
definíamos as expressões de pares, resta definirmos tokens para os
outros quatro operadores que são novos:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_XXPART  51 // O token simbólico xxpart'
#define TYPE_XYPART  52 // O token simbólico xypart'
#define TYPE_YXPART  53 // O token simbólico yxpart'
#define TYPE_YYPART  54 // O token simbólico yypart'
@
\fimcodigo

E as palavras reservadas associadas a cada token:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"xxpart", "xypart", "yxpart", "yypart",
@
\fimcodigo

Estes quatro novos operadores são tratados na função que avalia
expressões numéricas primárias:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type >= TYPE_XXPART &&
         begin_expression -> type <= TYPE_YYPART){
  struct transform_variable t;
  if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                       begin_expression -> next, end_expression,
                             &t))
    return false;
  result -> value = t.value[2 + begin_expression -> type - TYPE_XXPART];
  return true;
}
@
\fimcodigo

Mas e quanto ao \monoespaco{xpart} e \monoespaco{ypart}? Em princípio,
eles já foram tratados para o caso em que extraimos valores de
pares. Precisamos apenas incrementar a definição já feita na
Sub-subseção 8.2.4. para tratar o caso em que devemos aplicá-la quando
não temos um par. Fazendo isso no caso do \monoespaco{xpart}:

\iniciocodigo
@<Primário Numérico: X-Part em Não-Par@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &t))
  return false;
result -> value = t.value[0];
return true;
@
\fimcodigo

O mesmo deve ser feito no operador \monoespaco{ypart}:

\iniciocodigo
@<Primário Numérico: Y-Part em Não-Par@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &t))
  return false;
result -> value = t.value[1];
return true;
@
\fimcodigo

\subsubsecao{8.3.4. Transformações em Expressões de Pares}

Transformações também aparecem nas regras gramaticais de expressões de
pares. Existe uma expressão secundária que obtém uma expressão
secundária de par do lado esquerdo e um primário de transformação do
lado direito:

\alinhaverbatim
<Secundário de Par> -> <Secundário de Par><Transformador>
<Transformador> -> (...) | transformed <Primário de Transformação>
\alinhanormal

O que este operador faz é aplicar a transformação linear sobre o
par. Vamos implementá-lo com o código adicional abaixo que irá se
somar ao código que implementa transformações sobre pares da
Subsubseção 8.2.2.

\iniciocodigo
@<Operador Secundário de Pares: Operadores Adicionais@>=
else if(last_mul -> type == TYPE_TRANSFORMED){
  struct pair_variable a;
  struct transform_variable b;
  if(!eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a))
    return false;
  if(!eval_transform_primary(mf, cx, begin_primary, end_expression, &b))
    return false;
  result -> x = b.value[0] + a.x * b.value[2] + a.y * b.value[3];
  result -> y = b.value[1] + a.x * b.value[4] + a.y * b.value[5];
  return true;
}
@
\fimcodigo

\subsecao{8.4. Atribuições e Expressões de Caminhos}

Para realizar a atribuição de caminhos a variáveis do tipo certo,
usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Caminho@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  if(!eval_path_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_path_variable(mf, (struct path_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &result, false);
}
@
\fimcodigo

A declaração da função faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> length != -1 && disalloc != NULL)
    path_recursive_free(disalloc, target, false);
  recursive_copy_points(alloc, &target, source, false);
}
@
\fimcodigo

Copiar um caminho recursivamente significa alocar espaço para o novo
caminho a ser copiado e copiar seus dados. Ao copiar seus pontos,
devemos também checar se há outros subcaminhos que devem ser copiados
recursivamente. Para fazer isso, usamos a seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target);
@
\fimcodigo

Essa função faz a alocação se necessário, obtém ponteiros necessários
e em seguida chama a função que efetivamente percorre recursivamente a
origem enquanto copia para o destino os pontos da origem:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target){
  struct path_points *p;
  if(alloc_target)
    *target = (struct path_variable *) alloc(sizeof(struct path_variable));
  (*target) -> cyclic = source -> cyclic;
  (*target) -> length = source -> total_length;
  (*target) -> total_length = source -> total_length;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> total_length);
  p = (*target) -> points;
  recursive_aux_copy(&p, source);
}
@
\fimcodigo

A função que efetivamente percorre os pontos recursivamente e copia:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin){
  int index = 0;
  while(index <= origin -> length - 1){
    if(origin -> points[index].subpath == NULL &&
       !isnan(origin -> points[index].x)){
      // Copy:
      memcpy(*dst, &(origin -> points[index]),  sizeof(struct path_points));
      (*dst) -> subpath = NULL;
      (*dst) ++;
    }
    else if(origin -> points[index].subpath != NULL)
      recursive_aux_copy(dst, (struct path_variable *)
                              (origin -> points[index].subpath));
    index  ++;
  }
  return;
}
@
\fimcodigo


Vejamos agora a expressões que existem para expressões de caminhos:

\subsubsecao{8.4.1. Junção de Caminhos}

A gramática para a expressão de caminhos começa com:

\alinhaverbatim
<Expressão de Caminho> -> <Expressão de Par> | <Terciário de Caminho> |
                          <Sub-expressão de Caminho><Especificador de Direção> |
                          <Sub-expressão de Caminho><Junção de Caminho> cycle
<Junção de Caminho> -> <Especificador de Direção><Junção Básica>
                       <Especificador de Direção>
<Junção Básica> -> & | .. | .. <Tensão> .. | .. <Controles> .. | --
<Tensão> -> tension <Quantidade de Tensão> |
            tension <Quantidade de Tensão> and <Quantidade de Tensão>
<Quantidade de Tensão> -> <Primário Numérico> | atleast <Primário Numérico>
<Controles> -> controls <Par Primário> |
               controls <Par Primário> and <Par Primário>
<Especificação de Direção> -> Vazio |
                              { <Expressão de Par } |
                              { <Expressão Numérica> , <Expressão Numérica> }
<Sub-expressão de Caminho> -> <Expressão de Caminho> |
                              <Sub-expressão de Caminho><Junção de Caminho>
                              <Terciário de Caminho>
\alinhanormal

Tudo isso requer que registremos os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_CYCLE          55 // O token simbólico 'cycle'
#define TYPE_AMPERSAND      56 // O token simbólico '&'
#define TYPE_JOIN           57 // O token simbólico '..'
#define TYPE_TENSION        58 // O token simbólico 'tension'
#define TYPE_AND            59 // O token simbólico 'and'
#define TYPE_ATLEAST        60 // O token simbólico 'atleast'
#define TYPE_CONTROLS       61 // O token simbólico 'controls'
#define TYPE_CURL           52 // O token simbólico 'curl'
                               // (ainda não suportado)
#define TYPE_STRAIGHT_JOIN  63 // O token simbólico '--'
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"cycle", "&", "..", "tension", "and", "atleast", "controls", "curl", "--",
@
\fimcodigo

O que as regras gramaticais revelam é que toda expressão de caminho é
formado pela junção de vários outros sub-caminhos. Se não existir
nenhuma junção, então nosso caminho é um par, que é considerado um
caminho de um único ponto.

Uma das coisas que temos a fazer então é contar quantas junções
existem em uma expressão de caminho. Realizar a contagem pode ser
feito com a seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end);
@
\fimcodigo

A função funciona contando o número de ``\&'', ``--'' e também contando os
``..'' quando eles aparecem sozinhos ou quando eles aparecem pela
segunda vez dentro de uma junção que especifica pontos de controle ou
tensão:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end){
  int count = 0;
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin;
  while(p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_AMPERSAND)
        count ++;
      else if(p -> type == TYPE_STRAIGHT_JOIN)
        count ++;
      else if(p -> type == TYPE_JOIN){
        struct generic_token *next = (struct generic_token *) p -> next;
        if(p == end || (next -> type !=  TYPE_TENSION &&
                        next -> type != TYPE_CONTROLS))
          count ++;
      }
    }
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }
  return count;
}
@
\fimcodigo

Agora podemos começar a tratar as expressões:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result);
@
\fimcodigo


Saber o número de junções é o primeiro passo para saber o tamanho da
variável de caminho que estamos gerando e saber como alocar espaço
para ela. O número de elementos (pontos e sub-caminhos) de uma
variável de caminho é sempre igual ao número de junções mais um:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result){
  int expected_length;
  int number_of_joins = count_path_joins(begin_expression, end_expression);
  expected_length = number_of_joins + 1;
  @<Expressão de Caminho: Quando Não Há Junção@>
  @<Expressão de Caminho: Alocar Variável de Caminho@>
  @<Expressão de Caminho: Itera sobre Junções@>
  return true;
}
@
\fimcodigo

E se o número de junções for zero? Neste caso, podemos estar diante de
uma expressão de par, ou de uma expressão terciária de caminho. De
qualquer forma, pode haver um ou mais especificador de direção depois
da expressão, o qual precisa ser ignorado. Podemos checar se temos
especificadores de direção checando se o último token é um
``$\}$''. Se for o caso, mudamos a posição do fim da expressão para
imediatamente antes do primeiro especificador de direção:

\iniciocodigo
@<Expressão de Caminho: Quando Não Há Junção@>=
if(number_of_joins == 0){
  if(end_expression -> type == TYPE_CLOSE_BRACES){
    struct generic_token *p = begin_expression;
    DECLARE_NESTING_CONTROL();
    while(p != end_expression){
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() &&
         ((struct generic_token *) p -> next) -> type == TYPE_OPEN_BRACES)
        break;
      p = (struct generic_token *) p -> next;
    }
    end_expression = p;
  }
  return eval_path_tertiary(mf, cx, begin_expression, end_expression,
                            result);
}
@
\fimcodigo

Se existir uma ou mais junções, então caberá a nós criar uma nova
variável de caminho alocando as estruturas necessárias para ela. O que
temos a fazer é alocar nela um número de pontos igual à
variável \monoespaco{expected\_length}:

\iniciocodigo
@<Expressão de Caminho: Alocar Variável de Caminho@>=
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points) *
                     expected_length);
if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
          begin_expression -> line);
#endif
    return false;
}
result -> length = 0; // Inicialização
result -> total_length = 0;
result -> points[0].x = NAN;
result -> cyclic = false;
@
\fimcodigo

Agora temos que interpretar todas as junções. Temos que iterar sobre
cada junção presente na expressão, as quais possuem o formato:

$$
z_1{d} j {e}z_2
$$

Então vamos usar variáveis para indicar o começo e o fim de cada parte
à medida que iteramos. Vamos criar um laço onde iremos iterar sobre
cada uma das junções no formato acima para interpretá-las:

\iniciocodigo
@<Expressão de Caminho: Itera sobre Junções@>=
{
  struct generic_token *begin_z1, *end_z1 = NULL, *begin_z2, *end_z2;
  struct generic_token *begin_d = NULL, *end_d = NULL, *begin_e, *end_e;
  struct generic_token * begin_j, *end_j;
  struct path_points *z1_point = NULL, *z2_point = NULL;
  @<Expressão de Caminho: Declaração de Variáveis Adicionais@>
  begin_z1 = begin_expression;
  end_z1 = begin_z1;
  while(begin_z1 != end_expression || result -> length < expected_length){
    @<Expressão de Caminho: Separa Tokens da Junção@>
    @<Expressão de Caminho: Interpreta Extremidades da Junção@>
    @<Expressão de Caminho: Interpreta Direção se Existir@>
    @<Expressão de Caminho: Interpreta Junção@>
    @<Expressão de Caminho: Decide Forma da Curva@>
    @<Expressão de Caminho: Fim de Cada Iteração@>
    begin_z1 = begin_z2;
    end_z1 = end_z2;
  }
  
}
@
\fimcodigo

Para delimitar o primeiro elemento $z_1$, na primeira vez quando ainda
estamos no começo da expressão, basta avançarmos os tokens até
acharmos o primeiro ``{'', ``..'', ``\-\-'' ou ``\&'' fora de qualquer
parênteses ou colchetes. Nas demais vezes, o primeiro elemento $z_1$
já começa uma nova iteração delimitado como indicado no código acima.

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>=
if(begin_z1 == begin_expression){
  DECLARE_NESTING_CONTROL();
  int next_type;
  while(end_z1 != end_expression){
    COUNT_NESTING(end_z1);
    next_type = ((struct generic_token *) end_z1 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z1 = (struct generic_token *) end_z1 -> next;
  }
}
@
\fimcodigo

Agora vamos delimitar o primeiro especificador de direção. Primeiro
checamos se estamos no fim da expressão. Se estivermos, interrompemos
o laço e saímos, pois já terminamos de obter o resultado da expressão
e não haverá mais delimitador nenhum. Caso contrário, lemos o próximo
token para ver se é um ``$\{$''. Se não for, não há o primeiro
especificador de direção. Se for, então delimitamos ele até acharmos o
próximo ``$\}$'':

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_z1 == end_expression)
  return true;
begin_d = (struct generic_token *) end_z1 -> next;
if(begin_d -> type != TYPE_OPEN_BRACES){
  begin_d = NULL;
  end_d = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_d = begin_d;
  while(end_d  != end_expression){
    COUNT_NESTING(end_d);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_d) -> type == TYPE_CLOSE_BRACES)
      break;
    end_d = (struct generic_token *) end_d -> next;
  }
  if(begin_d == end_d){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_d -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Agora vamos delimitar a junção. Se ela for um ``\&'' ou um ``--'', ela
corresponde a um único token. Se for um ``..'', devemos checar o
próximo token para identificar se temos um ``\monoespaco{controls}''
ou ``\monoespaco{tension}''. Em caso afirmativo, teremos que delimitar
a junção englobando do primeiro ``..'' até o segundo ``..''. Em caso
negativo, a junção é somente um token ``..''.

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_d == NULL)
  begin_j = (struct generic_token *) end_z1 -> next;
else{
  if(end_d == end_expression)
    return true;
  begin_j = (struct generic_token *) end_d -> next;
}
end_j = begin_j;
if(begin_j -> type == TYPE_JOIN){
  struct generic_token *next_token;
  next_token = (struct generic_token *) begin_j -> next;
  if(next_token -> type == TYPE_CONTROLS || next_token -> type == TYPE_TENSION){
    DECLARE_NESTING_CONTROL();
    end_j = next_token;
    while(end_j != end_expression){
      COUNT_NESTING(end_j);
      if(IS_NOT_NESTED() && end_j -> type == TYPE_JOIN)
        break;
      end_j = (struct generic_token *) end_j -> next;
    }
  }
}
else if(begin_j -> type != TYPE_AMPERSAND &&
        begin_j -> type != TYPE_STRAIGHT_JOIN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, begin_j -> line);
#endif
  return false;
}
@
\fimcodigo

O próximo delimitador de direção pode existir ou não dependendo de
termos um token ``$\{$'' após a junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_j == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, end_j -> line);
#endif
  return false;
}
begin_e = (struct generic_token *) end_j -> next;
if(begin_e -> type != TYPE_OPEN_BRACES){
  begin_e = NULL;
  end_e = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_e = begin_e;
  while(end_e  != end_expression){
    COUNT_NESTING(end_e);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_e) ->  type == TYPE_CLOSE_BRACES)
      break;
    end_e = (struct generic_token *) end_e -> next;
  }
  if(begin_e == end_e){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_e -> line);
#endif
    return false;
  }
}
@
\fimcodigo

E por fim, o último elemento da junção é o próximo ponto da junção,
que seria uma expressão de caminho terciária. Este próximo elemento
tem seu fim delimitado pelo fim da expressão, por um token de abrir
chaves, ou pelo começo da próxima junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
{
  DECLARE_NESTING_CONTROL();
  int next_type;
  if(end_e == NULL)
    begin_z2 = (struct generic_token *) end_j -> next;
  else{
    if(end_e == end_expression)
      return true;
    begin_z2 = (struct generic_token *) end_e -> next;
  }
  end_z2 = begin_z2;
  while(end_z2 != end_expression){
    COUNT_NESTING(end_z2);
    next_type = ((struct generic_token *) end_z2 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z2 = (struct generic_token *) end_z2 -> next;
  }
}
@
\fimcodigo

Uma vez que tenhamos identificado cada parte da junção, temos que
interpretar cada uma delas. Primeiro devemos identificar os pontos das
extremidades da junção e copiá-las para o resultado da expressão. Para
isso primeiro interpretaremos $z_1$, a primeira extremidade de
junção. Ela precisa ser interpretada só no começo da expressão, nos
demais casos ela já foi obtida na iteração anterior:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>=
if(begin_z1 == begin_expression){
  bool ret;
  struct path_variable z1;
  ret = eval_path_tertiary(mf, cx, begin_z1, end_z1, &z1);
  if(!ret)
    return false;
  if(z1.length == 1 && z1.points[0].subpath == 0){
    result -> points[0].subpath = NULL;
    result -> points[0].x = z1.points[0].x;
    result -> points[0].y = z1.points[0].y;
    result -> total_length ++;
  }
  else{
    recursive_copy_points(temporary_alloc, (struct path_variable **)
                                           &(result -> points[0].subpath), &z1,
                                           true);
    result -> total_length += ((struct path_variable *)
                                result -> points[0].subpath) -> total_length;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z1, false);
}
@
\fimcodigo

E devemos fazer o mesmo com a outra extremidade da junção: $z_2$. Para
este caso, devemos levar em conta que podemos estar diante de um
token \monoespaco{cycle} ou de um ponto ou sub-caminho normal. Se for um
token \monoespaco{cycle}, devemos copiar o primeiro ponto. Caso
contrário, fazemos tal como fizemos para obter o $z_1$:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  struct path_points *p = result -> points;
  while(p[0].subpath != NULL)
    p = ((struct path_variable *) p[0].subpath) -> points;
  result -> points[result -> length].subpath = NULL;
  result -> points[result -> length].x = p[0].x;
  result -> points[result -> length].y = p[0].y;
  result -> points[result -> length].u_x = p[0].u_x;
  result -> points[result -> length].u_y = p[0].u_y;
  result -> points[result -> length].v_x = p[0].v_x;
  result -> points[result -> length].v_y = p[0].v_y;
  result -> length ++;
  result -> total_length ++;
  result -> cyclic = true;
}
else{
  bool ret;
  struct path_variable z2;
  ret = eval_path_tertiary(mf, cx, begin_z2, end_z2, &z2);
  if(!ret)
    return false;
  if(z2.length == 1 && z2.points[0].subpath == 0){
    result -> points[result -> length].subpath = NULL;
    result -> points[result -> length].x = z2.points[0].x;
    result -> points[result -> length].y = z2.points[0].y;
    result -> total_length ++;
  }
  else{
    recursive_copy_points(temporary_alloc,
                         (struct path_variable **)
                         &(result -> points[result -> length].subpath), &z2, true);
    result -> total_length +=
        ((struct path_variable *)
            result -> points[result -> length].subpath) -> total_length;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z2, false);
}
@
\fimcodigo

Após rodarmos o código acima, nossa variável de resultado da expressão
que estamos montando já possui todos os pontos de extremidade desta
junção ajustados. Mas nós ainda não temos os pontos de controle. Mas
antes de poder calculá-los, vamos ajustar os
ponteiros \monoespaco{z1\_point} e \monoespaco{z2\_point} para apontar
para os pontos de extremidade da junção atual, obtendo tal informação
da variável \monoespaco{result} que estamos preenchendo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
z1_point = &(result -> points[result -> length - 2]);
while(z1_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z1_point -> subpath;
  z1_point = &(p -> points[p -> length - 1]);
}
z2_point = &(result -> points[result -> length - 1]);
while(z2_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z2_point -> subpath;
  z2_point = &(p -> points[0]);
}
@
\fimcodigo

Agora temos que interpretar os dois especificadores de direção. Eles
podem ser vazios (equivalente a ter uma direção $(0, 0)$) ou podem ser
um par especificando um vetor de direção.

Vamos armazenar os especificadores em variáveis \monoespaco{(w0\_x,
w0\_y)} e \monoespaco{(w1\_x, w1\_y)}.  Também vamos armazenar estes
valores da iteração anterior e também da próxima, já que em alguns
casos será necessário lembrar o que havia antes ou espiar o que existe
depois para montarmos uma curva levando em conta um contexto maior:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>=
float w0_x = NAN, w0_y = NAN, w1_x = NAN, w1_y = NAN;
float prev_w_x = NAN, prev_w_y = NAN;
float next_w_x = NAN, next_w_y = NAN;
@
\fimcodigo

Durante a iteração em que estamos delimitando e interpretando os
valores presentes na junção devemos reinicializar tais valores. O
primeiro dos especificadores atuais não precisa ser lido novamente e
só herda valores já armazenados se por algum motivo ele foi lido
anteriormente e está armazenado na variável que na iteração anterior
armazenou o que seria o próximo valor. Depois disso, os próximos
valores são apagados. E por fim, lemos o segundo especificador de
direção:

\iniciocodigo
@<Expressão de Caminho: Interpreta Direção se Existir@>=
w0_x = w0_y = w1_x = w1_y = NAN;
if(!isnan(next_w_x)){
  w0_x = next_w_x;
  w0_y = next_w_y;
}
else if(!eval_direction_specifier(mf, cx, begin_d, end_d, &w0_x, &w0_y))
  return false;
next_w_x = next_w_y = NAN;
if(!eval_direction_specifier(mf, cx, begin_e, end_e, &w1_x, &w1_y))
  return false;
@
\fimcodigo

A função que avalia os especificadores de direção é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y);
@
\fimcodigo

E ela funciona checando quatro casos diferentes: quando não há
especificador nenhum, quando ele é especificador de curvatura, quando
é um de direção no formato de dois números e quando é um de direção no
formato de um par:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y){
  @<Especificador de Direção: Caso 1@>
  @<Especificador de Direção: Caso 2@>
  @<Especificador de Direção: Caso 3@>
  return false;
}
@
\fimcodigo

Quando um especificador não existe, não marcamos nada e retornamos,
deixando como indefinidos os valores:

\iniciocodigo
@<Especificador de Direção: Caso 1@>=
if(begin == NULL || end == NULL){
  return true;
}
@
\fimcodigo

Agora devemos checar se temos um caso do tipo ``$\{ a , b\}$'' onde
$a$ e $b$ são números. Para isso, tentaremos delimitar os tokens de
$a$ e $b$ procurando pela vírgula. Mas somente se a vírgula for
encontrada, iremos tratar a especificação desta forma:

\iniciocodigo
@<Especificador de Direção: Caso 2@>=
DECLARE_NESTING_CONTROL();
struct generic_token *begin_a, *end_a, *begin_b = NULL, *end_b;
begin_a = (struct generic_token *) begin -> next;
end_a = begin_a;
while(end_a -> next != end){
  COUNT_NESTING(end_a);
  if(IS_NOT_NESTED() && end_a -> type == TYPE_COMMA){
    begin_b = (struct generic_token *) end_a -> next;
    break;
  }
  end_a = (struct generic_token *) end_a -> next;
}
if(begin_b != NULL){
  struct numeric_variable a, b;
  end_b = begin_b;
  while(end_b -> next != end)
    end_b = (struct generic_token *) end_b -> next;
  if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(a.value != 0.0 || b.value != 0.0){
    *w_x = a.value;
    *w_y = b.value;
  }
  return true;
}
@
\fimcodigo

E finalmente, o último caso, onde teremos um elemento $\{a\}$, onde
$a$ é uma expressão de par. Para tratar este caso, observe que no caso
anterior nós já delimitamos $a$. Se a vírgula não foi encontrada, de
qualquer forma temos seus tokens delimitados. Então podemos
interpretá-los como uma expressão de par:

\iniciocodigo
@<Especificador de Direção: Caso 3@>=
else{ // Se no caso anterior não achamos a vírgula
  struct pair_variable a;
  if(!eval_pair_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(a.x != 0.0 || a.y != 0.0){
    *w_x = a.x;
    *w_y = a.y;
  }
  return true;
}
@
\fimcodigo

Agora finalmente devemos interpretar a junção em si. Assim como o
especificador de direção pode estar expresso como um par representando
um vetor de direção ou como um inteiro representando a curvatura, a
junção pode ser representada como dois números representando a tensão
(ou o limite inferior para a tensão) ou como dois pares $u$ e $v$
representando os dois pontos de controle diretamente. Vamos colocar
agora as variáveis que irão armazenar os valores:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>=
float tension0 = NAN, tension1 = NAN, u_x = NAN, u_y = NAN, v_x = NAN,
      v_y = NAN;
bool atleast0 = false, atleast1 = false; // Se a tensão é só um limite inferior
@
\fimcodigo

Primeiro vamos tratar os casos mais simples. Se nossa junção for um
token ``\&'', então estamos lidando com a concatenação de dois pontos
ou (mais provavelmente) sub-caminhos. Neste caso, devemos checar se os
dois pontos que estão sendo unidos ocupam a mesma posição
(consideramos a mesma posição como sendo uma distância menor que
0,00002). Se não estiverem, um erro deve ser gerado. Se estiverem,
juntaremos ambos os caminhos removendo a segunda cópia do ponto onde
está sendo feita a junção.

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
  double dif_x = z1_point -> x - z2_point -> x;
  double dif_y = z1_point -> y - z2_point -> y;
  if(hypot(dif_x * dif_x, dif_y * dif_y) > 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Concatenating discontinuous paths.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  v_x = u_x = z1_point -> x;
  v_y = u_y = z1_point -> y;
  // Isso fará o primeiro ponto de extremidade ser sobrescrito
  result -> total_length --;
  z1_point -> x = NAN;
  z1_point -> y = NAN;
}
@
\fimcodigo

Outro caso simples será quando usamos a junção composta por
``\monoespaco{--}''. Neste caso, devemos preencher os pontos de
controle como igualmente espaçados entre os dois pontos de extremidade
formando uma reta:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN){
  u_x = z1_point -> x + (1.0/3.0) * (z2_point -> x - z1_point -> x);
  u_y = z1_point -> y + (1.0/3.0) * (z2_point -> y - z1_point -> y);
  v_x = z1_point -> x + (2.0/3.0) * (z2_point -> x - z1_point -> x);
  v_y = z1_point -> y + (2.0/3.0) * (z2_point -> y - z1_point -> y);
}
@
\fimcodigo


Se a nossa junção for somente o token ``..'', então nossa junção será
definida como tendo uma tensão de exatamente 1 e 1:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_JOIN){
  tension0 = 1.0;
  tension1 = 1.0;
  atleast0 = false;
  atleast1 = false;
}
@
\fimcodigo

Nossa junção também pode ser que esteja especificando diretamente os
pontos de controle na forma de ``.. controls $c_0$ ..'' ou
``.. controls $c_0$ and $c_1$ .. '', onde $c_0$ e $c_1$ são expressões
de pares. Neste caso tentamos delimitar os valores de $c_0$ e $c_1$
(se este segundo existir) e usamos eles diretamente como os pontos de
controle (se $c_1$ não existir, ele será igual a $c_0$):

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_c0, *end_c0, *begin_c1 = NULL, *end_c1 = NULL;
  struct pair_variable c0, c1;
  begin_c0 = (struct generic_token *) begin_j -> next;
  begin_c0 = (struct generic_token *) begin_c0 -> next;
  if(begin_c0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  end_c0 = begin_c0;
  while(end_c0 -> next != end_j){
    COUNT_NESTING(end_c0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_c0 -> next) -> type == TYPE_AND)
      break;
    end_c0 = (struct generic_token *) end_c0 -> next;
  }
  if(end_c0 -> next != end_j){
    begin_c1 = end_c0 -> next;
    begin_c1 = (struct generic_token *) begin_c1 -> next;
    if(begin_c1 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    end_c1 = begin_c1;
    while(end_c1 -> next != end_j)
      end_c1 = (struct generic_token *) end_c1 -> next;
  }
  if(!eval_pair_primary(mf, cx, begin_c0, end_c0, &c0))
    return false;
  u_x = c0.x;
  u_y = c0.y;
  if(begin_c1 != NULL){
    if(!eval_pair_primary(mf, cx, begin_c1, end_c1, &c1))
      return false;
     v_x = c1.x;
     v_y = c1.y;
  }
  else{
    v_x = c0.x;
    v_y = c0.y;
  }
}
@
\fimcodigo

O último tipo de junção tem a forma ``.. tension $t_0$ ..'' ou
``.. tension $t_0$ and $t_1$ .. '' onde $t_0$ e $t_1$ são expressões
primárias numéricas representando um número maior ou igual a 3/4 que
podem ou não estar precedidas pelo token ``\monoespaco{atleast}''. Se
somente um valor de tensão for especificado, assumimos que ambos os
valores necessários são iguais a este valor único
passado. Interpretemos então este tipo de junção com o código abaixo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_TENSION){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_t0, *end_t0, *begin_t1 = NULL, *end_t1 = NULL;
  struct numeric_variable t0, t1;
  begin_t0 = (struct generic_token *) begin_j -> next;
  begin_t0 = (struct generic_token *) begin_t0 -> next;
  if(begin_t0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  if(begin_t0 == end_j ||
     (begin_t0 -> type == TYPE_ATLEAST && begin_t0 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  else
    atleast0 = false;
  end_t0 = begin_t0;
  while(end_t0 -> next != end_j){
    COUNT_NESTING(end_t0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_t0 -> next) -> type == TYPE_AND)
      break;
    end_t0 = (struct generic_token *) end_t0 -> next;
  }
  if(end_t0 -> next != end_j){
    begin_t1 = end_t0 -> next;
    begin_t1 = (struct generic_token *) begin_t1 -> next;
    if(begin_t1 == end_j ||
       (begin_t1 -> type == TYPE_ATLEAST && begin_t1 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    if(begin_t1 -> type == TYPE_ATLEAST){
      atleast1 = true;
      begin_t1 = (struct generic_token *) begin_t1 -> next;
    }
    else
      atleast1 = false;
    end_t1 = begin_t1;
    while(end_t1 -> next != end_j)
      end_t1 = (struct generic_token *) end_t1 -> next;
  }
  if(!eval_numeric_primary(mf, cx, begin_t0, end_t0, &t0))
    return false;
  tension0 = t0.value;
  if(begin_t1 != NULL){
    if(!eval_numeric_primary(mf, cx, begin_t1, end_t1, &t1))
      return false;
    tension1 = t1.value;
  }
  else{
    tension1 = t0.value;
  }
  if(tension0 < 0.75 || tension1 < 0.75){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
          "METAFONT: Error: %s:%d: Improper tension. Should be >= 0.75\n",
          mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Depois de termos interpretado a junção, isso significa que já temos ou
um par de pontos de controle, caso em que não precisaremos fazer mais
nada além de apenas registrar tais pontos de controle na nossa
variável que estamos interpretando, ou que temos dois números
representando a tensão da curva. Neste segundo caso, será importante
levar em conta os especificadores de direção para determinar o formato
final da curva.

Contudo, os especificadores de direção podem estar vazios. Neste caso,
devemos usar várias regras diferentes para determinar qual deve ser o
valor deles.

%A primeira regra é que o começo e fim de um caminho não-cíclico sempre
%tem um ``\monoespaco{$\{$curl 1$\}$}'' implícito. O mesmo ocorre
%imediatamente antes e depois de uma concatenação. Assim:

%$$
%z_0 .. z_1 .. z_2 = \{\monoespaco{curl}\ 1\}z_0 .. z_1 .. z_2\{\monoespaco{curl}\ 1\}
%$$

%E também:

%$$
%.. z_n \& z_{n+1} .. = .. z_n\{\monoespaco{curl}\ 1\} \& \{\monoespaco{curl}\ 1\}z_{n+1} ..
%$$

%Isso significa que na primeira iteração, devemos considerar que o
%especificador de direção anterior é \monoespaco{curl 1}, desde que o
%caminho que estejamos lendo não seja cíclico:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>=
%if(begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE)
%  prev_curl = 1.0;
%
%\fimcodigo

%Já se estivermos em uma concatenação, se não existirem dois especificadores
%de direção atuais, também consideramos eles como \monoespaco{curl 1}:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>+=
%if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
%  if(isnan(curl0) && isnan(w0_x))
%    curl0 = 1.0;
%  if(isnan(curl1) && isnan(w1_x))
%    curl1 = 1.0;
%}
%
%\fimcodigo

%E finalmente, se não estivermos em um caminho cíclico e não existir um
%próximo especificador de direção após o segundo ponto atual, devemos
%checar se estamos na última junção do caminho. Isso pode ser conferido
%se não existir outra junção depois desta até o fim da expressão. Neste
%caso, marcamos o \monoespaco{curl 1} como próximo especificador de
%direção:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>+=
%if(end_z1 == end_expression)
%  next_curl = 1.0;
%else if(end_expression -> type != TYPE_CYCLE &&
%        ((struct generic_token *) (end_z1 -> next)) -> type !=
%        TYPE_OPEN_BRACES){
%  bool last_join = true;
%  struct generic_token *p = (struct generic_token *) end_z1 -> next;
%  DECLARE_NESTING_CONTROL();
%  while(p != end_expression){
%    COUNT_NESTING(p);
%    if(IS_NOT_NESTED() &&
%       (p -> type == TYPE_AMPERSAND || p -> type == TYPE_JOIN)){
%      last_join = false;
%      break;
%    }
%    p = (struct generic_token *) p -> next;
%  }
%  if(last_join)
%    next_curl = 1.0;
%}
%
%\fimcodigo

%Estas regras por si só não significam nada. O começo e fim de um
%caminho não-cíclico é um ponto descontínuo, não faz sentido definir
%pontos de controle após ele, não há continuação alguma. Já uma
%concatenação liga dois pontos iguais, também não há nada entre os
%pontos ligados. Contudo, essa regra passa a ser relevante quando
%combinada com as próximas.

Se existir um especificador após um ponto, mas não antes dele, é
copiada para antes dele. Da mesma forma, se houver um especificador
depois de um ponto, mas não antes dele, o especificador depois é
copiado. Assim:

$$
.. z_0 .. z_1\{d\} ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

E também:

$$
.. z_0 .. \{d\}z_1 ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

A natureza cíclica de um caminho deve ser levada em conta nesta regra.

Para o primeiro caso, no qual queremos copiar o especificador à
esquerda do primeiro ponto, será importante preservar este valor entre
iterações. Mas pelas nossas regras, só precisamos preservá-los quando
lemos ele diretamente por existir um especificador explícito. Então,
no fim da iteração que interpreta junções, nós armazenamos o
especificador anterior nestes casos. Nos demais, nós só os apagamos:

\iniciocodigo
@<Expressão de Caminho: Fim de Cada Iteração@>=
if((begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE) ||
   (begin_j == end_j && begin_j -> type == TYPE_AMPERSAND) ||
   (begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN) ||
   (begin_e != NULL && end_e != NULL)){
  prev_w_x = w1_x;
  prev_w_y = w1_y;
}
else{
  prev_w_x = NAN;
  prev_w_y = NAN;
}
@
\fimcodigo

Então, para aplicar a regra e copiar o especificador da esquerda para
a direita, usamos o seguinte código:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(w0_x) && isnan(w0_y)){
  w0_x = prev_w_x;
  w0_y = prev_w_y;
}
@
\fimcodigo

Temos agora que copiar o especificador da direita pra esquerda. Vamos
fazer isso somente se não temos ainda um especificador definido e se
existir um especificador explícito à direita do segundo ponto:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(w1_x) && isnan(w1_y)){
  if(end_z2 -> next != NULL && end_z2 != end_expression &&
     ((struct generic_token *) (end_z2 -> next)) -> type ==
     TYPE_OPEN_BRACES){
    struct generic_token *next0, *next1;
    DECLARE_NESTING_CONTROL();
    next0 = (struct generic_token *) end_z2 -> next;
    next1 = next0;
    while(next1 != end_expression){
      COUNT_NESTING(next1);
      if(IS_NOT_NESTED() && next1 -> type == TYPE_CLOSE_BRACES)
        break;
      next1 = (struct generic_token *) next1 -> next;
    }
    if(next0 -> type == TYPE_OPEN_BRACES && next1 -> type == TYPE_CLOSE_BRACES){
      if(!eval_direction_specifier(mf, cx, next0, next1, &next_w_x,
                                   &next_w_y))
        return false;
      w1_x = next_w_x;
      w1_y = next_w_y;
    }
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
              mf -> file, begin_j -> line);
#endif
      return false;
    }
  }
}
@
\fimcodigo

Mas também temos que levar em conta o caso cíclico. Pelas regras
gramaticais, não há nenhum especificador de direção antes do primeiro
ponto. Mas pode existir um especificador de direção antes do
token \monoespaco{cycle} e se ele existir, ele pode ser passado para a
direita do primeiro ponto. Da mesma forma, o especificador de direção
logo depois do primeiro ponto pode ser copiado para antes do
token \monoespaco{cycle} se não houver um especificador explícito.

Primeiro o caso mais simples: há um especificador de direção explícito
após o primeiro ponto no começo da expressão e estamos em um caminho
cíclico. Neste caso, devemos memorizá-lo para caso precisemos usar ele
no último ponto do caminho. Para memorizá-lo, vamos usar as seguintes
variáveis:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float first_w_x = NAN, first_w_y = NAN;
@
\fimcodigo

E então, na primeira iteração sobre os pontos do caminho, se
estivermos em um caminho cíclico e existir um especificador explícito,
armazenamos seu conteúdo:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d != NULL && end_d != NULL){
  first_w_x = w0_x;
  first_w_y = w0_y;
}
@
\fimcodigo

Depois, quando chegarmos na última iteração de um caminho cíclico,
vamos levar estes valores em conta:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  if(!isnan(first_w_x) && isnan(w1_x)){
    w1_x = first_w_x;
    w1_y = first_w_y;
  }
}
@
\fimcodigo

Já para fazer a cópia na direção oposta, quando estamos na primeira
iteração ficamos obrigados a ir olhar a última junção. Primeiro
percorremos e expressão até o fim (até encontrar o
token \monoespaco{cycle}) tomando nota do último especificador de
direção e última junção. Se o token \monoespaco{cycle} vier logo
depois do último especificador, então devemos obter seu valor e
copiá-lo se não existir um especificador explícito.

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d == NULL && isnan(w0_x) && isnan(u_x)){
  struct generic_token *begin_last_spec = NULL, *end_last_spec = NULL,
                       *last_join = NULL, *second_last_join = NULL, *p;
  DECLARE_NESTING_CONTROL();
  p = end_z1 -> next;
  while(p != end_expression){
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_OPEN_BRACES){
        begin_last_spec = p;
      }
      else if(p -> type == TYPE_CLOSE_BRACES)
        end_last_spec = p;
      else if(p -> type == TYPE_JOIN || p -> type == TYPE_AMPERSAND ||
              p -> type == TYPE_STRAIGHT_JOIN){
        second_last_join = last_join;
        last_join = p;
      }
      else if(p -> type == TYPE_CYCLE)
        break;
      else
        COUNT_NESTING(p);
    }
    else
      COUNT_NESTING(p);
    p = (struct generic_token *) p -> next;
  }
  if(end_last_spec != NULL && end_last_spec -> next == p &&
     p -> type == TYPE_CYCLE){
    if(!eval_direction_specifier(mf, cx, begin_last_spec, end_last_spec,
                                 &w0_x, &w0_y))
      return false;
  }
  @<Código Após Espiarmos Última Junção de Caminho Cíclico@>
}
@
\fimcodigo

A próxima regra se aplica quando temos uma construção como:

\alinhaverbatim
.. z .. controls  u  and  v ..  = .. z{u-z} .. controls  u  and  v ..
\alinhanormal

E também:

\alinhaverbatim
.. controls u and v .. z =  .. controls u and v .. z{z-v} ..
\alinhanormal

Isso se aplica somente quando o resultado da subtração de pares $u-z$
e $z-v$ é diferente de zero. Se for igual a zero, iremos retornar um
erro por ainda não suportarmos este caso.

Primeiro o caso mais fácil: os pontos de controle explícitos vem antes
do caminho atual. Foram os pontos de controle explícitos que lemos na
iteração anterior. Então, precisamos de uma variável para armazenar
este ponto de controle:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float previous_point_x = NAN, previous_point_y = NAN;
@
\fimcodigo


Se nós temos algum valor armazenado nestas variáveis e se nós não
temos especificador de direção explícito, então geramos o
especificador com as regras que descrevemos. Só observando que
consideramos como iguais quaisquer pontos cuja distância for menor que
0,00002.

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_d == NULL && end_d == NULL && !isnan(previous_point_x) &&
   !isnan(previous_point_y) && isnan(w0_x)){
  w0_x = z1_point -> x - previous_point_x;
  w0_y = z1_point -> y - previous_point_y;
  if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Neste momento, depois de possivelmente termos usado o especificador
anterior, não precisaremos mais dele e o atualizamos para o valor atual:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  previous_point_x = v_x;
  previous_point_y = v_y;
}
else{
  previous_point_x = NAN;
  previous_point_y = NAN;
}
@
\fimcodigo

Já se não temos um valor explícito até agora no segundo especificador
de direção, devemos checar a próxima junção para saber se ela contém
pontos de controle explícitos. Se tiver, lemos o primeiro destes
pontos, o interpretamos e usamos seu valor pelas regras acima:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_e == NULL && end_e == NULL &&  isnan(w1_x) &&
   end_z2 != end_expression){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_point, *end_point;
  begin_point = (struct generic_token *) end_z2 -> next;
  while(begin_point != end_expression){
    COUNT_NESTING(begin_point);
    if(IS_NOT_NESTED() && (begin_point -> type == TYPE_JOIN ||
                          begin_point -> type == TYPE_AMPERSAND ||
                          begin_point -> type == TYPE_STRAIGHT_JOIN))
      break;
    begin_point = (struct generic_token *) begin_point -> next;
  }
  if(begin_point != end_expression &&
     begin_point -> type != TYPE_AMPERSAND &&
     begin_point -> type != TYPE_STRAIGHT_JOIN){
    begin_point = (struct generic_token *) begin_point -> next;
    if(begin_point != end_expression && begin_point -> type == TYPE_CONTROLS){
      begin_point = (struct generic_token *) begin_point -> next;
      end_point = begin_point;
      while(end_point != end_expression){
        struct generic_token *next = (struct generic_token *) end_point -> next;
        COUNT_NESTING(end_point);
        if(IS_NOT_NESTED() && next != NULL &&
           (next -> type == TYPE_AND || next -> type == TYPE_JOIN))
          break;
        end_point = (struct generic_token *) end_point -> next;
      }
      if(end_point != end_expression){
        struct pair_variable var;
        if(!eval_pair_primary(mf, cx, begin_point, end_point, &var))
          return false;
        w1_x = var.x - z2_point -> x;
        w1_y = var.y - z2_point -> y;
        if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                          "direction specifier.\n",  mf -> file,
                          begin_j -> line);
#endif
          return false;
        }
      }
    }
  }
}
@
\fimcodigo

Agora vamos ao caso cíclico. Se estamos na primeira iteração, nosso
caminho é cíclico e temos pontos de controle explícitos, então devemos
ter uma variável adicional para armazenar tal ponto de controle
explícito:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float first_point_x = NAN, first_point_y = NAN;
@
\fimcodigo

E inicializamos a variável se for o caso na primeira iteração:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  first_point_x = u_x;
  first_point_y = u_y;
}
@
\fimcodigo

Depois, quando chegar a hora de escolher o formato da junção das
extremidades cíclicas, levaremos a existência desta variável em conta:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE && begin_d == NULL &&
   end_d == NULL && isnan(w1_x) && !isnan(first_point_x) && isnan(w1_x)){
  w1_x = first_point_x - z2_point -> x;
  w1_y = first_point_y - z2_point -> y;
  if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

E agora a direção oposta. Se estamos na primeira iteração de um
caminho cíclico, devemos espiar a última junção e checar se temos
pontos de controle explícitos para aplicar esta regra. Mas na regra
anterior nós já escrevemos o código para obter dentre outras coisas, a
última junção. Então podemos continuar à partir do código anterior:


\iniciocodigo
@<Código Após Espiarmos Última Junção de Caminho Cíclico@>=
if(last_join != NULL && last_join -> type == TYPE_JOIN){
  struct generic_token *p = (struct generic_token *) second_last_join -> next;
  if(p -> type == TYPE_CONTROLS){
    struct generic_token *p_end;
    p = (struct generic_token *) p -> next;
    p_end = p;
    while(p_end != end_expression){
      struct generic_token *next = (struct generic_token *) p_end -> next;
      COUNT_NESTING(p_end);
      if(IS_NOT_NESTED()){
        if(next -> type == TYPE_AND)
          p = (struct generic_token *) next -> next;
        else if(next -> type == TYPE_JOIN)
          break;
      }
      p_end = next;
    }
    if(p_end != end_expression){
      struct pair_variable var;
      if(!eval_pair_primary(mf, cx, p, p_end, &var))
        return false;
      w0_x = z1_point -> x - var.x;
      w0_y = z1_point -> y - var.y;
      if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                        "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
        return false;
      }
    }
  }
}
@
\fimcodigo

Após executar as regras, espera-se que tenhamos já ou dois pontos de
controle bem-definidos, ou então valores de tensão com especificadores
de direção à partir dos quais iremos deduzir os pontos de controle. Se
não tivermos nem um e nem outro, geraremos um erro e encerraremos:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  if(isnan(w0_x) || isnan(w0_y) || isnan(w1_x) || isnan(w1_y)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Se tudo deu certo até aqui, ou já temos os nossos pontos de controle,
ou então temos que descobrir quais são os pontos de controle por meio
de uma construção como a abaixo:

$$
z_n\{w_n\}..\ {\hskip2mm \monoespaco{tension}\hskip2mm } \alpha {\hskip2mm \monoespaco{and}\hskip2mm } \beta .. \{w_{n+1}\}z_{n+1}
$$

Para calcular os pontos de controle à partir destas informações,
tratamos os pontos como números complexos e calculamos:

$$
\theta = arg(w_n/(z_{n+1}-z_n))
$$

$$
\phi = arg((z_{n+1}-z_n)/w_{n+1})
$$

Em seguida, os pontos de controle $u$ e $v$ são:

$$
u = z_{n} + e^{i\theta}(z_{n+1}-z_n)f(\theta, \phi)/\alpha
$$

$$
v = z_{n+1} - e^{-i\phi}(z_{n+1}-z_n)f(\phi, \theta)/\beta
$$

Exceto quando é usada a palavra-chave ``atleast'', o que significa que
o valor de $\alpha$ ou $\beta$ é aumentado de modo que o resultado
fique dentro da área delimitada pelo triângulo cujos dois pontos são
os pontos de extremidade e o ângulo em cada um destes pontos é dado
pelo especificador de direção. Caso isso não forme um triângulo
válido, mantemos os valores de tensão sem os modificar.

A função $f$ que aparece acima é definida como:

$$
f(\theta, \phi) = {{2+\sqrt{2}(\sin\theta-{{1}\over{16}}\sin\phi)(\sin\phi-{{1}\over{16}}\sin\theta)(\cos\theta-\cos\phi)}\over{3(1+{1\over 2}(\sqrt 5 - 1)\cos\theta+{1\over 2}(3-\sqrt 5)\cos\phi)}}
$$

Primeiro vamos implementar a função $f$ como uma função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
double compute_f(double theta, double phi);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double compute_f(double theta, double phi){
  double n = 2 + sqrt(2) * (sin(theta) - 0.0625 * sin(phi)) *
             (sin(phi) - 0.0625 * sin(theta)) * (cos(theta) - cos(phi));
  double d = 3 * (1 + 0.5 * (sqrt(5.0) - 1) * cos(theta) + 0.5 * (3 - sqrt(5)) *
                  cos(phi));
  return n/d;
}
@
\fimcodigo

Agora podemos calcular os pontos de controle caso ainda não tenhamos
eles. Como devemos tratar os pontos como números complexos, vamos
precisar do seguinte cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <complex.h>
@
\fimcodigo

E com ajuda das funções da biblioteca padrão para números complexos,
calculamos a fórmula para os pontos de controle:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  double complex u, v;
  double complex z0 = z1_point -> x + z1_point -> y * I;
  double complex z1 = z2_point -> x + z2_point -> y * I;
  double theta = carg((w0_x + w0_y * I) / (z1 - z0));
  double phi = carg((z1 - z0)/(w1_x + w1_y * I));
  u = z0 + (cexp(theta * I) * (z1 - z0) * compute_f(theta, phi)) / tension0;
  v = z1 - (cexp(-phi * I) * (z1 - z0) * compute_f(phi, theta)) / tension1;
  u_x = creal(u);
  u_y = cimag(u);
  v_x = creal(v);
  v_y = cimag(v);
  @<Ajusta Tensão em Caso de 'atleast'@>
}
@
\fimcodigo

Vamos agora tratar o caso de termos encontrado a palavra-chave
``atleast''. Se ela existir, o ponto de controle correspondente deve,
se possível, ser ajustado para estar dentro do triângulo delimitado
pelos dois pontos de extremidade e pelos ângulos definidos pelos seus
especificadores de direção.

A primeira coisa que teremos que calcular é se temos um triângulo
válido. Para isso devemos checar os seus ângulos internos. Dados três
pares de coordenadas, sendo o primeiro par um vértice onde queremos
medir o ângulo, podemos calcular o ângulo existente ali com ajuda da
seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y){
  double v0_x, v0_y, v1_x, v1_y;
  v0_x = c0_x - v_x;
  v0_y = c0_y - v_y;
  v1_x = c1_x - v_x;
  v1_y = c1_y - v_y;
  if(fabs(v0_x) <= 0.00002 &&  fabs(v0_y) <= 0.00002)
    return INFINITY;
  if(fabs(v1_x) <= 0.00002 &&  fabs(v1_y) <= 0.00002)
    return INFINITY;
  return acos((v0_x * v1_x + v0_y * v1_y) /
                (hypot(v0_x * v0_x, v0_y * v0_y) *
                 hypot(v1_x * v1_x, v1_y * v1_y)));
}
@
\fimcodigo

Sabendo medir os ângulos podemos verificar se o triângulo é
válido. Sabendo fazer isso, podemos escrever uma função que ajusta o
valor do ponto de controle para o valor adequado de modo a permanecer
dentro do triângulo. Primeiro medimos e obtemos todos os ângulos
internos. Depois, para descobrir a coordenada do terceiro vértice do
triângulo (os dois outros vértices são pontos de extremidade) usamos a
Lei do Senos. Sabendo quais são os vértices todos, verificamos se os
pontos de controle estão dentro do triângulo. E somente se não
estiver, fazemos o ajuste:


\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y){
  double internal_angle0, internal_angle1, internal_angle2;
  double triangle_angle;
  double p2_x, p2_y;
  internal_angle0 = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + d0_x, p0_y + d0_y);
  internal_angle1 = get_angle(p1_x, p1_y, p0_x, p0_y, p1_x + d1_x, p1_y + d1_y);
  internal_angle2 = M_PI - internal_angle0 - internal_angle1;
  if(internal_angle0 + internal_angle1 >= M_PI - 0.00002)
    return; // Não é triângulo válido
  { // Descobrir coordenada do terceiro vértice:
    // Primeiro calculamos o lado do triângulo que vai de p0 ao vértice
    // desconhecido
    double known_side = hypot((p1_x - p0_x) * (p1_x - p0_x),
                              (p1_y - p0_y) * (p1_y - p0_y));
    double triangle_side = known_side * sin(internal_angle0) /
                           sin(internal_angle2);
    // Conhecendo o tamanho do lado do triângulo, basta combinar com o
    // ângulo e chegamos ao vértice desconhecido:
    triangle_angle = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + 1.0, p0_y);
    p2_x = p0_x + triangle_side * cos(triangle_angle + internal_angle0);
    p2_y = p0_y + triangle_side * sin(triangle_angle + internal_angle0);
  }
  {
    @<Checa se Ponto Está Dentro do Triângulo@>
    @<Se Não Estiver, Ajusta Tensão para Ficar@>
  }
}
@
\fimcodigo

Como checar se um ponto está dentro de um triângulo? Há várias formas,
a que usaremos consiste em medir a área com sinal dos três novos
triângulos formados pelo ponto e dois vértices do triângulo. A ``área
com sinal'' é a área do triângulo, só que ela tem valor positivo ou
negativo dependendo se passamos os vértices no sentido horário ou
anti-horário. Em seguida, apenas verificamos se todas as áreas tem o
mesmo sinal (positivo ou negativo). Se tiver, então o ponto certamente
está fora. Caso contrário, o ponto está dentro do triângulo:

\iniciocodigo
@<Checa se Ponto Está Dentro do Triângulo@>=
bool s1, s2, s3; // O sinal das áreas
s1 = ((*control_x - p1_x) * (p0_y - p1_y) -
      (p0_x - p1_x) * (*control_y - p1_y)) < 0;
s2 = ((*control_x - p2_x) * (p1_y - p2_y) -
      (p1_x - p2_x) * (*control_y - p2_y)) < 0;
s3 = ((*control_x - p0_x) * (p2_y - p0_y) -
      (p2_x - p0_x) * (*control_y - p0_y)) < 0;
if(s1 == s2 && s2 == s3)
  return;
@
\fimcodigo

Uma vantagem deste método é que dependendo de qual área com sinal tem
um sinal diferente das outras, isso determina qual dos lados do
triângulo é mais próximo do ponto. Então, se ainda estivermos na
função, checamos qual é o lado mais próximo, obtemos sua equação de
reta e calculamos o ponto mais próximo na reta. Se o ponto estiver no
lado do triângulo, este é o novo ponto do ponto de controle. Se não, o
ponto de controle se torna a extremidade do triângulo mais próxima do
ponto.

\iniciocodigo
@<Se Não Estiver, Ajusta Tensão para Ficar@>=
{
  double x0, y0, x1, y1;
  if(s1 != s2 && s1 != s3){
    x0 = p0_x; y0 = p0_y;
    x1 = p1_x; y1 = p1_y;
  }
  else if(s2 != s1 && s2 != s3){
    x0 = p1_x; y0 = p1_y;
    x1 = p2_x; y1 = p2_y;
  }
  else{
    x0 = p2_x; y0 = p2_y;
    x1 = p0_x; y1 = p0_y;
  }
  if(x1 < x0){ // x1 deve ser maior ou igual a x0
    double tmp;
    tmp = x1 ; x1 = x0; x0 = tmp;
    tmp = y1; y1 = y0; y0 = tmp;
  }
  if(x0 == x1){ // Reta vertical (equação da reta daria divisão por zero)
    *control_x = x0;
    if(*control_y > y0 && *control_y > y1){
      if(y0 > y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
    else if(*control_y < y0 && *control_y < y1){
      if(y0 < y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
  }
  else if(y0 == y1) // Reta horizontal
    *control_y = y0;
  else{ // Usar equação da reta
    // m0 x + b0 = y é a reta que contém o lado do triângulo
    double m0 = (y1 - y0) / (x1 - x0);
    double b0 = y1 - m0 * x1;
    // m1 x + b1 = y é a perpendicular ao lado do triângulo e passa pelo ponto
    double m1 = - m0;
    double b1 = *control_y - m1 * *control_x;
    *control_x = (b1 - b0) / (m0 - m1);
    *control_y = m0 * *control_x + b0;
  }
  if(*control_x > x1){
    *control_x = x1;
    *control_y = y1;
  }
  else if(*control_x < x0){
    *control_x = x0;
    *control_y = y0;
  }
}
@
\fimcodigo

Isso finaliza a nossa função para ajustar a tensão caso estejamos
lidando com pontos de controle com a palavra-chave
``\monoespaco{atleast}''. Agora podemos apenas usar esta função sempre
que estivermos lidando com um caso assim:

\iniciocodigo
@<Ajusta Tensão em Caso de 'atleast'@>=
if(atleast0)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &u_x, &u_y);
if(atleast1)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &v_x, &v_y);
@
\fimcodigo

E com isso terminamos de calcular os pontos de controle e podemos
atualizar seu valor na variável de caminho que estamos montando ao
avaliar a expressão. Se estivermos na última iteração de uma curva
não-cíclica, além disso nós preenchemos os últimos pontos de controle
como sendo iguais ao último ponto de extremidade:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
z1_point -> u_x = u_x;
z1_point -> u_y = u_y;
z1_point -> v_x = v_x;
z1_point -> v_y = v_y;
if(result -> length >= expected_length && result -> cyclic == false){
  struct path_points *final_point =
                           &(result -> points[result -> length - 1]);
  while(final_point -> subpath != NULL){
    struct path_variable *p = (struct path_variable *)
                                (final_point -> subpath);
    final_point = &(p -> points[p -> length - 1]);
  }
  final_point -> u_x = final_point -> x;
  final_point -> u_y = final_point -> y;
  final_point -> v_x = final_point -> x;
  final_point -> v_y = final_point -> y;
}
@
\fimcodigo

Isso finaliza a construção de uma curva dados seus pontos e
subcaminhos lidos. Agora iremos estabelecer como ler os pontos e
subcaminhos.

\subsubsecao{8.4.2. Expressões Terciárias de Caminhos}

A gramática para expressões de caminho terciárias é:

\alinhaverbatim
<Terciário de Caminho> -> <Terciário de Par> | <Secundário de Caminho>
\alinhanormal

E é só isso. Então, para interpretar uma expressão terciária de
caminho, o que faremos é percorrer ela e verificar se encontramos uma
expressão terciária de par. Se encontrarmos, devemos interpretar a
expressão inteira como um terciário de par. Caso contrário, a
interpretaremos como um secundário de caminho. Se interpretarmos tudo
como um par, devemos também depois converter o resultado de um par
para um caminho com um único ponto.

De qualquer forma, depois de interpretar a expressão e obter um
caminho como resultado, nós retornamos o resultado.

A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  struct generic_token *p, *prev = NULL;
  bool this_expression_is_pair = false;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      this_expression_is_pair = true;
      break;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(this_expression_is_pair){
    struct pair_variable pair;
    if(!eval_pair_expression(mf, cx, begin_expression, end_expression,
                            &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> total_length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> x = pair.x;
    result -> points -> y = pair.y;
    result -> points -> u_x = pair.x;
    result -> points -> u_y = pair.y;
    result -> points -> v_x = pair.x;
    result -> points -> v_y = pair.y;
    result -> points -> subpath = NULL;
    return true;
  }
  else
    return eval_path_secondary(mf, cx, begin_expression, end_expression,
                               result);
}
@
\fimcodigo

\subsubsecao{8.4.3. Expressões Secundárias de Caminhos: Transformadores}

A gramática para expressões secundárias de caminho é:

\alinhaverbatim
<Secundário de Caminho> -> <Secundário de Par> | <Primário de Caminho> |
                           <Secundário de Caminho><Transformador>
\alinhanormal

Os transformadores são os mesmos que já foram apresentados na
expressão secundária de par, mas incluindo o
operador \monoespaco{transformed} introduzido na seção sobre
transformações. A primeira coisa que devemos testar é se temos um
transformador no fim e se temos uma operação secundária de par
(multiplicação e divisão). Depois de percorrer toda a expressão, se
houver o tranformador, aplicamos a terceira regra da gramática
acima. Se houver uma multiplicação e divisão, mas não um
transformador, aplicamos a segunda regra. E caso não haja nada disso,
aplicamos a primeira.

Transformar um caminho via rotação, escala e outras modificações
envolve aplicar tais modificações sobre cada ponto de extremidade e
cada ponto de controle.

A declaração da função que fará isso é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  bool have_transform = false, have_pair_operator = false;
  struct generic_token *p, *last_fraction = NULL, *transform_op = NULL,
                       *before_transform = NULL, *prev = NULL,
                       *prev_prev = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else if(p -> type == TYPE_DIVISION ||
               p -> type == TYPE_MULTIPLICATION)
         have_pair_operator = true;
       else{
         have_transform = true;
         transform_op = p;
         before_transform = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(have_transform){
    if(transform_op -> next == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_path_secondary(mf, cx, begin_expression, before_transform,
                            result))
      return false;
    @<Transformação de Caminho: Rotação@>
    @<Transformação de Caminho: Escala@>
    @<Transformação de Caminho: Deslocamento@>
    @<Transformação de Caminho: Inclinação@>
    @<Transformação de Caminho: X-Escala@>
    @<Transformação de Caminho: Y-Escala@>
    @<Transformação de Caminho: Z-Escala@>
    @<Transformação de Caminho: Transformação Genérica@>
  }
  else if(have_pair_operator){
    struct pair_variable pair;
    if(!eval_pair_secondary(mf, cx, begin_expression, end_expression,
                            &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> total_length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points[0].x = pair.x;
    result -> points[0].y = pair.y;
    result -> points[0].u_x = pair.x;
    result -> points[0].u_y = pair.y;
    result -> points[0].v_x = pair.x;
    result -> points[0].v_y = pair.y;
    result -> points[0].subpath = NULL;
    return true;    
  }
  else
    return eval_path_primary(mf, cx, begin_expression, end_expression,
                             result);
}
@
\fimcodigo

No código acima, quando verificamos se temos um transformador na
expressão, sempre armazenamos o último transformador encontrado na
variável \monoespaco{transform\_op} e o último token antes do
transformador em \monoespaco{before\_transform}. Isso nos permite
depois poder dividir a expressão em partes para poder interpretá-la e
obter o caminho sobre o qual devemos aplicar o transformador.

Se temos uma rotação, para interpretar um transformador de rotação
depois de termos obtido o caminho a ser rotacionado na
variável \monoespaco{result}, podemos então aplicar o código abaixo:

\iniciocodigo
@<Transformação de Caminho: Rotação@>=
if(transform_op -> type == TYPE_ROTATED){
  struct numeric_variable a;
  double theta, sin_theta, cos_theta;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  theta = 0.0174533 * a.value; // Converter de graus para radianos
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  path_rotate(result, sin_theta, cos_theta);
  return true;
}
@
\fimcodigo

O código acima assume que temos uma função recursiva que faz a rotação
uma vez que passemos o seno e cosseno do ângulo que devemos
rotacionar. Vamos usar a função abaixo para isso:


\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_rotate((struct path_variable *) (p -> points[i].subpath),
                  sin_theta, cos_theta);
    else{
      double x = p -> points[i].x, y = p -> points[i].y;
      p -> points[i].x = x * cos_theta - y * sin_theta;
      p -> points[i].y = x * sin_theta + y * cos_theta;
      x = p -> points[i].u_x;
      y = p -> points[i].u_y;
      p -> points[i].u_x = x * cos_theta - y * sin_theta;
      p -> points[i].u_y = x * sin_theta + y * cos_theta;
      x = p -> points[i].v_x;
      y = p -> points[i].v_y;
      p -> points[i].v_x = x * cos_theta - y * sin_theta;
      p -> points[i].v_y = x * sin_theta + y * cos_theta;
    }
  }
}
@
\fimcodigo

Agora vamos ao operador que muda a escala de um caminho. Ele deve
interpretar um valor numérico e depois multiplicar cada ponto do
caminho por tal valor numérico:

@<Transformação de Caminho: Escala@>=
else if(transform_op -> type == TYPE_SCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_xyscale(result, a.value, a.value);  
  return true;
}
@
\fimcodigo

A função recursiva que aplica isso a todos os pontos de um caminho é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y);
@
\fimcodigo

Note que a função é mais ampla e pode ser usada para aumentar de
maneira não-proporcional o tamanho de uma curva no eixo $x$ e $y$,
apesar de aqui só a estarmis usando para esticá-la a mesma quantidade
na horizontal e vertical. A sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_xyscale((struct path_variable *) (p -> points[i].subpath), x,
                   y);
    else{
      p -> points[i].x *= x;
      p -> points[i].y *= y;
      p -> points[i].u_x *= x;
      p -> points[i].u_y *= y;
      p -> points[i].v_x *= x;
      p -> points[i].v_y *= y;
    }
  }
}
@
\fimcodigo

A próxima transformação é uma simples translação ou
deslocamento. Recebemos um par e este par determina o quanto cada
ponto deve ser deslocado no eixo $s$ e $y$:

\iniciocodigo
@<Transformação de Caminho: Deslocamento@>=
else if(transform_op -> type == TYPE_SHIFTED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_shift(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

E a função recursiva que faz o deslocamento:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_shift((struct path_variable *) (p -> points[i].subpath), x, y);
    else{
      p -> points[i].x += x;
      p -> points[i].y += y;
      p -> points[i].u_x += x;
      p -> points[i].u_y += y;
      p -> points[i].v_x += x;
      p -> points[i].v_y += y;
    }
  }
}
@
\fimcodigo

Vamos agora à inclinação, o transformador que empurra os pontos mais à
direita se estiverem acima do 0 no eixo $y$ e mais à esquerda se
estiverem mais abaixo da origem no eixo $y$:

\iniciocodigo
@<Transformação de Caminho: Inclinação@>=
else if(transform_op -> type == TYPE_SLANTED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_slant(result, a.value);  
  return true;
}
@
\fimcodigo

E a função recursiva que faz a inclinação em si:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_slant(struct path_variable *p, float s);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_slant(struct path_variable *p, float s){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_slant((struct path_variable *) (p -> points[i].subpath), s);
    else{
      p -> points[i].x += s * p -> points[i].y;
      p -> points[i].u_x += s * p -> points[i].u_y;
      p -> points[i].v_x += s * p -> points[i].v_y;
    }
  }
}
@
\fimcodigo

A próxima transformação muda o tamanho horizontal do caminho, mas
preserva o tamanho vertical. Devemos ler um valor numérico e ele
determina o quanto o caminho deve ser esticado horizontalmente:


\iniciocodigo
@<Transformação de Caminho: X-Escala@>=
else if(transform_op -> type == TYPE_XSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, a.value, 1.0);  
  return true;
}
@
\fimcodigo

Aqui estamos usando uma função recursiva já definida, então não
precisamos defini-la novamente. Além de transformar esticando
horizontalmente, vamos agora esticar verticalmente:

\iniciocodigo
@<Transformação de Caminho: Y-Escala@>=
else if(transform_op -> type == TYPE_YSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, 1.0, a.value);  
  return true;
}
@
\fimcodigo

A penúltima transformação é a mudança de escala Z que lê um par, o
interpreta como número complexo, e também interpreta cada ponto do
caminho como número complexo fazendo a multiplicação:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

Interpretamos e realizamos a transformação da forma abaixo, lembrando
também que esta é a última transformação possível:

\iniciocodigo
@<Transformação de Caminho: Z-Escala@>=
else if(transform_op -> type == TYPE_ZSCALED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_zscale(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

E a função recursiva que fará isso:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_zscale((struct path_variable *) (p -> points[i].subpath),
                  x, y);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = x0 * x - y0 * y;
      p -> points[i].y = x0 * y + y0 * x;
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = x0 * x - y0 * y;
      p -> points[i].u_y = x0 * y + y0 * x;
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = x0 * x - y0 * y;
      p -> points[i].v_x = x0 * y + y0 * x;
    }
  }
}
@
\fimcodigo

E o último tipo de transformador é a transformação genérica, onde
teremos um transformador que irá indicar como iremos mudar todos os
pontos do caminho. Tratamos este caso da seguinte forma:

\iniciocodigo
@<Transformação de Caminho: Transformação Genérica@>=
else if(transform_op -> type == TYPE_TRANSFORMED){
  struct transform_variable a;
  if(!eval_transform_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_transform(result, a.value[0], a.value[1], a.value[2], a.value[3],
                 a.value[4], a.value[5]);
  return true;
}
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer\n",
          mf -> file, transform_op -> line);
#endif
  return false;
}
@
\fimcodigo

Para isso usamos a seguinte função recursiva:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_transform(struct path_variable *p, float x, float y, float xx,
                    float xy, float yx, float yy);
@
\fimcodigo

A função é definida como:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_transform(struct path_variable *p, float x, float y, float xx,
                    float xy, float yx, float yy){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_transform((struct path_variable *) (p -> points[i].subpath),
                     x, y, xx, xy, yx, yy);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = x + x0 * xx + y0 * xy;
      p -> points[i].y = y + x0 * yx + y0 * yy;
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = x + x0 * xx + y0 * xy;
      p -> points[i].u_y = y + x0 * yx + y0 * yy;
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = x + x0 * xx + y0 * xy;
      p -> points[i].v_x = y + x0 * yx + y0 * yy;
    }
  }
}
@
\fimcodigo


\subsubsecao{8.4.4. Expressões Primárias de Caminhos}

A gramática para expressões primárias de caminho é:

\alinhaverbatim
<Primário de Caminho> -> <Primário de Par> | <Variável de Caminho> |
                       ( <Expressão de Caminho> ) |
                       reverse <Primário de Caminho> |
                       subpath <Expressão de Par> of <Primário de Caminho> |
                       ...
\alinhanormal

Isso significa que devemos registrar tokens
novos: \monoespaco{reverse}, \monoespaco{subpath} e \monoespaco{of}:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_REVERSE        64 // O token simbólico 'reverse'
#define TYPE_SUBPATH        65 // O token simbólico 'subpath'
#define TYPE_OF             66 // O token simbólico 'of'
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"reverse", "subpath", "of",
@
\fimcodigo

O que as regras gramaticais dizem é que no fim de toda expressão de
caminho, terminaremos encontrando no fim uma variável de caminho,
um parênteses, algum destes operadores novos de subcaminho e de
caminho reverso, ou em todos os demais casos, isso se encaixa em uma
expressão primária de par que irá nos dar um par. Devemos então testar
se estamos nestes casos, e se não estivermos, basta interpretar como
par.

A função que irá interpretar expressões primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result){
  if(begin_expression -> type == TYPE_REVERSE){
    @<Caminho Primário: Reverso@>
  }
  else if(begin_expression -> type == TYPE_SUBPATH){
    @<Caminho Primário: Subcaminho@>
  }
  else if(begin_expression == end_expression &&
          begin_expression -> type == TYPE_SYMBOLIC){
    @<Caminho Primário: Variável@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Caminho Primário: Parênteses@>
  }
  @<Caminho Primário: Outras Expressões@>
  { // Se ainda não retornou, é um par primário
    @<Caminho Primário: Par Primário@>
  }
  return false;
}
@
\fimcodigo

Vamos ao primeiro caso: devemos calcular o reverso de um caminho. Para
isso, devemos inverter a ordem na qual aparecem os pontos de
extremidade e mover os pontos de controle para suas novas posições.

Dada a natureza recursiva das variáveis de caminho, precisamos de uma
função recursiva para copiar os pontos de uma variável de origem e
colocá-los na ordem reversa em uma variável de destino já alocada.

Esta função auxiliar recursiva precisa receber como argumento qual o
ponteiro de destino onde devemos copiar o próximo ponto. Como vamos
copiar na ordem reversa, a posição começará no último lugar e iremos
decrementar ela a cada cópia. Assim a variável de destino será
percorrida da direita para a esquerda.

Na variável de origem, precisamos passar como argumento a posição do
próximo ponto a ser percorrido. O qual é representado por uma variável
de caminho e o índice a ser consultado no vetor de pontos. A função
irá percorrer os pontos da origem para copiá-los da esquerda para a
direita.

Fazendo isso nós iremos obter como resultado uma variável plana, com
todos os seus pontos em um único vetor, sem mais variáveis de caminho
recursivas dentro de outra variável de caminho. Segue a definição da
função a seguir:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool aux_reverse(struct path_points **right_dst,
                 struct path_variable *pointer, int *index,
                 int *copied_points, int total_points){
  while(*copied_points < total_points){
    if(pointer -> points[*index].subpath == NULL &&
       !isnan(pointer -> points[*index].x)){
      // Copiar:
      memcpy(*right_dst, &(pointer -> points[*index]),
             sizeof(struct path_points));
      (*right_dst) -> subpath = NULL;
      (*right_dst) --;
      (*copied_points) ++;
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].subpath != NULL){
      int new_index = 0;
      aux_reverse(right_dst, (struct path_variable *)
                  (pointer -> points[*index].subpath),
                  &new_index, copied_points, total_points);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

Essa função auxiliar vai nos ajudar a definir a verdadeira função que
fará a reversão. A função de reversão será chamada abaixo, quando
detectarmos o operador de reversão:

\iniciocodigo
@<Caminho Primário: Reverso@>=
struct path_variable tmp;
if(begin_expression -> next == NULL ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                      &tmp))
  return false;
result -> length = tmp.total_length;
result -> total_length = tmp.total_length;
result -> points =
     (struct path_points *)
     temporary_alloc(sizeof(struct path_points) * tmp.total_length);
reverse_path(&tmp, result);
if(temporary_free != NULL)
  path_recursive_free(temporary_free, &tmp, false);
return true;
@
\fimcodigo

Temos agora que definir a verdadeira função que realizará a
reversão. A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst){
  int index = 0, i, copied_points = 0;
  struct path_points *right = &(dst -> points[dst -> length - 1]);
  struct path_variable *l = src;
  aux_reverse(&right, l, &index, &copied_points, dst -> length);
  for(i = 0; i < dst -> length - 1; i ++){
    dst -> points[i].u_x = dst -> points[i + 1].v_x;
    dst -> points[i].u_y = dst -> points[i + 1].v_y;
    dst -> points[i].v_x = dst -> points[i + 1].u_x;
    dst -> points[i].v_y = dst -> points[i + 1].u_y;
  }
  dst -> points[i].u_x = dst -> points[i].x;
  dst -> points[i].u_y = dst -> points[i].y;
  dst -> points[i].v_x = dst -> points[i].x;
  dst -> points[i].v_y = dst -> points[i].y;
  dst -> cyclic = src -> cyclic;
}
@
\iniciocodigo

O próximo passo é calcular um subcaminho. O subcaminho gera um novo
caminho que é parte de um caminho maior. Por exemplo:

\alinhaverbatim
subpath (0, 2) of p1 -- p2 -- p3;
\alinhanormal

O código acima avalia para o novo caminho \monoespaco{p1 -- p2},
assumindo que \monoespaco{p1} e \monoespaco{p2} são um único ponto
cada um.

No METAFONT original, é possível calcular subcaminhos entre pontos em
posições não-inteiras. Por exemplo, calcular o subcaminho do ponto 0,5
até 1,8. O METAFONT obteria um ponto intermediário entre os pontos de
controle 0 e 1 e entre 1 e 2 conforme pedido. Novos pontos de
extremidade e de controle adequados seriam gerados.  Aqui por hora
iremos suportar só uma versão mais simples de subcaminhos. Somente
subcaminhos inteiros serão suportados.

No caso de caminhos não-cíclicos, se tentarmos especificar um
subcaminho com uma posição menos que zero, tal índice será tratado
como zero. E se tentarmos especificar uma posição maior que seu índice
máximo, será tratada como igual ao seu índice máximo.

No case de caminhos cíclicos, índices negativos são contados
caminhando no ciclo na direção oposta do caminho. E também não há um
índice máximo permitido. Desta forma, você pode criar um subcaminho de
um caminho cíclico que é maior que o caminho original. Mas a natureza
cíclica do caminho será sempre perdida após a operação.

\iniciocodigo
@<Caminho Primário: Subcaminho@>=
DECLARE_NESTING_CONTROL();
struct pair_variable a;
struct path_variable b;
struct generic_token *of, *end_pair_expr = begin_expression;
struct generic_token *begin_subexpr;
if(begin_expression -> next == NULL ||  end_pair_expr -> type == TYPE_OF ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
of = (struct generic_token *) (end_pair_expr -> next);
while(of != NULL && of != end_expression){
  COUNT_NESTING(of);
  if(IS_NOT_NESTED() && of -> type == TYPE_OF)
    break;
  end_pair_expr = of;
  of = (struct generic_token *) (of -> next);
}
if(of == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_expression(mf, cx, (struct generic_token *) begin_expression -> next,
                         end_pair_expr, &a))
  return false;
begin_subexpr = of -> next;
if(!eval_path_primary(mf, cx, begin_subexpr, end_expression, &b))
  return false;
{
  int final_path_size, offset;
  result -> cyclic = false;
  if(a.x < 0 && !b.cyclic)
    a.x = 0;
  if(a.y < 0  && !b.cyclic)
    a.y = 0;
  if(a.x >= b.total_length  && !b.cyclic)
    a.x = b.total_length - 1;
  if(a.y >= b.total_length  && !b.cyclic)
    a.y = b.total_length - 1;
  final_path_size = a.y - a.x;
  if(final_path_size < 0)
    final_path_size *= -1;
  final_path_size ++;
  offset = (a.x <= a.y)?(a.x):(a.y);
  if(b.cyclic)
    offset = offset % (b.total_length - 1);
  else
    offset = offset % b.total_length;
  if(offset < 0)
    offset *= -1;
  result -> length = final_path_size;
  result -> total_length = final_path_size;
  result -> points = (struct path_points *)
                       temporary_alloc(final_path_size *
                                       sizeof(struct path_points));
  if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  copy_subpath(result -> points, &b, offset, final_path_size);
  // Ajusta últimos pontos de controle se perdemos o caráter cíclico:
  result -> points[result -> length - 1].u_x =
                                      result -> points[result -> length - 1].x;
  result -> points[result -> length - 1].u_y =
                                      result -> points[result -> length - 1].y;
  result -> points[result -> length - 1].v_x =
                                      result -> points[result -> length - 1].x;
  result -> points[result -> length - 1].v_y =
                                      result -> points[result -> length - 1].y;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  if(a.x > a.y){
    struct path_variable c;
    c.length = result -> total_length;
    c.total_length = result -> total_length;
    c.points = (struct path_points *) temporary_alloc(sizeof(struct path_points) *
                                                      c.total_length);
    if(c.points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
              begin_expression -> line);
#endif
      return false;
    }
    reverse_path(result, &c);
    temporary_free(result -> points);
    result -> points = c.points;
  }
  return true;
}
@
\fimcodigo

Temos agora que apresentar a função que efetivamente copia
recursivamente um caminho para o outro, como visto no código
acima. Essa função recebe um ponteiro para onde cada ponto será
copiado da esquerda para a direita, recebe uma variável de caminho, um
offset representando quantos pontos iniciais serão ignorados e o
número de pontos que devem ser copiados:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size);
@
\fimcodigo

A definição da função será a seguinte:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size){
  struct path_points *dst_pointer = dst;
  while(size > 0){
    int index = 0;
    int initial_offset = offset, initial_size = size;
    recursive_copy_subpath(&dst_pointer, src, &index, &offset, &size);
    // Se copiamos coisas, é um caminho cíclico e copiamos o último ponto:
    if(offset <= 0 && src -> cyclic &&
       initial_offset + initial_size >= src -> total_length){
      dst_pointer --; // O último ponto é redundante, igual ao 1o. Apagar.
      size ++;
    }
  }
}
@
\fimcodigo

E agora finalmente a função que irá percorrer recursivamente o caminho
de origem para copiá-lo:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size);
@
\fimcodigo


\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size){
  while(*size > 0){
    if(pointer -> points[*index].subpath == NULL &&
       !isnan(pointer -> points[*index].x)){
      if(*offset > 0)
        (*offset) --;
      else{
        // Copy:
        memcpy(*dst, &(pointer -> points[*index]),
               sizeof(struct path_points));
        (*dst) -> subpath = NULL;
        (*dst) ++;
        (*size) --;
      }
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].subpath != NULL){
      int new_index = 0;
      recursive_copy_subpath(dst, (struct path_variable *)
                                  (pointer -> points[*index].subpath),
                             &new_index, offset, size);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

O próximo caso a tratar é quando estamos diante de uma variável. Neste
caso, devemos determinar seu tipo. Pode ser um par ou um caminho. Em
seguida, alocamos o tamanho certo para nosso resultado e copiamos o
conteúdo da variável para ele:

\iniciocodigo
@<Caminho Primário: Variável@>=
{
  struct symbolic_token *v = (struct symbolic_token *) begin_expression;
  void *content = v -> var;
  if(((struct pair_variable *) content) -> type == TYPE_T_PAIR){
    result -> length = 1;
    result -> total_length = 1;
    result -> cyclic = false;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    result -> points[0].x = ((struct pair_variable *) content) -> x;
    result -> points[0].y = ((struct pair_variable *) content) -> y;
    result -> points[0].u_x = ((struct pair_variable *) content) -> x;
    result -> points[0].u_y = ((struct pair_variable *) content) -> y;
    result -> points[0].v_x = ((struct pair_variable *) content) -> x;
    result -> points[0].v_y = ((struct pair_variable *) content) -> y;
    result -> points[0].subpath = NULL;
    return true;
  }
  else if(((struct path_variable *) content) -> type == TYPE_T_PATH){
    recursive_copy_points(temporary_alloc, &result,
                          (struct path_variable *) content, false);
    return true;
  }
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Variable is not pair nor path!\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

O próximo caso a ser tratado é quando a expressão primária de caminho
começa e termina com parênteses. E não estamos diante de um par. Neste
caso, devemos avaliar a expressão entre parênteses como uma nova
expressão de caminho. Mas para isso temos antes que checar que não há
uma vírgula dentro dela, caso em que estamos diante de um par:

\iniciocodigo
@<Caminho Primário: Parênteses@>=
struct generic_token *t = begin_expression -> next;
bool found_comma = false;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  if(IS_NOT_NESTED() && t -> type == TYPE_COMMA){
    found_comma = true;
    break;
  }
  t = t -> next;
}
if(!found_comma){
  return eval_path_expression(mf, cx, begin_expression -> next, t, result);
}
@
\fimcodigo

E finalmente, o último caso de expressãso primária é quando temos uma
expressão primária de par. Neste caso, alocamos o único ponto de nosso
caminho, avaliamos a expressão de par e passamos o resultado para o
ponto alocado:

\iniciocodigo
@<Caminho Primário: Par Primário@>=
struct pair_variable v;
if(!eval_pair_primary(mf, cx, begin_expression, end_expression, &v))
  return false;
result -> length = 1;
result -> total_length = 1;
result -> cyclic = false;
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points));
result -> points[0].subpath = NULL;
result -> points[0].x = v.x;
result -> points[0].y = v.y;
result -> points[0].u_x = v.x;
result -> points[0].u_y = v.y;
result -> points[0].v_x = v.x;
result -> points[0].v_y = v.y;
return true;
@
\fimcodigo

\subsubsecao{8.4.5. Caminhos em Expressões Numéricas}

Existe a expressão numérica primária com o
operador \monoespaco{length} que retorna o número de pontos de
extremidade de um caminho menos um. A sua sintaxe é:

\alinhaverbatim
<Primário Numérico> -> length <Caminho Primário>
\alinhanormal
%                       turningnumber <Caminho Primário> |
%                       directiontime <Expressão de Par> of <Caminho Primário>

Não precisamos aqui de nenhum tipo de token novo. A
expressão \monoespaco{length} já era usada para obter o módulo de
números e de pares. Para o caso deste operador obter um caminho, sua
implementação é ainda mais simples:

\iniciocodigo
@<Avalia 'length'@>+=
else if(expr_type == TYPE_T_PATH){
  struct path_variable p;
  if(!eval_path_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) (p.total_length - 1);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &p, false);
  return true;
}
@
\fimcodigo

\subsubsecao{8.4.6. Caminhos em Expressões de Pares}

Dado um caminho, nós podemos extrair pares dele. O par pode ser um dos
pontos de extremidade ou algum dos pontos de controle. A sintaxe para
isso é:

\alinhaverbatim
<Primário de Par> -> point <Expressão Numérica> of <Primário de Caminho> |
                     precontrol <Expressão Numérica> of <Primário de Caminho> |
                     postcontrol <Expressão Numérica> of <Primário de Caminho>
\alinhanormal

Isso requer adicionarmos os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_POINT             67 // O token simbólico 'point'
#define TYPE_PRECONTROL        68 // O token simbólico 'precontrol'
#define TYPE_POSTCONTROL       69 // O token simbólico 'postcontrol'
@
\fimcodigo

E os adicionamos à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"point", "precontrol", "postcontrol",
@
\fimcodigo

Todos estes operadores requerem que nós encontremos determinado ponto
na posição $n$ de um caminho. Para isso, será útil uma função auxiliar
que irá receber uma variável de caminho e um número e irá retornar um
ponteiro para um dos pontos desta variável. Essa função irá primeiro
verificar se temos um caminho onde o tamanho total é igual ao tamanho
(\monoespaco{length == total\_length}). Se for o caso, assumiremos
estar diante de um caminho sem subcaminhos recursivos e retornar o
ponto correto será fácil e rápido. Caso contrário, vamos chamar uma
função recursiva auxiliaar para nos responder qual é o ponto correto:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n){
  if(v -> length == v -> total_length){
    struct path_points *ret = (struct path_points *) &(v -> points[n]);
    while(ret -> subpath != NULL)
      ret = &(((struct path_variable *) (ret -> subpath)) -> points[0]);
    return ret;
  }
  else{
    int count = 0;
    return _get_point(v, n, &count);
  }
}
@
\fimcodigo

Essa função auxiliar recursiva para obter o ponto correto no caso de
caminhos com subcaminhos recursivos irá percorrer os pontos do caminho
na ordem, contando quantos são encontrados. E irá retornar o ponto
quando chegar ao correto. Para isso ela precisa saber qual a variável
de caminho, qual o índice $n$ do ponto e por fim, quantos pontos já
foram percorridos:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count);
@
\fimcodigo

A definição desta função será:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count){
  int i;
  for(i = 0; i < v -> length; i ++){
    if(v -> points[i].subpath == NULL) {
      if(*count == n && !isnan(v -> points[i].x))
	return ((struct path_points *) &(v -> points[i]));
      else if(!isnan(v -> points[i].x))
	(*count) ++;
    }
    else{
      struct path_points *r =
	_get_point((struct path_variable *) (v -> points[i].subpath),
		   n, count);
      if(r != NULL)
	return r;
    }
  }
  return NULL;
}
@
\fimcodigo


No caso do primeiro operador, \monoespaco{point}, ele nos retorna o
ponto de extremidade indicado. Se o caminho não for cíclico, os pontos
de índice menor que zero serão iguais ao de índice zero (o primeiro) e
os pontos de índice maior ou igual ao tamanho serão iguais ao último
ponto. Se o caminho for cíclico, o índice é contado seguindo o
ciclo. No METAFONT original, índices não-positivos eram permitidos,
mas aqui eles serão convertidos para inteiros.

O operador \monoespaco{postcontrol} é semelhante, mas ele obtém o
primeiro ponto de controle imediatamente após o ponto cujo índice é
indicado. E o \monoespaco{precontrol} obtém o ponto de controle
imediatamente antes do ponto indicado.

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>=
if(begin_expression -> type == TYPE_POINT ||
   begin_expression -> type == TYPE_PRECONTROL ||
   begin_expression -> type == TYPE_POSTCONTROL){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_num, *end_num , *of = NULL, *begin_path, *end_path;
  struct numeric_variable a;
  struct path_variable b;
  begin_num = begin_expression -> next;
  end_num = begin_num;
  int index;
  while(end_num != NULL && end_num -> next != end_expression){
    COUNT_NESTING(end_num);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_num -> next) -> type == TYPE_OF){
      of = end_num -> next;
      break;
    }
    end_num = end_num -> next;
  }
  if(of == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'of' in 'point' expression\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(of -> next == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing path expression in "
            "'point' expression\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  begin_path = of -> next;
  end_path = end_expression;
  if(!eval_numeric_expression(mf, cx, begin_num, end_num, &a))
    return false;
  if(!eval_path_primary(mf, cx, begin_path, end_path, &b))
    return false;
  if(b.cyclic){
    index = ((int)(a.value)) % (b.total_length - 1);
    if(begin_expression -> type == TYPE_PRECONTROL)
      index = (index - 1) % (b.total_length - 1);
  }
  else{
    index = (int) (a.value);
    if(index < 0) index = 0;
    if(index >= b.total_length) index = b.total_length - 1;
    if(begin_expression -> type == TYPE_PRECONTROL)
      index --;
  }
  if(begin_expression -> type == TYPE_POINT){
    result -> x = get_point(&b, index) -> x;
    result -> y = get_point(&b, index) -> y;
  }
  else if(begin_expression -> type == TYPE_PRECONTROL){
    if(index < 0){
      result -> x = get_point(&b, 0) -> x;
      result -> y = get_point(&b, 0) -> y;
    }
    else{
      result -> x = get_point(&b, index) -> v_x;
      result -> y = get_point(&b, index) -> v_y;
    }
  }
  else{
    result -> x = get_point(&b, index) -> u_x;
    result -> y = get_point(&b, index) -> u_y;
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  return true;
}
@
\fimcodigo

\subsecao{8.5. Atribuições e Expressões de Caneta}

Para realizar a atribuição de canetas a variáveis do tipo certo,
usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Caneta@>=
else if(type == TYPE_T_PEN){
  int i;
  struct pen_variable result;
  if(!eval_pen_expression(mf, cx, begin_expression,
                         (struct generic_token *) *end_token_list,
                         &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pen_variable(mf, (struct pen_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL && result.format !=  NULL &&
     result.referenced == NULL)
    path_recursive_free(temporary_free, result.format, true);
  if(result.gl_vbo != 0 && result.referenced == NULL)
    glDeleteBuffers(1, &(result.gl_vbo));
}
@
\fimcodigo

A declaração da função que faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_pen_variable(struct metafont *mf,
                        struct pen_variable *target,
                        struct pen_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_pen_variable(struct metafont *mf,
                          struct pen_variable *target,
                          struct pen_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> referenced == NULL){
    if(target -> format != NULL && disalloc != NULL)
      path_recursive_free(disalloc, target -> format, true);
    if(target -> gl_vbo != 0)
      glDeleteBuffers(1, &(target -> gl_vbo));
  }
  memcpy(target, source, sizeof(struct pen_variable));
  target -> type = TYPE_T_PEN;
  if(! (source -> flags & (FLAG_CIRCULAR | FLAG_SQUARE | FLAG_NULL)))
    recursive_copy_points(alloc, &(target -> format), source -> format, true);
  target -> number_of_vertices = 0;
  target -> gl_vbo = 0;
  target -> referenced = NULL;
}
@
\fimcodigo

\subsubsecao{8.5.1. Expressão Terciária de Caneta}

Por enquanto não existe nenhum operador terciário de caneta:

\alinhaverbatim
<Expressão de Caneta> -> <Terciário de Caneta>
<Terciário de Caneta> -> <Secundário de Caneta>
\alinhanormal

Então a função que avalia expressão terciária de canetas apenas
repassa a expressão para a expressão secundária:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result){
  return eval_pen_secondary(mf, cx, begin_expression, end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.5.2. Transformadores de Caneta}

A sintaxe para expressões secundárias de caneta é:

\alinhaverbatim
<Secundário de Caneta> -> <Primário de Caneta> |
                          <Secundário de Caneta> <Transformador>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> |
                   transformed <Primário de Transformação>
\alinhanormal

Transformadores não são coisas novas, eles já eram usados em
expressões de pares, transformações e de caminho. Mas aplicá-los sobre
canetas é ligeiramente diferente, pois ao invés de modificar cada um
de seus pontos, nós modificamos apenas sua matriz de transformação
OpenGL.

A declaração da função que avaliará expressões secundárias de caneta
é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

Sua implementação consiste em percorrer os tokens da expressão até
achar o último transformador, se houver. Se não houver, é só repassar
a avaliação para a função que avalia expressões primárias. Se houver,
então avaliamos como expressão secundária o que vem antes e então
realizamos a transformação adequada:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct pen_variable *pen){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_pen_primary(mf, cx, begin_expression, end_expression, pen);
  else{
    if(!eval_pen_secondary(mf, cx, begin_expression, before_last_transformer, pen))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Secundário de Caneta: Rotação@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Secundário de Caneta: Escala@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Secundário de Caneta: Deslocamento@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Secundário de Caneta: Inclinação@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Secundário de Caneta: X-Escala@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Secundário de Caneta: Y-Escala@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Secundário de Caneta: Z-Escala@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Secundário de Caneta: Transformação Genérica@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Primeiro cuidaremos da rotação. Se nós representarmos cada ponto como
quatro coordenadas como é o padrão em OpenGL (três coordenadas para
três dimensões, uma quarta para que as principais operações possam ser
representadas como transformações lineares), para rotacionar uma
coordenada, é necessário multiplicar por uma matriz como mostrado
abaixo:

$$\left[x\; y\; z\; 1\right]\left[{{cos(\theta) \atop -\sin(\theta)}\atop
      {0\atop 0}}{{\sin(\theta) \atop cos(\theta)}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=\left[x\cdot cos(\theta) - y\cdot sin(\theta)\;\;
      x\cdot sin(\theta) + y\cdot cos(\theta)\;\; z\;\; 1\right]
$$

No caso, o ângulo $\theta$ é medido em radianos. Então devemos
converter o ângulo em graus que o Metafont usa. Rotacionar uma caneta
então envolve fazer essa conversão, somar o valor da rotação com o que
já está armazenado na variável \monoespaco{rotation} dentro da
variável de caneta e multiplicar a sua matriz de
transformação. Rotacionar uma caneta nunca requer que tenhamos que
retriangular ela.

\iniciocodigo
@<Secundário de Caneta: Rotação@>=
struct numeric_variable r;
float temp_matrix[16];
double rotation, cos_theta, sin_theta;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
sin_theta = sin(rotation);
cos_theta = cos(rotation);
memcpy(temp_matrix, pen -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[0] = temp_matrix[0] * cos_theta - temp_matrix[1] * sin_theta;
pen -> gl_matrix[1] = temp_matrix[0] * sin_theta + temp_matrix[1] * cos_theta;
pen -> gl_matrix[4] = temp_matrix[4] * cos_theta - temp_matrix[5] * sin_theta;
pen -> gl_matrix[5] = temp_matrix[4] * sin_theta + temp_matrix[5] * cos_theta;
pen -> gl_matrix[8] = temp_matrix[8] * cos_theta - temp_matrix[9] * sin_theta;
pen -> gl_matrix[9] = temp_matrix[8] * sin_theta + temp_matrix[9] * cos_theta;
pen -> gl_matrix[12] = temp_matrix[12] * cos_theta - temp_matrix[13] * sin_theta;
pen -> gl_matrix[13] = temp_matrix[12] * sin_theta + temp_matrix[13] * cos_theta;
return true;
@
\fimcodigo

Para fazer a operação de escala, devemos também usar a seguinte matriz
que irá ampliar a posição de cada um dos pontos:

$$\left[x\; y\; z\; 1\right]\left[{{a \atop 0}\atop {0\atop
      0}}{{0 \atop a}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]=\left[ax \;\; ay\;\;
      z\;\; 1\right]
$$

Então, para aumentar ou diminuir a escala de uma caneta, devemos
multiplicar a matriz de transformação OpenGL pela matriz
acima. Contudo, quando mudamos o tamanho de uma caneta será necessário
retriangulá-la caso ela não seja composta somente por linhas
retas. Por isso também removemos seus triângulos anteriores enviados
ao OpenGL e zeramos tal variável fazendo com que os triângulos sejam
recomputados futuramente se necessário.

\iniciocodigo
@<Secundário de Caneta: Escala@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, pen -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[0] = temp_matrix[0] * a.value;
pen -> gl_matrix[1] = temp_matrix[1] * a.value;
pen -> gl_matrix[4] = temp_matrix[4] * a.value;
pen -> gl_matrix[5] = temp_matrix[5] * a.value;
pen -> gl_matrix[8] = temp_matrix[8] * a.value;
pen -> gl_matrix[9] = temp_matrix[9] * a.value;
pen -> gl_matrix[12] = temp_matrix[12] * a.value;
pen -> gl_matrix[13] = temp_matrix[13] * a.value;
// Requer retriangular a caneta:
if(!(pen -> flags & (FLAG_STRAIGHT | FLAG_NULL)) && a.value != 1.0){
  if(pen -> referenced != NULL){
    recursive_copy_points(temporary_alloc, &(pen -> format),
                          pen -> referenced -> format, true);
    pen -> referenced = NULL;
  }
  else if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));  
  pen -> gl_vbo = 0;
}
return true;
@
\fimcodigo

A transformação de deslocamento desloca cada um dos pontos de uma
caneta uma dada posição. Ela nunca requer que a caneta tenha que ser
retriangulada. Fazer o deslocamento de um ponto requer multiplicá-lo
por uma matriz como a abaixo:

$$\left[x\; y\; z\; 1\right]\left[{{1 \atop 0}\atop {0\atop
      a}}{{0 \atop 1}\atop {0 \atop b}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]=\left[x+a \;\; y+b\;\;
      z\;\; 1\right]
$$

Desta forma, realizar um deslocamento significa apenas multiplicar a
matriz acima pela matriz de transformação da caneta:

\iniciocodigo
@<Secundário de Caneta: Deslocamento@>=
struct pair_variable p;
float temp_matrix[16];
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
memcpy(temp_matrix, pen  -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[0] = temp_matrix[0] + temp_matrix[3] * p.x;
pen -> gl_matrix[1] = temp_matrix[1] + temp_matrix[3] * p.y;
pen -> gl_matrix[4] = temp_matrix[4] + temp_matrix[7] * p.x;
pen -> gl_matrix[5] = temp_matrix[5] + temp_matrix[7] * p.y;
pen -> gl_matrix[8] = temp_matrix[8] + temp_matrix[11] * p.x;
pen -> gl_matrix[9] = temp_matrix[8] + temp_matrix[11] * p.y;
pen -> gl_matrix[12] = temp_matrix[12] + temp_matrix[15] * p.x;
pen -> gl_matrix[13] = temp_matrix[12] + temp_matrix[15] * p.y;
return true;
@
\fimcodigo

O próximo transformador é a inclinação. Ela muda as proporções de uma
caneta, então requer que nós refaçamos a triangulação caso tenhamos
uma caneta que não é composta só por linhas retas. Inclinar significa
multiplicar pela seguinte matriz:

$$\left[x\; y\; z\; 1\right]\left[{{1 \atop a}\atop {0\atop
      0}}{{0 \atop 1}\atop {0 \atop 1}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]=\left[x+ay \;\; y\;\;
      z\;\; 1\right]
$$

Então devemos tratar uma inclinação como a multiplicação da matriz de
transformação OpenGL pela matriz acima:

\iniciocodigo
@<Secundário de Caneta: Inclinação@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, pen -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[0] = temp_matrix[0] + a.value * temp_matrix[1];
pen -> gl_matrix[4] = temp_matrix[4] + a.value * temp_matrix[5];
pen -> gl_matrix[8] = temp_matrix[8] + a.value * temp_matrix[9];
pen -> gl_matrix[12] = temp_matrix[12] + a.value  * temp_matrix[13];
// Requer retriangular a caneta:
if(!(pen -> flags & (FLAG_STRAIGHT | FLAG_NULL)) && a.value != 0.0){
  if(pen -> referenced != NULL){
    recursive_copy_points(temporary_alloc, &(pen  -> format),
                          pen  -> referenced -> format, true);
    pen -> referenced = NULL;
  }
  else if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen  -> gl_vbo));  
  pen -> gl_vbo = 0;
}
return true;
@
\fimcodigo

A transformação de escala no eixo $x$ é igual à transformação de
escala, mas ajustando para o valor de 1 a transformação no eixo
$y$. Desta forma, a caneta é esticada ou comprimida somente no eixo
horizontal:

$$\left[x\; y\; z\; 1\right]\left[{{a \atop 0}\atop {0\atop
      0}}{{0 \atop 1}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]=\left[ax \;\; y\;\;
      z\;\; 1\right]
$$

Multiplicar a matriz de transformação pela matriz acima é feita no
código abaixo:

\iniciocodigo
@<Secundário de Caneta: X-Escala@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, pen -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[0] = temp_matrix[0] * a.value;
pen -> gl_matrix[4] = temp_matrix[4] * a.value;
pen -> gl_matrix[8] = temp_matrix[8] * a.value;
pen -> gl_matrix[12] = temp_matrix[12] * a.value;
// Requer retriangular a caneta:
if(!(pen -> flags & (FLAG_STRAIGHT | FLAG_NULL)) && a.value != 1.0){
  if(pen -> referenced != NULL){
    recursive_copy_points(temporary_alloc, &(pen -> format),
                          pen -> referenced -> format, true);
    pen -> referenced = NULL;
  }
  else if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));  
  pen -> gl_vbo = 0;
}
return true;
@
\fimcodigo

Da mesma forma, mudar a escala somente no eixo $y$ é feito
multiplicando pela matriz:

$$\left[x\; y\; z\; 1\right]\left[{{1 \atop 0}\atop {0\atop
      0}}{{0 \atop a}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]=\left[x \;\; ay\;\;
      z\;\; 1\right]
$$

E isso é feito no código abaixo:

\iniciocodigo
@<Secundário de Caneta: Y-Escala@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, pen -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[1] = temp_matrix[1] * a.value;
pen -> gl_matrix[5] = temp_matrix[5] * a.value;
pen -> gl_matrix[9] = temp_matrix[9] * a.value;
pen -> gl_matrix[13] = temp_matrix[13] * a.value;
// Requer retriangular a caneta:
if(!(pen -> flags & (FLAG_STRAIGHT | FLAG_NULL)) && a.value != 1.0){
  if(pen -> referenced != NULL){
    recursive_copy_points(temporary_alloc, &(pen -> format),
                          pen -> referenced -> format, true);
    pen -> referenced = NULL;
  }
  else if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));  
  pen -> gl_vbo = 0;
}
return true;
@
\fimcodigo

A mudança de escala $z$ înterpreta dois pares como números
complexos e os multiplica:

$$
(x+yi)(a+bi) = ax + (bx)i + (ay)i + (by)i^2 = (ax - by) + (bx+ay)i
$$

Do ponto de vista de multiplicação de vetor por matriz, o que ocorre é
a seguinte multiplicação:

$$\left[x\; y\; z\; 1\right]\left[{{a \atop -b}\atop {0\atop
      0}}{{b \atop a}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]=\left[ax-by \;\; bx+ay\;\;
      z\;\; 1\right]
$$

Podemos então realizar a multiplicação de matrizes usando o código
abaixo:

\iniciocodigo
@<Secundário de Caneta: Z-Escala@>=
struct pair_variable p;
float temp_matrix[16];
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
memcpy(temp_matrix, pen -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[0] = temp_matrix[0] * p.x - temp_matrix[1] * p.y;
pen -> gl_matrix[1] = temp_matrix[0] * p.y + temp_matrix[1] * p.x;
pen -> gl_matrix[4] = temp_matrix[4] * p.x - temp_matrix[5] * p.y;
pen -> gl_matrix[5] = temp_matrix[4] * p.y + temp_matrix[5] * p.x;
pen -> gl_matrix[8] = temp_matrix[8] * p.x - temp_matrix[9] * p.y;
pen -> gl_matrix[9] = temp_matrix[8] * p.y + temp_matrix[9] * p.x;
pen -> gl_matrix[12] = temp_matrix[12] * p.x - temp_matrix[13] * p.y;
pen -> gl_matrix[13] = temp_matrix[12] * p.y + temp_matrix[13] * p.x;
if(!(pen -> flags & (FLAG_STRAIGHT | FLAG_NULL))){ // Requer retriangular a caneta:
  if(pen -> referenced != NULL){
    recursive_copy_points(temporary_alloc, &(pen -> format),
                          pen -> referenced -> format, true);
    pen -> referenced = NULL;
  }
  else if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));  
  pen -> gl_vbo = 0;
}
return true;
@
\fimcodigo

Por fim, a última transformação envolve aplicar a transformação linear
$(a, b, c, d, e, f)$, o que é o mesmo que multiplicar o ponto $(x, y,
z, 1)$ por:

$$\left[x\; y\; z\; 1\right]\left[{{c \atop d}\atop {0\atop
      a}}{{e \atop f}\atop {0 \atop b}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]=\left[a+cx+dy \;\; b+ex+fy\;\;
      z\;\; 1\right]
$$

Fazemos esta transformação com o código abaixo:

\iniciocodigo
@<Secundário de Caneta: Transformação Genérica@>=
struct transform_variable t;
float temp_matrix[16];
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression, &t))
  return false;
memcpy(temp_matrix, pen -> gl_matrix, 16 * sizeof(float));
pen -> gl_matrix[0] = temp_matrix[0] * t.value[2] + temp_matrix[1] * t.value[3] +
                      temp_matrix[3] * t.value[0];
pen -> gl_matrix[1] = temp_matrix[0] * t.value[4] + temp_matrix[1] * t.value[5] +
                      temp_matrix[3] * t.value[1];
pen -> gl_matrix[4] = temp_matrix[4] * t.value[2] + temp_matrix[5] * t.value[3] +
                      temp_matrix[7] * t.value[0];
pen -> gl_matrix[5] = temp_matrix[4] * t.value[4] + temp_matrix[5] * t.value[5] +
                      temp_matrix[7] * t.value[1];
pen -> gl_matrix[12] = temp_matrix[12] * t.value[2] + temp_matrix[13] * t.value[3] +
                      temp_matrix[15] * t.value[0];
pen -> gl_matrix[13] = temp_matrix[12] * t.value[4] + temp_matrix[13] * t.value[5] +
                       temp_matrix[15] * t.value[1];
if(!(pen -> flags & (FLAG_STRAIGHT | FLAG_NULL))){ // Requer retriangular a caneta:
  if(pen -> referenced != NULL){
    recursive_copy_points(temporary_alloc, &(pen -> format),
                          pen -> referenced -> format, true);
    pen -> referenced = NULL;
  }
  else if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));  
  pen -> gl_vbo = 0;
}
return true;
@
\fimcodigo


\subsubsecao{8.5.3. Expressões Primárias de Caneta}

A gramática das expressões primárias de caminho é definida como:

\alinhaverbatim
<Primário de Caneta> -> <Variável de Caneta> |
                        nullpen | ( <Expressão de Caneta> ) |
                        pencircle | makepen <Primário de Caminho>
\alinhanormal


Isso requer registrar três novas palavras reservadas:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_NULLPEN        70 // O token simbólico 'nullpen'
#define TYPE_PENCIRCLE      71 // O token simbólico 'pencircle'
#define TYPE_MAKEPEN        72 // O token simbólico 'makepen'
@
\fimcodigo

E adicionamos uma string com o nome delas na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"nullpen", "pencircle", "makepen",
@
\fimcodigo

A função que irá interpretar expressões primárias de caneta é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Caneta Primária: Variável@>
    }
    else if(begin_expression -> type == TYPE_NULLPEN){
      @<Caneta Primária: Caneta Nula@>
    }
    else if(begin_expression -> type == TYPE_PENCIRCLE){
      @<Caneta Primária: Caneta Circular@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Caneta Primária: Parênteses@>
    }
    else if(begin_expression -> type == TYPE_MAKEPEN){
      @<Caneta Primária: Formato Personalizado@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

Se a expressão avaliar para uma variável, devemos copiar o conteúdo da
variável. Mas em um primeiro momento não precisamos criar um novo
vértice ou alocar espaço para o novo caminho. A nossa nova variável
obtida pela avaliação irá inicialmente apenas referenciar tais
informações:

\iniciocodigo
@<Caneta Primária: Variável@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct pen_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-pen variable (%d) in pen expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
memcpy(result, content, sizeof(struct pen_variable));
result -> referenced = content;
return true;
@
\fimcodigo

Se a expressão avaliar para uma caneta nula, devemos apenas gerar uma
nova caneta com a flag de \monoespaco{FLAG\_NULL} ativa. Esta caneta
nunca será triangulada e nunca produzirá qualquer desenho:

\iniciocodigo
@<Caneta Primária: Caneta Nula@>=
result -> format = NULL;
result -> flags = FLAG_NULL;
result -> referenced = false;
result -> gl_vbo = 0;
result -> gl_matrix[0] = result -> gl_matrix[5] = result -> gl_matrix[10] =
                         result -> gl_matrix[15] = 1.0; 
result -> gl_matrix[1] = result -> gl_matrix[2] = result -> gl_matrix[3] = 
                         result -> gl_matrix[4] = result -> gl_matrix[6] =
                         result -> gl_matrix[7] = result -> gl_matrix[8] = 
                         result -> gl_matrix[9] = result -> gl_matrix[11] =
                         result -> gl_matrix[12] = result -> gl_matrix[13] =
                         result -> gl_matrix[14] = 0.0;
return true;
@
\fimcodigo

Se a expressão avaliar para uma caneta circular, geraremos uma nova
caneta com as flags de ser circular e convexa. Também inicializamos a
matriz de transformação como sendo a matriz identidade:

\iniciocodigo
@<Caneta Primária: Caneta Circular@>=
result -> format = NULL;
result -> flags = FLAG_CONVEX | FLAG_CIRCULAR;
result -> referenced = false;
result -> gl_vbo = 0;
result -> number_of_vertices = 0;
result -> gl_matrix[0] = result -> gl_matrix[5] = result -> gl_matrix[10] =
                         result -> gl_matrix[15] = 1.0; 
result -> gl_matrix[1] = result -> gl_matrix[2] = result -> gl_matrix[3] = 
                         result -> gl_matrix[4] = result -> gl_matrix[6] =
                         result -> gl_matrix[7] = result -> gl_matrix[8] = 
                         result -> gl_matrix[9] = result -> gl_matrix[11] =
                         result -> gl_matrix[12] = result -> gl_matrix[13] =
                         result -> gl_matrix[14] = 0.0;
return true;
@
\fimcodigo

Avaliar parênteses envolve avaliar como expressão de caneta os tokens
do que vem após o abrir parênteses até o que vem imediatamente antes
do fechar parênteses:

\iniciocodigo
@<Caneta Primária: Parênteses@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_pen_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

O último caso de expressão primária de caneta é quando o usuário
escolhe um formato personalizado. Neste caso devemos avaliar a
expressão de caminho indicada e com ela criamos a nova caneta com tal
formato:

\iniciocodigo
@<Caneta Primária: Formato Personalizado@>=
struct generic_token *p = begin_expression -> next;
result -> format =
        (struct path_variable *) temporary_alloc(sizeof(struct path_variable));
if(result -> format == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, p, end_expression, result -> format))
  return false;
if(!(result -> format -> cyclic)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr,
          "METAFONT: Error: %s:%d: Using 'makepen' with non-cyclic path.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
result -> flags = read_flags(result -> format); // Função a ser implemementada
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> number_of_vertices = 0;
result -> gl_matrix[0] = result -> gl_matrix[5] = result -> gl_matrix[10] =
                         result -> gl_matrix[15] = 1.0; 
result -> gl_matrix[1] = result -> gl_matrix[2] = result -> gl_matrix[3] = 
                         result -> gl_matrix[4] = result -> gl_matrix[6] =
                         result -> gl_matrix[7] = result -> gl_matrix[8] = 
                         result -> gl_matrix[9] = result -> gl_matrix[11] =
                         result -> gl_matrix[12] = result -> gl_matrix[13] =
                         result -> gl_matrix[14] = 0.0;
return true;
@
\fimcodigo

O que falta implementar para que o código acima funcione é a função
que percorra os pontos de uma variável de caminho e retorne quais
flags teria uma caneta com aquele formato.

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int read_flags(struct path_variable *path);
@
\fimcodigo

Já sabemos que ela nunca seria circular, pois círculos perfeitos não
podem ser expressos como curvas de Beziér. Iremos então verificar se
ela é reta ou convexa percorrendo os seus pontos:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int read_flags(struct path_variable *path){
  int i, positive_cross_product = -1;
  int flag = FLAG_CONVEX | FLAG_STRAIGHT;
  for(i = 0; i < path -> total_length - 1; i ++){
    struct path_points *current, *next;
    current = get_point(path, i);
    next = get_point(path, i + 1);
    if(flag & FLAG_STRAIGHT){
      // Ela não é reta se os pontos de extremidade e de controle não estão
      // na mesma reta. Eles estão na mesma reta se a área de seu triângulo
      // é igual a zero (ou suficientemente próxima):
      double area =  current -> x * (current -> u_y - next -> y) +
                     current -> u_x * (next -> y - current -> y) +
                     next -> x * (current -> y - current -> u_y);
      if(area > 0.00002)
        flag -= FLAG_STRAIGHT;
      area =  current -> x * (current -> v_y - next -> y) +
              current -> v_x * (next -> y - current -> y) +
              next -> x * (current -> y - current -> v_y);
      if((flag & FLAG_STRAIGHT) && area > 0.00002)
        flag -= FLAG_STRAIGHT;
    }
    if(flag & FLAG_CONVEX){
      // Ela é convexa somente se o componente z do produto vetorial dos
      // vetores formados pelos pontos de extremidade e controle na ordem
      // de desenho são todos ou não-positivos ou não-negativos.
      int j;
      double d1_x, d1_y, d2_x, d2_y, z_cross_product;
      double p1_x, p1_y, p2_x, p2_y, p3_x, p3_y; // Pontos
      for(j = 0; j < 3; j ++){
        switch(j){
          case 0:
            p1_x = current -> x; p1_y = current -> y;
            p2_x = current -> u_x; p2_y = current -> u_y;
            p3_x = current -> v_x; p3_y = current -> v_y;
            break;
          case 1:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> x; p3_y = next -> y;
            break;
          default:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> u_x; p3_y = next -> u_y;
            break;
        }
        d1_x = p2_x - p1_x;
        d1_y = p2_y - p1_y;
        d2_x = p3_x - p2_x;
        d2_y = p3_y - p2_y;
        z_cross_product = d1_x * d2_y - d1_y * d2_x;
        if(z_cross_product > 0.00002 || z_cross_product < -0.00002){
          if(positive_cross_product == -1)
            positive_cross_product = (z_cross_product > 0);
          else if((z_cross_product > 0) != positive_cross_product){
            flag -= FLAG_CONVEX;
            break;
          }
        }
      }
    }
  }
  return flag;
}
@
\fimcodigo

\subsubsecao{8.5.4. Canetas em Expressões de Caminho}

Expressões primárias de caneta podem aparecer também quando avaliamos
uma expressão primária de caminho. Isso permite que possamos extrair
um caminho à partir do formato de uma caneta. A gramática de tal
operação é:

\alinhaverbatim
<Primário de Caminho> -> makepath <Primário de Caneta>
\alinhanormal

Temos que registrar um novo token para o ``makepath'':

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_MAKEPATH       73 // O token simbólico 'makepath'
@
\fimcodigo

E adicionamos a string com seu nome à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"makepath",
@
\fimcodigo

O operador ``makepath'' deve avaliar tudo o que vem depois dele como
sendo uma expressão primária da caneta. Em seguida, o resultado da
avaliação é um caminho com o formato da caneta. Contudo, devemos
lembrar que nem sempre armazenamos o formato de uma caneta
explicitamente. Caso tenhamos uma \monoespaco{nullpen},
um \monoespaco{circlepen} ou se estivermos diante de um quadrado,
então precisamos gerar um caminho novo, já que não temos caminho nenhum:

\iniciocodigo
@<Caminho Primário: Outras Expressões@>=
else if(begin_expression -> type == TYPE_MAKEPATH){
  struct pen_variable tmp;
  if(begin_expression -> next == NULL ||
     begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_pen_primary(mf, cx, begin_expression -> next, end_expression,
                       &tmp))
    return false;
  if(tmp.flags & FLAG_NULL){ // nullpen: Avalia para ponto único (0, 0)
    @<'makepath': 'nullpen'@>
  }
  else if(tmp.flags & FLAG_CIRCULAR){ // circlepen: Cria aproximação de círculo
    @<'makepath': 'pencircle'@>
  }
  else if(tmp.flags & FLAG_SQUARE){ // Caneta quadrada
    @<'makepath': 'pensquare'@>
  }
  else{ // Caneta com formato personalizado
    @<'makepath': Formato Personalizado@>
  }
  @<'makepath': Realiza Transformação Linear@>
  return true;
}
@
\fimcodigo

Assim como na linguagem METAFONT original, o \monoespaco{nullpen}
significa um único ponto na posição $(0, 0)$ que nunca é desenhado:

\iniciocodigo
@<'makepath': 'nullpen'@>=
result -> length = 1;
result -> total_length = 1;
result -> cyclic = false;
result -> points =
  (struct path_points *) temporary_alloc(sizeof(struct path_points));
result -> points[0].x = 0.0;
result -> points[0].y = 0.0;
result -> points[0].u_x = 0.0;
result -> points[0].u_y = 0.0;
result -> points[0].v_x = 0.0;
result -> points[0].v_y = 0.0;
result -> points[0].subpath = NULL;
@
\fimcodigo

Caso estejamos diante de um caminho circular, usaremos como
representação do caminho os mesmos valores que o METAFONT original usa
para representar o caminho na macro \monoespaco{fullcircle}. O
resultado será algo próximo a um círculo.

\iniciocodigo
@<'makepath': 'pencircle'@>=
result -> length = 9;
result -> total_length = 9;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 9);
result -> points[0].subpath = NULL;
result -> points[0].x = 0.5; result -> points[0].y = 0.0;
result -> points[0].u_x = 0.5; result -> points[0].u_y = 0.13261;
result -> points[0].v_x = 0.44733; result -> points[0].v_y = 0.2598;
result -> points[1].subpath = NULL;
result -> points[1].x = 0.35356; result -> points[1].y = 0.35356;
result -> points[1].u_x = 0.2598; result -> points[1].u_y = 0.44733;
result -> points[1].v_x = 0.13261; result -> points[1].v_y = 0.5;
result -> points[2].subpath = NULL;
result -> points[2].x = 0.0; result -> points[2].y = 0.5;
result -> points[2].u_x = -0.13261; result -> points[2].u_y = 0.5;
result -> points[2].v_x = -0.2598; result -> points[2].v_y = 0.44733;
result -> points[3].subpath = NULL;
result -> points[3].x = -0.35356; result -> points[3].y = 0.35356;
result -> points[3].u_x = -0.44733; result -> points[3].u_y = 0.2598;
result -> points[3].v_x = -0.5; result -> points[3].v_y = 0.13261;
result -> points[4].subpath = NULL;
result -> points[4].x = -0.5; result -> points[4].y = 0.0;
result -> points[4].u_x = -0.5; result -> points[4].u_y = -0.13261;
result -> points[4].v_x = -0.44733; result -> points[4].v_y = -0.2598;
result -> points[5].subpath = NULL;
result -> points[5].x = -0.35356; result -> points[5].y = -0.35356;
result -> points[5].u_x = -0.2598; result -> points[5].u_y = -0.44733;
result -> points[5].v_x = -0.13261; result -> points[5].v_y = -0.5;
result -> points[6].subpath = NULL;
result -> points[6].x = 0.0; result -> points[6].y = -0.5;
result -> points[6].u_x = 0.13261; result -> points[6].u_y = -0.5;
result -> points[6].v_x = 0.2598; result -> points[6].v_y = -0.44733;
result -> points[7].subpath = NULL;
result -> points[7].x = 0.35356; result -> points[7].y = -0.35356;
result -> points[7].u_x = 0.44733; result -> points[7].u_y = -0.2598;
result -> points[7].v_x = 0.5; result -> points[7].v_y = -0.13261;
result -> points[8].subpath = NULL;
result -> points[8].x = 0.5; result -> points[8].y = 0.0;
result -> points[8].u_x = 0.5; result -> points[8].u_y = 0.13261;
result -> points[8].v_x = 0.44733; result -> points[8].v_y = 0.2598;
result -> cyclic = true;
@
\fimcodigo

Se acaneta for quadrada, geramos seu formato verdadeiro preenchendo
manualmente seus pontos de extremidade e de controle:

\iniciocodigo
@<'makepath': 'pensquare'@>=
result -> length = 5;
result -> total_length = 5;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 5);
result -> points[0].subpath = NULL;
result -> points[0].x = -0.5; result -> points[0].y = -0.5;
result -> points[0].u_x = (-0.5+(1.0/3.0)); result -> points[0].u_y = -0.5;
result -> points[0].v_x = (-0.5+(2.0/3.0)); result -> points[0].v_y = -0.5;
result -> points[1].subpath = NULL;
result -> points[1].x = 0.5; result -> points[1].y = -0.5;
result -> points[1].u_x = 0.5; result -> points[1].u_y = (-0.5+(1.0/3.0));
result -> points[1].v_x = 0.5; result -> points[1].v_y = (-0.5+(2.0/3.0));
result -> points[2].subpath = NULL;
result -> points[2].x = 0.5; result -> points[2].y = 0.5;
result -> points[2].u_x = (0.5-(1.0/3.0)); result -> points[2].u_y = 0.5;
result -> points[2].v_x = (0.5-(2.0/3.0)); result -> points[2].v_y = 0.5;
result -> points[3].subpath = NULL;
result -> points[3].x = -0.5; result -> points[3].y = 0.5;
result -> points[3].u_x = -0.5; result -> points[3].u_y = (0.5-(1.0/3.0));
result -> points[3].v_x = -0.5; result -> points[3].v_y = (0.5-(2.0/3.0));
result -> points[4].subpath = NULL;
result -> points[4].x = -0.5; result -> points[4].y = -0.5;
result -> points[4].u_x = (-0.5+(1.0/3.0)); result -> points[4].u_y = -0.5;
result -> points[4].v_x = (-0.5+(2.0/3.0)); result -> points[4].v_y = -0.5;
result -> cyclic = true;
@
\fimcodigo

Por fim, se estivermos diante de uma caneta com formato personalizado,
então nós já temos uma representação de seu formato na forma de um
caminho e nós só temos que copiá-la:


\iniciocodigo
@<'makepath': Formato Personalizado@>=
if(tmp.referenced == NULL)
  recursive_copy_points(temporary_alloc, &result, tmp.format, false);
else
  recursive_copy_points(temporary_alloc, &result, tmp.referenced -> format,
                        false);
if(temporary_free != NULL && tmp.referenced == NULL)
  temporary_free(tmp.format);
@
\fimcodigo

E finalmente, uma vez que tenhamos o nosso caminho, devemos aplicar
todas as transformações de rotação, translação e demais transformações
lineares que estiverem registradas na matriz de transformação OpenGL:

\iniciocodigo
@<'makepath': Realiza Transformação Linear@>=
{
  int i;
  for(i = 0; i < result -> length; i ++){
    float old_x = result -> points[i].x;
    result -> points[i].x = result -> points[i].x * tmp.gl_matrix[0] +
                            result -> points[i].y * tmp.gl_matrix[4] +
                            tmp.gl_matrix[12];
    result -> points[i].y = old_x * tmp.gl_matrix[1] +
                            result -> points[i].y * tmp.gl_matrix[5] +
                            tmp.gl_matrix[13];
    old_x = result -> points[i].u_x;
    result -> points[i].u_x = result -> points[i].u_x * tmp.gl_matrix[0] +
                              result -> points[i].u_y * tmp.gl_matrix[4] +
                              tmp.gl_matrix[12];
    result -> points[i].u_y = old_x * tmp.gl_matrix[1] +
                              result -> points[i].u_y * tmp.gl_matrix[5] +
                              tmp.gl_matrix[13];
    old_x = result -> points[i].v_x;
    result -> points[i].v_x = result -> points[i].v_x * tmp.gl_matrix[0] +
                              result -> points[i].v_y * tmp.gl_matrix[4] +
                              tmp.gl_matrix[12];
    result -> points[i].v_y = old_x * tmp.gl_matrix[1] +
                              result -> points[i].v_y * tmp.gl_matrix[5] +
                              tmp.gl_matrix[13];
  }
}
@
\fimcodigo

\subsecao{8.6. Atribuições e Expressões de Imagens}

Para realizar a atribuição de imagens a variáveis do tipo certo,
usamos o código abaixo. O que ele faz é avaliar uma expressão de
imagem e coletar o resultado. Em seguida, ele precisa fazer com que
todas as variáveis da atribuição recebam uma cópia da imagem
avaliada. Se existe somente uma variável a ser atribuída, nós apenas
copiamos o identificador textura já obtida e desenhada na
avaliação. Se houver mais de uma variável, a primeira delas recebe uma
cópia direta do identificador da imagem já obtida. Para as demais,
precisaremos usar comandos OpenGL para copiar a textura avaliada para
o destino.

\iniciocodigo
@<Atribuição de Variável de Imagem@>=
else if(type == TYPE_T_PICTURE){
  int i;
  struct picture_variable result;
  if(!eval_picture_expression(mf, cx, begin_expression,
                              (struct generic_token *) *end_token_list,
                              &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    if(i == 0){
      struct picture_variable *pic = (struct picture_variable *) var -> var;
      if(pic -> texture != 0)
        glDeleteTextures(1, &(pic -> texture));
      memcpy(pic, &result, sizeof(struct picture_variable));
      pic -> type = TYPE_T_PICTURE;
    }
    else 
      assign_picture_variable(mf, (struct picture_variable *) var -> var,
                              &result);
    //printf("Picture '%s':", var -> value);
    //print_picture((struct picture_variable *) var -> var);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  
}
@
\fimcodigo

A função \monoespaco{assign\_picture\_variable} acima precisa gerar
uma nova textura na variável de destino (apagando a textura já
existente se for o caso) e copiar o conteúdo da textura de origem no
destino. Isso significa que nós precisaremos renderizar o conteúdo de
uma textura na outra.

Para renderizar algo, primeiro precisaremos de vértices. Como tudo que
vamos renderizar são sempre imagens e texturas retangulares, os únicos
vértices que precisaremos renderizar são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
const static float square[20] = {
  -1.0, -1.0, //Primeiro vértice
  0.0, 0.0, // Coordenada da textura
  1.0, -1.0, // Segundo vértice
  1.0, 0.0, // Textura
  1.0, 1.0, // Terceiro vértice
  1.0, 1.0, // Textura
  -1.0, 1.0, // Quarto vértice
  0.0, 1.0}; // Textura
static GLuint vbo; // OpenGL Vertex Buffer Object
@
\fimcodigo

Associamos acima a cada vértice uma coordenada de textura. Desta forma
conseguiremos enviar para a placa de vídeo ambas as informações de uma
só vez. Note que o que definimos acima é um quadrado de lado 2
centralizado na origem. Este é o tamanho padrão para que ele seja
renderizado em todo o espaço disponível nas convenções OpenGL. Nós
também definimos o quadrado definindo seus vértices no sentido
anti-horário, o que faz com que por convenção ele seja renderizado de
frente para a câmera. Isso é necessário para que o quadrado sempre
seja renderizado, mesmo que otimizações estejam ativas fazendo com que
o lado de trás dos polígonos não sejam desenhados.

Na inicialização do Weaver Metafont nós enviamos estes vértices para
a placa de vídeo:

\iniciocodigo
@<Inicialização de Weaver Metafont@>=
glGenBuffers(1, &vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// Enviando os vértices para a placa de vídeo:
glBufferData(GL_ARRAY_BUFFER, sizeof(square), square, GL_STATIC_DRAW);
@
\fimcodigo

Na finalização nós removemos os vértices da placa de vídeo:

\iniciocodigo
@<Finalização de Weaver Metafont@>=
glDeleteBuffers(1, &vbo);
@
\fimcodigo

Além de vértices, precisamos de um shader de vértice que nos indique
como renderizar tais vértices. O programa deve ser versátil o bastante
para receber como argumento uma matriz com transformações lineares a
serem aplicadas a cada vértice. Os atributos do programa são a
coordenada do vértice e da textura. O valor uniforme recebido é a
matriz para transformação linear. E o valor de retorno a ser passado para o shader de
fragmento é a posição final da coordenada depois da transformação,
além da coordenada de textura. 

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat4 model_view_matrix;\n"
  "varying highp vec2 texture_coordinate;\n"
  "void main(){\n"
  "  gl_Position = vec4(vertex_data.xy, 0.0, 1.0) * model_view_matrix;\n"
  "  texture_coordinate = vertex_data.zw;\n"
  "}\n";
@
\fimcodigo

Já o código do shader de fragmento recebe a saída do shader de vértice
acima além de uma textura:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  gl_FragColor = texture2D(texture1, texture_coordinate);"
  "}\n";
static GLuint program; // Armazenará o programa após compilar os shaders acima
GLint uniform_matrix; // Armazenará a posição da matriz de modelo visualização acima
GLint uniform_texture; // A posição da variável de textura no código acima
@
\fimcodigo

Estes shaders simples precisam ser compilados na inicialização. Vamos
criar uma função auxiliar local para nos ajudar na compilação:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source);
@
\fimcodigo

Esta função irá retornar o identificador do programa compilado à
partir dos códigos-fontes dos shaders passados como argumento. Se algo
der errado, irá retornar zero.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source){
  GLuint vertex, fragment, prog;
  GLint status = GL_TRUE;
  // Criando shader de vértice e de fragmento
  vertex = glCreateShader(GL_VERTEX_SHADER);
  fragment = glCreateShader(GL_FRAGMENT_SHADER);
  // Passando o código-fonte a cada um deles
  glShaderSource(vertex, 1, &vertex_shader_source, NULL);
  glShaderSource(fragment, 1, &fragment_shader_source, NULL);
  // Compilando shader de vértice:
  glCompileShader(vertex);
  glGetShaderiv(vertex, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont vertex shader compilation failed!\n");
    return 0;
  }
  // Compilando shader de fragmento:
  glCompileShader(fragment);
  glGetShaderiv(fragment, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont fragment shader compilation failed!\n");
    return 0;
  }
  // Criando programa:
  prog = glCreateProgram();
  // Ligando o programa:
  glAttachShader(prog, vertex);
  glAttachShader(prog, fragment);
  glBindAttribLocation(prog, 0, "vertex_data");
  glLinkProgram(prog);
  glGetProgramiv(prog, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr, "ERROR: Weaver Metafont shader linking failed!\n");
    return 0;
  }
  // Finalização:
  glDeleteShader(vertex);
  glDeleteShader(fragment);
  return prog;
}
@
\fimcodigo

E podemos usar esta função para inicializar nosso programa de shader padrão:

\iniciocodigo
@<Inicialização de Weaver Metafont@>+=
{
  program = compile_shader_program(vertex_shader, fragment_shader);
  uniform_matrix = glGetUniformLocation(program, "model_view_matrix");
  uniform_texture = glGetUniformLocation(program, "texture1");
}
@
\fimcodigo

Na finalização iremos destruir o programa compilado acima:

\iniciocodigo
@<Finalização de Weaver Metafont@>+=
glDeleteProgram(program);
@
\fimcodigo

Para a parte de renderizar o conteúdo de uma textura para dentro de
outra, devemos criar um framebuffer com uma nova textura associada a
ele. A função abaixo cria tanto um novo framebuffer como uma nova
textura, deixando-os ligados e ativos. Tudo o que for renderizado em
seguida será renderizado na nova textura, e não na tela.

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height){
  glGenFramebuffers(1, new_framebuffer);
  glGenTextures(1, new_texture);
  glBindTexture(GL_TEXTURE_2D, *new_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
               GL_UNSIGNED_BYTE, NULL);
  glBindFramebuffer(GL_FRAMEBUFFER, *new_framebuffer);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                         *new_texture, 0);
  if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: OpenGL cannot create framebuffer!\n");
#endif
    glBindTexture(GL_TEXTURE_2D, 0);
    return false;
  }
  glBindTexture(GL_TEXTURE_2D, 0);
  return true;
}
@
\fimcodigo

Outro código que vamos usar muito e por isso é importante isolar em
uma função é para renderizar uma imagem usando o framebuffer atual e o
programa de shader padrão que fizemos:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background);
// XXX:
void print_picture(struct picture_variable *pic);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background){
  glColorMask(true, true, true, true);
  glViewport(0, 0, dst_width, dst_height);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *) 0);
  glEnableVertexAttribArray(0);
  glUseProgram(program);
  glUniformMatrix4fv(uniform_matrix, 1, true, matrix);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, pic -> texture);
  glUniform1i(uniform_texture, 0);
  if(clear_background){
    // Limpando o destino para branco transparente antes de renderizar:
    glClearColor(1.0, 1.0, 1.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
  }
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBindTexture(GL_TEXTURE_2D, 0);
}
// XXX:
void print_picture(struct picture_variable *pic){
  float model_view_matrix[16] = {1.0, 0.0, 0.0, 0.0,
                               0.0, 1.0, 0.0, 0.0,
                               0.0, 0.0, 1.0, 0.0,
                               0.0, 0.0, 0.0, 1.0};
  GLuint framebuffer;
  GLuint texture;
  unsigned char data[100000];
  get_new_framebuffer(&framebuffer, &texture, pic -> width, pic -> height);
  render_picture(pic, model_view_matrix, pic -> width, pic -> height, true);
  // Ler dados do framebuffer:
  glFinish();
  glReadPixels(0, 0, pic -> width, pic -> height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    int i, j;
    for(i = pic -> width * (pic -> height - 1) * 4;
        i >= 0; i -= (pic -> width * 4)){
      for(j = 0; j < (pic -> width * 4); j += 4)
        printf("(%hu %hu %hu %hu)", (unsigned char) data[i + j], (unsigned char) data[i+j+1], (unsigned char) data[i+j+2], (unsigned char) data[i+j+3]);
        printf("\n");
    }
  }
}
@
\fimcodigo

Agora vamos declarar a função que atribui o conteúdo de uma variável
de imagem à outra, gerando uma nova textura e copiando o conteúdo das
texturas:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source){
  GLuint temporary_framebuffer;
  float model_view_matrix[16] = {1.0, 0.0, 0.0, 0.0,
                               0.0, 1.0, 0.0, 0.0,
                               0.0, 0.0, 1.0, 0.0,
                               0.0, 0.0, 0.0, 1.0};
  if(target -> texture != 0)
    glDeleteTextures(1, &(target -> texture));
  get_new_framebuffer(&temporary_framebuffer, &(target -> texture),
                      source -> width, source -> height);
  render_picture(source, model_view_matrix, source -> width, source -> height, true);
  // Finalizando
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glBindTexture(GL_TEXTURE_2D, 0);
  glDeleteFramebuffers(1, &temporary_framebuffer);
}
@
\fimcodigo

\subsubsecao{8.6.1. Expressões Terciárias de Imagem: Soma e Subtração}

A operação terciária de imagem é a soma e a subtração:

\alinhaverbatim
<Expressão de Imagem> -> <Terciário de Imagem>
<Terciário de Imagem> -> <Terciário de Imagem><Mais ou Menos><Secundário de Imagem>
<Mais ou Menos> -> + | -
\alinhanormal

Imagens então podem ser somadas ou subtraídas. O resultado de
$p_1+p_2$ representa uma nova imagem composta por todos os pixels da
primeira imagem mais os pixels da segunda imagem. Já $p_1-p_2$ são os
pixels da primeira menos os pixels da segunda.  A imagem resultante
sempre terá a largura igual ao maior valor em ambas as imagens e terá
a altura igual ao maior valor em ambas as imagens. A soma dos seus
pixels sempre ocorrerá com ambas as imagens centralizadas uma na
outra.

A função que avalia expressões terciárias de imagem:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct picture_variable *result);
@
\fimcodigo

A implementação da função consiste em identificar o operador $+$ ou o
operador $-$ que estiver mais ao fim da expressão. Se ele não existe,
então devemos avaliar tudo como uma expressão secundária. Se ele
existe, o lado à esquerda dele será avaliado como expressão terciária
e o lado à direita como expressão secundária. E só então fazemos a
soma ou subtração.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct picture_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_SUM || p -> type == TYPE_SUBTRACT) &&
       prev -> type != TYPE_SUM && prev -> type != TYPE_SUBTRACT){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL || before_last_operator == NULL){
    struct picture_variable a;
    struct picture_variable *sec = &a;
    @<Imagem: Avalia Expressão Secundária em 'sec'@>
    return true;
  }
  else{
    struct picture_variable a, b;
    struct picture_variable *sec = &b;
    if(last_operator == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Incomplete picture expression "
                      "ending with '+' or '-'.\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_picture_expression(mf, cx, begin_expression, before_last_operator, &a))
      return false;
    @<Imagem: Avalia Expressão Secundária em 'sec'@>
    @<Expressão de Imagem: Soma ou Subtração@>
    if(a.texture != 0)
      glDeleteTextures(1, &(a.texture));
    if(b.texture != 0)
      glDeleteTextures(1, &(b.texture));
    return true;
  }
}
@
\fimcodigo

Para somar ou subtrair as imagens, devemos primeiro obter qual deve
ser o tamanho da imagem de destino. Ela terá a maior altura e maior
largura dentre as imagens sendo somadas. Em seguida, a criamos e a
inicializamos como sendo uma imagem transparente. Tanto na soma como
na subtração, desenhamos o primeiro operando no destino. Em seguida,
dependendo se estamos realizando soma ou subtração, usamos o OpenGL
para ajustar como as cores serão misturadas. No caso da soma,
ajustamos para que seja feita uma mistura de cores de modo que a nova
cor $(y_R, y_G, y_B, y_A)$ seja multiplicada pelo seu valor alfa e
somada à cor de destino $(x_R, x_G, x_B, x_A)$ multiplicada pelo
complemento do alfa da nova cor:

$$(1-y_A)(x_R, x_G, x_B, x_A) + y_A(y_R, y_G, y_B, y_A)$$

O caso da subtração é mais complexo e para entendê-la, devemos
entender as regras de como representamos nossas texturas com
imagens. Por padrão, assumimos que uma imagem inicializada vazia com
um dado tamanho é toda preenchida por uma cor branca totalmente
transparente (representada pelo vetor RGBA $(1, 1, 1, 0)$). Já quando
escrevemos algo em uma imagem usando canetas ou outro método, usamos
uma tinta preta totalmente opaca (representada pelo vetor RGBA $(0, 0,
0, 1)$). Para nós a cor branca é o zero, a ausência de tinta e a cor
preta é a presença de tinta. O branco é o elemento neutro da
subtração, remover o branco não deve mudar nada. Já remover o preto
remove toda a tinta. Isso é o oposto da representação do branco como 1
e o preto como 0 usada no OpenGL. Por causa disso, a equação de quando
subtraímos uma cor existente $(x_R, x_G, x_B, x_A)$ por uma nova cor
$(y_R, y_G, y_B, y_A)$ é:

$$
(max(x_R, 1-y_R), max(x_G, 1-y_G), max(x_B, 1-y_B), x_A-y_A)
$$

Infelizmente não é possível expressar a equação acima usando apenas o
recurso de ajuste da equação de combinação de cores. O OpenGL ES 3.0 e
OpenGL 4 suporta o uso da função $max$, mas quando a usa, ele ignora
os fatores configurados. O que significa que é possível calcular
$max(x_R, y_R)$, mas não $max(x_R, 1- y_R)$. Essa inversão precisa ser
feita então a nível de shader. O shader de fragmento que inverte uma
cor deixando o alfa intacto é:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char fragment_shader_inverse[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  vec4 texture = texture2D(texture1, texture_coordinate);\n"
  "  gl_FragColor = vec4(1.0 - texture.r, 1.0 - texture.g, 1.0 - texture.b, \n"
  "                      texture.a);\n"
  "}\n";
static GLuint inv_program; // O programa acima compilado
static GLint uniform_inv_texture; // A posição da textura acima
static GLint uniform_inv_matrix; // A posição da matriz do programa acima
@
\fimcodigo

Um novo programa de shader deve ser então compilado na inicialização
para podermos inverter os valores RGB de imagens:

\iniciocodigo
@<Inicialização de Weaver Metafont@>+=
{
  inv_program = compile_shader_program(vertex_shader, fragment_shader_inverse);
  uniform_inv_matrix = glGetUniformLocation(inv_program, "model_view_matrix");
  uniform_inv_texture = glGetUniformLocation(inv_program, "texture1");
}
@
\fimcodigo

E na finalização nós destruimos este programa:

\iniciocodigo
@<Finalização de Weaver Metafont@>+=
glDeleteProgram(inv_program);
@
\fimcodigo

E usando esse novo programa shader para ajudar a inverter valores RGB,
podemos enfim computar a equação de mistura de cores no caso da
subtração:

\iniciocodigo
@<Expressão de Imagem: Soma ou Subtração@>=
// Alocando e declarando dados, gerando imagem vazia inicial
GLuint temporary_framebuffer = 0;
float model_view_matrix[16] = {1.0, 0.0, 0.0, 0.0,
                               0.0, 1.0, 0.0, 0.0,
                               0.0, 0.0, 1.0, 0.0,
                               0.0, 0.0, 0.0, 1.0};
result -> width = ((a.width >= b.width)?(a.width):(b.width));
result -> height = ((a.height >= b.height)?(a.height):(b.height));
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Renderizando imagem 'a'
model_view_matrix[0] = (double) a.width / (double) result -> width;
model_view_matrix[5] = (double) a.height / (double) result -> height;
render_picture(&a, model_view_matrix, result -> width, result -> height, true);
// Renderizando imagem 'b'
model_view_matrix[0] = (double) b.width / (double) result -> width;
model_view_matrix[5] = (double) b.height / (double) result -> height;
if(last_operator -> type == TYPE_SUBTRACT){
  glEnable(GL_BLEND);
  // Os fatores a serem usados na mistura
  glBlendFunc(GL_ONE, GL_ONE);
  // Função 'max' para RGB e subtração para o canal alfa:
  glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  glUseProgram(inv_program);
  glUniformMatrix4fv(uniform_inv_matrix, 1, true, model_view_matrix);
  glUniform1i(uniform_inv_texture, 0);
  glBindTexture(GL_TEXTURE_2D, b.texture);
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBlendEquation(GL_FUNC_ADD);
  glDisable(GL_BLEND);
}
else{ // Soma
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glBlendEquation(GL_FUNC_ADD);
  render_picture(&b, model_view_matrix, result -> width, result -> height, false);
  glDisable(GL_BLEND);
}
// Finalizando
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glBindTexture(GL_TEXTURE_2D, 0);
glDeleteFramebuffers(1, &temporary_framebuffer);
@
\fimcodigo

\subsubsecao{8.6.2. Expressões Secundárias de Imagem: Transformadores}

Uma expressão secundária de imagem tem a seguinte sintaxe:

\alinhaverbatim
<Secundário de Imagem> -> <Primário de Imagem> |
                          <Secundário de Imagem><Transformador>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> |
                   transformed <Primário de Transformação>
\alinhanormal

Os mesmos transformadores que podem ser usados em pares,
transformações, caminhos e canetas podem também ser usados em
imagens. Mas o modo como transformamos as imagens é diferente. Assim
como canetas, as transformações lineares sobre imagens são armazenadas
na forma de uma matriz que acumula todas as transformações. Desta
forma, podemos realizar as transformações de uma só vez somente depois
que o usuário especificar todas as que serão necessárias. Mas ao
contrário de canetas, as variáveis de imagem não possuem uma matriz
própria armazenada na variável.

As matrizes são recursos que irão existir somente enquanto estivermos
avaliando expressões secundárias de imagem. E serão efetivamente
usadas para transformar a imagem somente ao terminarmos a avaliação de
uma expressão tercisária. Desta forma, no código abaixo:

\alinhaverbatim
a = img totated 45 slanted 0.2 zscaled(2, 3)
\alinhanormal

Ao invés de realizarmos três transformações diferentes, nós apenas
acumularemos as transformações em uma matriz. Já quando não houver
mais transformação e estivermos terminando de interpretar a expressão
terciária, é quando usaremos a matriz para efetivamente transformar a
imagem em sua forma final. Isso significa que a função que avaliará as
expressões secundárias de imagem deverá ser diferente das demais. Ela
irá receber dois argumentos adicionais: uma matriz pré-inicializada
como a matriz identidade e um ponteiro para uma variável booleana
pré-inicializada como falso. Esta variável será mudada para verdadeira
somente se a matriz passada for modificada.

\iniciocodigo
@<Imagem: Avalia Expressão Secundária em 'sec'@>=
{
  float matrix[16];
  int i;
  bool modified = false;
  for(i = 0; i < 16; i ++)
    if(i % 5 == 0)
      matrix[i] = 1.0;
    else
      matrix[i] = 0.0;//)
  if(last_operator == NULL){
     if(!eval_picture_secondary(mf, cx, begin_expression, end_expression, sec,
                             matrix, &modified))
      return false;
  }
  else if(!eval_picture_secondary(mf, cx, last_operator -> next,
                                  end_expression, sec, matrix, &modified))
    return false;
  if(modified){
    if(!apply_image_transformation(mf, result, sec, matrix))
      return false;
    if(sec -> texture != 0)
      glDeleteTextures(1, &(sec -> texture));
  }
  else{
    result -> width = sec -> width;
    result -> height = sec -> height;
    result -> texture = sec -> texture;
  }
}
@
\fimcodigo

A declaração da função que avalia expressões secundárias de imagem é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct picture_variable *result,
                            float *matrix, bool *modified);
@
\fimcodigo

E a sua implementação consiste primeiramente em percorrermos toda a
expressão até achar o último token com um operador secundário de
transformação. Se não achamos nada, é só avaliar tudo como expressão
primária. Se achamos um, avaliamos tudo antes dele como expressão
secundária e aplicamos a transformação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct picture_variable *result,
                            float *matrix, bool *modified){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_picture_primary(mf, cx, begin_expression, end_expression, result);
  else{
    if(!eval_picture_secondary(mf, cx, begin_expression,
                               before_last_transformer, result, matrix, modified))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Secundário de Imagem: Rotação@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Secundário de Imagem: Escala@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Secundário de Imagem: Deslocamento@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Secundário de Imagem: Inclinação@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Secundário de Imagem: X-Escala@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Secundário de Imagem: Y-Escala@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Secundário de Imagem: Z-Escala@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Secundário de Imagem: Transformação Genérica@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Avaliar cada um dos diferentes tipos de transformadores significa
modificar a matriz multiplicando ela pela matriz que representa a
transformação. Exatamente como fizemos com as canetas. Conforme visto
na subseção 8.4.2, fazer mudança de escala fazendo a imagem ser
ampliada multiplicando suas dimensões por $x$ é feito multiplicando
pela matriz abaixo:


$$\left[{{x \atop 0}\atop {0\atop
      0}}{{0 \atop x}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
$$

Que é o que o código abaixo faz com a matriz da expressão secundária:

\iniciocodigo
@<Secundário de Imagem: Escala@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, matrix, 16 * sizeof(float));
matrix[0] = temp_matrix[0] * a.value;
matrix[1] = temp_matrix[1] * a.value;
matrix[4] = temp_matrix[4] * a.value;
matrix[5] = temp_matrix[5] * a.value;
matrix[8] = temp_matrix[8] * a.value;
matrix[9] = temp_matrix[9] * a.value;
matrix[12] = temp_matrix[12] * a.value;
matrix[13] = temp_matrix[13] * a.value;
*modified = true;
return true;
@
\fimcodigo

Já para rotacionar uma imagem um ângulo $\theta$, multiplicamos sua
matriz pela vista abaixo:

$$\left[{{cos(\theta) \atop -\sin(\theta)}\atop
      {0\atop 0}}{{sin(\theta) \atop cos(\theta)}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
$$

Como na matriz acima o ângulo é em radianos, também devemos fazer uma
conversão, já que para Weaver Metafont, ângulos são apresentados em
graus. E assim obtemos o código abaixo que multiplica a matriz das
expressões secundárias pela matriz de rotação:

\iniciocodigo
@<Secundário de Imagem: Rotação@>=
struct numeric_variable r;
float temp_matrix[16];
double rotation, cos_theta, sin_theta;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
sin_theta = sin(rotation);
cos_theta = cos(rotation);
memcpy(temp_matrix, matrix, 16 * sizeof(float));
matrix[0] = temp_matrix[0] * cos_theta - temp_matrix[1] * sin_theta;
matrix[1] = temp_matrix[0] * sin_theta + temp_matrix[1] * cos_theta;
matrix[4] = temp_matrix[4] * cos_theta - temp_matrix[5] * sin_theta;
matrix[5] = temp_matrix[4] * sin_theta + temp_matrix[5] * cos_theta;
matrix[8] = temp_matrix[8] * cos_theta - temp_matrix[9] * sin_theta;
matrix[9] = temp_matrix[8] * sin_theta + temp_matrix[9] * cos_theta;
matrix[12] = temp_matrix[12] * cos_theta - temp_matrix[13] * sin_theta;
matrix[13] = temp_matrix[12] * sin_theta + temp_matrix[13] * cos_theta;
*modified = true;
return true;
@
\fimcodigo

Deslocar a imagem uma coordenada $(x, y)$ é feito multiplicando pela
matriz abaixo:

$$\left[{{1 \atop 0}\atop {0\atop
   x}}{{0 \atop 1}\atop {0 \atop y}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
$$

Então multiplicamos a matriz de expressão secundária pela matriz acima
com o código abaixo:

\iniciocodigo
@<Secundário de Imagem: Deslocamento@>=
struct pair_variable p;
float temp_matrix[16];
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
memcpy(temp_matrix, matrix, 16 * sizeof(float));
p.x = 2.0 * (p.x / result -> width);
p.y = 2.0 * (p.y / result -> height);
matrix[0] = temp_matrix[0] + temp_matrix[3] * p.x;
matrix[1] = temp_matrix[1] + temp_matrix[3] * p.y;
matrix[4] = temp_matrix[4] + temp_matrix[7] * p.x;
matrix[5] = temp_matrix[5] + temp_matrix[7] * p.y;
matrix[8] = temp_matrix[8] + temp_matrix[11] * p.x;
matrix[9] = temp_matrix[8] + temp_matrix[11] * p.y;
matrix[12] = temp_matrix[12] + temp_matrix[15] * p.x;
matrix[13] = temp_matrix[12] + temp_matrix[15] * p.y;
*modified = true;
return true;
@
\fimcodigo

Inclinar a imagem com intensidade $x$ é feito multiplicando pela
matriz:

$$\left[{{1 \atop x}\atop {0\atop
      0}}{{0 \atop 1}\atop {0 \atop 1}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
$$

O que é obtido pelo código abaixo:

\iniciocodigo
@<Secundário de Imagem: Inclinação@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, matrix, 16 * sizeof(float));
matrix[0] = temp_matrix[0] + a.value * temp_matrix[1];
matrix[4] = temp_matrix[4] + a.value * temp_matrix[5];
matrix[8] = temp_matrix[8] + a.value * temp_matrix[9];
matrix[12] = temp_matrix[12] + a.value  * temp_matrix[13];
*modified = true;
return true;
@
\fimcodigo

Mudança de escala só no eixo $x$ é feito multiplicando pela matriz:

$$\left[{{a \atop 0}\atop {0\atop
      0}}{{0 \atop 1}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
$$

E para isso usamos o código abaixo:

o\iniciocodigo
@<Secundário de Imagem: X-Escala@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, matrix, 16 * sizeof(float));
matrix[0] = temp_matrix[0] * a.value;
matrix[4] = temp_matrix[4] * a.value;
matrix[8] = temp_matrix[8] * a.value;
matrix[12] = temp_matrix[12] * a.value;
*modified = true;
return true;
@
\fimcodigo

Quando é só no eixo $y$, a matriz a ser multiplicada é:

$$\left[{{1 \atop 0}\atop {0\atop
      0}}{{0 \atop a}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
$$

Como é feito no código abaixo:

\iniciocodigo
@<Secundário de Imagem: Y-Escala@>=
struct numeric_variable a;
float temp_matrix[16];
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
memcpy(temp_matrix, matrix, 16 * sizeof(float));
matrix[1] = temp_matrix[1] * a.value;
matrix[5] = temp_matrix[5] * a.value;
matrix[9] = temp_matrix[9] * a.value;
matrix[13] = temp_matrix[13] * a.value;
*modified = true;
return true;
@
\fimcodigo

Já a  mudança de escala $z$ é representada pela multiplicação
pela matriz:

$$\left[{{a \atop -b}\atop {0\atop
      0}}{{b \atop a}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
$$

O que requer o código abaixo:

\iniciocodigo
@<Secundário de Imagem: Z-Escala@>=
struct pair_variable p;
float temp_matrix[16];
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
memcpy(temp_matrix, matrix, 16 * sizeof(float));
matrix[0] = temp_matrix[0] * p.x - temp_matrix[1] * p.y;
matrix[1] = temp_matrix[0] * p.y + temp_matrix[1] * p.x;
matrix[4] = temp_matrix[4] * p.x - temp_matrix[5] * p.y;
matrix[5] = temp_matrix[4] * p.y + temp_matrix[5] * p.x;
matrix[8] = temp_matrix[8] * p.x - temp_matrix[9] * p.y;
matrix[9] = temp_matrix[8] * p.y + temp_matrix[9] * p.x;
matrix[12] = temp_matrix[12] * p.x - temp_matrix[13] * p.y;
matrix[13] = temp_matrix[12] * p.y + temp_matrix[13] * p.x;
*modified = true;
return true;
@
\fimcodigo

Finalmente, a transformação genérica $(a, b, c, d, e, f)$ é
representada pela matriz;

$$\left[{{c \atop c}\atop {0\atop
      a}}{{e \atop f}\atop {0 \atop b}}{{0\atop 0}\atop{1 \atop
      0}}{{0 \atop 0}\atop{0\atop 1}}\right]
$$

Então para multiplicar a matriz existente pela transformação, usamos o
código abaixo:

\iniciocodigo
@<Secundário de Imagem: Transformação Genérica@>=
struct transform_variable t;
float temp_matrix[16];
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression,
                           &t))
  return false;
memcpy(temp_matrix, matrix, 16 * sizeof(float));
matrix[0] = temp_matrix[0] * t.value[2] + temp_matrix[1] * t.value[3] +
            t.value[0];
matrix[1] = temp_matrix[0] * t.value[4] + temp_matrix[1] * t.value[5] +
            t.value[1];
matrix[4] = temp_matrix[4] * t.value[2] + temp_matrix[5] * t.value[3] +
            t.value[0];
matrix[5] = temp_matrix[4] * t.value[4] + temp_matrix[5] * t.value[5] +
            t.value[1];
matrix[12] = temp_matrix[12] * t.value[2] + temp_matrix[13] * t.value[3] +
             t.value[0];
matrix[13] = temp_matrix[12] * t.value[4] + temp_matrix[13] * t.value[5] +
             t.value[1];
*modified = true;
return true;
@
\fimcodigo

Agora resta definir como iremos aplicar as transformações lineares
sobre uma imagem uma vez que tenhamos a matriz, a variável de imagem
de origem e a de destino. Isso é feito com ajuda da seguinte função
auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix);
@
\fimcodigo

Aplicar a transformação da imagem envolve usar a matriz de
transformação obtida para transformar a imagem de origem gerando assim
a nova imagem de destino. Para isso aplicamos as seguintes etapas:

1) Devemos descobrir qual deve ser o tamanho em pixels da imagem de
destino. Para isso, multiplicamos as coordenadas da origem pela
matriz. Mas neste caso, medidmos tais coordenadas por pixels, não
pelas coordenadas OpenGL. Se a imagem de origem é um quadrado de 5
pixels de lado, um de seus vértices será $(-5/2, -5/2)$ e outro será
$(5/2, 5/2)$. O resultado da transformação serão as coordenadas dos
vértices medidos por pixels, à partir das quais obtemos o tamanho em
pixels. Nesta etapa, podemos ignorar a translação presente na matriz.

2) Para levar em conta a translação, devemos somar o dobro da
distância em píxels da translação ao tamanho da imagem. Lembre-se que a
translação não muda o centro da imagem. Então, ao deslocar $(1, 1)$
uma imagem com um píxel preto $1\times 1$, geramos nova imagem de
$3\times 3$ com o píxel preto no canto. O centro da imagem continua
sendo a posição em que o píxel preto estava antes do deslocamento.

3) A mudança de tamanho do desenho da imagem original será obtida
simplesmente renderizando o desenho transformado em uma imagem de
destino ou menor. Então devemos remover da matriz de transformação a
mudança de tamanho e escala que estiver presente. Também devemos
ajustar levando em conta isso qualquer translação sendo feita. Isso é
feito aplicando um valor calculado de correção para as posições $x$ e
$y$ da matriz.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix){
  int i;
  GLuint temporary_framebuffer = 0;
  // Para calcular o tamanho final da imagem, armazenaremos as maiores e
  // menores coordenadas que encontrarmos nas extremidades da imagem
  // nos dois eixos após aplicar a matriz de transformação. (Etapa 1)
  float min_x = INFINITY, min_y = INFINITY, max_x = -INFINITY, max_y = -INFINITY;
  float origin_coordinates[8];
  origin_coordinates[0] = -((float) origin -> width) / 2.0;
  origin_coordinates[1] = -((float) origin -> height) / 2.0;
  origin_coordinates[2] = ((float) origin -> width) / 2.0;
  origin_coordinates[3] = -((float) origin -> height) / 2.0;
  origin_coordinates[4] = ((float) origin -> width) / 2.0;
  origin_coordinates[5] = ((float) origin -> height) / 2.0;
  origin_coordinates[6] = -((float) origin -> width) / 2.0;
  origin_coordinates[7] = ((float) origin -> height) / 2.0;
  for(i = 0; i < 8; i += 2){
    float x = origin_coordinates[i] * matrix[0] +
              origin_coordinates[i + 1] * matrix[4];
    float y = origin_coordinates[i] * matrix[1] +
              origin_coordinates[i + 1] * matrix[5];
    if(x > max_x) max_x = x;
    if(x < min_x) min_x = x;
    if(y > max_y) max_y = y;
    if(y < min_y) min_y = y;
  }
  // Ajuste de tamanho da imagem final devido ao deslocamento (Etapa 2)
  dst -> width = (int) (max_x - min_x) +
                 (int) (origin -> width * matrix[12]);
  dst -> height = (int) (max_y - min_y) +
                  (int) (origin -> height * matrix[13]);
  // Ajustando escala e translação da imagem final levando em conta novo tamanho
  // do destino (Etapa 3):
  {
    double x_correction = ((double) origin -> width) / (double) dst -> width;
    double y_correction = ((double) origin -> height) / (double) dst -> height;
    matrix[0] = matrix[0] * x_correction;
    matrix[4] = matrix[4] * x_correction;
    matrix[8] = matrix[8] * x_correction;
    matrix[12] = matrix[12] * x_correction;
    matrix[1] = matrix[1] * y_correction;
    matrix[5] = matrix[5] * y_correction;
    matrix[9] = matrix[9] * y_correction;
    matrix[13] = matrix[13] * y_correction;
  }
  //printf("\nDEBUG:\n%f %f %f %f\n%f %f %f %f\n%f %f %f %f\n%f %f %f %f\n",
  //matrix[0], matrix[1], matrix[2], matrix[3], matrix[4],
  //matrix[5], matrix[6], matrix[7], matrix[8], matrix[9],
  //matrix[10], matrix[11], matrix[12], matrix[13], matrix[14],
  //matrix[15]);
  // Gerando textura inicial, framebuffer
  get_new_framebuffer(&temporary_framebuffer, &(dst -> texture), dst -> width,
                    dst -> height);
  // Renderizando:
  render_picture(origin, matrix, dst -> width, dst -> height, true);
  // Finalização
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.3. Expressões Primárias de Imagem: Inversores, Identidade e Imagens Vazias}

Segundo a gramática da linguagem, a sintaxe para expressões primárias
de imagens é:

\alinhaverbatim
<Primário de Imagem> -> <Variável de Imagem> |
                        nullpicture <Primário de Par> |
                        ( <Expressão de Imagem> ) |
                        <Mais ou Menos> <Primário de Imagem>
\alinhanormal

Isso requer registrar ``nullpicture'' como um token:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_NULLPICTURE        74 // O token simbólico 'nullpicture'
@
\fimcodigo

E requer que essa string seja adicionada à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"nullpicture",
@
\fimcodigo

A função que irá interpretar expressões primárias de imagem é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct picture_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct picture_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Imagem Primária: Variável@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Imagem Primária: Parênteses@>
    }
    else if(begin_expression -> type == TYPE_NULLPICTURE){
      @<Imagem Primária: Imagem em Branco@>
    }
    else if(begin_expression -> type == TYPE_SUM){
      @<Imagem Primária: Identidade@>
    }
    else if(begin_expression -> type == TYPE_SUBTRACT){
      @<Imagem Primária: Inverso@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O primeiro caso de expressão primária de imagem é ler uma imagem de
uma variável. Isso envolve copiar o conteúdo da variável armazenada no
resultado da avaliação.

\iniciocodigo
@<Imagem Primária: Variável@>=
GLuint temporary_framebuffer = 0;
float identity_matrix[16] = {1.0, 0.0, 0.0, 0.0,
                             0.0, 1.0, 0.0, 0.0,
                             0.0, 0.0, 1.0, 0.0,
                             0.0, 0.0, 0.0, 1.0};
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct picture_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PICTURE){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-picture variable (%d) in "
                  "picture expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
// Preparar renderização:
result -> width = content -> width;
result -> height = content -> height;
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Renderiza:
render_picture(content, identity_matrix, result -> width, result -> height, true);
// Finaliza:
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

Lidar com os parênteses envolve percorrer os tokens até encontrar o
último token antes do fechar de parênteses. E avaliar como uma nova
expressão de imagem tudo aquilo que estiver entre o parênteses inicial
e o final:

\iniciocodigo
@<Imagem Primária: Parênteses@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_picture_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

A próxima expressão primária é a criação de uma imagem em branco com
um dado tamanho. Isso ocorre quando lemos um
token \monoespaco{nullpicture} seguido de um par primário. Criar a
imagem vazia envolve primeiro interpretar o par primário que contém o
seu tamanho e em seguida criar uma textura vazia com tal tamanho.

\iniciocodigo
@<Imagem Primária: Imagem em Branco@>=
struct generic_token *begin_pair_expression, *end_pair_expression;
struct pair_variable p;
unsigned char *data;
begin_pair_expression = begin_expression -> next;
end_pair_expression = end_expression;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing pair expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_primary(mf, cx, begin_pair_expression, end_pair_expression, &p))
  return false;
result -> width = p.x;
result -> height = p.y;
data = temporary_alloc(p.x * p.y * 4);
if(data == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
  return false;
}
// Pintando a nova textura de branco
memset(data, 255, result -> width * result -> height * 4);
{ // E deixando ela totalmente transparente:
  int i, size = result -> width * result -> height * 4;
  for(i = 3; i < size; i += 4)
    data[i] = 0;
}
glGenTextures(1, &(result -> texture));
glBindTexture(GL_TEXTURE_2D, result -> texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, result -> width, result -> height, 0,
             GL_RGBA, GL_UNSIGNED_BYTE, data);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glBindTexture(GL_TEXTURE_2D, 0);
if(temporary_free != NULL)
  temporary_free(data);
return true;
@
\fimcodigo

E agora o penúltimo caso de imagem primária: quando vem um
token \monoespaco{+} antes de uma imagem. Neste caso o operador não faz
nada, é um operador de identidade para imagens. Então só precisamos
ignorar ele e avaliar os tokens restantes:

\iniciocodigo
@<Imagem Primária: Identidade@>=
struct generic_token *p = begin_expression -> next;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing image expression "
                  "after '+'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
return eval_picture_primary(mf, cx, p, end_expression, result);
@
\fimcodigo

Para o operador \monoespaco{-} que é usado para inverter uma imagem,
nós iremos novamente renderizar ativando a equação de mistura de
cores, mas fazendo com que a nova cor seja obtida usando $(1, 1, 1,
1)$ como a cor atural e subtraindo disso a nova cor. Isso é obtido
tratando os fatores de mistura como 1 (GL\_ONE) e usando a subtração
como operador (GL\_FUNC\_SUBTRACT):


\iniciocodigo
@<Imagem Primária: Inverso@>=
struct picture_variable p;
GLuint temporary_framebuffer = 0;
float identity_matrix[16] = {1.0, 0.0, 0.0, 0.0,
                             0.0, 1.0, 0.0, 0.0,
                             0.0, 0.0, 1.0, 0.0,
                             0.0, 0.0, 0.0, 1.0};
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                  "'-'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_picture_primary(mf, cx, begin_expression -> next, end_expression, &p))
  return false;
// Preparar renderização:
result -> width = p.width;
result -> height = p.height;
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Inicializar nova textura com branco opaco (1, 1, 1, 1)
glClearColor(1.0, 1.0, 1.0, 1.0);
glClear(GL_COLOR_BUFFER_BIT);
// Ajustar equação de mistura pra subtrair ela do branco opaco:
glEnable(GL_BLEND);
glBlendFuncSeparate(GL_ONE, GL_ONE, GL_ONE, GL_ONE);
glBlendEquationSeparate(GL_FUNC_REVERSE_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT);
// Renderiza:
render_picture(&p, identity_matrix, result -> width, result -> height, false);
// Finaliza:
glDisable(GL_BLEND);
glDeleteTextures(1, &(p.texture));
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

\subsubsecao{8.6.4. Imagens em Expressões Numéricas}

Há um caso no qual precisamos avaliar uma expressão de imagem dentro
de uma expressão numérica. Há uma expressão primária numérica
adicional:

\alinhaverbatim
<Primário Numérico> -> totalweight <Primário de Imagem>
\alinhanormal

O que o operador \monoespaco{totalweight} faz é avaliar uma expressão
de imagem, ler a imagem obtida e retornar a soma do ``peso'' de cada
pixel. O peso de um pixel branco transparente deve ser zero e o de um
pixelpreto opaco deve ser 1. Já para calcular valores intermediários,
converteremos um pixel colorido para um tom de cinza. Para isso
obteremos uma média ponderada entre os valores entre 0 e 1 deles,
dando um peso maior para o verde e menor para o azul. Isso porque a
visão humana é mais sensível ao verde que ao azul. O resultado desta
média sera o peso do píxel colorido. Depois de obter o valor,
multiplicamos pela transparência.

Primeiro vamos adicionar um novo tipo de token para esse operador:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_TOTALWEIGHT        75 // O token simbólico 'totalweight'
@
\fimcodigo

E adicionamos seu nome à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"totalweight",
@
\fimcodigo

O modo pelo qual iremos obter os pixels de uma textura será
renderizando ela para um framebuffer e lendo
usando \monoespaco{glReadPixels} para obter o conteúdo do framebuffer:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type == TYPE_TOTALWEIGHT){
  struct picture_variable p;
  char *data;
  GLuint temporary_framebuffer = 0;
  GLuint temporary_texture = 0;
  float identity_matrix[16] = {1.0, 0.0, 0.0, 0.0,
                               0.0, 1.0, 0.0, 0.0,
                               0.0, 0.0, 1.0, 0.0,
                               0.0, 0.0, 0.0, 1.0};
  if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'totalweight'.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &p))
    return false;
  data = temporary_alloc(p.width * p.height * 4);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Not enough memory!\n", mf -> file);
#endif
    return false;
  }
  get_new_framebuffer(&temporary_framebuffer, &(temporary_texture),
                    p.width, p.height);
  // Renderiza:
  render_picture(&p, identity_matrix, p.width, p.height, true);
  // Ler dados do framebuffer:
  glReadPixels(0, 0, p.width, p.height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    //printf("--WEIGHT---\n");
    int i, size = p.width * p.height * 4;
    double sum = 0.0;
    for(i = 0; i < size; i += 4){
      //if(i%(4*p.width) == 0) printf("\n");
      //printf("(%d %d %d %d)", (unsigned char) data[i], (unsigned char) data[i+1], (unsigned char) data[i+2], (unsigned char) data[i+3]);
      // If the values are equal, let's avoid rounding errors:
      if(data[i] == data[i+1] && data[i+1] == data[i+2]){
        sum += ((255 - (unsigned char) data[i]) / 255.0) *
               (((unsigned char) data[i+3]) / 255.0);
      }
      else{
        double r = ((255 - (unsigned char) data[i]) / 255.0) * 0.2989,
               g = ((255 - (unsigned char) data[i+1]) / 255.0) * 0.5870,
               b = ((255 - (unsigned char) data[i+2]) / 255.0) * 0.1140,
               a = ((unsigned char) data[i+3]) / 255.0;
        sum += ((r+g+b) * a);
      }
    }
    result -> value = sum;
  }
  // Finalização:
  if(temporary_free != NULL)
    temporary_free(data);
  glDeleteTextures(1, &temporary_texture);
  glDeleteTextures(1, &(p.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsecao{8.7. Atribuições e Expressões Booleanas}

\secao{Referências}



\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim






