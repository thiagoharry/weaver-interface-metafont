% To test path expressions
% This program should work and be accepted.

path p1, p2, p3, p4, p5, p6, p7, p8, p9, p10;
path quartercircle, halfcircle, fullcircle;
path unitsquare;
path a, b, c, d, e, f, g, h, i, j, k, l;
numeric n;
pair q, r, s;
path m, m1, m2, m3;

p1 = (1, 5);
p2 = p1;
p3 = reverse p1;
p4 = subpath (-10, 8) of p3;
p9 = p5 = (1, 5) / 2;
p6 = f = 2 * (1, 5);
p7 = (1, 0) rotated 90;
p8 = (1, 5) - (0, 4);
p9 = p1 .. controls (1, 3)  .. p8;
% This test if direction specifiers are correctly read, even if they
% are not used:
p10 = (p1{1, 8} .. controls (1, 3)  .. p8){2, 3};
quartercircle =
  (0.5, 0)
  .. controls (0.5, 0.13261) and (0.44733, 0.2598) ..
  (0.35356, 0.35356)
  .. controls (0.2598, 0.44733) and (0.13261, 0.5) ..
  (0, 0.5);
halfcircle = quartercircle & quartercircle rotated 90; %  DEBUG: ERROR
fullcircle = halfcircle & halfcircle rotated 180 & cycle;
unitsquare = (0, 0)--(1, 0)--(1, 1)--(0, 1)--cycle;
a = (0, 0){(1, 0)} .. {(0, 1)} (10, 10);
b = (0, 0){(1, 0)} ..{(0, 1)}(2, 2) ..{(1,0)}(3, 2) .. cycle;
d = (0, 0) .. (2, 2){(0, 1)} ..{(1,0)}(3, 2) .. {(1, 0)}cycle;
c = (0, 0) .. (2, 2) .. controls (3, 4) and (2, 3) .. cycle;
e = (0, 0) .. controls (3, 4) and (2, 3) .. (2, 2) .. cycle;
f = (0, 0){(1, 0)} .. tension 0.75 and 4 .. {(0, 1)}(2, 2);

% This is expected to produce (0,0)..controls(-0.11848,0.59238)and(-0.2,1)..(0,1);
% Or without 'atleast': (0,0)..controls(-0.11848,0.59238)and(-0.5875,1)..(0,1);
g = (0, 0){(-1, 5)} .. tension atleast 0.75 .. {(5, 0)}(0, 1);

h = reverse halfcircle;
i = subpath (-2, 5) of g; % This makes i = g
j = subpath (-1, 3) of e; % Erases cyclic nature, creates bigger path
k = subpath (10, -15) of halfcircle; % Generates 'reverse halfcircle'
l = subpath (1, 3) of halfcircle;
n = length fullcircle;
q = point 666 of fullcircle;
r = precontrol 666 of halfcircle;
s = postcontrol 1 of halfcircle;
m = unitsquare transformed (3, 4, 5, 6, 7, 8);
m1 = (0, 0)..(3, 3);
m2 = (0, 0){curl 1}..{curl 2}(3, 3);
m3 = (0, 0){1, 0} .. {curl 1.5}(3, 3);
