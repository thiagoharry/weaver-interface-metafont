\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Usuário Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém uma implementação de um interpretador para
 uma linguagem baseada no METAFONT. Esta linguagem é projetada para
 permitir a definição de fontes tipográficas flexíveis e
 parametrizadas que podem ser interpretadas e renderizadas rapidamente
 à medida que são lidas. Por causa disso, nós sacrificamos alguma
 flexibilidade da linguagem METAFONT original para sermos capazes de
 criar resultados mais rápidos. A implementação será usada pelo Motor
 de Jogos Weaver como um módulo e usará OpenGL moderno para renderizar
 as fontes.}

\secao{1. Introdução}

A linguagem METAFONT original é uma linguagem feita para descrever
fontes tipográficas. Ela foi criada em 1984 por Donald Knuth e difere
de outros formatos de fontes tipográficas por permitir a criação de
fontes à partir da modificação de parâmetros definidos na descrição
básica da fonte. Desta forma, o projetista de uma fonte não deve criar
uma simples fonte tipográfica, mas uma meta-fonte, a qual pode por sua
vez gerar muitas outras fontes tipográficas diferentes mediante a
simples modificação dos parâmetros.

A especificação original da linguagem METAFONT pode ser encontrada em
[KNUTH, 1989], mas a implementação aqui não será compatível com a
linguagem original. Ao invés disso uma nova linguagem será definida,
mas ela terá objetivos similares.

Como este artigo define um subsistema do Motor de Jogos Weaver, e mais
especificamente um subsistema de interface de usuário, nosso objetivo
aqui será definir a seguinte função que irá interpretar um arquivo com
código METAFONT e irá gerar uma interface de usuário com as letrar
lidas como textura:

\iniciocodigo
@<Declaração de Função (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
@
\fimcodigo

E nós precisamos inserir o cabeçalho Weaver de interface de usuário:

\iniciociodigo
@<Inclui Cabeçalhos Gerais (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

Mas além de simplesmente carregar as fontes tipográficas lidas para um
arquivo, é importante poder gerar também uma estrutura de dados
representando a fonte lida, para que ela depois possa ser usada por
uma função que renderiza texto:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Antes de chamar qualquer uma das funções acima, será importante chamar
a seguinte função de inicialização que especifica ãlgumas das funções
que devem ser usadas, e além disso nos informa quantos píxels
correspontem à unidade de medida de ``1pt'':

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
void Winit_metafont(void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *),
                    void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    uint64_t (*rand)(void), int pt);
@
\fimcodigo

As funções passadas como argumento para tal inicializador são
respectivamente uma para fazer alocações temporárias de memória, outra
para desalocar o que foi alocado com ela (pode ser NULL), outra para
fazer alocações mais permanentes, outra para desalocar o que foi
alocado com ela (pode ser NULL também), uma para gerar 64 bits
aleatórios e por fim a medida de quantos píxels correspondem a 1pt.


\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{metafont.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
#if !defined(_WIN32)
#include <sys/param.h> // Necessário no BSD, mas causa problema no Windows
#endif
@<Inclui Cabeçalhos Gerais (metafont.h)@>
//@<Macros Gerais (metafont.h)@>
@<Estrutura de Dados (metafont.h)@>
@<Declaração de Função (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
/@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (metafont.h)'', o mesmo nome apresentado no
trecho de código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{metafont.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Cabeçalhos Locais (metafont.c)@>
//@<Macros Locais (metafont.c)@>
@<Estrutura de Dados Locais (metafont.c)@>
@<Variáveis Locais (metafont.c)@>
@<Declaração de Função Local (metafont.c)@>
@<Funções Auxiliares Locais (metafont.c)@>
@<Definição de Funções da API (metafont.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{2. Inicialização}

Primeiro vamos definir a função de inicialização. O que ela fará será
armazenar em uma série de variáveis estáticas várias das funções que
iremos usar no programa, além de nos informar quantos píxels
correspondem a 1 pt. As variáveis que armazenarão tais informações são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

E a função de inicialização consiste em preencher tais variáveis:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>=
void Winit_metafont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
}
@
\fimcodigo

\secao{3. Analisador Léxico}

A primeira coisa a criar para uma linguagem é seu analisador
léxico. Ele irá ler o código-fonte da linguagem presente em um arquivo
e irágerar uma lista de ``tokens'', sendo cada token a unidade mais
básica da linguagem, basicamente uma palavra.

METAFONT reconhece três tipos de tokens: numéricos, strings e
simbólicos. Na prática nós iremos dividir os tokens simbólicos em
diferentes tipos de subtokens para podermos armazená-los e lê-los de
maneira mais eficiente.

Um token numérico será representado internamente como um número em
ponto flutuante. Nisso iremos diferir do METAFONT original que usava
uma representação própria de números. Em nome de operações mais
rápidas, usaremos a forma moderna de representar números. Então essa é
a aparência de um token numérico:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>=
#define TYPE_NUMERIC 1
struct numeric_token{
  int type;   // Deve ser igual a 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

E isso é como representaremos tokens de strings:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_STRING 2
struct string_token{
  int type;   // Deve ser igual a 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

Nós iremos armazenar apenas os primeiros 5 bytes de cada string que
encontrarmos, mesmo que no código-fonte a string seja maior. Isso será
feito porque ao contrário do METAFONT original, a única utilidade para
strings aqui será indicar qual caractere Unicode deve estar associado
a cada glifo definido. Para isso nós precisamos de apenas 5 bytes (no
máximo 4 para o caractere mais o byte 0 final). E também podemos usar
eles para associar certos glifos a ligaduras como ``ff'', que também
cabe em 5 bytes.

Já no caso de tokens simbólicos, precisamos armazenar todo o seu
conteúdo para podermos saber qual token temos, e vamos alocar
dinamicamente de acordo com o tamanho do símbolo:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_SYMBOLIC 3
struct symbolic_token{
  int type;   // Deve ser igual a 'TYPE_SYMBOLIC'
  void *next, *var;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char *value;
};
@
\fimcodigo

Também colocamos neste token o ponteiro \monoespaco{var}, já que ele
pode corresponder a uma variável, e por isso pode precisar apontar
para a região da memória com o conteúdo da variável.

Mas isso pode consumir mais espaço na memória do que é
necessário. Alguns símbolos são muito comuns e são definidos por
padrão na própria linguagem e podem usar menos espaço que isso. Por
exemplo, parênteses e vírgulas. Podemos representar eles com a
seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_OPEN_PARENTHESIS  4 // '('
#define TYPE_CLOSE_PARENTHESIS 5 // ')'
#define TYPE_COMMA             6 // ','
#define TYPE_SEMICOLON         7 // ';'
@<METAFONT: Definição de Token Simbólico@>
// (...)
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

Podemos definir posteriormente muitos outros tipos de tokens
simbólicos reservados. Basta definirmos eles associando a um número
único maior do que 6. Qualquer token cujo tipo é um número igual ou
maior que 3 é simbólico.

Todo token possui um ponteiro para um próximo token. Isso ocorre
porque eles geralmente formarão uma lista encadeada de tokens. Para
desalocar a memória ocupada por uma lista de tokens dada uma função de
desalocação e apagá-los, pode-se usar a seguinte função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Agora a função que fará a análise léxica. Ela receberá como argumento
uma função de alocação de memória e uma string com caminho para
arquivo com código-fonte METAFONT. Ela retornará uma lista encadeada
de tokens:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void *lexer(void *(*alloc)(size_t), void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Análise Léxica: Regra 1@>
    @<Análise Léxica: Regra 2@>
    @<Análise Léxica: Regra 3@>
    @<Análise Léxica: Regra 4@>
    @<Análise Léxica: Regra 5@>
    @<Análise Léxica: Regra 6@>
    // Nenhuma regra aplicada: erro
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  return first_token;
}
@
\fimcodigo

Oh, como usamos o tipo \monoespaco{FILE}, precisamos inserir o
cabeçalho de entrada e saída padrão para podermos abrir e ler
arquivos:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

As regras para ler os tokens consiste em ler cada linha do código
fonte aplicando as seguintes regras para cada novo caractere lido:

1) Se o próximo caractere é um espaço ou um ponto que não é sucedido
por um dígito decimal ou um novo ponto, ignore-o e siga em frente.

\iniciocodigo
@<Análise Léxica: Regra 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

Como estamos usando a função \monoespaco{isdigit}, devemos inserir o
seguinte cabeçalho que a declara:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) Se o próximo caractere é o símbolo de porcentagem, ignore-o e
ignore todos os outros caracteres seguintes na linha. Este símbolo
marca o começo de comentários na linguagem.

\iniciocodigo
@<Análise Léxica: Regra 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) Se o próximo caractere é um dígito decimal ou um ponto seguido por
um dígito decimal, então o próximo token será numérico. E é formado
pela maior sequência possível de ser lida envolvendo dígitos decimais
e opcionalmente um único ponto representando o ponto decimal.

\iniciocodigo
@<Análise Léxica: Regra 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


4) Se o próximo caractere é uma aspa dupla, então o próximo token deve
ser uma string e será composto pela sequência de caracteres até a
próxima aspa dupla, que deve estar na mesma linha. Se existir uma aspa
dupla iniciando uma string, mas não existir outra para finalizar a
string na mesma linha, um erro será gerado.

\iniciocodigo
@<Análise Léxica: Regra 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

5) Se o próximo caractere for um parêntese, ponto-e-vírgula ou uma
vírgula, então o próximo token será um token simbólico formado por
este único caractere.

\iniciocodigo
@<Análise Léxica: Regra 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Caso contrário, o próximo token será simbólico e formado pela
sequência mais longa dentre 12 famílias de caracteres:

\iniciocodigo
@<Análise Léxica: Regra 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer é lido de acordo com as subregras 6-a a 6-l
  @<Análise Léxica: Regra A@>
  @<Análise Léxica: Regra B@>
  @<Análise Léxica: Regra C@>
  @<Análise Léxica: Regra D@>
  @<Análise Léxica: Regra E@>
  @<Análise Léxica: Regra F@>
  @<Análise Léxica: Regra G@>
  @<Análise Léxica: Regra H@>
  @<Análise Léxica: Regra I@>
  @<Análise Léxica: Regra J@>
  @<Análise Léxica: Regra K@>
  @<Análise Léxica: Regra L@>
  // De acordo com conteúdo do buffer, gera o próximo token
  @<Análise Léxica: Gera Token Simbólico Reservado@>
  @<Análise Léxica: Gera Token Simbólico Genérico@>
}
@
\fimcodigo


a) A primeira família de letras são as letras de A a Z maiúsculas e
minúsculas além do ``underline'' e dígitos. Um dígito não pode ser o
primeiro caractere da sequência, ou ele seria interpretado como um
token numérico.


\iniciocodigo
@<Análise Léxica: Regra A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) A segunda família são os símbolos de maior, menor, igual, dois
pontos e ``|''.

\iniciocodigo
@<Análise Léxica: Regra B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acento agudo e grave.

\iniciocodigo
@<Análise Léxica: Regra C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Mais e menos.

\iniciocodigo
@<Análise Léxica: Regra D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Barra, barra invertida e símbolo de multiplicação.

\iniciocodigo
@<Análise Léxica: Regra E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Ponto de interrogação e exclamação.

\iniciocodigo
@<Análise Léxica: Regra F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Cerquilha, ``e'' comercial, arroba e cifrão.

\iniciocodigo
@<Análise Léxica: Regra G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Acento circunflexo e til.

\iniciocodigo
@<Análise Léxica: Regra H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Abrir colchetes.

\iniciocodigo
@<Análise Léxica: Regra I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Fechar colchetes.

\iniciocodigo
@<Análise Léxica: Regra J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Abrir e fechar chaves.

\iniciocodigo
@<Análise Léxica: Regra K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Análise Léxica: Regra L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo


Depois de ler todos os caracteres do próximo token, primeiro vemos se
estamos diante de um token simbólico reservado. Estes são tokens
simbólicos com o que seriam palavras-chave da linguagem. Por hora
ainda não iremos mostrá-los, mas testar se é o caso é apenas uma
questão de usar a função \monoespaco{strcmp}. Vamos inclusive inserir
o cabeçalho para poder comparar e manipular strings:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <string.h>
@
\fimcodigo

Se não for um token simbólico reservado, e se existir algo copiado
para o nosso buffer, então geramos um novo token simbólico genérico:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Genérico@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


\secao{4. Programas METAFONT}

Quando avaliamos um programa METAFONT, vamos precisar de duas
extruturas adicionais. A primeira delas, a qual chamaremos
de \monoespaco{struct metafont} irá conter as informações finais da
fonte tipográfica que foi lida e que terá tudo que for necessário para
que tal fonte possa ser usada para renderizar cada um dos glifos. A
segunda estrutura, a qual chamaremos de \monoespaco{struct context}
representa o estado atual do analisador sintático e representa
informações que devemos saber para poder continuar interpretando
corretamente uma lista de tokens. Essa segunda estrutura pode ser
descartada depois de terminarmos de ler os tokens de nossa fonte.

A primeira coisa que nosso analisador sintático precisa saber é que
todo programa METAFONT é uma sequência de declarações (possivelmente
vazia) finalizada por um token simbólico que
representa \monoespaco{end} ou \monoespaco{dump}:

\alinhaverbatim
<Programa> -> <Lista de Declarações> end | <Lista de Declarações> dump
\alinhanormal

Para nós não haverá nenhuma diferença entre \monoespaco{end}
e \monoespaco{dump}. No METAFONT original, o primeiro era usado para
finalizar o programa de uma fonte tipográfica e o segundo para
finalizar a descrição de um arquivo-base (algo como uma biblioteca
padrão básica).

Vamos definir então um novo tipo de token simbólico que será uma
abreviação deste símbolo de finalização, seja qual ele for:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>=
#define TYPE_END             8 // O token simbólico 'end' ou 'dump'
@
\fimcodigo

E geraremos esse tipo de token no nosso analisador léxico quando
encontrarmos uma das duas palavras-chaves (tecnicamente METAFONT chama
elas não de palavras-chaves, mas de ``sparks''):

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Reservado@>=
if(!strcmp(buffer, "end") || !strcmp(buffer, "dump")){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_END;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

A primeira função de análise sintática que definiremos é a que
reconhece um programa inteiro. Ela basicamente checa se o programa é
corretamente finalizado e se não o for, retorna erro. Caso ele esteja
corretamente finalizado, ela passa o programa para a próxima função de
análise sintática que interpreta lista de declarações, marcando o
começo e o fim da lista de declarações:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  struct generic_token *previous = NULL;
  while(end != NULL && end -> type != TYPE_END){
    previous = end;
    end = (struct generic_token *) (end -> next);
  }
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file,
                    (previous == NULL)?(1):(previous -> line));
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, previous);
}
@
\fimcodigo

A estrutura de contexto ainda não será definida inteiramente. Iremos
mostrar o conteúdo dela à medida que for necessário:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>=
struct context{
  @<Atributos (struct context)@>
};
@
\fimcodigo

E como indicado acima, um dos conteúdos de \monoespaco{struct
metafont} é o arquivo de onde saiu a fonte que ele representa. Também
vamos armazenar o que é necessário para alocar e desalocar a estrutura
e seus elementos:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Atributos (struct metafont)@>
};
@
\fimcodigo

Ambas as estruturas de dados terão uma função que as inicializa e as
finaliza:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct context *cx);
@
\fimcodigo

A estrutura \monoespaco{metafont} precisa armazenar mais informações,
e também pode tanto ser alocada com a função permanente ou temporária
de alocação. Já o contexto sempre será temporário, e por isso sempre
será alocado e desalocado com as funções temporárias de memória.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Inicialização (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Inicialização (struct context)@>
  return cx;
}
@
\fimcodigo

Já a definição das funções que finalizam e desalocam as estruturas:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalização (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct context *cx){
  if(temporary_free != NULL){
    @<Finalização (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo

\secao{5. Listas de Declarações}

Uma lista de declarações é uma série de declarações (potencialmente
vazias) sempre separadas por ponto-e-vírgula:

\alinhaverbatim
<Lista de Declarações> -> <Vazio> | <Declaração> ; <Lista de Declarações>
\alinhanormal

A função que iremos usar para avaliar e interpretar uma lista de
declarações é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

O que esta função fará será iterar sobre cada declaração e executar em
cada uma delas na ordem, a função de avaliação de declaração
individual. Para isso seu trabalho será ver onde cada declaração é
delimitada por cada ponto-e-vírgula e passar os limites de cada
declaração para essa próxima função de avaliação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
      if(!ret)
        return false;
      begin = end -> next;
    }
  }
  return ret;
}
@
\fimcodigo

A função acima itera sobre cada declaração, passando direto por
declarações vazias, e para cada declaração não-vazia, faz com que os
ponteiros \monoespaco{begin} e \monoespaco{end} a delimitem. Durante a
iteração avançamos os ponteiros para os próximos tokens, mas cuidamos
para nunca sair de dentro da região delimitada
por \monoespaco{begin\_token\_list} e \monoespaco{end\_token\_list}.

\secao{6. Declaração Composta}

Uma declaração individual na linguagem pode na verdade ser composta
por muitas outras declarações. A sintaxe para isso é:

\alinhaverbatim
<Declaração> -> <Vazia> | <Composta> | <Título> | <Equação> |
                <Atribuição> | <Declaração de Variável> | <Definição> |
                <Comando>
<Composta> -> begingroup <Lista de Declarações> <Não-Título> endgroup
\alinhanormal

Já sabemos o que é uma lista de declarações e já temos uma função que
as avalia. Já a declaração não-título, por enquanto iremos tratar como
sendo qualquer tipo de declaração. Pois nossa versão da linguagem
ainda não suporta declarações de título (seriam strings
isoladas). Desta forma, para nós, uma declaração composta é apenas uma
lista de declarações delimitada por tokens \monoespaco{begingroup}
e \monoespaco{endgroup}.

Por isso vamos ter que levar em conta a existência destes dois tipos
novos de tokens simbólicos no nosso analisador léxico:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_BEGINGROUP             9 // O token simbólico 'begingroup'
#define TYPE_ENDGROUP              10 // O token simbólico 'endgroup'
@
\fimcodigo

E adicionamos a descrição de como gerá-los na análise léxica:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Reservado@>+=
else if(!strcmp(buffer, "begingroup") || !strcmp(buffer, "endgroup")){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(buffer[0] == 'b')
    new_token -> type = TYPE_BEGINGROUP;
  else
    new_token -> type = TYPE_ENDGROUP;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

E agora a função que irá avaliar uma declaração individual. Como
visto, há 8 tipos diferentes de declarações:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Declaração: Vazia@>
  @<Declaração: Composta@>
  @<Declaração: Declaração de Variável@>
  //@<Declaração: Título@>
  //@<Declaração: Equação@>
  //@<Declaração: Atribuição@>
  //@<Declaração: Definição@> 
  //@<Declaração: Comando@>
  // Se estamos aqui, não identificamos o tipo de declaração:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

No caso da declaração vazia, geralmente não precisaremos lidar com
ela. A função \monoespaco{eval\_list\_of\_statements} silenciosamente
as ignora antes de passar para cá. Mas só para o caso de uma delas
aparecer por outros motivo, vamos explicitamente aceitá-las como
válidas abaixo:

\iniciocodigo
@<Declaração: Vazia@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Agora vamos à declaração composta. A primeira coisa a lembrarmos é que
será importante para a linguagem saber em qual nível de aninhamento
estamos para saber o escopo de eventuais variáveis declaradas. Por
causa disso, o contexto de nossa análise deve memorizar o nível de
aninhamento atual. Cada \monoespaco{begingroup} aumenta esse nível em
1 e cada \monoespaco{endgroup} diminui o nível em 1. Declaremos o
nível de aninhamento atual abaixo:

\iniciocodigo
@<Atributos (struct context)@>=
  int nesting_level;
@
\fimcodigo

Isso deve ser inicializado em zero:

\iniciocodigo
@<Inicialização (struct context)@>=
  cx -> nesting_level = 0;
@
\fimcodigo

A segunda coisa a lembrarmos é que se estivermos em uma declaração
composta, isso significa que o ponteiro para o fim da declaração pode
estar errado. Por exemplo, suponha que a função
\monoespaco{eval\_list\_of\_statements} avaliou os seguintes tokens
abaixo:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;]
\alinhanormal

Corretamente a função marcou o começo da primeira declaração
em \monoespaco{begingroup}, mas erroneamente ela
marcou \monoespaco{T2} como o fim da primeira declaração porque ela
funciona de maneira ingênua, tratando os ponto-e-vírgula como
separador de declarações, sem levar em conta as declarações compostas
que podem conter ponto-e-vírgula dentro delas. O fim da primeira
declaração deveria ser ao invés de \monoespaco{T2}, o
token \monoespaco{endgroup}.

Ao invés de aumentar a complexidade da
função \monoespaco{eval\_list\_of\_statements} fazendo ela levar em
conta declarações compostas, ao invés disso vamos fazer com que a
função \monoespaco{eval\_statements} seja capaz de corrigir o ponteiro
passado, mudando ele para a verdadeira posição. Somente depois disso
podemos passar a lista de declarações dentro do bloco para ser
avaliada:

\iniciocodigo
@<Declaração: Composta@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  struct generic_token *t = begin_token_list, *previous = NULL;
  int nesting_level = 0;
  while(t != NULL){
    if(t -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(t -> type == TYPE_ENDGROUP){
      nesting_level --;
      if(nesting_level == 0)
        break;
    }
    previous = t;
    t = (struct generic_token *) (t -> next);
  }
  *end_token_list = t; // Agora a declaração está demarcada corretamente
  if(*end_token_list == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed 'begingroup'.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(previous == begin_token_list) // Declaração composta vazia
    return true;
  else{
    bool ret;
    cx -> nesting_level ++;
    ret = eval_list_of_statements(mf, cx, ((struct generic_token *)
                                         begin_token_list) -> next,
                                  previous);
    cx -> nesting_level --;
    return ret;
  }
}
@
\fimcodigo

\secao{7. Declaração de Variáveis}

A sintaxe para declarar variáveis é:

\alinhaverbatim
<Declaração de Variável> -> <Tipo> <Lista de Declaração>
<Tipo> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<Lista de Declaração> -> <Tag> | <Tag> , <Lista de Declaração>
\alinhanormal

Uma ``tag'' é basicamente um token simbólico sem um significado
pré-definido na linguagem. Por exemplo, ``\monoespaco{tag}'' é uma tag,
mas ``\monoespaco{begingroup}'' não é.

Para interpretar a declaração de variáveis, vamos então introduzir no
nosso analisador léxico os seguintes tokens especiais:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_T_BOOLEAN               11 // O token simbólico 'boolean'
#define TYPE_T_PATH                  12 // O token simbólico 'path'
#define TYPE_T_PEN                   13 // O token simbólico 'pen'
#define TYPE_T_PICTURE               14 // O token simbólico 'picture'
#define TYPE_T_TRANSFORM             15 // O token simbólico 'transform'
#define TYPE_T_PAIR                  16 // O token simbólico 'pair'
#define TYPE_T_NUMERIC               17 // O token simbólico 'numeric'
@
\fimcodigo

E este é o código do analisador léxico que os identifica:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Reservado@>+=
else if(!strcmp(buffer, "boolean") || !strcmp(buffer, "path") ||
        !strcmp(buffer, "pen") || !strcmp(buffer, "picture") ||
        !strcmp(buffer, "transform") || !strcmp(buffer, "pair") ||
        !strcmp(buffer, "numeric")){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  switch(buffer[0]){
  case 'b':
    new_token -> type = TYPE_T_BOOLEAN; break;
  case 'n':
    new_token -> type = TYPE_T_NUMERIC; break;    
  case 't':
    new_token -> type = TYPE_T_TRANSFORM; break;
  default: // paTh, peN, piCture, paIr
    switch(buffer[2]){
      case 't':
        new_token -> type = TYPE_T_PATH; break;
      case 'n':
        new_token -> type = TYPE_T_PEN; break;
      case 'c':
        new_token -> type = TYPE_T_PICTURE; break;
      default:
        new_token -> type = TYPE_T_PAIR; break;
    }
  }
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

Quando uma variável é declarada, devemos fazer duas coisas:

1) Se a variável não existir no nível de aninhamento atual, devemos
alocar uma estrutura da memória para armazenar seu conteúdo. Se ela já
existir, um erro é gerado. A variável é inicialmente preenchida com um
valor padrão que depende de seu tipo. Ela não poderá ser usada antes
de ser inicializada.

2) Devemos percorrer a lista de tokens e procurar por ocorrências
desta variável mais adiante no mesmo nível de aninhamento, ou em
aninhamento inferior. E devemos atualizar o ponteiro destes tokens
para que apontem para a região de memória recém-alocada para esta
variável.

Como cada variável possui diferentes informações e conteúdo,
dependendo de seu tipo, o modo pelo qual cada uma delas é criada pode
diferir. O que todas as variáveis tem em comum é a seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
// Variável genérica
struct variable{
  int type;
  int nesting_level;
  void *next;  
};
@
\fimcodigo

Todas armazenam primeiro o seu tipo, depois o nível de aninhamento em
que estão e um ponteiro para a próxima. Mas dependendo do tipo da
variável haverá mais informações após o ponteiro para a próxima.

Se estivermos diante de uma variável global, podemos querer preservar
e armazenar o nome da variável para o caso de querermos depois
modificar o seu valor dado o seu nome. Então vamos usar a seguinte
estrutura que armazena o nome e a variável:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

E a estrutura de dados da fonte possui ponteiros para as variáveis
globais com nome armazenado e as sem nome armazenado:

\iniciocodigo
@<Atributos (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

Tais ponteiros para variáveis são inicializados como NULL:

\iniciocodigo
@<Inicialização (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

Para desalocar a lista de variáveis globais, basta percorrer a lista
encadeada que elas formam. Algumas variáveis mais complexas precisarão
de operações adicionais para serem removidas, mas trataremos delas
posteriormente.

\iniciocodigo
@<Finalização (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

Já desalocar a lista de variáveis globais com nomes preservados é
feito de maneira semelhante:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *v = (struct named_variable *)
                                 (mf -> named_variables);
  struct named_variable *next;
  while(v != NULL){
    next = (struct named_variable *) (v -> next);
    mf -> free(v -> name);
    mf -> free(v -> var);
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

No caso das variáveis que não são globais, elas serão armazenadas no
contexto, não na estrutura da fonte. Afinal, a duração delas será
sempre temporária:

\iniciocodigo
@<Atributos (struct context)@>=
  void *variables;
@
\fimcodigo

A lista de variáveis é inicializada como vazia:

\iniciocodigo
@<Inicialização (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

E finalizamos ela assim como finalizamos a lista de variáveis globais:

\iniciocodigo
@<Finalização (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

Agora vamos à interpretação da declaração de variável:

\iniciocodigo
@<Declaração: Declaração de Variável@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // Todos os tipos de declaração
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insere Variável Declarada@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

A inserção de uma nova variável segue a seguinte lógica:

\iniciocodigo
@<Insere Variável Declarada@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

A função que insere uma nova variável sem o nome é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

Ela aloca uma nova variável e a coloca no local indicado
por \monoespaco{target}:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Já inserir uma variável nova com o nome é feito com a seguinte função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

Ela funciona de maneira similar, apenas alocando a estrutura do nome e
colocando a nova variável ali:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));
  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL)
    mf -> named_variables = named;
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

E finalmente, a função que percorre uma lista de tokens procurando por
tokens simbólicos com o mesmo nome da variável alocada e fazendo o
ponteiro deles apontar para onde a variável está:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

A função percorre todos os tokens que vem depois do token com o nome
da nova variável e só para quando percorre a lista inteira ou quando
sai do nível de aninhamento atual para um onde a variável não existe
mais (quando acha um \monoespaco{endgroup} encerrando o nível de
aninhamento da variável):

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Variáveis Numéricas}

Uma variável numérica será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Uma variável numérica é inserida da seguinte forma:



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}

\fim
