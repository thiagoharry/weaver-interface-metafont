\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Usuário Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém uma implementação de um interpretador para
 uma linguagem baseada no METAFONT. Esta linguagem é projetada para
 permitir a definição de fontes tipográficas flexíveis e
 parametrizadas que podem ser interpretadas e renderizadas rapidamente
 à medida que são lidas. Por causa disso, nós sacrificamos alguma
 flexibilidade da linguagem METAFONT original para sermos capazes de
 criar resultados mais rápidos. A implementação será usada pelo Motor
 de Jogos Weaver como um módulo e usará OpenGL moderno para renderizar
 as fontes.}

\secao{1. Introdução}

A linguagem METAFONT original é uma linguagem feita para descrever
fontes tipográficas. Ela foi criada em 1984 por Donald Knuth e difere
de outros formatos de fontes tipográficas por permitir a criação de
fontes à partir da modificação de parâmetros definidos na descrição
básica da fonte. Desta forma, o projetista de uma fonte não deve criar
uma simples fonte tipográfica, mas uma meta-fonte, a qual pode por sua
vez gerar muitas outras fontes tipográficas diferentes mediante a
simples modificação dos parâmetros.

A especificação original da linguagem METAFONT pode ser encontrada em
[KNUTH, 1989], mas a implementação aqui não será compatível com a
linguagem original. Ao invés disso uma nova linguagem será definida,
mas ela terá objetivos similares.

Como este artigo define um subsistema do Motor de Jogos Weaver, e mais
especificamente um subsistema de interface de usuário, nosso objetivo
aqui será definir a seguinte função que irá interpretar um arquivo com
código METAFONT e irá gerar uma interface de usuário com as letrar
lidas como textura:

\iniciocodigo
@<Declaração de Função (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
@
\fimcodigo

E nós precisamos inserir o cabeçalho Weaver de interface de usuário:

\iniciocodigo
@<Inclui Cabeçalhos Gerais (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

Mas além de simplesmente carregar as fontes tipográficas lidas para um
arquivo, é importante poder gerar também uma estrutura de dados
representando a fonte lida, para que ela depois possa ser usada por
uma função que renderiza texto:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Antes de chamar qualquer uma das funções acima, será importante chamar
a seguinte função de inicialização que especifica ãlgumas das funções
que devem ser usadas, e além disso nos informa quantos píxels
correspontem à unidade de medida de ``1pt'':

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
void Winit_metafont(void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *),
                    void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    uint64_t (*rand)(void), int pt);
@
\fimcodigo

As funções passadas como argumento para tal inicializador são
respectivamente uma para fazer alocações temporárias de memória, outra
para desalocar o que foi alocado com ela (pode ser NULL), outra para
fazer alocações mais permanentes, outra para desalocar o que foi
alocado com ela (pode ser NULL também), uma para gerar 64 bits
aleatórios e por fim a medida de quantos píxels correspondem a 1pt.


\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{metafont.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
#if !defined(_WIN32)
#include <sys/param.h> // Necessário no BSD, mas causa problema no Windows
#endif
@<Inclui Cabeçalhos Gerais (metafont.h)@>
//@<Macros Gerais (metafont.h)@>
@<Estrutura de Dados (metafont.h)@>
@<Declaração de Função (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (metafont.h)'', o mesmo nome apresentado no
trecho de código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{metafont.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Cabeçalhos Locais (metafont.c)@>
@<Macros Locais (metafont.c)@>
@<Estrutura de Dados Locais (metafont.c)@>
@<Variáveis Locais (metafont.c)@>
@<Declaração de Função Local (metafont.c)@>
@<Funções Auxiliares Locais (metafont.c)@>
@<Definição de Funções da API (metafont.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{2. Inicialização}

Primeiro vamos definir a função de inicialização. O que ela fará será
armazenar em uma série de variáveis estáticas várias das funções que
iremos usar no programa, além de nos informar quantos píxels
correspondem a 1 pt. As variáveis que armazenarão tais informações são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

E a função de inicialização consiste em preencher tais variáveis:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>=
void Winit_metafont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
}
@
\fimcodigo

\secao{3. Analisador Léxico}

A primeira coisa a criar para uma linguagem é seu analisador
léxico. Ele irá ler o código-fonte da linguagem presente em um arquivo
e irágerar uma lista de ``tokens'', sendo cada token a unidade mais
básica da linguagem, basicamente uma palavra.

METAFONT reconhece três tipos de tokens: numéricos, strings e
simbólicos. Na prática nós iremos dividir os tokens simbólicos em
diferentes tipos de subtokens para podermos armazená-los e lê-los de
maneira mais eficiente.

Um token numérico será representado internamente como um número em
ponto flutuante. Nisso iremos diferir do METAFONT original que usava
uma representação própria de números. Em nome de operações mais
rápidas, usaremos a forma moderna de representar números. Então essa é
a aparência de um token numérico:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>=
#define TYPE_NUMERIC 1
struct numeric_token{
  int type;   // Deve ser igual a 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

E isso é como representaremos tokens de strings:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_STRING 2
struct string_token{
  int type;   // Deve ser igual a 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

Nós iremos armazenar apenas os primeiros 5 bytes de cada string que
encontrarmos, mesmo que no código-fonte a string seja maior. Isso será
feito porque ao contrário do METAFONT original, a única utilidade para
strings aqui será indicar qual caractere Unicode deve estar associado
a cada glifo definido. Para isso nós precisamos de apenas 5 bytes (no
máximo 4 para o caractere mais o byte 0 final). E também podemos usar
eles para associar certos glifos a ligaduras como ``ff'', que também
cabe em 5 bytes.

Já no caso de tokens simbólicos, precisamos armazenar todo o seu
conteúdo para podermos saber qual token temos, e vamos alocar
dinamicamente de acordo com o tamanho do símbolo:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_SYMBOLIC 3
struct symbolic_token{
  int type;   // Deve ser igual a 'TYPE_SYMBOLIC'
  void *next, *var;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char *value;
};
@
\fimcodigo

Também colocamos neste token o ponteiro \monoespaco{var}, já que ele
pode corresponder a uma variável, e por isso pode precisar apontar
para a região da memória com o conteúdo da variável.

Mas isso pode consumir mais espaço na memória do que é
necessário. Alguns símbolos são muito comuns e são definidos por
padrão na própria linguagem e podem usar menos espaço que isso. Por
exemplo, parênteses e vírgulas. Podemos representar eles com a
seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
#define TYPE_OPEN_PARENTHESIS  4 // '('
#define TYPE_CLOSE_PARENTHESIS 5 // ')'
#define TYPE_COMMA             6 // ','
#define TYPE_SEMICOLON         7 // ';'
@<METAFONT: Definição de Token Simbólico@>
// (...)
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

Podemos definir posteriormente muitos outros tipos de tokens
simbólicos reservados. Basta definirmos eles associando a um número
único maior do que 6. Qualquer token cujo tipo é um número igual ou
maior que 3 é simbólico.

Todo token possui um ponteiro para um próximo token. Isso ocorre
porque eles geralmente formarão uma lista encadeada de tokens. Para
desalocar a memória ocupada por uma lista de tokens dada uma função de
desalocação e apagá-los, pode-se usar a seguinte função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Agora a função que fará a análise léxica. Ela receberá como argumento
a estrutura da fonte, uma função de alocação de memória e uma string
com caminho para arquivo com código-fonte METAFONT. Ela retornará uma
lista encadeada de tokens:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Análise Léxica: Regra 1@>
    @<Análise Léxica: Regra 2@>
    @<Análise Léxica: Regra 3@>
    @<Análise Léxica: Regra 4@>
    @<Análise Léxica: Regra 5@>
    @<Análise Léxica: Regra 6@>
    // Nenhuma regra aplicada: erro
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, como usamos o tipo \monoespaco{FILE}, precisamos inserir o
cabeçalho de entrada e saída padrão para podermos abrir e ler
arquivos:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

As regras para ler os tokens consiste em ler cada linha do código
fonte aplicando as seguintes regras para cada novo caractere lido:

1) Se o próximo caractere é um espaço ou um ponto que não é sucedido
por um dígito decimal ou um novo ponto, ignore-o e siga em frente.

\iniciocodigo
@<Análise Léxica: Regra 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

Como estamos usando a função \monoespaco{isdigit}, devemos inserir o
seguinte cabeçalho que a declara:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) Se o próximo caractere é o símbolo de porcentagem, ignore-o e
ignore todos os outros caracteres seguintes na linha. Este símbolo
marca o começo de comentários na linguagem.

\iniciocodigo
@<Análise Léxica: Regra 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) Se o próximo caractere é um dígito decimal ou um ponto seguido por
um dígito decimal, então o próximo token será numérico. E é formado
pela maior sequência possível de ser lida envolvendo dígitos decimais
e opcionalmente um único ponto representando o ponto decimal.

\iniciocodigo
@<Análise Léxica: Regra 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


4) Se o próximo caractere é uma aspa dupla, então o próximo token deve
ser uma string e será composto pela sequência de caracteres até a
próxima aspa dupla, que deve estar na mesma linha. Se existir uma aspa
dupla iniciando uma string, mas não existir outra para finalizar a
string na mesma linha, um erro será gerado.

\iniciocodigo
@<Análise Léxica: Regra 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

5) Se o próximo caractere for um parêntese, ponto-e-vírgula ou uma
vírgula, então o próximo token será um token simbólico formado por
este único caractere.

\iniciocodigo
@<Análise Léxica: Regra 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Caso contrário, o próximo token será simbólico e formado pela
sequência mais longa dentre 12 famílias de caracteres:

\iniciocodigo
@<Análise Léxica: Regra 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer é lido de acordo com as subregras 6-a a 6-l
  @<Análise Léxica: Regra A@>
  @<Análise Léxica: Regra B@>
  @<Análise Léxica: Regra C@>
  @<Análise Léxica: Regra D@>
  @<Análise Léxica: Regra E@>
  @<Análise Léxica: Regra F@>
  @<Análise Léxica: Regra G@>
  @<Análise Léxica: Regra H@>
  @<Análise Léxica: Regra I@>
  @<Análise Léxica: Regra J@>
  @<Análise Léxica: Regra K@>
  @<Análise Léxica: Regra L@>
  // De acordo com conteúdo do buffer, gera o próximo token
  @<Análise Léxica: Gera Token Simbólico Reservado@>
  @<Análise Léxica: Gera Token Simbólico Genérico@>
}
@
\fimcodigo


a) A primeira família de letras são as letras de A a Z maiúsculas e
minúsculas além do ``underline'' e dígitos. Um dígito não pode ser o
primeiro caractere da sequência, ou ele seria interpretado como um
token numérico.


\iniciocodigo
@<Análise Léxica: Regra A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) A segunda família são os símbolos de maior, menor, igual, dois
pontos e a barra vertical.

\iniciocodigo
@<Análise Léxica: Regra B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acento agudo e grave.

\iniciocodigo
@<Análise Léxica: Regra C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Mais e menos.

\iniciocodigo
@<Análise Léxica: Regra D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Barra, barra invertida e símbolo de multiplicação.

\iniciocodigo
@<Análise Léxica: Regra E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Ponto de interrogação e exclamação.

\iniciocodigo
@<Análise Léxica: Regra F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Cerquilha, ``e'' comercial, arroba e cifrão.

\iniciocodigo
@<Análise Léxica: Regra G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Acento circunflexo e til.

\iniciocodigo
@<Análise Léxica: Regra H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Abrir colchetes.

\iniciocodigo
@<Análise Léxica: Regra I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Fechar colchetes.

\iniciocodigo
@<Análise Léxica: Regra J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Abrir e fechar chaves.

\iniciocodigo
@<Análise Léxica: Regra K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Análise Léxica: Regra L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

Depois de ler todos os caracteres do próximo token, primeiro vemos se
estamos diante de um token simbólico reservado. Estes são tokens
simbólicos com o que seriam palavras-chave da linguagem. Podemos
identificá-los porque iremos armazenar uma lista de palavras-chave
reservadas da linguagem aqui:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static char* list_of_keywords[] = {
@<Lista de Palavras Reservadas@>
  NULL};
@
\fimcodigo

Sendo assim, sabemos que temos um token que corresponde a uma
palavra-chave reservada se ele estiver presente nesta lista terminada
em NULL. Se for o caso, geramos um token especial com um tipo
dependendo de sua posição na lista:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Reservado@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // O tipo de tokens reservados começa no 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(dealloc, first_token);
      return NULL;
    }
    @<Muda Tipo na Geração de Tokens em Casos Especiais@>
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(first_token == NULL)
      first_token = last_token = new_token;
    else{
      ((struct generic_token *) last_token) -> next = new_token;
      last_token = new_token;
    }
    continue;
  }
}
@
\fimcodigo

Para usar a função \monoespaco{strcmp}, precisamos do seguinte
cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <string.h>
@
\fimcodigo

Se não for um token simbólico reservado, e se existir algo copiado
para o nosso buffer, então geramos um novo token simbólico genérico:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Genérico@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Preenche Ponteiro para Variável Interna@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


\secao{4. Programas METAFONT}

Quando avaliamos um programa METAFONT, vamos precisar de duas
extruturas adicionais. A primeira delas, a qual chamaremos
de \monoespaco{struct metafont} irá conter as informações finais da
fonte tipográfica que foi lida e que terá tudo que for necessário para
que tal fonte possa ser usada para renderizar cada um dos glifos. A
segunda estrutura, a qual chamaremos de \monoespaco{struct context}
representa o estado atual do analisador sintático e representa
informações que devemos saber para poder continuar interpretando
corretamente uma lista de tokens. Essa segunda estrutura pode ser
descartada depois de terminarmos de ler os tokens de nossa fonte.

A primeira coisa que nosso analisador sintático precisa saber é que
todo programa METAFONT é uma sequência de declarações (possivelmente
vazia) finalizada por um token simbólico que
representa \monoespaco{end} ou \monoespaco{dump}:

\alinhaverbatim
<Programa> -> <Lista de Declarações> end | <Lista de Declarações> dump
\alinhanormal

Para nós não haverá nenhuma diferença entre \monoespaco{end}
e \monoespaco{dump}. No METAFONT original, o primeiro era usado para
finalizar o programa de uma fonte tipográfica e o segundo para
finalizar a descrição de um arquivo-base (algo como uma biblioteca
padrão básica).

Vamos definir então um novo tipo de token simbólico que será uma
abreviação deste símbolo de finalização, seja qual ele for:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>=
#define TYPE_END             8 // O token simbólico 'end'
#define TYPE_DUMP            9 // O token simbólico 'dump'
@
\fimcodigo

E vamos adicionar tanto a palavra-chave \monoespaco{end}
como \monoespaco{dump} na lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>=
"end", "dump",
@
\fimcodigo

Mas para simplificar, não iremos usar o \monoespaco{TYPE\_DUMP}, ele
será sempre transformado em \monoespaco{TYPE\_END} para facilitar o
nosso código no analisador sintático:

\iniciocodigo
@<Muda Tipo na Geração de Tokens em Casos Especiais@>=
if(token_type == TYPE_DUMP)
  token_type = TYPE_END;
@
\fimcodigo

A primeira função de análise sintática que definiremos é a que
reconhece um programa inteiro. Ela basicamente checa se o programa é
corretamente finalizado e se não o for, retorna erro. Caso ele esteja
corretamente finalizado, ela passa o programa para a próxima função de
análise sintática que interpreta lista de declarações, marcando o
começo e o fim da lista de declarações:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  struct generic_token *previous = NULL;
  while(end != NULL && end -> type != TYPE_END){
    previous = end;
    end = (struct generic_token *) (end -> next);
  }
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file,
                    (previous == NULL)?(1):(previous -> line));
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, previous);
}
@
\fimcodigo

A estrutura de contexto ainda não será definida inteiramente. Iremos
mostrar o conteúdo dela à medida que for necessário:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>=
struct context{
  @<Atributos (struct context)@>
};
@
\fimcodigo

E como indicado acima, um dos conteúdos de \monoespaco{struct
metafont} é o arquivo de onde saiu a fonte que ele representa. Também
vamos armazenar o que é necessário para alocar e desalocar a estrutura
e seus elementos:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Atributos (struct metafont)@>
};
@
\fimcodigo

Ambas as estruturas de dados terão uma função que as inicializa e as
finaliza:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct context *cx);
@
\fimcodigo

A estrutura \monoespaco{metafont} precisa armazenar mais informações,
e também pode tanto ser alocada com a função permanente ou temporária
de alocação. Já o contexto sempre será temporário, e por isso sempre
será alocado e desalocado com as funções temporárias de memória.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Inicialização (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Inicialização (struct context)@>
  return cx;
}
@
\fimcodigo

Já a definição das funções que finalizam e desalocam as estruturas:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalização (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct context *cx){
  if(temporary_free != NULL){
    @<Finalização (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo

\secao{5. Listas de Declarações}

Uma lista de declarações é uma série de declarações (potencialmente
vazias) sempre separadas por ponto-e-vírgula:

\alinhaverbatim
<Lista de Declarações> -> <Vazio> | <Declaração> ; <Lista de Declarações>
\alinhanormal

A função que iremos usar para avaliar e interpretar uma lista de
declarações é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

O que esta função fará será iterar sobre cada declaração e executar em
cada uma delas na ordem, a função de avaliação de declaração
individual. Para isso seu trabalho será ver onde cada declaração é
delimitada por cada ponto-e-vírgula e passar os limites de cada
declaração para essa próxima função de avaliação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
      if(!ret)
        return false;
      begin = end -> next;
    }
  }
  return ret;
}
@
\fimcodigo

A função acima itera sobre cada declaração, passando direto por
declarações vazias, e para cada declaração não-vazia, faz com que os
ponteiros \monoespaco{begin} e \monoespaco{end} a delimitem. Durante a
iteração avançamos os ponteiros para os próximos tokens, mas cuidamos
para nunca sair de dentro da região delimitada
por \monoespaco{begin\_token\_list} e \monoespaco{end\_token\_list}.

\secao{6. Declaração Composta}

Uma declaração individual na linguagem pode na verdade ser composta
por muitas outras declarações. A sintaxe para isso é:

\alinhaverbatim
<Declaração> -> <Vazia> | <Composta> | <Declaração de Variável> |
                <Atribuição> | <Definição> | <Comando>
<Composta> -> begingroup <Lista de Declarações> <Não-Título> endgroup
\alinhanormal

Já sabemos o que é uma lista de declarações e já temos uma função que
as avalia. Já a declaração não-título, por enquanto iremos tratar como
sendo qualquer tipo de declaração. Pois nossa versão da linguagem
ainda não suporta declarações de título (seriam strings
isoladas). Desta forma, para nós, uma declaração composta é apenas uma
lista de declarações delimitada por tokens \monoespaco{begingroup}
e \monoespaco{endgroup}.

Por isso vamos ter que levar em conta a existência destes dois tipos
novos de tokens simbólicos no nosso analisador léxico:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_BEGINGROUP            10 // O token simbólico 'begingroup'
#define TYPE_ENDGROUP              11 // O token simbólico 'endgroup'
@
\fimcodigo

E adicionamos eles à nossa lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"begingroup", "endgroup",
@
\fimcodigo

E agora a função que irá avaliar uma declaração individual. Como
visto, há 8 tipos diferentes de declarações:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Declaração: Vazia@>
  @<Declaração: Composta@>
  @<Declaração: Declaração de Variável@>
  @<Declaração: Atribuição@>
  //@<Declaração: Definição@>
  //@<Declaração: Comando@>
  // Se estamos aqui, não identificamos o tipo de declaração:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

No caso da declaração vazia, geralmente não precisaremos lidar com
ela. A função \monoespaco{eval\_list\_of\_statements} silenciosamente
as ignora antes de passar para cá. Mas só para o caso de uma delas
aparecer por outros motivo, vamos explicitamente aceitá-las como
válidas abaixo:

\iniciocodigo
@<Declaração: Vazia@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Agora vamos à declaração composta. A primeira coisa a lembrarmos é que
será importante para a linguagem saber em qual nível de aninhamento
estamos para saber o escopo de eventuais variáveis declaradas. Por
causa disso, o contexto de nossa análise deve memorizar o nível de
aninhamento atual. Cada \monoespaco{begingroup} aumenta esse nível em
1 e cada \monoespaco{endgroup} diminui o nível em 1. Declaremos o
nível de aninhamento atual abaixo:

\iniciocodigo
@<Atributos (struct context)@>=
  int nesting_level;
@
\fimcodigo

Isso deve ser inicializado em zero:

\iniciocodigo
@<Inicialização (struct context)@>=
  cx -> nesting_level = 0;
@
\fimcodigo

A segunda coisa a lembrarmos é que se estivermos em uma declaração
composta, isso significa que o ponteiro para o fim da declaração pode
estar errado. Por exemplo, suponha que a função
\monoespaco{eval\_list\_of\_statements} avaliou os seguintes tokens
abaixo:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;]
\alinhanormal

Corretamente a função marcou o começo da primeira declaração
em \monoespaco{begingroup}, mas erroneamente ela
marcou \monoespaco{T2} como o fim da primeira declaração porque ela
funciona de maneira ingênua, tratando os ponto-e-vírgula como
separador de declarações, sem levar em conta as declarações compostas
que podem conter ponto-e-vírgula dentro delas. O fim da primeira
declaração deveria ser ao invés de \monoespaco{T2}, o
token \monoespaco{endgroup}.

Ao invés de aumentar a complexidade da
função \monoespaco{eval\_list\_of\_statements} fazendo ela levar em
conta declarações compostas, ao invés disso vamos fazer com que a
função \monoespaco{eval\_statements} seja capaz de corrigir o ponteiro
passado, mudando ele para a verdadeira posição. Somente depois disso
podemos passar a lista de declarações dentro do bloco para ser
avaliada:

\iniciocodigo
@<Declaração: Composta@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  struct generic_token *t = begin_token_list, *previous = NULL;
  int nesting_level = 0;
  while(t != NULL){
    if(t -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(t -> type == TYPE_ENDGROUP){
      nesting_level --;
      if(nesting_level == 0)
        break;
    }
    previous = t;
    t = (struct generic_token *) (t -> next);
  }
  *end_token_list = t; // Agora a declaração está demarcada corretamente
  if(*end_token_list == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed 'begingroup'.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(previous == begin_token_list) // Declaração composta vazia
    return true;
  else{
    bool ret;
    cx -> nesting_level ++;
    ret = eval_list_of_statements(mf, cx, ((struct generic_token *)
                                         begin_token_list) -> next,
                                  previous);
    cx -> nesting_level --;
    return ret;
  }
}
@
\fimcodigo

\secao{7. Declaração de Variáveis}

A sintaxe para declarar variáveis é:

\alinhaverbatim
<Declaração de Variável> -> <Tipo> <Lista de Declaração>
<Tipo> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<Lista de Declaração> -> <Tag> | <Tag> , <Lista de Declaração>
\alinhanormal

Uma ``tag'' é basicamente um token simbólico sem um significado
pré-definido na linguagem. Por exemplo, ``\monoespaco{tag}'' é uma tag,
mas ``\monoespaco{begingroup}'' não é.

Para interpretar a declaração de variáveis, vamos então introduzir no
nosso analisador léxico os seguintes tokens especiais:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_T_BOOLEAN               12 // O token simbólico 'boolean'
#define TYPE_T_PATH                  13 // O token simbólico 'path'
#define TYPE_T_PEN                   14 // O token simbólico 'pen'
#define TYPE_T_PICTURE               15 // O token simbólico 'picture'
#define TYPE_T_TRANSFORM             16 // O token simbólico 'transform'
#define TYPE_T_PAIR                  17 // O token simbólico 'pair'
#define TYPE_T_NUMERIC               18 // O token simbólico 'numeric'
@
\fimcodigo

E adicionamos todos à lsita de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


Quando uma variável é declarada, devemos fazer duas coisas:

1) Se a variável não existir no nível de aninhamento atual, devemos
alocar uma estrutura da memória para armazenar seu conteúdo. Se ela já
existir, um erro é gerado. A variável é inicialmente preenchida com um
valor padrão que depende de seu tipo. Ela não poderá ser usada antes
de ser inicializada.

2) Devemos percorrer a lista de tokens e procurar por ocorrências
desta variável mais adiante no mesmo nível de aninhamento, ou em
aninhamento inferior. E devemos atualizar o ponteiro destes tokens
para que apontem para a região de memória recém-alocada para esta
variável.

Como cada variável possui diferentes informações e conteúdo,
dependendo de seu tipo, o modo pelo qual cada uma delas é criada pode
diferir. O que todas as variáveis tem em comum é a seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
// Variável genérica
struct variable{
  int type;
  int nesting_level;
  void *next;
};
@
\fimcodigo

Todas armazenam primeiro o seu tipo, depois o nível de aninhamento em
que estão e um ponteiro para a próxima. Mas dependendo do tipo da
variável haverá mais informações após o ponteiro para a próxima.

Se estivermos diante de uma variável global, podemos querer preservar
e armazenar o nome da variável para o caso de querermos depois
modificar o seu valor dado o seu nome. Então vamos usar a seguinte
estrutura que armazena o nome e a variável:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

E a estrutura de dados da fonte possui ponteiros para as variáveis
globais com nome armazenado e as sem nome armazenado:

\iniciocodigo
@<Atributos (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

Tais ponteiros para variáveis são inicializados como NULL:

\iniciocodigo
@<Inicialização (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

Para desalocar a lista de variáveis globais, basta percorrer a lista
encadeada que elas formam. Algumas variáveis mais complexas precisarão
de operações adicionais para serem removidas, mas trataremos delas
posteriormente.

\iniciocodigo
@<Finalização (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável Global 'v'@>
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

Já desalocar a lista de variáveis globais com nomes preservados é
feito de maneira semelhante:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) (named -> var);
    next = (struct named_variable *) (named -> next);
    mf -> free(named -> name);
    @<Finaliza Variável Global 'v'@>
    mf -> free(v);
    mf -> free(named);
    named = next;
  }
}
@
\fimcodigo

No caso das variáveis que não são globais, elas serão armazenadas no
contexto, não na estrutura da fonte. Afinal, a duração delas será
sempre temporária:

\iniciocodigo
@<Atributos (struct context)@>=
  void *variables;
@
\fimcodigo

A lista de variáveis é inicializada como vazia:

\iniciocodigo
@<Inicialização (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

E finalizamos ela assim como finalizamos a lista de variáveis globais:

\iniciocodigo
@<Finalização (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável Local 'v'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

Agora vamos à interpretação da declaração de variável:

\iniciocodigo
@<Declaração: Declaração de Variável@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // Todos os tipos de declaração
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insere Variável Declarada@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

A inserção de uma nova variável segue a seguinte lógica:

\iniciocodigo
@<Insere Variável Declarada@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

A função que insere uma nova variável sem o nome é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

Ela aloca uma nova variável e a coloca no local indicado
por \monoespaco{target}:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    case TYPE_T_PAIR:
      var_size = sizeof(struct pair_variable);
      break;
    case TYPE_T_PATH:
      var_size = sizeof(struct path_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Inicialização de Nova Variável@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Já inserir uma variável nova com o nome é feito com a seguinte função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

Ela funciona de maneira similar, apenas alocando a estrutura do nome e
colocando a nova variável ali:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));
  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL){
    mf -> named_variables = named;
  }  
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

E finalmente, a função que percorre uma lista de tokens procurando por
tokens simbólicos com o mesmo nome da variável alocada e fazendo o
ponteiro deles apontar para onde a variável está:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

A função percorre todos os tokens que vem depois do token com o nome
da nova variável e só para quando percorre a lista inteira ou quando
sai do nível de aninhamento atual para um onde a variável não existe
mais (quando acha um \monoespaco{endgroup} encerrando o nível de
aninhamento da variável):

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Variáveis Numéricas}

Uma variável numérica será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparando uma variável numérica com uma variável genérica, a
diferença é a variável de ponto-flutuante \monoespaco{value} que
armazena o valor numérico. Durante a criação da variável, o valor é
inicializado como NaN, que para nós representa uma variável com valor
desconhecido:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

O uso da macro \monoespaco{NAN} requer que usemos o cabeçalho
matemático:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

No caso das variáveis numéricas, nada a mais é necessário durante a
finalização, já que não há nada muito complexo além de um número em
ponto flutuante nelas.

Entretanto, além de variáveis declaradas pelo usuário, a nossa versão
da linguagem Metafont irá possuir algumas variáveis internas numéricas
próprias. Elas sempre estarão presentes e não precisam ser
declaradas. Iremos ter ao todo três
delas: \monoespaco{pt}, \monoespaco{cm} e \monoespaco{mm}. Basicamente
elas irão armazenar quantos pixels correspondem a 1pt, 1cm e 1mm
respectivamente.

Tais variáveis numéricas internas serão armazenadas na estrutura
metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

Na inicialização alocamos espaço para as três variáveis e as preenchemos:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   pt;
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   28.3465 * pt; // 1cm = 28.3465pt
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   2.83465 * pt; // 1mm = 2.83465pt
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;

  }
}
@
\fimcodigo

Criamos as seguintes macros para acessar cada uma destas variáveis
mais facilmente:

\iniciocodigo
@<Macros Locais (metafont.c)@>=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

Para finalizar a estrutura metafont, devemos desalocar tais variáveis
internas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

Quando o nosso analisador léxico gera um novo token simbólico que não
é uma palavra reservada, ele já deve checar se este token tem o nome
de uma variável interna. Se tiver, o ponteiro para ela já é preenchido
corretamente:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\subsecao{7.2. Variáveis de Pares}

Uma variável de par serve para armazenar coordenadas de um ponto. Ela
será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct pair_variable{
  int type; // Deve ser 'TYPE_T_PAIR'
  int nesting_level;
  void *next;
  float x, y;
};
@
\fimcodigo

A diferença é que elas possuem espaço para dois valores em ponto
flutuante ao invés de um. Inicialmente vamos representar o primeiro
deles como NaN, para representar uma variável não-inicializada:

\iniciocodigo
@<Initializing New Variable@>=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Variáveis de Caminhos}

Uma variável de caminho armazena uma sequência de pontos e uma
sequência de pontos de controle formando uma sequência de Curvas de
Beziér cúbicas.

Uma Curva de Beziér cúbica é definida por dois pontos de extremidade
($z_1$ e $z_4$) e dois pontos de controle ($z_2'$ e $z_3'$). Os dois
pontos de extremidade fazem parte da curva. Para obter todos os outros
pontos que fazem parte da curva à partir de quatro pontos $(z_1, z_2',
z_3', z_4)$, usa-se o seguinte procedimento:

1) Obtenha o ponto intermediário $z_{12}'$, que fica na metade do
caminho entre $z_1$ e $z_2'$, o ponto intermediário $z_{23}'$, que
fica no meio do caminho entre $z_2'$ e $z_3'$ e o ponto intermediário
$z_{34}'$, que fica no meio do caminho entre $z_3'$ e $z_4$.

2) Obtenha agora os dois pontos intermediários novos: $z_{123}'$, que
fica no meio do caminho entre $z_{12}'$ e $z_{23}'$ e o ponto
$z_{234}'$ que fica entre os pontos $z_{23}'$ e $z_{34}'$.

3) O novo ponto que faz parte da curva gerado é o ponto $z_{1234}$,
que fica no meio do caminho entre $z_{123}'$ e $z_{234}'$.

4) Gere os outros pontos da curva aplicando este procedimento
recursivamente sobre $(z_1, z_{12}', z_{123}', z_{1234})$ e sobre
$(z_{1234}, z_{234}', z_{34}', z_4)$.

É possível também obter uma fórmula para tais curvas. Dado dois pontos
de extremidade e dois de controle, todos os pontos intermediários
podem ser obtidos usando a fórmula abaixo, variando $t$ entre 0 e 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

A estrutura de dados que armazena a sequência de Curvas de Beziér
Cúbicas é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct path_points{
  float x, y; // Ponto de extremidade
  float u_x, u_y, v_x, v_y;   // Pontos de controle
  void *subpath;
};
struct path_variable{
  int type; // Deve ser 'TYPE_T_PATH'
  int nesting_level;
  void *next;
  bool cyclic;
  int length;
  struct path_points *points;
};
@
\fimcodigo

Basicamente seus pontos estarão apontados pelo
ponteiro \monoespaco{points}, um vetor de estrutura que terá um número
de elementos igual a \monoespaco{length}. Cada estrutura representará
um ponto $(x, y)$ ou então terá um ponteiro para outra variável de
caminho que contém um subcaminho (sempre que \monoespaco{subpath} não
for nulo, e nesta caso ignoraremos $x$ e $y$). Os pontos de controle
definidos por \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
e \monoespaco{v\_y} são os pontos de controle entre o ponto ou
subcaminho atual e o próximo, se houver. Caso seja um caminho cíclico,
os pontos de controle do último ponto ou subcaminho determinam como
ele será ligado ao primeiro ponto. Se não for cíclico, os pontos de
controle do último ponto são ignorados.

O modo como representaremos uma variável de caminho não-inicializada é
mantendo seu tamanho (\monoespaco{length}) como sendo igual a -1:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
  ((struct path_variable *) var) -> points = NULL;
}
@
\fimcodigo

Quando vamos remover uma variável global, se ela for do tipo caminho e
estiver inicializada, precisamos remover a lista de pontos alocada:

\iniciocodigo
@<Finaliza Variável Global 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && mf -> free != NULL)
    path_recursive_free(mf -> free, path, false);
}
@
\fimcodigo

Se a variável não for global fazemos o mesmo, mas usando uma função de
desalocação para variáveis temporárias:


\iniciocodigo
@<Finaliza Variável Local 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL)
    path_recursive_free(temporary_free, path, false);
}
@
\fimcodigo

Como um caminho pode conter subcaminhos e cada um deles também pode
ter seus próprios subcaminhos, em tais casos usamos uma função
recursiva para desalocar memória. Dada a função de desalocação e um
ponteiro para uma variável de caminho, nós desalocamos todos os seus
subcaminhos e depois a desalocamos. A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer);
@
\fimcodigo

E sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].subpath != NULL)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath, true);
    }
    free_func(path -> points);
    if(free_first_pointer)
      free_func(path);
  }
}
@
\fimcodigo


\secao{8. Atribuições}

Atribuições são como fazemos com que as variáveis sejam inicializadas,
como modificamos seus valores e como armazenamos nelas o resultado de
expressões.

A sintaxe de uma atribuição é:

\alinhaverbatim
<Atribuição> -> <Variável> = <Lado Direito> |
                <Variável> := <Lado Direito>
<Lado Direito> -> <Expressão> | <Atribuição>
\alinhanormal

Isso significa que podemos realizar atribuições encadeadas, por
exemplo, todas as variáveis abaixo, se forem numéricas, passarão a
valer 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

Se no começo de uma declaração nós encontramos uma variável, então
certamente estamos diante de uma atribuição.

Vamos começar então ensinando ao nosso analizador léxico que ambos os
tokens ``\monoespaco{=}'' e ``\monoespaco{:=}'' são equivalentes,
representam a mesma coisa e tem significado especial:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_ASSIGNMENT            19 // O token simbólico '='
#define TYPE_ASSIGNMENT2           20 // O token simbólico ':='
@
\fimcodigo

Ambos os tipos de atribuição vão para a lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"=", ":=",
@
\fimcodigo

Mas vamos tratar ambos como sinônimos e transformar o segundo tipo no
primeiro para simplificar o código:

\iniciocodigo
@<Muda Tipo na Geração de Tokens em Casos Especiais@>+=
else if(token_type == TYPE_ASSIGNMENT2)
  token_type = TYPE_ASSIGNMENT;
@
\fimcodigo

Agora que temos este novo tipo de token, o código para avaliar uma
atribuição segue em seguida. O que ele faz é percorrer a atribuição
detectando todas as variáveis que deverão passar pela
atribuição. Enquanto faz isso, o código checa se todas estão
declaradas, se todas possuem o mesmo tipo, se tentamos atribuir para
algo que não é uma variável, se não colocamos um símbolo de atribuição
ou se está faltando uma expressão depois do último símbolo de
atribuição. Em qualquer um destes casos, um erro é gerado.

A parte que ainda não está sendo mostrada no código abaixo, mas será
definida nas próximas subseções é como avaliar a expressão após o
último símbolo de atribuição e como efetivamente fazemos a
atribuição. Isso porque o modo de fazer isso depende do tipo das
variáveis. DEpendendo do tipo delas, esperaremos encontrar um tipo
diferente de expressão, e realizar o armazenamento de tais variáveis
também será diferente. Estes detalhes veremos nas próximas subseções.

\iniciocodigo
@<Declaração: Atribuição@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  struct generic_token *begin_expression;
  int type = 0; // Tipo das variáveis na atribuição
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment (type: %d).\n", mf -> file,
              var -> line, var -> type);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Atribuição de Variável Numérica@>
  @<Atribuição de Variável de Par@>
  @<Atribuição de Variável de Caminho@>
  return true;
}
@
\fimcodigo

\subsecao{8.1. Atribuições e Expressões Numéricas}

Como então realizar a atribuição de variáveis numéricas dado o código
acima? Usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável Numérica@>=
if(type == TYPE_T_NUMERIC){
  int i;
  bool ret;
  struct numeric_variable result;
  ret = eval_numeric_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_numeric_variable((struct numeric_variable *) var -> var,
                            &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

A função que efetivamente faz a atribuição é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source);

@
\fimcodigo

E a sua implementação bastante simples é essa:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source){
  target -> value = source -> value;
}
@
\fimcodigo

Agora passemos para definir como interpretar expressões numéricas.

\subsubsecao{8.1.1. Soma e Subtração: Normal e Pitagórica}

As regras iniciais de expressões numéricas seguem abaixo:

\alinhaverbatim
<Expressão Numérica> -> <Terciário Numérico>
<Terciário Numérico> -> <Secundário Numérico> |
                        <Terciário Numérico> <T-Op> <Secundário Numérico>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

Os símbolos de \monoespaco{+} e \monoespaco{-} corespondem à adição e
subtração. O símbolo \monoespaco{++} corresponde à soma pitagórica:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

Isso pode ser facilmente calculado em C usando a função da biblioteca
padrão matemática \monoespaco{hypot}.

Já o símbolo \monoespaco{+-+} corresponde à ``subtração pitagórica''
definida abaixo:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

Na subtração pitagórica, nós vamos usar a última definição envolvendo
a multiplicação de duas raízes quadradas em nossa implementação, pois
é a forma de cálculo que minimiza erros e presença de overflows e
underflows.

Os quatro operadores acima serão aqueles com a menor precedência. Tais
operações de soma e subtração serão feitas apenas depois que todas as
outras operações forem feitas.

Vamos agora aperfeiçoar o nosso analisador léxico para identificar e
gerar os tokens destes quatro operadores. Temos que criar tipos novos,
um para cada operador. Vamos aproveitar e criar tipos novos para
``['', ``]'', ``{'' e ``}'', pois vamos também precisar no nosso
analisador sintático:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_SUM                   21 // O token simbólico '+'
#define TYPE_SUBTRACT              22 // O token simbólico '-'
#define TYPE_PYTHAGOREAN_SUM       23 // O token simbólico '++'
#define TYPE_PYTHAGOREAN_SUBTRACT  24 // O token simbólico '+-+'
#define TYPE_OPEN_BRACKETS         25 // O token simbólico '['
#define TYPE_CLOSE_BRACKETS        26 // O token simbólico ']'
#define TYPE_OPEN_BRACES           27 // O token simbólico '{'
#define TYPE_CLOSE_BRACES          28 // O token simbólico '}'
@
\fimcodigo

E os adicionamos na lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo


Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo


As expressões numéricas começam nas expressões terciárias numéricas
onde aparecem essas somas e subtrações. Pelas regras de sintaxe, o que
temos que fazer é percorrer toda a expressão até chegar ao último
símbolo de soma ou subtração que não estiver delimitado por
parênteses, colchetes ou chaves.

Para ajudar com isso, as seguintes macros vão declarar variáveis para
armazenar o aninhamento de delimitadores como parênteses e chaves, vão
checar se o aninhamento está aumentando ou diminuindo e verificar se
estamos dentro de um aninhamento ou não:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define DECLARE_NESTING_CONTROL() int nesting_parenthesis = 0, \
                                      nesting_brackets = 0, \
                                      nesting_braces = 0;
#define COUNT_NESTING(p) if(p -> type == TYPE_OPEN_PARENTHESIS)           \
                               nesting_parenthesis ++;                    \
                             else if(p -> type == TYPE_CLOSE_PARENTHESIS) \
                               nesting_parenthesis --;                    \
                             else if(p -> type == TYPE_OPEN_BRACKETS)     \
                               nesting_brackets ++;                       \
                             else if(p -> type == TYPE_CLOSE_BRACKETS)    \
                               nesting_brackets --;                       \
                             else if(p -> type == TYPE_OPEN_BRACES)       \
                               nesting_braces ++;                         \
                             else if(p -> type == TYPE_CLOSE_BRACES)      \
                               nesting_braces --;
#define IS_NOT_NESTED() (nesting_parenthesis == 0 && nesting_brackets == 0 && \
                         nesting_braces == 0)
@
\fimcodigo

Tudo que estiver do lado esquerdo
deve ser avaliado recursivamente como outra expressão terciária
numérica. Já o que estiver à direita será interpretado como uma
expressão secundária numérica. Por fim, se nenhum símbolo de soma e
subtração for encontrada, a expressão inteira será avaliada como uma
expressão secundária numérica.

Contudo, existem exceções, casos nos quais não devemos considerar os
tokens \monoespaco{+} e \monoespaco{-} como soma e subtração. Isso
ocorre quando tais símbolos estiverem no começo da expressão numérica,
ou então caso sejam precedidos por vírgula, abrir de colchetes,
símbolo de multiplicação, divisão, outro operador terciário ou então
um dos tokens seguintes que veremos mais
adiante: \monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}.

Se nós temos um token anterior (\monoespaco{prev}) e um atual
(\monoespaco{cur}), podemos checar se ele representa uma adição ou
subtração válida com a macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_OF &&                    \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo

O código abaixo interpreta as expressões numéricas terciárias e trata
a execução de operadores terciários, identificando-os corretamente com
ajuda da macro:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secundary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_PYTHAGOREAN_SUM ||
                          p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
                          IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secundary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_numeric_secundary(mf, cx, begin_secundary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM)
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT)
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM)
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Negative square root "
                " in pythagorean subtraction.\n", mf -> file,
                last_sum -> line);
#endif
        return false;
      }
    }
    return true;
  }
  else
    return eval_numeric_secundary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.2. Multiplicação e Divisão}

As regras para lidar com expressões secundárias são:

\alinhaverbatim
<Secundário Numérico> -> <Primário Numérico> |
                         <Secundário Numérico> <S-Op> <Primário Numérico>
<S-Op> -> * | /
\alinhanormal

Os operadores \monoespaco{*} e \monoespaco{/} são respectivamente a
multiplicação e divisão.

Vamos adicionar estes operadores à lista de palavras-chave reservadas
e definir seus tipos:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_MULTIPLICATION        29 // O token simbólico '*'
#define TYPE_DIVISION              30 // O token simbólico '/'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"*", "/",
@
\fimcodigo

A função que irá avaliar expressões secundárias é:

Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct numeric_variable *result);
@
\fimcodigo

E a sua definição é muito semelhante à da função que avalia expressões
terciárias, exceto que ela lida com o cálculo de multiplicação e
divisão.

Entretanto, deve-se levar em conta que o token de divisão só deve ser
tratado neste estágio se aquilo que estiver antes e depois dele não
forem dois tokens numéricos. See forem, estamos diante de uma fração e
elas serão tratadas com um nível de precedência ainda maior. Por outro
lado, se já consideramos o token retrasado como uma fração, então
neste caso sim, o símbolo será de divisão, mesmo que esteja cercado de
tokens numéricos. Assim o código \monoespaco{1/3/1/3} é interpretado
como a divisão de duas frações $(1/3)/(1/3)$:


\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_secundary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
                          p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_token_list &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ // Multiplicação ou divisão válida
         last_mul = p;
         end_secundary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secundary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secundary(mf, cx, begin_expression, end_secundary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end_token_list, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION)
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){
      if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.\n",
                mf -> file, last_mul -> line);
#endif
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else
    return eval_numeric_primary(mf, cx, begin_expression,
                                end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.3. Módulo,
    Funções Trigonométricas, Exponenciais, Piso e Valores Aleatórios
    Uniformes}

As regras de expressões numéricas primárias é:

\alinhaverbatim
<Primário Numérico> -> <Átomo Numérico> |
                       length <Primário Numérico> | (...) |
                       <Operador Numérico> <Primário Numérico>
<Operador Numérico> -> sqrt | sind | cosd | log | exp | floor |
                       uniformdeviate |
                       <Operador de Multiplicador Escalar>
<Operador de Multiplicador  Escalar> -> + | - |
                       <Token Numérico Primário antes de var>
<Token Numérico Primário> -> <Token Numérico> / <Token Numérico> |
                             <Token Numérico não sucedido por ``/ num''>
\alinhanormal

O operador \monoespaco{length}, quando sucedido por um primário
numérico significa que queremos o módulo do valor. Ele pode ter outros
significados se sucedido por outro tipo de expressão primária.

O novo operador de módulo precisa ser adicionado à lista de palavras
reservadas. Vamos adicionar também os outros operadores da lista de
operadores numéricos. Os colchetes Já pertencem à esta lista:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_LENGTH         31 // O token simbólico 'length'
#define TYPE_SQRT           32 // O token simbólico 'sqrt'
#define TYPE_SIND           33 // O token simbólico 'sind'
#define TYPE_COSD           34 // O token simbólico 'cosd'
#define TYPE_LOG            35 // O token simbólico 'log'
#define TYPE_EXP            36 // O token simbólico 'exp'
#define TYPE_FLOOR          37 // O token simbólico 'floor'
#define TYPE_UNIFORMDEVIATE 38 // O token simbólico 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

A função que interpreta uma expressão numéria primária será esta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result);
@
\fimcodigo

Podemos decidir qual regra deve ser aplicada na avaliação da expressão
numérica primária por meio de sete regras de interpretação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result){
  @<Primário Numérico: Regra 1@>
  @<Primário Numérico: Regra 2@>
  @<Primário Numérico: Regra 3@>
  @<Primário Numérico: Operadores Adicionais@>
  @<Primário Numérico: Regra 4@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

As regras são:

1) Se a expressão for composta por um único token, se começar com
``('' e terminar com ``)'' ou se for composta por três tokens, um
numérico, um \monoespaco{/} e outro numérico, então toda a expressão é
um átomo numérico:

\iniciocodigo
@<Primário Numérico: Regra 1@>=
if(begin_expression == end_expression ||
   (begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
    end_expression -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin_expression -> type == TYPE_NUMERIC &&
     begin_expression -> next != end_expression &&
     ((struct generic_token *) begin_expression -> next) -> type ==
       TYPE_DIVISION &&
     ((struct generic_token *) begin_expression -> next) -> next ==
       end_expression &&
     end_expression -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin_expression, end_expression,
                          result);
}
@
\fimcodigo

2) Se encontramos o operador \monoespaco{length}, apenas checamos se a
expressão depois dele é numérica, e se for, calculamos o seu
módulo. Se for de outro tipo, será definido depois como iremos
calcular. Isso assume que temos uma função que identifica o tipo de
uma expressão.

\iniciocodigo
@<Primário Numérico: Regra 2@>=
else if(begin_expression -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx,
                                             (struct generic_token *)
                                             begin_expression -> next,
                                             end_expression);
  if(expr_type == TYPE_T_NUMERIC){
    bool ret;
    struct numeric_variable num;
    ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                               begin_expression -> next,
                               end_expression, &num);
    if(!ret)
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Avalia 'length'@>
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "primary expression after 'length'.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;
  }
}
@
\fimcodigo

Mas como vamos reconhecer se estamos diante de uma expressão primária
que é numérica ou se estamos diante de uma que é de outro tipo?
Basicamente lendo seus tokens. Ainda não podemos definir uma função
que faz isso completamente, pois ainda temos que ver como são as
expressões primárias de outros tipos. Mas por hora vamos apresentar a
definição mais simplória de que se a expressão é composta por um único
token, se for numérico, a expressão é numérica, e se for uma variável,
é do tipo que foi declarada a variável. Isso captura o caso mais
simples de uso desta função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(begin_expr -> type == TYPE_SYMBOLIC){
      struct symbolic_token *p = (struct symbolic_token *) begin_expr;
      if(p -> var == NULL)
        return 0; // Desconhecido
      else{
        struct variable *v = (struct variable *) (p -> var);
        return v -> type;
      }
    }
  }
  else{ // TODO: Código temporário. Usar detecção mais completa
    struct generic_token *aux;
    aux = (struct generic_token *) begin_expr -> next;
    aux = (struct generic_token *) aux -> next;
    if(begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
       end_expr -> type == TYPE_CLOSE_PARENTHESIS &&
       aux != NULL &&  aux -> type == TYPE_COMMA)
      return TYPE_T_PAIR;
    //@<Descobre Tipo de Expressão Primária@>
  }
  return TYPE_T_NUMERIC;
  //return 0; // Desconhecido
}
@
\fimcodigo

3) Se encontrarmos algum dos operadores numéricos, temos um operador
numérico seguido de um primário numérico.

O primeiro dos operadores numéricos é o de raíz quadrada:

\iniciocodigo
@<Primário Numérico: Regra 3@>=
else if(begin_expression -> type == TYPE_SQRT){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value < 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Square root "
            "of negative number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;
}
@
\fimcodigo

Em seguida, temos o \monoespaco{sind}, que interpreta o próximo número
em graus (``degrees'', por isso a letra ``d'' no fim) e calcula seu
seno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SIND){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = sinf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

O cálculo do cosseno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_COSD){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Em seguida calculamos o logaritmo na base $e$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_LOG){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value <= 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Computing logarithm of "
            "non-positive number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = logf(num.value);
  return true;
}
@
\fimcodigo

E a exponencial correspondente à $exp x = e^x$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_EXP){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = expf(num.value);
  return true;
}
@
\fimcodigo

O piso de um valor:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_FLOOR){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = floorf(num.value);
  return true;
}
@
\fimcodigo

Com relação ao operador \monoespaco{uniformdeviate}, o que ele faz é
gerar um número uniforme e aleatório entre 0 e o valor passado para o
operador. O modo que usaremos para fazer isso é gerar um número
aleatório em ponto flutuante entre 0 e 1, para em seguida
multiplicá-lo pelo operando.

Gerar um número em ponto flutuante entre 0 e 1 seguindo uma
distribuição próxima à uniforme, basicamente podemos gerar um inteiro
aleatório de 64 bits e multiplicá-lo por $2^{-64}$. Nem todos os valores
em ponto flutuante podem ser gerados desta forma, estaremos ignorando
valores menores que $2^{-64}$ e o arredondamento fará com que alguns
números mais próximos de 1 sejam mais comuns, embora a densidade
destes números mais comuns também seja menor. Entretanto, o resultado
será suficientemente próximo para nossos propósitos:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_UNIFORMDEVIATE){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;
  }
  return true;
}
@
\fimcodigo

O próximo operador numérico é o símbolo de \monoespaco{+}. Este
símbolo significa uma multiplicação por 1, e pode ser ignorado:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SUM){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  return true;
}
@
\fimcodigo

Já se tivermos um símbolo de \monoespaco{-}, então isso significa uma
multiplicação por -1:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SUBTRACT){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  result -> value *= -1;
  return true;
}
@
\fimcodigo


4) Nos demais casos, temos uma multiplicação escalar em que o escalar
é um token numérico primário, que não é sucedido
por \monoespaco{+}, \monoespaco{-} ou por outro token numérico. Para
lidar com isso, teremos que identificar o começo e o fim do token
numérico primário. Pelas regras ele é um único token numérico, ou
então três tokens (dois tokens numéricos separados pelo
token \monoespaco{/} representando uma fração). Depois de realizar a
separação, a primeira parte é multiplicada pela segunda (que é
interpretada como primário numérico):

\iniciocodigo
@<Primário Numérico: Regra 4@>=
else{
  bool ret;
  float token_value;
  struct generic_token *after_token;
  if(begin_expression -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  token_value = ((struct numeric_token *) begin_expression) -> value;
  after_token = (struct generic_token *) (begin_expression -> next);
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    after_token = (struct generic_token *) (after_token -> next);
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = (struct generic_token *) (after_token -> next);
  }
  ret = eval_numeric_primary(mf, cx, after_token, end_expression, result);
  if(!ret)
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Números Isolados e Valores Aeeatórios Normais}

As regras finais para as expressões numéricas que iremos tratar são:

\alinhaverbatim
<Átomo Numérico> -> <Variável Numérica> |
                    <Token Numérico Primário> |
                    normaldeviate |
                    ( <Expressão Numérica> )
\alinhanormal

O único token novo a ser tratado é \monoespaco{normaldeviate}:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_NORMALDEVIATE  39 // O token simbólico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"normaldeviate",
@
\fimcodigo

Este operador serve para gerar um novo número aleatório com uma
distribuição normal com média 0 e desvio padrão 1.

A função que interpreta átomos numéricos é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result);
@
\fimcodigo

Vamos decidir qual regra aplicar para interpretar o átomo primeiro com
base nele ser um único token ou não. E depois, aplicamos diferentes
regras em cada caso:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result){
  if(begin_expression == end_expression){
    @<Átomo Numérico: Regra 1@>
    @<Átomo Numérico: Regra 2@>
    @<Átomo Numérico: Regra 3@>
  }
  else{
    @<Átomo Numérico: Regra 4@>
    @<Átomo Numérico: Regra 5@>
  }
  return false;
}
@

1) Se temos um único token e ele é um token numérico, basta retornar o
seu valor:

\iniciocodigo
@<Átomo Numérico: Regra 1@>=
if(begin_expression -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin_expression) -> value;
  return true;
}
@
\fimcodigo

2) Se temos um único token e ele é uma variável, retornamos o conteúdo
da variável. Mas temos que checar se ela foi declarada, se é numérica
e se foi inicializada:

\iniciocodigo
@<Átomo Numérico: Regra 2@>=
if(begin_expression -> type == TYPE_SYMBOLIC){
  struct numeric_variable *var;
  var = ((struct symbolic_token *) begin_expression) -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric variable "
            "'%s' in numeric expression.\n", mf -> file,
            begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(isnan(var -> value)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

3) Por fim, se temos um único token e ele é \monoespaco{normaldeviate},
então temos que gerar um número aleatório de uma distribuição
normal. Dado que temos uma função que gera números aleatórios, podemos
fazer isso procedendo da seguinte forma:

a) Geramos dois números aleatórios e uniformes entre -1 e 1, os quais
chamaremos de $u$ e $v$. Isso pode ser feito obtendo 64 bits,
multiplicando os 63 primeiros por $2^{-63}$ e usando o último bit para
definir o sinal. O resultado é suficientemente próximo de uniforme
para nossos propósitos.

b) Se $u^2+v^2 \geq 1$, isso significa que eles correspondem a pontos
fora de um círculo de raio 1. Neste caso, os descartamos e voltamos ao
passo 1. Também voltamos ao passo um se ambos forem zero, pois neste
caso o método não funcionaria.

c) Isso permite gerar dois valores que terão uma distribuição
uniforme:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

Um dos valores pode ser retornado. O outro pode ser armazenado na
estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Inicialmente a estrutura não tem nenhum valor destes armazenado, vamos
armazenar nela só depois de usarmos o método acima:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

Então, quando precisarmos gerar um valor aleatório de uma distribuição
normal, sempre verificamos se existe um valor pré-obtido, e se não nós
geramos os dois valores:

\iniciocodigo
@<Átomo Numérico: Regra 3@>=
if(begin_expression -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    random_bits = random_func();
    do{
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Agora os casos em que o átomo numérico tem mais de um token. O
primeiro caso é quanto o primeiro token é ``('' e o último é
``)''. Neste caso, a parte interna aos parênteses é interpretada como
uma expressão numérica:

\iniciocodigo
@<Átomo Numérico: Regra 4@>=
if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
   end_expression -> type == TYPE_CLOSE_PARENTHESIS){
   bool ret;
   struct generic_token *p = begin_expression;
   while(p -> next != end_expression)
     p = (struct generic_token *) p -> next;
   if(p == begin_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.",
            mf -> file, begin_expression -> line);
#endif
     return false;
   }
   ret = eval_numeric_expression(mf, cx, (struct generic_token *)
                                         begin_expression -> next, p,
                                         result);
   if(!ret)
     return false;
   return true;
}
@
\fimcodigo

5) Finalmente, o caso em que o átomo numérico é uma fração composta
por um token numérico, \monoespaco{/} e outro token numérico. O
resultado deve ser obtido dividindo ambos os tokens numéricos:

\iniciocodigo
@<Átomo Numérico: Regra 5@>=
if(begin_expression -> type == TYPE_NUMERIC &&
   end_expression -> type == TYPE_NUMERIC &&
   ((struct generic_token * ) begin_expression -> next) -> type ==
   TYPE_DIVISION){
  result -> value = ((struct numeric_token *) begin_expression) -> value /
           ((struct numeric_token *) end_expression) -> value;
  return true;
}
@
\fimcodigo


\subsecao{8.2. Atribuições e Expressões de Pares}

Para realizar a atribuição de pares a variáveis do tipo certo, usamos
o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Par@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pair_variable((struct pair_variable *) var -> var, &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

A declaração da função faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source){
  target -> x = source -> x;
  target -> y = source -> y;
}
@
\fimcodigo

Vamos agora à avaliação de expressões de pares.

\subsubsecao{8.2.1. Soma e Subtração}

As regras gramaticais para as expressões de pares começam com:

\alinhaverbatim
<Expressão de Par> -> <Terciário de Par>
<Terciário de Par> -> <Secundário de Par> | (...) |
                      <Terciário de Par> <PT-Op> <Secundário de Par>
<PT-Op> -> + | -
\alinhanormal

A soma e subtração é tratada exatamente como se espera de uma soma e
subtração de vetores.

A função que avalia expressões de pares é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result);
@
\fimcodigo

O método de avaliar as expressões de pares terciárias não é diferente
do que já fizemos com as expressões numéricas. Apenas temos menos
operadores terciários aqui.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secundary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct pair_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secundary = (struct generic_token *) (last_sum -> next);
    eval_pair_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_pair_secundary(mf, cx, begin_secundary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM){
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else
    return eval_pair_secundary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo


\subsubsecao{8.2.2. Transformações, Multiplicação e Divisão Escalar}

A gramática para expressões de pares secundárias é:

\alinhaverbatim
<Secundário de Par> -> <Primário de Par> |
                       <Par Secundário><Mul ou Div><Numérico Primário> |
                       <Secundário Numérico> * <Primário de Par> |
                       <Secundário de Par><Transformador>
<Mul ou Div> -> * | /
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário>
\alinhanormal

Vamos adicionar as sete novas palavras-chave representando
transformadores:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_ROTATED  40 // O token simbólico 'rotated'
#define TYPE_SCALED   41 // O token simbólico 'scaled'
#define TYPE_SHIFTED  42 // O token simbólico 'shifted'
#define TYPE_SLANTED  43 // O token simbólico 'slanted'
#define TYPE_XSCALED  44 // O token simbólico 'xscaled'
#define TYPE_YSCALED  45 // O token simbólico 'yscaled'
#define TYPE_ZSCALED  46 // O token simbólico 'zscaled'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo

A declaração da função que avaliará expressões secundárias de pares:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_secundary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct pair_variable *result);
@
\fimcodigo


Interpretar uma expressão secundária aqui é similar ao que fizemos
para as expressões numéricas. Também devemos percorrer a lista de
tokens até achar a operação secundária mais à direita, ignorando
aquilo que está aninhado entre parênteses e colchetes. Deve-se seguir
as mesmas regras para determinar se o \monoespaco{/} é mesmo uma
divisão ou se é uma fração. Mas como aqui temos um total de nove
operadores secundários, incluindo os transformadores Devido à
quantidade, vamos mostrar separadamente cada um deles ao invés de
colocá-los todos neste bloco de código abaixo:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct pair_variable *result){
  struct generic_token *end_secundary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ //  Divisão ou operadores válidos
         last_mul = p;
         end_secundary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secundary != NULL){
    bool ret;
    begin_primary = (struct generic_token *) (last_mul -> next);
    @<Operador Secundário de Pares: Multiplicação@>
    @<Operador Secundário de Pares: Divisão@>
    @<Operador Secundário de Pares: Rotação@>
    @<Operador Secundário de Pares: Escala@>
    @<Operador Secundário de Pares: Deslocamento@>
    @<Operador Secundário de Pares: Inclinação@>
    @<Operador Secundário de Pares: X-Escala@>
    @<Operador Secundário de Pares: Y-Escala@>
    @<Operador Secundário de Pares: Z-Escala@>
  }
  else
    return eval_pair_primary(mf, cx, begin_expression,
                             end_expression, result);
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O primeiro operador é o de multiplicação. Note que podemos ter dois
tipos de multiplicação: um par por um numérico ou um numérico por um
par. Para identificar qual dos dois tipos se aplica, devemos examinar
o tipo da expressão à direita do operador. Ela é uma expressão
primária e nós temos uma função que descobre o tipo de expressões
primárias:

\iniciocodigo
@<Operador Secundário de Pares: Multiplicação@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end_expression) ==
     TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    ret = eval_numeric_secundary(mf, cx, begin_expression, end_secundary,
                                 &a);
    if(!ret)
      return false;
    ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary,
                              &a);
    if(!ret)
      return false;
    ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }
}
@
\fimcodigo

Se temos uma divisão, então sempre será um par dividido por um
numérico. Devemos gerar erro em caso de divisão por zero:

\iniciocodigo
@<Operador Secundário de Pares: Divisão@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.",
            mf -> file, last_mul -> line);
#endif
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

Se temos uma rotação, rotacionamos nosso par no sentido anti-horário
em relação à origem, interpretando o ângulo em graus, não radianos:

\iniciocodigo
@<Operador Secundário de Pares: Rotação@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  theta = 0.0174533 * b.value;
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

Se temos uma mudança de escala, isso é sinônimo a uma multiplicação:

\iniciocodigo
@<Operador Secundário de Pares: Escala@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Um deslocamento é igual a uma soma, mas tem uma ordem de precedência
maior:

\iniciocodigo
@<Operador Secundário de Pares: Deslocamento@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

O operador de inclinação desloca mais à direita um ponto quanto mais
acima do eixo $x$ ele está e mais à esquerda quanto mais abaixo do
eixo $x$ ele está:

\iniciocodigo
@<Operador Secundário de Pares: Inclinação@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Mudança de escala no eixo $x$ multiplica um escalar apenas pelo
primeiro valor do par:

\iniciocodigo
@<Operador Secundário de Pares: X-Escala@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Assim como no eixo $y$ multiplica o escalar só pelo segundo valor do
par:

\iniciocodigo
@<Operador Secundário de Pares: Y-Escala@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Por fim, a mudança de escala $z$ înterpreta dois pares como números
complexos e os multiplica:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Operador Secundário de Pares: Z-Escala@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Valores Intermediários de Pares, Literais e Variáveis}

As regras gramaticais finais para a expressão de pares é:

\alinhaverbatim
<Primário de Par> -> <Variável de Par> |
                     ( <Expressão Numérica> , <Expressão Numérica> ) |
                     ( <Expressão de Par> ) |
                     (...) |
                     <Átomo Numérico>[<Expressão de Par,
                                      <Expressão de Par]  |
                     <Operador de Multiplicação Escalar><Primário de Par>
\alinhanormal

A novidade é a construção do tipo $a[b, c]$ onde $b$ e $c$ são
pares. Ela representa um valor intermediário entre os
pontos. Basicamente é avaliado como $a(b+c)$, de modo que $.5[b,c]$
representa o meio do caminho entre os dois pontos.

As outras regras são análogas às que já vimos na gramática de
expressões numéricas.

A função que avaliará expressões de pares primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result);
@
\fimcodigo

E cada uma das cinco regras gramaticais acima será testada
separadamente para sabermos qual regra devemos aplicar ao encontrar
uma expressão primária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result){
  if(begin_expression == end_expression){
    @<Primário de Par: Regra 1@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Primário de Par: Regra 2@>
    @<Primário de Par: Regra 3@>
  }
  @<Primário de Par: Outras Regras a Definir Depois@>
  @<Primário de Par: Regra 4@>
  @<Primário de Par: Regra 5@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

A primeira regra será aplicada quando temos um único token na
expressão. O único caso em que isso ocorre é quando a expressão é uma
variável de par:

\iniciocodigo
@<Primário de Par: Regra 1@>=
struct symbolic_token *tok = (struct symbolic_token *) begin_expression;
struct pair_variable *var;
printf("REGRA 1 (%d)\n", tok -> type);
if(tok -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable token "
          "in pair expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
var = (struct pair_variable *) tok -> var;
if(var == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
          "'%s'.\n", mf -> file, begin_expression -> line, tok -> value);
#endif
  return false;
}
if(var -> type != TYPE_T_PAIR){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Non-pair variable "
          "'%s' in pair expression.\n", mf -> file,
          begin_expression -> line, tok -> value);
#endif
  return false;
}
result -> x = var -> x;
result -> y = var -> y;
return true;
@
\fimcodigo

Se a expressão é delimitada por parênteses, nós tanto podemos estar
diante de uma representação literal de um par ($(a, b)$) como podemos
estar diante de parênteses com uma expressão de par completa dentro
dele, ao invés de um literal. Podemos diferenciar os dois casos pela
vírgula interna no parênteses, a qual está no mesmo escopo que $a$ e
$b$, não deve estar dentro de outros parênteses e colchetes.

\iniciocodigo
@<Primário de Par: Regra 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  begin_a = (struct generic_token *) begin_expression -> next;
  end_a = begin_a;
  DECLARE_NESTING_CONTROL();
  bool literal = true;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    bool ret;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    ret = eval_numeric_expression(mf, cx, begin_a, end_a, &a);
    if(!ret)
      return false;
    ret = eval_numeric_expression(mf, cx, begin_b, end_b, &b);
    if(!ret)
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

No código acima nós identificamos se estamos diante de um literal pela
presença da vírgula e nós identificamos isso marcando na variável
booleana \monoespaco{literal}. Portanto, se esta variável não for
verdadeira, imediatamente após o último \monoespaco{if} acima,
executamos o \monoespaco{else} como a próxima regra:

\iniciocodigo
@<Primário de Par: Regra 3@>=
else{
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
}
@
\fimcodigo

Se o último token for um \monoespaco{]}, então temos uma construção do
tipo $a[b,c]$. Nossa tarefa é separar essas três partes $a$, $b$ e
$c$, interpretá-las e retornar $a(b+c)$:

\iniciocodigo
@<Primário de Par: Regra 4@>=
if(end_expression -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  DECLARE_NESTING_CONTROL();
  begin_a = begin_expression;
  end_a = begin_a;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type ==
        TYPE_OPEN_BRACKETS)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_b = (struct generic_token *) end_a -> next;
  begin_b = (struct generic_token *) begin_b -> next;
  if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_b = begin_b;
  while(end_b != end_expression){
    COUNT_NESTING(end_b);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_b -> next) -> type == TYPE_COMMA)
      break;
    if(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_c = (struct generic_token *) end_b -> next;
  begin_c = (struct generic_token *) begin_c -> next;
  if(begin_c == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_c = begin_c;
  while(end_c -> next != end_expression)
    end_c = (struct generic_token *) end_c -> next;
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c))
    return false;
  result -> x = (b.x + c.x) * a.value;
  result -> y = (b.y + c.y) * a.value;
  return true;
}
@
\fimcodigo

A última regra é quando temos um operador de multiplicação escalar e
um par. O operador pode ser um token
de \monoespaco{+}, \monoespaco{-}, um único token numérico, ou então
uma fração:

% Primario par

\iniciocodigo
@<Primário de Par: Regra 5@>=
else{
  bool ret;
  if(begin_expression -> type == TYPE_SUM)
    return eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
  else if(begin_expression -> type == TYPE_SUBTRACT){
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin_expression -> type == TYPE_NUMERIC){
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin_expression) -> value;
    tok = (struct generic_token *) begin_expression -> next;
    if(tok -> type == TYPE_DIVISION){
      tok = (struct generic_token *) begin_expression -> next;
      if(tok == end_expression || tok -> next == end_expression ||
         tok -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "expression.\n ", mf -> file, begin_expression -> line);
#endif
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = (struct generic_token *) tok -> next;
    }
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pares em Expressões Numéricas}

Subexpressões numéricas podem aparecer dentro de expressões de
pares. Por exemplo, em $a[b,c]$ onde $a$ é um átomo numérico. Da mesma
forma, subexpressões de pares podem aparecer em expressões
numéricas. Mas não definimos os casos quando definimos as expressões
numéricas porque então não tínhamos ainda definido como avaliar
expressões de pares. Existem quatro operadores numéricos primários que
envolvem avaliar pares:

\alinhaverbatim
<Primário Numérico> -> length <Par Primário> | xpart <Par Primário> |
                       ypart <Par Primário> | angle <Par Primário>
\alinhanormal

Isso requer definir os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_XPART  47 // O token simbólico 'xpart'
#define TYPE_YPART  48 // O token simbólico 'ypart'
#define TYPE_ANGLE  49 // O token simbólico 'angle'
@
\fimcodigo

Correspondentes às seguintes palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

O primeiro caso, que não precisou de um token
novo, \monoespaco{length} já era usado para obter o módulo de números
e havíamos avisado que ele poderia ser usado para outros tipos. No
caso de pares, ele mede a norma euclideana deles:

\iniciocodigo
@<Avalia 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) hypot(p.x * p.x, p.y * p.y);
  return true;
}
@
\fimcodigo

O operador \monoespaco{xpart} simplesmente retorna o primeiro valor de
um par:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin_expression -> type == TYPE_XPART){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = p.x;
  return true;
}
@
\fimcodigo

Enquanto o operador \monoespaco{ypart} retorna o segundo valor de um
par:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type == TYPE_YPART){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = p.y;
  return true;
}
@
\fimcodigo

Por fim, o último operador, \monoespaco{angle} retorna o ângulo de um
par. É o ângulo do segmento que conecta a origem ao par em relação ao
segmento que conecta a origem à $(1,0)$. Um erro deve ser gerado se
tentar medir o ângulo de $(0,0)$:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin_expression -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Measuring the angle "
            "of (0,0).\n ", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = (float) asin(p.y / (hypot(p.x * p.x, p.y * p.y)));
  result -> value *= 57.2958; // Radianos para graus
  return true;
}
@
\fimcodigo

\subsecao{8.3. Atribuições e Expressões de Caminhos}

Para realizar a atribuição de caminhos a variáveis do tipo certo,
usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Caminho@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  if(!eval_path_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_path_variable(mf, (struct path_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &result, false);
}
@
\fimcodigo

A declaração da função faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> length != -1 && disalloc != NULL)
    path_recursive_free(disalloc, target, false);
  recursive_copy_points(alloc, &target, source, false);
}
@
\fimcodigo

Copiar um caminho recursivamente significa alocar espaço para o novo
caminho a ser copiado e copiar seus dados. Ao copiar seus pontos,
devemos também checar se há outros subcaminhos que devem ser copiados
recursivamente. Para fazer isso, usamos a seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target){
  int i;
  if(alloc_target)
    *target = (struct path_variable *) alloc(sizeof(struct path_variable));
  (*target) -> cyclic = source -> cyclic;
  (*target) -> length = source -> length;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> length);
  for(i = 0; i < (*target) -> length; i ++){
    memcpy(&((*target) -> points[i]), &(source -> points[i]),
           sizeof(struct path_points));
    if(source -> points[i].subpath != NULL)
      recursive_copy_points(alloc, (struct path_variable **)
                                   &((*target) -> points[i].subpath),
                            source -> points[i].subpath, true);
  }
}
@
\fimcodigo

Vejamos agora a expressões que existem para expressões de caminhos:

\subsubsecao{8.3.1. Junção de Caminhos}

A gramática para a expressão de caminhos começa com:

\alinhaverbatim
<Expressão de Caminho> -> <Expressão de Par> | <Terciário de Caminho> |
                          <Sub-expressão de Caminho><Especificador de Direção> |
                          <Sub-expressão de Caminho><Junção de Caminho> cycle
<Junção de Caminho> -> <Especificador de Direção><Junção Básica>
                       <Especificador de Direção>
<Junção Básica> -> & | .. | .. <Tensão> .. | .. <Controles> ..
<Tensão> -> tension <Quantidade de Tensão> |
            tension <Quantidade de Tensão> and <Quantidade de Tensão>
<Quantidade de Tensão> -> <Primário Numérico> | atleast <Primário Numérico>
<Controles> -> controls <Par Primário> |
               controls <Par Primário> and <Par Primário>
<Especificação de Direção> -> Vazio |
                              { <Expressão de Par } |
                              { <Expressão Numérica> , <Expressão Numérica> }
<Sub-expressão de Caminho> -> <Expressão de Caminho> |
                              <Sub-expressão de Caminho><Junção de Caminho>
                              <Terciário de Caminho>
\alinhanormal

Tudo isso requer que registremos os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_CYCLE          50 // O token simbólico 'cycle'
#define TYPE_AMPERSAND      51 // O token simbólico '&'
#define TYPE_JOIN           52 // O token simbólico '..'
#define TYPE_TENSION        53 // O token simbólico 'tension'
#define TYPE_AND            54 // O token simbólico 'and'
#define TYPE_ATLEAST        55 // O token simbólico 'atleast'
#define TYPE_CONTROLS       56 // O token simbólico 'controls'
#define TYPE_CURL           57 // O token simbólico 'curl'
                               // (ainda não suportado)
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"cycle", "&", "..", "tension", "and", "atleast", "controls", "curl",
@
\fimcodigo

O que as regras gramaticais revelam é que toda expressão de caminho é
formado pela junção de vários outros sub-caminhos. Se não existir
nenhuma junção, então nosso caminho é um par, que é considerado um
caminho de um único ponto.

Uma das coisas que temos a fazer então é contar quantas junções
existem em uma expressão de caminho. Realizar a contagem pode ser
feito com a seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end);
@
\fimcodigo

A função funciona contando o número de ``\&'' e também contando os
``..'' quando eles aparecem sozinhos ou quando eles aparecem pela
segunda vez dentro de uma junção que especifica pontos de controle ou
tensão:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end){
  int count = 0;
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin;
  while(p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_AMPERSAND)
        count ++;
      else if(p -> type == TYPE_JOIN){
        struct generic_token *next = (struct generic_token *) p -> next;
        if(p == end || (next -> type !=  TYPE_TENSION &&
                        next -> type != TYPE_CONTROLS))
          count ++;
      }
    }
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }
  return count;
}
@
\fimcodigo

Agora podemos começar a tratar as expressões:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result);
@
\fimcodigo


Saber o número de junções é o primeiro passo para saber o tamanho da
variável de caminho que estamos gerando e saber como alocar espaço
para ela. O número de elementos (pontos e sub-caminhos) de uma
variável de caminho é sempre igual ao número de junções mais um:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result){
  int expected_length;
  int number_of_joins = count_path_joins(begin_expression, end_expression);
  expected_length = number_of_joins + 1;
  @<Expressão de Caminho: Quando Não Há Junção@>
  @<Expressão de Caminho: Alocar Variável de Caminho@>
  @<Expressão de Caminho: Itera sobre Junções@>
  return false;
}
@
\fimcodigo

E se o número de junções for zero? Neste caso, podemos estar diante de
uma expressão de par, ou de uma expressão terciária de caminho. De
qualquer forma, pode haver um ou mais especificador de direção depois
da expressão, o qual precisa ser ignorado. Podemos checar se temos
especificadores de direção checando se o último token é um
``$\}$''. Se for o caso, mudamos a posição do fim da expressão para
imediatamente antes do primeiro especificador de direção:

\iniciocodigo
@<Expressão de Caminho: Quando Não Há Junção@>=
if(number_of_joins == 0){
  if(end_expression -> type == TYPE_CLOSE_BRACES){
    struct generic_token *p = begin_expression;
    DECLARE_NESTING_CONTROL();
    while(p != end_expression){
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() &&
         ((struct generic_token *) p -> next) -> type == TYPE_OPEN_BRACES)
        break;
      p = (struct generic_token *) p -> next;
    }
    end_expression = p;
  }
  return eval_path_tertiary(mf, cx, begin_expression, end_expression,
                            result);
}
@
\fimcodigo

Se existir uma ou mais junções, então caberá a nós criar uma nova
variável de caminho alocando as estruturas necessárias para ela. O que
temos a fazer é alocar nela um número de pontos igual à
variável \monoespaco{expected\_length}:

\iniciocodigo
@<Expressão de Caminho: Alocar Variável de Caminho@>=
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points) *
                     expected_length);
if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
          begin_expression -> line);
#endif
    return false;
}
result -> length = 0; // Inicialização
result -> points[0].x = NAN;
@
\fimcodigo

Agora temos que interpretar todas as junções. Temos que iterar sobre
cada junção presente na expressão, as quais possuem o formato:

$$
z_1{d} j {e}z_2
$$

Então vamos usar variáveis para indicar o começo e o fim de cada parte
à medida que iteramos. Vamos criar um laço onde iremos iterar sobre
cada uma das junções no formato acima para interpretá-las:

\iniciocodigo
@<Expressão de Caminho: Itera sobre Junções@>=
{
  struct generic_token *begin_z1, *end_z1 = NULL, *begin_z2, *end_z2;
  struct generic_token *begin_d = NULL, *end_d = NULL, *begin_e, *end_e;
  struct generic_token * begin_j, *end_j;
  struct path_points *z1_point = NULL, *z2_point = NULL;
  @<Expressão de Caminho: Declaração de Variáveis Adicionais@>
  begin_z1 = begin_expression;
  while(begin_z1 != end_expression || result -> length < expected_length){
    @<Expressão de Caminho: Separa Tokens da Junção@>
    @<Expressão de Caminho: Interpreta Extremidades da Junção@>
    @<Expressão de Caminho: Interpreta Direção se Existir@>
    @<Expressão de Caminho: Interpreta Junção@>
    @<Expressão de Caminho: Decide Forma da Curva@>
    @<Expressão de Caminho: Fim de Cada Iteração@>
    begin_z1 = begin_z2;
    end_z1 = end_z2;
  }
}
@
\fimcodigo

Para delimitar o primeiro elemento $z_1$, na primeira vez quando ainda
estamos no começo da expressão, basta avançarmos os tokens até
acharmos o primeiro ``{'', ``..'' ou ``\&'' fora de qualquer
parênteses ou colchetes. Nas demais vezes, o primeiro elemento $z_1$
já começa uma nova iteração delimitado como indicado no código acima.

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>=
if(begin_z1 == begin_expression){
  DECLARE_NESTING_CONTROL();
  int next_type;
  while(end_z1 != end_expression){
    COUNT_NESTING(end_z1);
    next_type = ((struct generic_token *) end_z1 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND))
      break;
    end_z1 = (struct generic_token *) end_z1 -> next;
  }
}
@
\fimcodigo

Agora vamos delimitar o primeiro especificador de direção. Primeiro
checamos se estamos no fim da expressão. Se estivermos, interrompemos
o laço e saímos, pois já terminamos de obter o resultado da expressão
e não haverá mais delimitador nenhum. Caso contrário, lemos o próximo
token para ver se é um ``$\{$''. Se não for, não há o primeiro
especificador de direção. Se for, então delimitamos ele até acharmos o
próximo ``$\}$'':

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_z1 == end_expression)
  return true;
begin_d = (struct generic_token *) end_z1 -> next;
if(begin_d -> type != TYPE_OPEN_BRACES){
  begin_d = NULL;
  end_d = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_d = begin_d;
  while(end_d  != end_expression){
    COUNT_NESTING(end_d);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) (end_d -> next)) -> type == TYPE_CLOSE_BRACES)
      break;
    end_d = (struct generic_token *) end_d -> next;
  }
  if(end_d != end_expression)
    end_d = (struct generic_token *) end_d -> next;
  if(begin_d == end_d){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_d -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Agora vamos delimitar a junção. Se ela for um ``\&'', ela corresponde
a um único token. Se for um ``..'', devemos checar o próximo token
para identificar se temos um ``\monoespaco{controls}'' ou
``\monoespaco{tension}''. Em caso afirmativo, teremos que delimitar a
junção englobando do primeiro ``..'' até o segundo ``..''. Em caso
negativo, a junção é somente um token ``..''.

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_d == NULL)
  begin_j = (struct generic_token *) end_z1 -> next;
else{
  if(end_d == end_expression)
    return true;
  begin_j = (struct generic_token *) end_d -> next;
}
end_j = begin_j;
if(begin_j -> type == TYPE_JOIN){
  struct generic_token *next_token;
  next_token = (struct generic_token *) begin_j -> next;
  if(next_token -> type == TYPE_CONTROLS || next_token -> type == TYPE_TENSION){
    DECLARE_NESTING_CONTROL();
    end_j = next_token;
    while(end_j != end_expression){
      COUNT_NESTING(end_j);
      if(IS_NOT_NESTED() && end_j -> type != TYPE_JOIN)
        break;
      end_j = (struct generic_token *) end_j -> next;
    }
  }
}
else if(begin_j -> type != TYPE_AMPERSAND){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, begin_j -> line);
#endif
  return false;
}
@
\fimcodigo

O próximo delimitador de direção pode existir ou não dependendo de
termos um token ``$\{$'' após a junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_j == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, end_j -> line);
#endif
  return false;
}
begin_e = (struct generic_token *) end_j -> next;
if(begin_e -> type != TYPE_OPEN_BRACES){
  begin_e = NULL;
  end_e = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_e = begin_e;
  while(end_e  != end_expression){
    COUNT_NESTING(end_e);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) (end_e -> next)) ->  type == TYPE_CLOSE_BRACES)
      break;
    end_e = (struct generic_token *) end_e -> next;
  }
  if(end_e != end_expression)
    end_e = (struct generic_token *) end_e -> next;
  if(begin_e == end_e){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_e -> line);
#endif
    return false;
  }
}
@
\fimcodigo

E por fim, o último elemento da junção é o próximo ponto da junção,
que seria uma expressão de caminho terciária. Este próximo elemento
tem seu fim delimitado pelo fim da expressão, por um token de abrir
chaves, ou pelo começo da próxima junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
{
  DECLARE_NESTING_CONTROL();
  int next_type;
  if(end_e == NULL)
    begin_z2 = (struct generic_token *) end_j -> next;
  else{
    if(end_e == end_expression)
      return true;
    begin_z2 = (struct generic_token *) end_e -> next;
  }
  end_z2 = begin_z2;
  while(end_z2 != end_expression){
    COUNT_NESTING(end_z2);
    next_type = ((struct generic_token *) end_z2 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND))
      break;
    end_z2 = (struct generic_token *) end_z2 -> next;
  }
}
@
\fimcodigo

Uma vez que tenhamos identificado cada parte da junção, temos que
interpretar cada uma delas. Primeiro devemos identificar os pontos das
extremidades da junção e copiá-las para o resultado da expressão. Para
isso primeiro interpretaremos $z_1$, a primeira extremidade de
junção. Ela precisa ser interpretada só no começo da expressão, nos
demais casos ela já foi obtida na iteração anterior:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>=
if(begin_z1 == begin_expression){
  bool ret;
  struct path_variable z1;
  ret = eval_path_tertiary(mf, cx, begin_z1, end_z1, &z1);
  if(!ret)
    return false;
  if(z1.length == 1 && z1.points[0].subpath == 0){
    result -> points[0].subpath = NULL;
    result -> points[0].x = z1.points[0].x;
    result -> points[0].y = z1.points[0].y;
  }
  else
    recursive_copy_points(temporary_alloc, (struct path_variable **)
                                           &(result -> points[0].subpath), &z1,
                                           true);
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z1, false);
}
@
\fimcodigo

E devemos fazer o mesmo com a outra extremidade da junção: $z_2$. Para
este caso, devemos levar em conta que podemos estar diante de um
token \monoespaco{cycle} ou de um ponto ou sub-caminho normal. Se for um
token \monoespaco{cycle}, devemos copiar o primeiro ponto. Caso
contrário, fazemos tal como fizemos para obter o $z_1$:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  struct path_points *p = result -> points;
  while(p[0].subpath != NULL)
    p = ((struct path_variable *) p[0].subpath) -> points;
  result -> points[result -> length].subpath = NULL;
  result -> points[result -> length].x = p[0].x;
  result -> points[result -> length].y = p[0].y;
}
else{
  bool ret;
  struct path_variable z2;
  ret = eval_path_tertiary(mf, cx, begin_z2, end_z2, &z2);
  if(!ret)
    return false;
  if(z2.length == 1 && z2.points[0].subpath == 0){
    result -> points[result -> length].subpath = NULL;
    result -> points[result -> length].x = z2.points[0].x;
    result -> points[result -> length].y = z2.points[0].y;
  }
  else
    recursive_copy_points(temporary_alloc,
                         (struct path_variable **)
                         &(result -> points[result -> length].subpath), &z2, true);
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z2, false);
}
@
\fimcodigo

Após rodarmos o código acima, nossa variável de resultado da expressão
que estamos montando já possui todos os pontos de extremidade desta
junção ajustados. Mas nós ainda não temos os pontos de controle. Mas
antes de poder calculá-los, vamos ajustar os
ponteiros \monoespaco{z1\_point} e \monoespaco{z2\_point} para apontar
para os pontos de extremidade da junção atual, obtendo tal informação
da variável \monoespaco{result} que estamos preenchendo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
z1_point = &(result -> points[result -> length - 2]);
while(z1_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z1_point -> subpath;
  z1_point = &(p -> points[p -> length - 1]);
}
z2_point = &(result -> points[result -> length - 1]);
while(z2_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z2_point -> subpath;
  z2_point = &(p -> points[0]);
}
@
\fimcodigo

Agora temos que interpretar os dois especificadores de direção. Eles
podem ser vazios (equivalente a ter uma direção $(0, 0)$) ou podem ser
um par especificando um vetor de direção.

Vamos armazenar os especificadores em variáveis \monoespaco{(w0\_x,
w0\_y)} e \monoespaco{(w1\_x, w1\_y)}.  Também vamos armazenar estes
valores da iteração anterior e também da próxima, já que em alguns
casos será necessário lembrar o que havia antes ou espiar o que existe
depois para montarmos uma curva levando em conta um contexto maior:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>=
float w0_x = NAN, w0_y = NAN, w1_x = NAN, w1_y = NAN;
float prev_w_x = NAN, prev_w_y = NAN;
float next_w_x = NAN, next_w_y = NAN;
@
\fimcodigo

Durante a iteração em que estamos delimitando e interpretando os
valores presentes na junção devemos reinicializar tais valores. O
primeiro dos especificadores atuais não precisa ser lido novamente e
só herda valores já armazenados se por algum motivo ele foi lido
anteriormente e está armazenado na variável que na iteração anterior
armazenou o que seria o próximo valor. Depois disso, os próximos
valores são apagados. E por fim, lemos o segundo especificador de
direção:

\iniciocodigo
@<Expressão de Caminho: Interpreta Direção se Existir@>=
w0_x = w0_y = w1_x = w1_y = NAN;
if(!isnan(next_w_x)){
  w0_x = next_w_x;
  w0_y = next_w_y;
}
else if(!eval_direction_specifier(mf, cx, begin_d, end_d, &w0_x, &w0_y))
  return false;
next_w_x = next_w_y = NAN;
if(!eval_direction_specifier(mf, cx, begin_e, end_e, &w1_x, &w1_y))
  return false;
@
\fimcodigo

A função que avalia os especificadores de direção é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y);
@
\fimcodigo

E ela funciona checando quatro casos diferentes: quando não há
especificador nenhum, quando ele é especificador de curvatura, quando
é um de direção no formato de dois números e quando é um de direção no
formato de um par:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y){
  @<Especificador de Direção: Caso 1@>
  @<Especificador de Direção: Caso 2@>
  @<Especificador de Direção: Caso 3@>
  return false;
}
@
\fimcodigo

Quando um especificador não existe, não marcamos nada e retornamos,
deixando como indefinidos os valores:

\iniciocodigo
@<Especificador de Direção: Caso 1@>=
if(begin == NULL || end == NULL){
  return true;
}
@
\fimcodigo

Agora devemos checar se temos um caso do tipo ``$\{ a , b\}$'' onde
$a$ e $b$ são números. Para isso, tentaremos delimitar os tokens de
$a$ e $b$ procurando pela vírgula. Mas somente se a vírgula for
encontrada, iremos tratar a especificação desta forma:

\iniciocodigo
@<Especificador de Direção: Caso 2@>=
DECLARE_NESTING_CONTROL();
struct generic_token *begin_a, *end_a, *begin_b = NULL, *end_b;
begin_a = (struct generic_token *) begin -> next;
end_a = begin_a;
while(end_a -> next != end){
  COUNT_NESTING(end_a);
  if(IS_NOT_NESTED() && end_a -> type == TYPE_COMMA){
    begin_b = (struct generic_token *) end_a -> next;
    break;
  }
  end_a = (struct generic_token *) end_a -> next;
}
if(begin_b != NULL){
  struct numeric_variable a, b;
  end_b = begin_b;
  while(end_b -> next != end)
    end_b = (struct generic_token *) end_b -> next;
  if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(a.value != 0.0 || b.value != 0.0){
    *w_x = a.value;
    *w_y = b.value;
  }
  return true;
}
@
\fimcodigo

E finalmente, o último caso, onde teremos um elemento $\{a\}$, onde
$a$ é uma expressão de par. Para tratar este caso, observe que no caso
anterior nós já delimitamos $a$. Se a vírgula não foi encontrada, de
qualquer forma temos seus tokens delimitados. Então podemos
interpretá-los como uma expressão de par:

\iniciocodigo
@<Especificador de Direção: Caso 3@>=
else{ // Se no caso anterior não achamos a vírgula
  struct pair_variable a;
  if(!eval_pair_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(a.x != 0.0 || a.y != 0.0){
    *w_x = a.x;
    *w_y = a.y;
  }
  return true;
}
@
\fimcodigo

Agora finalmente devemos interpretar a junção em si. Assim como o
especificador de direção pode estar expresso como um par representando
um vetor de direção ou como um inteiro representando a curvatura, a
junção pode ser representada como dois números representando a tensão
(ou o limite inferior para a tensão) ou como dois pares $u$ e $v$
representando os dois pontos de controle diretamente. Vamos colocar
agora as variáveis que irão armazenar os valores:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>=
float tension0 = NAN, tension1 = NAN, u_x = NAN, u_y = NAN, v_x = NAN,
      v_y = NAN;
bool atleast0 = false, atleast1 = false; // Se a tensão é só um limite inferior
@
\fimcodigo

Primeiro vamos tratar os casos mais simples. Se nossa junção for um
token ``\&'', então estamos lidando com a concatenação de dois pontos
ou (mais provavelmente) sub-caminhos. Neste caso, devemos checar se os
dois pontos que estão sendo unidos ocupam a mesma posição
(consideramos a mesma posição como sendo uma distância menor que
0,00002). Se não estiverem, um erro deve ser gerado. Se estiverem, os
pontos de controle devem ficar no meio do caminho que os pontos que
estão sendo unidos.

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
  double dif_x = z1_point -> x - z2_point -> x;
  double dif_y = z1_point -> y - z2_point -> y;
  if(hypot(dif_x * dif_x, dif_y * dif_y) > 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Concatenating discontinuous paths.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  v_x = u_x = (z1_point -> x + z2_point -> x) / 2.0;
  v_y = u_y = (z1_point -> y + z2_point -> y) / 2.0;
}
@
\fimcodigo

Se a nossa junção for somente o token ``..'', então nossa junção será
definida como tendo uma tensão de exatamente 1 e 1:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_JOIN){
  tension0 = 1.0;
  tension1 = 1.0;
  atleast0 = false;
  atleast1 = false;
}
@
\fimcodigo

Nossa junção também pode ser que esteja especificando diretamente os
pontos de controle na forma de ``.. controls $c_0$ ..'' ou
``.. controls $c_0$ and $c_1$ .. '', onde $c_0$ e $c_1$ são expressões
de pares. Neste caso tentamos delimitar os valores de $c_0$ e $c_1$
(se este segundo existir) e usamos eles diretamente como os pontos de
controle (se $c_1$ não existir, ele será igual a $c_0$):

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_c0, *end_c0, *begin_c1 = NULL, *end_c1 = NULL;
  struct pair_variable c0, c1;
  begin_c0 = (struct generic_token *) begin_j -> next;
  begin_c0 = (struct generic_token *) begin_c0 -> next;
  if(begin_c0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  end_c0 = begin_c0;
  while(end_c0 -> next != end_j){
    COUNT_NESTING(end_c0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_c0 -> next) -> type == TYPE_AND)
      break;
    end_c0 = (struct generic_token *) end_c0 -> next;
  }
  if(end_c0 -> next != end_j){
    begin_c1 = end_c0 -> next;
    begin_c1 = (struct generic_token *) begin_c1 -> next;
    if(begin_c1 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    end_c1 = begin_c1;
    while(end_c1 -> next != end_j)
      end_c1 = (struct generic_token *) end_c1 -> next;
  }
  if(!eval_pair_primary(mf, cx, begin_c0, end_c0, &c0))
    return false;
  u_x = c0.x;
  u_y = c0.y;
  if(begin_c1 != NULL){
    if(!eval_pair_primary(mf, cx, begin_c1, end_c1, &c1))
      return false;
     v_x = c1.x;
     v_y = c1.y;
  }
  else{
    v_x = c0.x;
    v_y = c0.y;
  }
}
@
\fimcodigo

O último tipo de junção tem a forma ``.. tension $t_0$ ..'' ou
``.. tension $t_0$ and $t_1$ .. '' onde $t_0$ e $t_1$ são expressões
primárias numéricas que podem ou não estar precedidas pelo token
``\monoespaco{atleast}''. Se somente um valor de tensão for
especificado, assumimos que ambos os valores necessários são iguais a
este valor único passado. Interpretemos então este tipo de junção com
o código abaixo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_TENSION){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_t0, *end_t0, *begin_t1 = NULL, *end_t1 = NULL;
  struct numeric_variable t0, t1;
  begin_t0 = (struct generic_token *) begin_j -> next;
  begin_t0 = (struct generic_token *) begin_t0 -> next;
  if(begin_t0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  if(begin_t0 == end_j ||
     (begin_t0 -> type == TYPE_ATLEAST && begin_t0 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  else
    atleast0 = false;
  end_t0 = begin_t0;
  while(end_t0 -> next != end_j){
    COUNT_NESTING(end_t0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_t0 -> next) -> type == TYPE_AND)
      break;
    end_t0 = (struct generic_token *) end_t0 -> next;
  }
  if(end_t0 -> next != end_j){
    begin_t1 = end_t0 -> next;
    begin_t1 = (struct generic_token *) begin_t1 -> next;
    if(begin_t1 == end_j ||
       (begin_t1 -> type == TYPE_ATLEAST && begin_t1 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    if(begin_t1 -> type == TYPE_ATLEAST){
      atleast1 = true;
      begin_t1 = (struct generic_token *) begin_t1 -> next;
    }
    else
      atleast1 = false;
    end_t1 = begin_t1;
    while(end_t1 -> next != end_j)
      end_t1 = (struct generic_token *) end_t1 -> next;
  }
  if(!eval_numeric_primary(mf, cx, begin_t0, end_t0, &t0))
    return false;
  tension0 = t0.value;
  if(begin_t1 != NULL){
    if(!eval_numeric_primary(mf, cx, begin_t1, end_t1, &t1))
      return false;
    tension1 = t1.value;
  }
  else{
    tension1 = t0.value;
  }
}
@
\fimcodigo

Com isso nós já tratamos todos os tipos de junção existentes. Se não
conseguimos interpretar a junção que temos em nenhum dos casos acima,
devemos gerar um erro:

@<Expressão de Caminho: Interpreta Junção@>+=
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr,
          "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
          mf -> file, begin_j -> line);
#endif
  return false;
}
@
\fimcodigo

Depois de termos interpretado a junção, isso significa que já temos ou
um par de pontos de controle, caso em que não precisaremos fazer mais
nada além de apenas registrar tais pontos de controle na nossa
variável que estamos interpretando, ou que temos dois números
representando a tensão da curva. Neste segundo caso, será importante
levar em conta os especificadores de direção para determinar o formato
final da curva.

Contudo, os especificadores de direção podem estar vazios. Neste caso,
devemos usar várias regras diferentes para determinar qual deve ser o
valor deles.

%A primeira regra é que o começo e fim de um caminho não-cíclico sempre
%tem um ``\monoespaco{$\{$curl 1$\}$}'' implícito. O mesmo ocorre
%imediatamente antes e depois de uma concatenação. Assim:

%$$
%z_0 .. z_1 .. z_2 = \{\monoespaco{curl}\ 1\}z_0 .. z_1 .. z_2\{\monoespaco{curl}\ 1\}
%$$

%E também:

%$$
%.. z_n \& z_{n+1} .. = .. z_n\{\monoespaco{curl}\ 1\} \& \{\monoespaco{curl}\ 1\}z_{n+1} ..
%$$

%Isso significa que na primeira iteração, devemos considerar que o
%especificador de direção anterior é \monoespaco{curl 1}, desde que o
%caminho que estejamos lendo não seja cíclico:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>=
%if(begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE)
%  prev_curl = 1.0;
%
%\fimcodigo

%Já se estivermos em uma concatenação, se não existirem dois especificadores
%de direção atuais, também consideramos eles como \monoespaco{curl 1}:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>+=
%if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
%  if(isnan(curl0) && isnan(w0_x))
%    curl0 = 1.0;
%  if(isnan(curl1) && isnan(w1_x))
%    curl1 = 1.0;
%}
%
%\fimcodigo

%E finalmente, se não estivermos em um caminho cíclico e não existir um
%próximo especificador de direção após o segundo ponto atual, devemos
%checar se estamos na última junção do caminho. Isso pode ser conferido
%se não existir outra junção depois desta até o fim da expressão. Neste
%caso, marcamos o \monoespaco{curl 1} como próximo especificador de
%direção:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>+=
%if(end_z1 == end_expression)
%  next_curl = 1.0;
%else if(end_expression -> type != TYPE_CYCLE &&
%        ((struct generic_token *) (end_z1 -> next)) -> type !=
%        TYPE_OPEN_BRACES){
%  bool last_join = true;
%  struct generic_token *p = (struct generic_token *) end_z1 -> next;
%  DECLARE_NESTING_CONTROL();
%  while(p != end_expression){
%    COUNT_NESTING(p);
%    if(IS_NOT_NESTED() &&
%       (p -> type == TYPE_AMPERSAND || p -> type == TYPE_JOIN)){
%      last_join = false;
%      break;
%    }
%    p = (struct generic_token *) p -> next;
%  }
%  if(last_join)
%    next_curl = 1.0;
%}
%
%\fimcodigo

%Estas regras por si só não significam nada. O começo e fim de um
%caminho não-cíclico é um ponto descontínuo, não faz sentido definir
%pontos de controle após ele, não há continuação alguma. Já uma
%concatenação liga dois pontos iguais, também não há nada entre os
%pontos ligados. Contudo, essa regra passa a ser relevante quando
%combinada com as próximas.

Se existir um especificador após um ponto, mas não antes dele, é
copiada para antes dele. Da mesma forma, se houver um especificador
depois de um ponto, mas não antes dele, o especificador depois é
copiado. Assim:

$$
.. z_0 .. z_1\{d\} ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

E também:

$$
.. z_0 .. \{d\}z_1 ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

A natureza cíclica de um caminho deve ser levada em conta nesta regra.

Para o primeiro caso, no qual queremos copiar o especificador à
esquerda do primeiro ponto, será importante preservar este valor entre
iterações. Mas pelas nossas regras, só precisamos preservá-los quando
lemos ele diretamente por existir um especificador explícito. Então,
no fim da iteração que interpreta junções, nós armazenamos o
especificador anterior nestes casos. Nos demais, nós só os apagamos:

\iniciocodigo
@<Expressão de Caminho: Fim de Cada Iteração@>=
if((begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE) ||
   (begin_j == end_j && begin_j -> type == TYPE_AMPERSAND) ||
   (begin_e != NULL && end_e != NULL)){
  prev_w_x = w1_x;
  prev_w_y = w1_y;
}
else{
  prev_w_x = NAN;
  prev_w_y = NAN;
}
@
\fimcodigo

Então, para aplicar a regra e copiar o especificador da esquerda para
a direita, usamos o seguinte código:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(w0_x) && isnan(w0_y)){
  w0_x = prev_w_x;
  w0_y = prev_w_y;
}
@
\fimcodigo

Temos agora que copiar o especificador da direita pra esquerda. Vamos
fazer isso somente se não temos ainda um especificador definido e se
existir um especificador explícito à direita do segundo ponto:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(w1_x) && isnan(w1_y)){
  if(end_z2 -> next != NULL && end_z2 != end_expression &&
     ((struct generic_token *) (end_z2 -> next)) -> type ==
     TYPE_OPEN_BRACES){
    struct generic_token *next0, *next1;
    DECLARE_NESTING_CONTROL();
    next0 = (struct generic_token *) end_z2 -> next;
    next1 = next0;
    while(next1 != end_expression){
      COUNT_NESTING(next1);
      if(IS_NOT_NESTED() && next1 -> type == TYPE_CLOSE_BRACES)
        break;
      next1 = (struct generic_token *) next1 -> next;
    }
    if(next0 -> type == TYPE_OPEN_BRACES && next1 -> type == TYPE_CLOSE_BRACES){
      if(!eval_direction_specifier(mf, cx, begin_e, end_e, &next_w_x,
                                   &next_w_y))
        return false;
      w1_x = next_w_x;
      w1_y = next_w_y;
    }
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
              mf -> file, begin_j -> line);
#endif
      return false;
    }
  }
}
@
\fimcodigo

Mas também temos que levar em conta o caso cíclico. Pelas regras
gramaticais, não há nenhum especificador de direção antes do primeiro
ponto. Mas pode existir um especificador de direção antes do
token \monoespaco{cycle} e se ele existir, ele pode ser passado para a
direita do primeiro ponto. Da mesma forma, o especificador de direção
logo depois do primeiro ponto pode ser copiado para antes do
token \monoespaco{cycle} se não houver um especificador explícito.

Primeiro o caso mais simples: há um especificador de direção explícito
após o primeiro ponto no começo da expressão e estamos em um caminho
cíclico. Neste caso, devemos memorizá-lo para caso precisemos usar ele
no último ponto do caminho. Para memorizá-lo, vamos usar as seguintes
variáveis:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float first_w_x = NAN, first_w_y = NAN;
@
\fimcodigo

E então, na primeira iteração sobre os pontos do caminho, se
estivermos em um caminho cíclico e existir um especificador explícito,
armazenamos seu conteúdo:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d != NULL && end_d != NULL){
  first_w_x = w0_x;
  first_w_y = w0_y;
}
@
\fimcodigo

Depois, quando chegarmos na última iteração de um caminho cíclico,
vamos levar estes valores em conta:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  if(!isnan(first_w_x) && isnan(w1_x)){
    w1_x = first_w_x;
    w1_y = first_w_y;
  }
}
@
\fimcodigo

Já para fazer a cópia na direção oposta, quando estamos na primeira
iteração ficamos obrigados a ir olhar a última junção. Primeiro
percorremos e expressão até o fim (até encontrar o
token \monoespaco{cycle}) tomando nota do último especificador de
direção e última junção. Se o token \monoespaco{cycle} vier logo
depois do último especificador, então devemos obter seu valor e
copiá-lo se não existir um especificador explícito.

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d == NULL && isnan(w0_x)){
  struct generic_token *begin_last_spec = NULL, *end_last_spec = NULL,
                       *last_join = NULL, *p;
  DECLARE_NESTING_CONTROL();
  p = end_z2;
  while(p != end_expression){
    if(IS_NOT_NESTED() && p -> type == TYPE_OPEN_BRACES)
      begin_last_spec = p;
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_CLOSE_BRACES)
        end_last_spec = p;
      else if(p -> type == TYPE_JOIN || p -> type == TYPE_AMPERSAND)
        last_join = p;
      else if(p -> type == TYPE_CYCLE)
        break;
    }
    p = (struct generic_token *) p -> next;
  }
  if(end_last_spec != NULL && end_last_spec -> next == p &&
     p -> type == TYPE_CYCLE){
    if(!eval_direction_specifier(mf, cx, begin_last_spec, end_last_spec,
                                 &w0_x, &w0_y))
      return false;
  }
  @<Código Após Espiarmos Última Junção de Caminho Cíclico@>
}
@
\fimcodigo

A próxima regra se aplica quando temos uma construção como:

\alinhaverbatim
.. z .. controls  u  and  v ..  = .. z{u-z} .. controls  u  and  v ..
\alinhanormal

E também:

\alinhaverbatim
.. controls u and v .. z =  .. controls u and v .. z{z-v} ..
\alinhanormal

Isso se aplica somente quando o resultado da subtração de pares $u-z$
e $z-v$ é diferente de zero. Se for igual a zero, iremos retornar um
erro por ainda não suportarmos este caso.

Primeiro o caso mais fácil: os pontos de controle explícitos vem antes
do caminho atual. Foram os pontos de controle explícitos que lemos na
iteração anterior. Então, precisamos de uma variável para armazenar
este ponto de controle:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float previous_point_x = NAN, previous_point_y = NAN;
@
\fimcodigo


Se nós temos algum valor armazenado nestas variáveis e se nós não
temos especificador de direção explícito, então geramos o
especificador com as regras que descrevemos. Só observando que
consideramos como iguais quaisquer pontos cuja distância for menor que
0,00002.

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_d == NULL && end_d == NULL && !isnan(previous_point_x) &&
   !isnan(previous_point_y) && isnan(w0_x)){
  w0_x = z1_point -> x - previous_point_x;
  w0_y = z1_point -> y - previous_point_y;
  if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Neste momento, depois de possivelmente termos usado o especificador
anterior, não precisaremos mais dele e o atualizamos para o valor atual:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  previous_point_x = v_x;
  previous_point_y = v_y;
}
else{
  previous_point_x = NAN;
  previous_point_y = NAN;
}
@
\fimcodigo

Já se não temos um valor explícito até agora no segundo especificador
de direção, devemos checar a próxima junção para saber se ela contém
pontos de controle explícitos. Se tiver, lemos o primeiro destes
pontos, o interpretamos e usamos seu valor pelas regras acima:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_e == NULL && end_e == NULL &&  isnan(w1_x) &&
   end_z1 != end_expression){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_point, *end_point;
  begin_point = (struct generic_token *) end_z1 -> next;
  while(begin_point != end_expression){
    COUNT_NESTING(begin_point);
    if(IS_NOT_NESTED() && (begin_point -> type == TYPE_JOIN ||
                          begin_point -> type == TYPE_AMPERSAND))
      break;
    begin_point = (struct generic_token *) begin_point -> next;
  }
  if(begin_point != end_expression && begin_point -> type != TYPE_AMPERSAND){
    begin_point = (struct generic_token *) begin_point -> next;
    if(begin_point != end_expression && begin_point -> type == TYPE_CONTROLS){
      begin_point = (struct generic_token *) begin_point -> next;
      end_point = begin_point;
      while(end_point != end_expression){
        struct generic_token *next = (struct generic_token *) end_point -> next;
        COUNT_NESTING(end_point);
        if(IS_NOT_NESTED() && next != NULL &&
           (next -> type == TYPE_AND || next -> type == TYPE_JOIN))
          break;
        end_point = (struct generic_token *) end_point -> next;
      }
      if(end_point != end_expression){
        struct pair_variable var;
        if(!eval_pair_primary(mf, cx, begin_point, end_point, &var))
          return false;
        w1_x = var.x - z2_point -> x;
        w1_y = var.y - z2_point -> y;
        if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                          "direction specifier.\n",  mf -> file,
                          begin_j -> line);
#endif
          return false;
        }
      }
    }
  }
}
@
\fimcodigo

Agora vamos ao caso cíclico. Se estamos na primeira iteração, nosso
caminho é cíclico e temos pontos de controle explícitos, então devemos
ter uma variável adicional para armazenar tal ponto de controle
explícito:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float first_point_x = NAN, first_point_y = NAN;
@
\fimcodigo

E inicializamos a variável se for o caso na primeira iteração:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  first_point_x = u_x;
  first_point_y = u_y;
}
@
\fimcodigo

Depois, quando chegar a hora de escolher o formato da junção das
extremidades cíclicas, levaremos a existência desta variável em conta:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE && begin_d == NULL &&
   end_d == NULL && isnan(w1_x) && !isnan(first_point_x) && isnan(w1_x)){
  w1_x = first_point_x - z2_point -> x;
  w1_y = first_point_y - z2_point -> y;
  if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

E agora a direção oposta. Se estamos na primeira iteração de um
caminho cíclico, devemos espiar a última junção e checar se temos
pontos de controle explícitos para aplicar esta regra. Mas na regra
anterior nós já escrevemos o código para obter dentre outras coisas, a
última junção. Então podemos continuar à partir do código anterior:


\iniciocodigo
@<Código Após Espiarmos Última Junção de Caminho Cíclico@>=
if(last_join != NULL && last_join -> type == TYPE_JOIN){
  struct generic_token *p = (struct generic_token *) last_join -> next;
  if(p -> type == TYPE_CONTROLS){
    struct generic_token *p_end;
    p = (struct generic_token *) p -> next;
    p_end = p;
    while(p_end != end_expression){
      struct generic_token *next = (struct generic_token *) p_end -> next;
      COUNT_NESTING(p_end);
      if(IS_NOT_NESTED() && (next -> type == TYPE_JOIN ||
                             next -> type == TYPE_AND))
        break;
      p_end = next;
    }
    if(p_end != end_expression){
      struct pair_variable var;
      if(!eval_pair_primary(mf, cx, p, p_end, &var))
        return false;
      w0_x = z1_point -> x - var.x;
      w0_y = z1_point -> y - var.y;
      if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                        "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
        return false;
      }
    }
  }
}
@
\fimcodigo

Após executar as regras, espera-se que tenhamos já ou dois pontos de
controle bem-definidos, ou então valores de tensão com especificadores
de direção à partir dos quais iremos deduzir os pontos de controle. Se
não tivermos nem um e nem outro, geraremos um erro e encerraremos:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  if(isnan(w0_x) || isnan(w0_y) || isnan(w1_x) || isnan(w1_y)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Se tudo deu certo até aqui, ou já temos os nossos pontos de controle,
ou então temos que descobrir quais são os pontos de controle por meio
de uma construção como a abaixo:

$$
z_n\{w_n\}..\ {\hskip2mm \monoespaco{tension}\hskip2mm } \alpha {\hskip2mm \monoespaco{and}\hskip2mm } \beta .. \{w_{n+1}\}z_{n+1}
$$

Para calcular os pontos de controle à partir destas informações,
tratamos os pontos como números complexos e calculamos:

$$
\theta = arg(w_n/(z_{n+1}-z_n))
$$

$$
\phi = arg((z_{n+1}-z_n)/w_{n+1})
$$

Em seguida, os pontos de controle $u$ e $v$ são:

$$
u = z_{n} + e^{i\theta}(z_{n+1}-z_n)f(\theta, \phi)/\alpha
$$

$$
v = z_{n+1} - e^{-i\phi}(z_{n+1}-z_n)f(\phi, \theta)/\beta
$$

Exceto quando é usada a palavra-chave ``atleast'', o que significa que
o valor de $\alpha$ ou $\beta$ é aumentado de modo que o resultado
fique dentro da área delimitada pelo triângulo cujos dois pontos são
os pontos de extremidade e o ângulo em cada um destes pontos é dado
pelo especificador de direção. Caso isso não forme um triângulo
válido, mantemos os valores de tensão sem os modificar.

A função $f$ que aparece acima é definida como:

$$
f(\theta, \phi) = {{2+\sqrt{2}(\sin\theta-{{1}\over{16}}\sin\phi)(\sin\phi-{{1}\over{16}}\sin\theta)(\cos\theta-\cos\phi)}\over{3(1+{1\over 2}(\sqrt 5 - 1)\cos\theta+{1\over 2}(3-\sqrt 5)\cos\phi)}}
$$

Primeiro vamos implementar a função $f$ como uma função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
double compute_f(double theta, double phi);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double compute_f(double theta, double phi){
  double n = 2 + sqrt(2) * (sin(theta) - 0.0625 * sin(phi)) *
             (sin(phi) - 0.0625 * sin(theta)) * (cos(theta) - cos(phi));
  double d = 3 * (1 + 0.5 * (sqrt(5) - 1) * cos(theta) + 0.5 * (3 - sqrt(5)) *
                  cos(phi));
  return n/d;
}
@
\fimcodigo

Agora podemos calcular os pontos de controle caso ainda não tenhamos
eles. Como devemos tratar os pontos como números complexos, vamos
precisar do seguinte cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <complex.h>
@
\fimcodigo

E com ajuda das funções da biblioteca padrão para números complexos,
calculamos a fórmula para os pontos de controle:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  double complex u, v;
  double complex z0 = z1_point -> x + z1_point -> y * I;
  double complex z1 = z2_point -> x + z2_point -> y * I;
  double theta = carg(z0 / (z1 - z0));
  double phi = carg((z1 - z0)/z1);
  u = z0 + (cexp(theta * I) * (z1 - z0) * compute_f(theta, phi)) / tension0;
  v = z1 - (cexp(-phi * I) * (z1 - z0) * compute_f(phi, theta)) / tension1;
  u_x = creal(u);
  u_y = cimag(u);
  v_x = creal(v);
  v_y = cimag(v);
  @<Ajusta Tensão em Caso de 'atleast'@>
}
@
\fimcodigo

Vamos agora tratar o caso de termos encontrado a palavra-chave
``atleast''. Se ela existir, o ponto de controle correspondente deve,
se possível, ser ajustado para estar dentro do triângulo delimitado
pelos dois pontos de extremidade e pelos ângulos definidos pelos seus
especificadores de direção.

A primeira coisa que teremos que calcular é se temos um triângulo
válido. Para isso devemos checar os seus ângulos internos. Dados três
pares de coordenadas, sendo o primeiro par um vértice onde queremos
medir o ângulo, podemos calcular o ângulo existente ali com ajuda da
seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y){
  double v0_x, v0_y, v1_x, v1_y;
  v0_x = c0_x - v_x;
  v0_y = c0_y - v_y;
  v1_x = c1_x - v_x;
  v1_y = c1_y - v_y;
  if(fabs(v0_x) <= 0.00002 &&  fabs(v0_y) <= 0.00002)
    return INFINITY;
  if(fabs(v1_x) <= 0.00002 &&  fabs(v1_y) <= 0.00002)
    return INFINITY;
  return acos((v0_x * v1_x + v0_y * v1_y) /
                (hypot(v0_x * v0_x, v0_y * v0_y) *
                 hypot(v1_x * v1_x, v1_y * v1_y)));
}
@
\fimcodigo

Sabendo medir os ângulos podemos verificar se o triângulo é
válido. Sabendo fazer isso, podemos escrever uma função que ajusta o
valor do ponto de controle para o valor adequado de modo a permanecer
dentro do triângulo. Primeiro medimos e obtemos todos os ângulos
internos. Depois, para descobrir a coordenada do terceiro vértice do
triângulo (os dois outros vértices são pontos de extremidade) usamos a
Lei do Senos. Sabendo quais são os vértices todos, verificamos se os
pontos de controle estão dentro do triângulo. E somente se não
estiver, fazemos o ajuste:


\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y){
  double internal_angle0, internal_angle1, internal_angle2;
  double triangle_angle;
  double p2_x, p2_y;
  internal_angle0 = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + d0_x, p0_y + d0_y);
  internal_angle1 = get_angle(p1_x, p1_y, p0_x, p0_y, p1_x + d1_x, p1_y + d1_y);
  internal_angle2 = M_PI - internal_angle0 - internal_angle1;
  if(internal_angle0 + internal_angle1 >= M_PI - 0.00002)
    return; // Não é triângulo válido
  { // Descobrir coordenada do terceiro vértice:
    // Primeiro calculamos o lado do triângulo que vai de p0 ao vértice
    // desconhecido
    double known_side = hypot((p1_x - p0_x) * (p1_x - p0_x),
                              (p1_y - p0_y) * (p1_y - p0_y));
    double triangle_side = known_side * sin(internal_angle0) /
                           sin(internal_angle2);
    // Conhecendo o tamanho do lado do triângulo, basta combinar com o
    // ângulo e chegamos ao vértice desconhecido:
    triangle_angle = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + 1.0, p0_y);
    p2_x = p0_x + triangle_side * cos(triangle_angle + internal_angle0);
    p2_y = p0_y + triangle_side * sin(triangle_angle + internal_angle0);
  }
  {
    @<Checa se Ponto Está Dentro do Triângulo@>
    @<Se Não Estiver, Ajusta Tensão para Ficar@>
  }
}
@
\fimcodigo

Como checar se um ponto está dentro de um triângulo? Há várias formas,
a que usaremos consiste em medir a área com sinal dos três novos
triângulos formados pelo ponto e dois vértices do triângulo. A ``área
com sinal'' é a área do triângulo, só que ela tem valor positivo ou
negativo dependendo se passamos os vértices no sentido horário ou
anti-horário. Em seguida, apenas verificamos se todas as áreas tem o
mesmo sinal (positivo ou negativo). Se tiver, então o ponto certamente
está fora. Caso contrário, o ponto está dentro do triângulo:

\iniciocodigo
@<Checa se Ponto Está Dentro do Triângulo@>=
bool s1, s2, s3; // O sinal das áreas
s1 = ((*control_x - p1_x) * (p0_y - p1_y) -
      (p0_x - p1_x) * (*control_y - p1_y)) < 0;
s2 = ((*control_x - p2_x) * (p1_y - p2_y) -
      (p1_x - p2_x) * (*control_y - p2_y)) < 0;
s3 = ((*control_x - p0_x) * (p2_y - p0_y) -
      (p2_x - p0_x) * (*control_y - p0_y)) < 0;
if(s1 == s2 && s2 == s3)
  return;
@
\fimcodigo

Uma vantagem deste método é que dependendo de qual área com sinal tem
um sinal diferente das outras, isso determina qual dos lados do
triângulo é mais próximo do ponto. Então, se ainda estivermos na
função, checamos qual é o lado mais próximo, obtemos sua equação de
reta e calculamos o ponto mais próximo na reta. Se o ponto estiver no
lado do triângulo, este é o novo ponto do ponto de controle. Se não, o
ponto de controle se torna a extremidade do triângulo mais próxima do
ponto.

\iniciocodigo
@<Se Não Estiver, Ajusta Tensão para Ficar@>=
{
  double x0, y0, x1, y1;
  if(s1 != s2 && s1 != s3){
    x0 = p0_x; y0 = p0_y;
    x1 = p1_x; y1 = p1_y;
  }
  else if(s2 != s1 && s2 != s3){
    x0 = p1_x; y0 = p1_y;
    x1 = p2_x; y1 = p2_y;
  }
  else{
    x0 = p2_x; y0 = p2_y;
    x1 = p0_x; y1 = p0_y;
  }
  if(x1 < x0){ // x1 deve ser maior ou igual a x0
    double tmp;
    tmp = x1 ; x1 = x0; x0 = tmp;
    tmp = y1; y1 = y0; y0 = tmp;
  }
  if(x0 == x1){ // Reta vertical (equação da reta daria divisão por zero)
    *control_x = x0;
    if(*control_y > y0 && *control_y > y1){
      if(y0 > y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
    else if(*control_y < y0 && *control_y < y1){
      if(y0 < y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
  }
  else if(y0 == y1) // Reta horizontal
    *control_y = y0;
  else{ // Usar equação da reta
    // m0 x + b0 = y é a reta que contém o lado do triângulo
    double m0 = (y1 - y0) / (x1 - x0);
    double b0 = y1 - m0 * x1;
    // m1 x + b1 = y é a perpendicular ao lado do triângulo e passa pelo ponto
    double m1 = - m0;
    double b1 = *control_y - m1 * *control_x;
    *control_x = (b1 - b0) / (m0 - m1);
    *control_y = m0 * *control_x + b0;
  }
  if(*control_x > x1){
    *control_x = x1;
    *control_y = y1;
  }
  else if(*control_x < x0){
    *control_x = x0;
    *control_y = y0;
  }
}
@
\fimcodigo

Isso finaliza a nossa função para ajustar a tensão caso estejamos
lidando com pontos de controle com a palavra-chave
``\monoespaco{atleast}''. Agora podemos apenas usar esta função sempre
que estivermos lidando com um caso assim:

\iniciocodigo
@<Ajusta Tensão em Caso de 'atleast'@>=
if(atleast0)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &u_x, &u_y);
if(atleast1)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &v_x, &v_y);
@
\fimcodigo

E com isso terminamos de calcular os pontos de controle e podemos
atualizar seu valor na variável de caminho que estamos montando ao
avaliar a expressão:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
result -> points[result -> length].u_x = u_x;
result -> points[result -> length].u_y = u_y;
result -> points[result -> length].v_x = v_x;
result -> points[result -> length].v_y = v_y;
@
\fimcodigo

Isso finaliza a construção de uma curva dados seus pontos e
subcaminhos lidos. Agora iremos estabelecer como ler os pontos e
subcaminhos.

\subsubsecao{8.3.2. Expressões Terciárias de Caminhos}

A gramática para expressões de caminho terciárias é:

\alinhaverbatim
<Terciário de Caminho> -> <Terciário de Par> | <Secundário de Caminho>
\alinhanormal

E é só isso. Então, para interpretar uma expressão terciária de
caminho, o que faremos é percorrer ela e verificar se encontramos uma
expressão terciária de par. Se encontrarmos, devemos interpretar a
expressão inteira como um terciário de par. Caso contrário, a
interpretaremos como um secundário de caminho. Se interpretarmos tudo
como um par, devemos também depois converter o resultado de um par
para um caminho com um único ponto.

De qualquer forma, depois de interpretar a expressão e obter um
caminho como resultado, nós retornamos o resultado.

A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  struct generic_token *p, *prev = NULL;
  bool this_expression_is_pair = false;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      this_expression_is_pair = true;
      break;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(this_expression_is_pair){
    struct pair_variable pair;
    if(!eval_pair_expression(mf, cx, begin_expression, end_expression,
                            &pair));
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> x = pair.x;
    result -> points -> y = pair.y;
    return true;
  }
  else
    return eval_path_secundary(mf, cx, begin_expression, end_expression,
                               result);
}
@
\fimcodigo

\subsubsecao{8.3.3. Expressões Secundárias de Caminhos: Transformadores}

A gramática para expressões secundárias de caminho é:

\alinhaverbatim
<Secundário de Caminho> -> <Secundário de Par> | <Primário de Caminho> |
                           <Secundário de Caminho><Transformador>
\alinhanormal

Os transformadores são os mesmos que já foram apresentados na
expressão secundária de par. A primeira coisa que devemos testar é se
temos um transformador no fim e se temos uma operação secundária de
par (multiplicação e divisão). Depois de percorrer toda a expressão,
se houver o tranformador, aplicamos a terceira regra da gramática
acima. Se houver uma multiplicação e divisão, mas não um
transformador, aplicamos a segunda regra. E caso não haja nada disso,
aplicamos a primeira.

Transformar um caminho via rotação, escala e outras modificações
envolve aplicar tais modificações sobre cada ponto de extremidade e
cada ponto de controle.

A declaração da função que fará isso é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_secundary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_secundary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  bool have_transform = false, have_pair_operator = false;
  struct generic_token *p, *last_fraction = NULL, *transform_op = NULL,
                       *before_transform = NULL, *prev = NULL,
                       *prev_prev = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else if(p -> type == TYPE_DIVISION ||
               p -> type == TYPE_MULTIPLICATION)
         have_pair_operator = true;
       else{
         have_transform = true;
         transform_op = p;
         before_transform = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(have_transform){
    if(transform_op -> next == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_path_secundary(mf, cx, begin_expression, before_transform,
                            result))
      return false;
    @<Transformação de Caminho: Rotação@>
    @<Transformação de Caminho: Escala@>
    @<Transformação de Caminho: Deslocamento@>
    @<Transformação de Caminho: Inclinação@>
    @<Transformação de Caminho: X-Escala@>
    @<Transformação de Caminho: Y-Escala@>
    @<Transformação de Caminho: Z-Escala@>
  }
  else if(have_pair_operator){
    struct pair_variable pair;
    if(!eval_pair_secundary(mf, cx, begin_expression, end_expression,
                            &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points[0].x = pair.x;
    result -> points[0].y = pair.y;
    result -> points[0].u_x = pair.x;
    result -> points[0].u_y = pair.y;
    result -> points[0].v_x = pair.x;
    result -> points[0].v_y = pair.y;
    result -> points[0].subpath = NULL;
    return true;    
  }
  else
    return eval_path_primary(mf, cx, begin_expression, end_expression,
                             result);
}
@
\fimcodigo

No código acima, quando verificamos se temos um transformador na
expressão, sempre armazenamos o último transformador encontrado na
variável \monoespaco{transform\_op} e o último token antes do
transformador em \monoespaco{before\_transform}. Isso nos permite
depois poder dividir a expressão em partes para poder interpretá-la e
obter o caminho sobre o qual devemos aplicar o transformador.

Se temos uma rotação, para interpretar um transformador de rotação
depois de termos obtido o caminho a ser rotacionado na
variável \monoespaco{result}, podemos então aplicar o código abaixo:

\iniciocodigo
@<Transformação de Caminho: Rotação@>=
if(transform_op -> type == TYPE_ROTATED){
  struct numeric_variable a;
  double theta, sin_theta, cos_theta;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  theta = 0.0174533 * a.value; // Converter de graus para radianos
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  path_rotate(result, sin_theta, cos_theta);
  return true;
}
@
\fimcodigo

O código acima assume que temos uma função recursiva que faz a rotação
uma vez que passemos o seno e cosseno do ângulo que devemos
rotacionar. Vamos usar a função abaixo para isso:


\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_rotate((struct path_variable *) (p -> points[i].subpath),
                  sin_theta, cos_theta);
    else{
      double x = p -> points[i].x, y = p -> points[i].y;
      p -> points[i].x = x * cos_theta - y * sin_theta;
      p -> points[i].y = x * sin_theta + y * cos_theta;
      x = p -> points[i].u_x;
      y = p -> points[i].u_y;
      p -> points[i].u_x = x * cos_theta - y * sin_theta;
      p -> points[i].u_y = x * sin_theta + y * cos_theta;
      x = p -> points[i].v_x;
      y = p -> points[i].v_y;
      p -> points[i].v_x = x * cos_theta - y * sin_theta;
      p -> points[i].v_y = x * sin_theta + y * cos_theta;
    }
  }
}
@
\fimcodigo

Agora vamos ao operador que muda a escala de um caminho. Ele deve
interpretar um valor numérico e depois multiplicar cada ponto do
caminho por tal valor numérico:

@<Transformação de Caminho: Escala@>=
else if(transform_op -> type == TYPE_SCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_xyscale(result, a.value, a.value);  
  return true;
}
@
\fimcodigo

A função recursiva que aplica isso a todos os pontos de um caminho é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y);
@
\fimcodigo

Note que a função é mais ampla e pode ser usada para aumentar de
maneira não-proporcional o tamanho de uma curva no eixo $x$ e $y$,
apesar de aqui só a estarmis usando para esticá-la a mesma quantidade
na horizontal e vertical. A sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_xyscale((struct path_variable *) (p -> points[i].subpath), x,
                   y);
    else{
      p -> points[i].x *= x;
      p -> points[i].y *= y;
      p -> points[i].u_x *= x;
      p -> points[i].u_y *= y;
      p -> points[i].v_x *= x;
      p -> points[i].v_y *= y;
    }
  }
}
@
\fimcodigo

A próxima transformação é uma simples translação ou
deslocamento. Recebemos um par e este par determina o quanto cada
ponto deve ser deslocado no eixo $s$ e $y$:

\iniciocodigo
@<Transformação de Caminho: Deslocamento@>=
else if(transform_op -> type == TYPE_SHIFTED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_shift(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

E a função recursiva que faz o deslocamento:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_shift((struct path_variable *) (p -> points[i].subpath), x, y);
    else{
      p -> points[i].x += x;
      p -> points[i].y += y;
      p -> points[i].u_x += x;
      p -> points[i].u_y += y;
      p -> points[i].v_x += x;
      p -> points[i].v_y += y;
    }
  }
}
@
\fimcodigo

Vamos agora à inclinação, o transformador que empurra os pontos mais à
direita se estiverem acima do 0 no eixo $y$ e mais à esquerda se
estiverem mais abaixo da origem no eixo $y$:

\iniciocodigo
@<Transformação de Caminho: Inclinação@>=
else if(transform_op -> type == TYPE_SLANTED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_slant(result, a.value);  
  return true;
}
@
\fimcodigo

E a função recursiva que faz a inclinação em si:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_slant(struct path_variable *p, float s);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_slant(struct path_variable *p, float s){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_slant((struct path_variable *) (p -> points[i].subpath), s);
    else{
      p -> points[i].x += s * p -> points[i].y;
      p -> points[i].u_x += s * p -> points[i].u_y;
      p -> points[i].v_x += s * p -> points[i].v_y;
    }
  }
}
@
\fimcodigo

A próxima transformação muda o tamanho horizontal do caminho, mas
preserva o tamanho vertical. Devemos ler um valor numérico e ele
determina o quanto o caminho deve ser esticado horizontalmente:


\iniciocodigo
@<Transformação de Caminho: X-Escala@>=
else if(transform_op -> type == TYPE_XSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, a.value, 1.0);  
  return true;
}
@
\fimcodigo

Aqui estamos usando uma função recursiva já definida, então não
precisamos defini-la novamente. Além de transformar esticando
horizontalmente, vamos agora esticar verticalmente:

\iniciocodigo
@<Transformação de Caminho: Y-Escala@>=
else if(transform_op -> type == TYPE_YSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, 1.0, a.value);  
  return true;
}
@
\fimcodigo

A última transformação é a mudança de escala Z que lê um par, o
interpreta como número complexo, e também interpreta cada ponto do
caminho como número complexo fazendo a multiplicação:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

Interpretamos e realizamos a transformação da forma abaixo, lembrando
também que esta é a última transformação possível:

\iniciocodigo
 @<Transformação de Caminho: Z-Escala@>=
else if(transform_op -> type == TYPE_ZSCALED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_zscale(result, a.x, a.y);  
  return true;
}
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer\n",
          mf -> file, transform_op -> line);
#endif
  return false;
}
@
\fimcodigo

E a função recursiva que fará isso:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_zscale((struct path_variable *) (p -> points[i].subpath),
                  x, y);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = x0 * x - y0 * y;
      p -> points[i].y = x0 * y + y0 * x;
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = x0 * x - y0 * y;
      p -> points[i].u_y = x0 * y + y0 * x;
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = x0 * x - y0 * y;
      p -> points[i].v_x = x0 * y + y0 * x;
    }
  }
}
@
\fimcodigo


\subsubsecao{8.3.4. Expressões Primárias de Caminhos}

A gramática para expressões primárias de caminho é:

\alinhaverbatim
<Primário de Caminho> -> <Primário de Par> | <Variável de Caminho> |
                       ( <Expressão de Caminho> ) |
                       reverse <Primário de Caminho> |
                       subpath <Expressão de Par> of <Primário de Caminho>
\alinhanormal

Isso significa que devemos registrar tokens
novos: \monoespaco{reverse}, \monoespaco{subpath} e \monoespaco{of}:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_REVERSE        58 // O token simbólico 'reverse'
#define TYPE_SUBPATH        59 // O token simbólico 'subpath'
#define TYPE_OF             60 // O token simbólico 'of'
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"reverse", "subpath", "of",
@
\fimcodigo

O que as regras gramaticais dizem é que no fim de toda expressão de
caminho, terminaremos encontrando no fim uma variável de caminho,
um parênteses, algum destes operadores novos de subcaminho e de
caminho reverso, ou em todos os demais casos, isso se encaixa em uma
expressão primária de par que irá nos dar um par. Devemos então testar
se estamos nestes casos, e se não estivermos, basta interpretar como
par.

A função que irá interpretar expressões primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result){
  if(begin_expression -> type == TYPE_REVERSE){
    @<Caminho Primário: Reverso@>
  }
  else if(begin_expression -> type == TYPE_SUBPATH){
    @<Caminho Primário: Subcaminho@>
  }
  else if(begin_expression == end_expression &&
          begin_expression -> type == TYPE_SYMBOLIC){
    @<Caminho Primário: Variável@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Caminho Primário: Parênteses@>
  }
  { // Se ainda não retornou, é um par primário
    @<Caminho Primário: Par Primário@>
  }
  return false;
}
@
\fimcodigo

Vamos ao primeiro caso: devemos calcular o reverso de um caminho. Para
isso, devemos inverter a ordem na qual aparecem os pontos de
extremidade, e também para cada um deles, inverter a ordem de seus
dois pontos de controle. A reversão deve ser feita recursivamente
inclusive entre os sub-caminhos. O código para isso é:

\iniciocodigo
@<Caminho Primário: Reverso@>=
if(begin_expression -> next == NULL ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                      result))
  return false;
reverse_path(result);
return true;
@
\fimcodigo

Temos agora que definir a função recursiva que realiza a reversão. A
declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void reverse_path(struct path_variable *path);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void reverse_path(struct path_variable *path){
  struct path_points tmp;
  int i, iter = (path -> length) / 2;
  for(i = 0; i < iter; i ++){
    memcpy(&tmp, &(path -> points[i]), sizeof(struct path_points));
    memcpy(&(path -> points[i]),
           &(path -> points[path -> length - i - 1]),
           sizeof(struct path_points));
    memcpy(&(path -> points[path -> length - i - 1]), &tmp,
           sizeof(struct path_points));
    tmp.u_x = path -> points[i].u_x;
    tmp.u_y = path -> points[i].u_y;
    path -> points[i].u_x = path -> points[i].v_x;
    path -> points[i].u_y = path -> points[i].v_y;
    path -> points[i].v_x = tmp.u_x;
    path -> points[i].v_y = tmp.u_y;
    tmp.u_x = path -> points[path -> length - i - 1].u_x;
    tmp.u_y = path -> points[path -> length - i - 1].u_y;
    path -> points[path -> length - i - 1].u_x =
                              path -> points[path -> length - i - 1].v_x;
    path -> points[path -> length - i - 1].u_y =
                              path -> points[path -> length - i - 1].v_y;
    path -> points[path -> length - i - 1].v_x = tmp.u_x;
    path -> points[path -> length - i - 1].v_y = tmp.u_y;
    if(path -> points[i].subpath != NULL)
      reverse_path((struct path_variable *) path -> points[i].subpath);
    if(path -> points[path -> length - i - 1].subpath != NULL)
      reverse_path((struct path_variable *)
                   path -> points[path -> length - i - 1].subpath);
  }
}
@
\iniciocodigo

O próximo passo é calcular um subcaminho. No METAFONT original, é
possível calcular subcaminhos entre pontos em posições
não-inteiras. Por exemplo, calcular o subcaminho do ponto 0,5 até
1,8. O METAFONT obteria um ponto intermediário entre os pontos de
controle 0 e 1 e entre 1 e 2 conforme pedido. Novos pontos de
extremidade e de controle adequados seriam gerados.  Aqui por hora
iremos suportar só uma versão mais simples de subcaminhos. Somente
subcaminhos inteiros serão suportados.

\iniciocodigo
@<Caminho Primário: Subcaminho@>=
DECLARE_NESTING_CONTROL();
struct pair_variable a;
struct path_variable b;
struct generic_token *of, *end_pair_expr = begin_expression;
struct generic_token *begin_subexpr;
if(begin_expression -> next == NULL ||  end_pair_expr -> type == TYPE_OF ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
of = (struct generic_token *) (end_pair_expr -> next);
while(of != NULL && of != end_expression){
  COUNT_NESTING(of);
  if(IS_NOT_NESTED() && of -> type == TYPE_OF)
    break;
  end_pair_expr = of;
  of = (struct generic_token *) (of -> next);
}
if(of == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_expression(mf, cx, (struct generic_token *) begin_expression -> next,
                         end_pair_expr, &a))
  return false;
begin_subexpr = of -> next;
if(!eval_path_primary(mf, cx, begin_subexpr, end_expression, &b))
  return false;
{
  int final_path_size;
  result -> cyclic = false;
  if(b.cyclic && ((a.x - a.y) >= b.length || -(a.x - a.y) >= b.length))
    result -> cyclic = true;
  if(a.x < 0)
    a.x = 0;
  if(a.y < 0)
    a.y = 0;
  if(a.x >= b.length)
    a.x = b.length - 1;
  if(a.y >= b.length)
    a.y = b.length - 1;
  final_path_size = a.y - a.x;
  if(final_path_size < 0)
    final_path_size *= -1;
  final_path_size ++;
  result -> length = final_path_size;
  result -> points = (struct path_points *)
                       temporary_alloc(final_path_size *
                                       sizeof(struct path_points));
  if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  recursive_copy_subpath(result -> points, &b, (a.x <= a.y)?(a.x):(a.y),
                         final_path_size);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  if(a.x > a.y)
    reverse_path(result);
  return true;
}
@
\fimcodigo

Temos agora que apresentar a função que efetivamente copia
recursivamente um caminho para o outro, como visto no código
acima. Temos que o caminho de origem pode ser um caminho com vários
subcaminhos recursivos. Mas o caminho de destino não terá subcaminhos
e já teve toda a sua memória alocada. De fato, nós já recebemos como
endereço de destino o endereço onde escreveremos cada um dos
pontos. Já como origem, recebemos como endereço a posição de uma
variável de caminho. A função recebe como argumento um ``offset'' que
determina quantos pontos iniciais devem ser ignorados e um tamanho que
representa quantos pontos devem ser copiados. A função deve sempre
retornar quantos pontos foram percorridos e funcionará recursivamente:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int recursive_copy_subpath(struct path_points *dst, struct path_variable *src,
                           int offset, int size);
@
\fimcodigo


\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int recursive_copy_subpath(struct path_points *dst, struct path_variable *src,
                           int offset, int size){
  int i, read_data = 0;
  for(i = 0; i < src -> length; i ++){
    if(size <= 0)
      break;
    if(src -> points[i].subpath == NULL){
      if(offset <= 0){
        dst -> subpath = NULL;
        dst -> x = src -> points[i].x;
        dst -> y = src -> points[i].y;
        dst -> u_x = src -> points[i].u_x;
        dst -> u_y = src -> points[i].u_y;
        dst -> v_x = src -> points[i].v_x;
        dst -> v_y = src -> points[i].v_y;
        size --;
        dst ++;
      }
      else
        offset --;
      read_data ++;
    }
    else{
      int recursive_read = recursive_copy_subpath(dst, (struct path_variable *)
                                                       src -> points[i].subpath,
                                                  offset, size);
      if(offset > recursive_read){
        offset -= recursive_read;
        read_data += recursive_read;
      }
      else{
        read_data += recursive_read;
        dst += (read_data - offset);
        size -= (read_data - offset);
        offset = 0;
      }
    }
  }
  return read_data;
}
@
\fimcodigo

O próximo caso a tratar é quando estamos diante de uma variável. Neste
caso, devemos determinar seu tipo. Pode ser um par ou um caminho. Em
seguida, alocamos o tamanho certo para nosso resultado e copiamos o
conteúdo da variável para ele:

\iniciocodigo
@<Caminho Primário: Variável@>=
{
  struct symbolic_token *v = (struct symbolic_token *) begin_expression;
  void *content = v -> var;
  if(((struct pair_variable *) content) -> type == TYPE_T_PAIR){
    result -> length = 1;
    result -> cyclic = false;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    result -> points[0].x = ((struct pair_variable *) content) -> x;
    result -> points[0].y = ((struct pair_variable *) content) -> y;
    result -> points[0].u_x = ((struct pair_variable *) content) -> x;
    result -> points[0].u_y = ((struct pair_variable *) content) -> y;
    result -> points[0].v_x = ((struct pair_variable *) content) -> x;
    result -> points[0].v_y = ((struct pair_variable *) content) -> y;
    result -> points[0].subpath = NULL;
    return true;
  }
  else if(((struct path_variable *) content) -> type == TYPE_T_PATH){
    recursive_copy_points(temporary_alloc, &result,
                          (struct path_variable *) content, false);
    return true;
  }
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Variable is not pair nor path!\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

O próximo caso a ser tratado é quando a expressão primária de caminho
começa e termina com parênteses. E não estamos diante de um par. Neste
caso, devemos avaliar a expressão entre parênteses como uma nova
expressão de caminho. Mas para isso temos antes que checar que não há
uma vírgula dentro dela, caso em que estamos diante de um par:

\iniciocodigo
@<Caminho Primário: Parênteses@>=
struct generic_token *t = begin_expression -> next;
bool found_comma = false;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  if(IS_NOT_NESTED() && t -> type == TYPE_COMMA){
    found_comma = true;
    break;
  }
  t = t -> next;
}
if(!found_comma){
  return eval_path_expression(mf, cx, begin_expression -> next, t, result);
}
@
\fimcodigo

E finalmente, o último caso de expressãso primária é quando temos uma
expressão primária de par. Neste caso, alocamos o único ponto de nosso
caminho, avaliamos a expressão de par e passamos o resultado para o
ponto alocado:

\iniciocodigo
@<Caminho Primário: Par Primário@>=
struct pair_variable v;
if(!eval_pair_primary(mf, cx, begin_expression, end_expression, &v))
  return false;
result -> length = 1;
result -> cyclic = false;
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points));
result -> points[0].subpath = NULL;
result -> points[0].x = v.x;
result -> points[0].y = v.y;
result -> points[0].u_x = v.x;
result -> points[0].u_y = v.y;
result -> points[0].v_x = v.x;
result -> points[0].v_y = v.y;
return true;
@
\fimcodigo

\subsubsecao{8.3.5. Caminhos em Expressões Numéricas}

Existe a expressão numérica primária com o
operador \monoespaco{length} que retorna o número de pontos de
extremidade de um caminho menos um. A sua sintaxe é:

\alinhaverbatim
<Primário Numérico> -> length <Caminho Primário>
\alinhanormal
%                       turningnumber <Caminho Primário> |
%                       directiontime <Expressão de Par> of <Caminho Primário>

Não precisamos aqui de nenhum tipo de token novo. A
expressão \monoespaco{length} já era usada para obter o módulo de
números e de pares. Para o caso deste operador obter um caminho, sua
implementação é ainda mais simples:

\iniciocodigo
@<Avalia 'length'@>+=
else if(expr_type == TYPE_T_PATH){
  struct path_variable p;
  if(!eval_path_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) (p.length - 1);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &p, false);
  return true;
}
@
\fimcodigo

\subsubsecao{8.3.5. Caminhos em Expressões de Pares}

Dado um caminho, nós podemos extrair pares dele. O par pode ser um dos
pontos de extremidade ou algum dos pontos de controle. A sintaxe para
isso é:

\alinhaverbatim
<Primário de Par> -> point <Expressão Numérica> of <Primário de Caminho> |
                     precontrol <Expressão Numérica> of <Primário de Caminho> |
                     postcontrol <Expressão Numérica> of <Primário de Caminho>
\alinhanormal

Isso requer adicionarmos os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
#define TYPE_POINT             61 // O token simbólico 'point'
#define TYPE_PRECONTROL        62 // O token simbólico 'precontrol'
#define TYPE_POSTCONTROL       63 // O token simbólico 'postcontrol'
@
\fimcodigo

E os adicionamos à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"point", "precontrol", "postcontrol",
@
\fimcodigo

No caso do primeiro operador, \monoespaco{point}, ele nos retorna o
ponto de extremidade indicado. Se o caminho não for cíclico, os pontos
de índice menor que zero serão iguais ao de índice zero (o primeiro) e
os pontos de índice maior ou igual ao tamanho serão iguais ao último
ponto. Se o caminho for cíclico, o índice é contado seguindo o
ciclo. No METAFONT original, índices não-positivos eram permitidos,
mas aqui eles serão convertidos para inteiros.

O operador \monoespaco{postcontrol} é semelhante, mas ele obtém o
primeiro ponto de controle imediatamente após o ponto cujo índice é
indicado. E o \monoespaco{precontrol} obtém o ponto de controle
imediatamente antes do ponto indicado.

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>=
if(begin_expression -> type == TYPE_POINT ||
   begin_expression -> type == TYPE_PRECONTROL ||
   begin_expression -> type == TYPE_POSTCONTROL){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_num, *end_num , *of = NULL, *begin_path, *end_path;
  struct numeric_variable a;
  struct path_variable b;
  begin_num = begin_expression -> next;
  end_num = begin_num;
  int index;
  while(end_num != NULL && end_num -> next != end_expression){
    COUNT_NESTING(end_num);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_num -> next) -> type == TYPE_OF){
      of = end_num -> next;
      break;
    }
    end_num = end_num -> next;
  }
  if(of == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'of' in 'point' expression\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(of -> next == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing path expression in "
            "'point' expression\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  begin_path = of -> next;
  end_path = end_expression;
  if(!eval_numeric_expression(mf, cx, begin_num, end_num, &a))
    return false;
  if(!eval_path_primary(mf, cx, begin_path, end_path, &b))
    return false;
  if(b.cyclic){
    index = ((int)(a.value)) % b.length;
    if(begin_expression -> type == TYPE_PRECONTROL)
      index = (index - 1) % b.length;
  }
  else{
    index = (int) (a.value);
    if(index < 0) index = 0;
    if(index >= b.length) index = b.length - 1;
    if(begin_expression -> type == TYPE_PRECONTROL)
      index = (index - 1) % b.length;
  }
  if(begin_expression -> type == TYPE_POINT){
    result -> x = b.points[index].x;
    result -> y = b.points[index].y;
  }
  else if(begin_expression -> type == TYPE_PRECONTROL){
    if(index < 0){
      result -> x = b.points[0].x;
      result -> y = b.points[0].y;
    }
    else{
      result -> x = b.points[index].v_x;
      result -> y = b.points[index].v_y;
    }
  }
  else{
    result -> x = b.points[index].u_x;
    result -> y = b.points[index].u_y;
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  return true;
}
@
\fimcodigo


%%%%%%%


%struct path_points{
%  float x, y; // Ponto de extremidade
%  float u_x, u_y, v_x, v_y;   // Pontos de controle
%  void *subpath;
%};
%struct path_variable{
%  int type; // Deve ser 'TYPE_T_PATH'
%  int nesting_level;
%  void *next;
%  bool cyclic;
%  int length;
%  struct path_points *points;
%};

\secao{Referências}

% Ignorar + e - depois de:
% ['penoffset'], ['point'], ['precontrol'], ['postcontrol'],
% ['intersectiontimes']w
j

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}

\fim
