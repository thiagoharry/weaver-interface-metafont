\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\def\matrix#1#2#3#4#5#6#7#8#9{\left[{{#1 \atop #4}\atop
      {\scriptstyle #7}}{{#2 \atop #5}\atop {\scriptstyle #8}}{{#3\atop
      #6}\atop{\scriptstyle #9}}\right]}


\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}

\secao{1. Introduction}

The original METAFONT is a language made to describe typographical
fonts. It was created on 1984 by Donald Knuth and differs from other
formats for allowing a designer to create different fonts merely by
changing basic parameters in the base description of the font. This
way, a designer should not create a single typographic font, but a
meta-font from which new fonts could be obtained changing these basic
parameters.

The original specification for the METAFONT language can be found in
[KNUTH, 1989], but the implementation described here will not be
compatible with that language. Instead, a new language will be
defined, strongly based on the original METAFONT, but with a different
grammar. The new language will have similar objectives, but it will be
focused on defining typographical fonts that could be interpreted and
rendered on the fly.

As this article defines a subsystem for Weaver Game Engine, and more
specifically a subsystem for the user interface modulus, our objective
here will be define the following function that will interpret a file
with METAFONT source code and load as user interface using the letters
read as texture:

\iniciocodigo
@<Function Declaration (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
@
\fimcodigo

And we will need the header for Weaver user interfaces:

\iniciocodigo
@<Include General Headers (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

But besides loading the typographical fonts to a texture, we also want
to create a font structure that could be used to render text for other
functions:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
struct metafont *_Wnew_metafont(char *filename);
void _Wdestroy_metafont(struct metafont *mf);
@
\fimcodigo

Before acalling any of these function, it is necessary to call a
initialization function that sets which functions will be called in
some contexts and also how many dots per inch has our screen (DPI):

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
bool _Winit_metafont(void *(*temporary_alloc)(size_t),
                     void (*temporary_free)(void *),
                     void *(*permanent_alloc)(size_t),
                     void (*permanent_free)(void *),
                     uint64_t (*rand)(void), int dpi);
@
\fimcodigo

The functions passed as parameters are respectivelly the one that
allocates memory temporarily , other to free what was allocated by it,
a function to make more permanent allocation, the function that frees
what was allocated by it, a function that returns 64 random bits and
finally our DPI. The disallocation functions can be set to NULL. The
function returns true if the initialization was successful.

After using this library API, the function below should be called to
finalize it:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
void _Wfinish_metafont(void);
@
\fimcodigo


\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{metafont.h}.

We can show the structure of the file \monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif
@<Include General Headers (metafont.h)@>
//@<General Macros (metafont.h)@>
@<General Declarations (metafont.h)@>
@<Data Structures (metafont.h)@>
@<Function Declaration (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Function Declaration
(weaver.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{metafont.c} file related
with this header, its structure is:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Local Headers (metafont.c)@>
@<Local Macros (metafont.c)@>
@<Local Data Structures (metafont.c)@>
@<Local Variables (metafont.c)@>
@<Local Function Declaration (metafont.c)@>
@<Auxiliary Local Functions (metafont.c)@>
@<API Functions Definition (metafont.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\secao{X. General Auxiliary Code}

The code presented in this Section will be an introduction about how
we define code in this article. All code here will be widely used in
the next Sections and all code will be independant of the specific
data structure used by Weaver Metafont.

\subsecao{X.Y. Linear Algebra Code}

We will use very frequently matrices $3\times 3$, that usually will
represent linear transformations over a vector space with 3
dimensions. Such matrices will be an array of 9 elements,
representing the matrix content.

The matrix elements will be organized as below, according with how
they are stored in array M:

$$
\matrix{M[0]}{M[1]}{M[2]}{M[3]}{M[4]}{M[5]}{M[6]}{M[7]}{M[8]}
$$


We can initialize an identity matrix with:

\iniciocodigo
@<Local Macros (metafont.c)@>=
#define INITIALIZE_IDENTITY_MATRIX(I) {\
  int _i;\
  for(_i = 0; _i < 9; _i++)\
    I[_i] = ((_i%4)?(0.0):(1.0));\
}   
@
\fimcodigo

Despite our dealings in a vector space with 3 dimensions, on practice
all the values we deal will be contained in the plane $\{(x, y, 1)\}$
with $x$ and $y$ being real numbers. The reason for working in 3
dimensions is that we want to represent translations (or shifting
points) as linear transforms, and this is only possible if we assume
that our 2D plane is inside a 3D vector space.

Given a 3-dimentional vector $(x, y, 1)$, we can transform it in a new
 vector $(x', y', 1)$ applying a linear transformation represented by
 the matrix below:

$$\left[x\; y\; 1\right]
\matrix{M[0]}{M[1]}{0}{M[3]}{M[4]}{0}{M[6]}{M[7]}{1}
=\left[x'\;\; y'\;\; 1\right]
$$

The new coordinates $(x', y')$ can be computed using the macros below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define LINEAR_TRANSFORM_X(x, y, M) (x * M[0] + y * M[3] + M[6])
#define LINEAR_TRANSFORM_Y(x, y, M) (x * M[1] + y * M[4] + M[7])
@
\fimcodigo

The matrix multiplication is associative as seen below:

$$
\left((x, y, 1)\cdot A\right) \cdot B = (x, y, 1)\cdot \left(A \cdot B\right)
$$

This means that the applying the linear transform $AB$ over a vector
is the same than first applying the linear transform $A$ and then the
linear transform $B$. The code below accumulate two linear transforms
computing $AB$ and storing the result in $A$. Notice that our code
always assumes that all matrices have $(0, 0, 1)^T$ as the last
column:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define MATRIX_MULTIPLICATION(A, B) {\
  float _a0 = A[0], _a1 = A[1], _a3 = A[3], _a4 = A[4], _a6 = A[6],\
        _a7 = A[7];\
  A[0] = _a0 * B[0] + _a1 * B[3];\
  A[1] = _a0 * B[1] + _a1 * B[4];\
  A[3] = _a3 * B[0] + _a4 * B[3];\
  A[4] = _a3 * B[1] + _a4 * B[4];\
  A[6] = _a6 * B[0] + _a7 * B[3] + B[6];\
  A[7] = _a6 * B[1] + _a7 * B[4] + B[7];\
}
@
\fimcodigo

Some linear transforms are very common. For them, we will create more
macros to perform them more easily. For example, rotating a vector
$(x, y, 1)$ around the axis $(0, 0, 1)$ by the angle $\theta$. This
can be done multiplying by the matrix:

$$\left[x\; y\; 1\right]
\matrix{cos(\theta)}{sin(\theta)}{0}{-\sin(\theta)}{cos(\theta)}{0}{0}{0}{1}
=\left[x\cdot cos(\theta) - y\cdot sin(\theta)\;\; x\cdot sin(\theta)
+ y\cdot cos(\theta)\;\; 1\right]
$$

Applying the linear transform above over a matrix can be done using
 the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_ROTATE(M, theta) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  double _cos_theta, _sin_theta;\
  _sin_theta = sin(theta);\
  _cos_theta = cos(theta);\
  M[0] = _m0 * _cos_theta - _m1 * _sin_theta;\
  M[1] = _m0 * _sin_theta + _m1 * _cos_theta;\
  M[3] = _m3 * _cos_theta - _m4 * _sin_theta;\
  M[4] = _m3 * _sin_theta + _m4 * _cos_theta;\
  M[6] = _m6 * _cos_theta - _m7 * _sin_theta;\
  M[7] = _m6 * _sin_theta + _m7 * _cos_theta;\
}
@
\fimcodigo

Another relevant linear transform is changing the vector sizes,
compressing or stretching them. To perform this in the axis $x$, we
multiply by the following matrix:

$$\left[x\; y\; 1\right]
\matrix{s}{0}{0}{0}{1}{0}{0}{0}{1}
=\left[sx\;\; y\;\; 1\right]
$$

And this is done by the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE_X(M, s) {\
  M[0] = M[0] * s;\
  M[3] = M[3] * s;\
  M[6] = M[6] * s;\
}
@
\fimcodigo

Perform this in the axis $y$ means multiplying:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{s}{0}{0}{0}{1}
=\left[x\;\; sy\;\; 1\right]
$$

And we use the following code:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE_Y(M, s) {\
  M[1] = M[1] * s;\
  M[4] = M[4] * s;\
  M[7] = M[7] * s;\
}
@
\fimcodigo

And doing this in both axis means just applying both transforms in any
order:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE(M, s) {\
  TRANSFORM_SCALE_X(M, s);\
  TRANSFORM_SCALE_Y(M, s);\
}
@
\fimcodigo

The translation, or shifting, is the only operation here that requires
three dimensions to work as a linear transform. Shifting a vector $a$
in the horizontal and $b$ in the vertical is done by the matrix
multiplication:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{1}{0}{a}{b}{1}
=\left[x+a\;\; y+b\;\; 1\right]
$$

This matrix multiplication is done using the following macro:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SHIFT(M, a, b) {\
  M[6] = M[6] + a;\
  M[7] = M[7] + b;\
}
@
\fimcodigo

Slant using $s$ as the intensity is performed by the multiplication:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{s}{1}{0}{a}{b}{1}
=\left[x+sy\;\; y\;\; 1\right]
$$

Which we apply over other matrices using the macro:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SLANT(M, s) {\
  M[0] = M[0] + s * M[1];\
  M[3] = M[3] + s * M[4];\
  M[6] = M[6] + s * M[7];\
}
@
\fimcodigo


The last special transform described here is changing the scale in the
complex plane. This means multiplying the points by a pair $(s, t)$,
treating all them as complex numbers. This performs a scale change and
a rotation at the same time. And it is done multiplying by the matrix:

$$\left[x\; y\; 1\right]
\matrix{s}{t}{0}{-t}{s}{0}{0}{0}{1}
=\left[sx-ty\;\; tx+sy\;\; 1\right]
$$

Performing this operation in another matrix can be done using:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define TRANSFORM_SCALE_Z(M, s, t) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  M[0] = _m0 * s - _m1 * t;\
  M[1] = _m0 * t + _m1 * s;\
  M[3] = _m3 * s - _m4 * t;\
  M[4] = _m3 * t + _m4 * s;\
  M[6] = _m6 * s - _m7 * t;\
  M[7] = _m6 * t + _m7 * s;\
}
@
\fimcodigo


\secao{2. Initialization and Finalization}

First we will define the initialization function. What it will do is
set some static variables with some functions that we will use in the
program. It also will set in a variable our screen pixel density in
DPI. The variables that will store these information are:

\iniciocodigo
@<Local Variables (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int dpi;
@
\fimcodigo

And the initialization function that sets these variables:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
bool _Winit_metafont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pixel_density){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  dpi = pixel_density;
  @<Weaver Metafont Initialization@>
  return true;
}
@
\fimcodigo

There is also a finalization function and when we update the
initialization function, we may need to update with correnponding code
the finalization function:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
void _Wfinish_metafont(void){
  @<Weaver Metafont Finalization@>
}
@
\fimcodigo


\secao{3. Lexer}

The first thing to be created for a language is its lexer. It will
read the source code in a file and will output a list of tokens, where
tokens are the most basic unit in the language. A token is like a
word.

METAFONT recognizes three kind of tokens: numeric, strings and
symbolic. In practice we will subdivide the symbolic tokens in several
kind of subtokens to store and read them in a more efficient way.

A numeric token will be represented internally as a floating point
number. This is different than specified in the original METAFONT,
where a custom numeric representation was used. As here we are
interested in more speed, we will choose floating point numbers
because they have nowadays more hardware support. This is how a
numeric token is represented:

\iniciocodigo
@<Local Data Structures (metafont.c)@>=
enum { // Token types
  TYPE_NUMERIC = 1, TYPE_STRING, TYPE_SYMBOLIC,
  // The 3 basic token types (numeric, string and symbolic) are abov.
  // Others will be placed below:
  @<METAFONT: Symbolic Token Definition@>
  // And there is also this last one that shouldn't be used:
  TYPE_INVALID_TOKEN
};
struct numeric_token{
  int type;   // Should be equal 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

And this is how we will represent string tokens:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct string_token{
  int type;   // Should be equal 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
  // Pointer for the glyph represented by string (will be used in Section XX)
  struct _glyph *glyph;
};
@
\fimcodigo

We will store only the first 5 bytes of each given string, even if in
the source code the string is bigger. This is so because unlike in the
original METAFONT, our only use for strings are saying wich Unicode
character each glyph should represent. For this we need only 5 bytes
(at most 4 for the character and a final byte 0). But we could use
them to associate a glyph with ligatures like ``ff'', which also fits
in these 5 bytes.

In the case of symbolic tokens, we need to store their entire name to
know which symbolic token we have. We shoul allocate dynamically
a string to store its name:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct symbolic_token{
  int type;   // Should be equal 'TYPE_SYMBOLIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  void *var;
  char *value;
};
@
\fimcodigo

We also added in this token a pointer \monoespaco{var}, because the
token can represent a variable, and therefore could need to point to
the memory region with its content.

But this could consume much more memory than needed. Some symbols are
very common and are embedded in the language. These symbols could use
less space. For example, parenthesis, semicolon and commas. We can
represent them with the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

We just need to define a type for each of them:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>=
TYPE_OPEN_PARENTHESIS,  // '('
TYPE_CLOSE_PARENTHESIS, // ')'
TYPE_COMMA,             // ','
TYPE_SEMICOLON,         // ';'
@
\fimcodigo


We can define later more reserved symbolic tokens. Notice that by
C \monoespaco{enum} rules, any token whose type is a number greater or
equal than 3 is a symbolic token.

Every token have a pointer to a next token. This happens because
usually they will be part of a linked list. To deallocate the memory
occupied by a token list given a deallocation function and the given
list, we can use the following function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Now the funtion that represents our lexer. It will get as argument an
allocation function and a string with a path for the file with
METAFONT source code. It will return a linked list of tokens:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Lexer: Rule 1@>
    @<Lexer: Rule 2@>
    @<Lexer: Rule 3@>
    @<Lexer: Rule 4@>
    @<Lexer: Rule 5@>
    @<Lexer: Rule 6@>
    // No rule applied: error
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, we used the struct \monoespaco{FILE}, this means that we need to
include the header with data about input/output to be able to read
files:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

The rules to read tokens consist in reading each line in the source
code applying the following rules for each character in the line:

1) If the next character is a space or a period and is not followed by
a period or a decimal digit, then ignore this character and go to the
next one.

\iniciocodigo
@<Lexer: Rule 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

As we are using \monoespaco{isdigit} function, we need to insert the
following header that declares this function:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) If the character is a percent sign, ignore it and also ignore all
other following characters in this line. Percentage sign is how we
start comments in the language.

\iniciocodigo
@<Lexer: Rule 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) If the next character is a decimal digit or a period, then the next
token in numeric. It will be interpreted from the biggest sequence of
decimal digests and a single optional period representing the decimal
dot present in the input.

\iniciocodigo
@<Lexer: Rule 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

4) If the next character is a double quote, the next token will be a
string. Its content will be all other chacarters until the next double
quote that should be in the same line. If we have a double quote
opening a string, but the same line do not have another double quote
to close the string, this is an error.

\iniciocodigo
@<Lexer: Rule 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


5) If the next character is a parenthesis, semicolon or a comma, the
next token will be symbolic and composed by that single character.

\iniciocodigo
@<Lexer: Rule 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Otherwise, the next token will be symbolic and will be composed by
the longest sequence of 12 families of characteres:

\iniciocodigo
@<Lexer: Rule 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer is read according with subrules 6-a to 6-l
  @<Lexer: Rule A@>
  @<Lexer: Rule B@>
  @<Lexer: Rule C@>
  @<Lexer: Rule D@>
  @<Lexer: Rule E@>
  @<Lexer: Rule F@>
  @<Lexer: Rule G@>
  @<Lexer: Rule H@>
  @<Lexer: Rule I@>
  @<Lexer: Rule J@>
  @<Lexer: Rule K@>
  @<Lexer: Rule L@>
  // Depending on buffer content, generates next token
  @<Lexer: New Reserved Symbolic Token@>
  @<Lexer: New Generic Symbolic Token@>
}
@
\fimcodigo

a) The first family of letters are the uppercase and lowercase
alphabetic letters, digits and underline. A digit cannot be the first
character in the sequence, otherwise it would be considered part of a
numeric token.

\iniciocodigo
@<Lexer: Rule A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) The second family is composed by the symbols for greater, equal and
lesser, colon and a pipe.

\iniciocodigo
@<Lexer: Rule B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acute and grave accents.

\iniciocodigo
@<Lexer: Rule C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Plus and minus.

\iniciocodigo
@<Lexer: Rule D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Slash, backslash and multiplication symbol.

\iniciocodigo
@<Lexer: Rule E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Opening brackets

\iniciocodigo
@<Lexer: Rule F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Hash sign, ampersand, at sign and dollar sign.

\iniciocodigo
@<Lexer: Rule G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Circumflex accent and tilde.

\iniciocodigo
@<Lexer: Rule H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Opening brackets.

\iniciocodigo
@<Lexer: Rule I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Closing brackets.

\iniciocodigo
@<Lexer: Rule J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Opening and closing braces.

\iniciocodigo
@<Lexer: Rule K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Lexer: Rule L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo


After reading the characters for our new symbolic token, we check if
we have a reserved symbolic token: a token representing a language
keyword. We can check this using function \monoespaco{strcmp}
comparing the buffer with some keywords. We will store a list of
keywords here:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static char* list_of_keywords[] = {
@<List of Keywords@>
  NULL};
@
\fimcodigo

Therefore, to know if we are dealing with a token that represents a
reserved keyword, we check if it is in this NULL terminated list. If
so, we create a token whose type is chosen according with the position
in this list:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // Token types for keywords begin in 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(dealloc, first_token);
      return NULL;
    }
    @<Change Type in Token Creation for Special Cases@>
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(first_token == NULL)
      first_token = last_token = new_token;
    else{
      ((struct generic_token *) last_token) -> next = new_token;
      last_token = new_token;
    }
    continue;
  }
}
@
\fimcodigo

To use function \monoespaco{strcmp} we need the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <string.h>
@
\fimcodigo


If we do not have a reserved symbolic token, and if we have something
in our buffer, then we generate a new generic symbolic token:

\iniciocodigo
@<Lexer: New Generic Symbolic Token@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Set Pointer to Internal Variable@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

\secao{4. METAFONT Programs}

When we evaluate a METAFONT program, we need two additional
structures. The first one, which we will call \monoespaco{struct
metafont} will contain all the final information extracted from the
typographical font and that will be needed to render each glyph. The
second structure, which we will call \monoespaco{struct context}
represents the current state in our parser and represents information
that we need to know to interpret correctly the token list. This
second structure can be discarded after we read all the tokens from
our font.

The first thing that our parser needs to know is that a METAFONT
program is a list (possibly empty) of statements ended by a symbolic
token \monoespaco{end} or \monoespaco{dump}:

\alinhaverbatim
<Program> -> <List of Statements> end | <List of Statements> dump
\alinhanormal

for us, there will be no difference between these two kind of programs
and symbols \monoespaco{end} and \monoespaco{dump} will be
equivalent. In the original METAFONT, one of them ends programs that
define typographical fonts and the other ends the description of a
base file (something like a basic standard library).

We will define then a new kind of symbolic token to represent this
end-of-file marking:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>=
TYPE_END,  // Symbolic token 'end'
TYPE_DUMP, // Symbolic token 'dump'
@
\fimcodigo

And let's add both the keywords \monoespaco{end} and \monoespaco{dump}
in ourt list of keywords:

\iniciocodigo
@<List of Keywords@>=
"end", "dump",
@
\fimcodigo

But to simplify, we will not use \monoespaco{TYPE\_DUMP},
only \monoespaco{TYPE\_END} to make the code simpler in the parser:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>=
if(token_type == TYPE_DUMP)
  token_type = TYPE_END;
@
\fimcodigo


The first parser function to be defined is the one that recognizes an
entire program. It basically checks if the program is ended correctly
and if not, generates an error. If the program is ended correctly, it
passes for the next parser function that evaluates list of statements,
marking the beginning and end of such list:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  while(end != NULL && end -> type != TYPE_END)
    end = (struct generic_token *) (end -> next);
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file);
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, end);
}
@
\fimcodigo

The context struct still will not be entirely defined. We will show
its content while each attribute becames necessary:

\iniciocodigo
@<Data Structures (metafont.h)@>=
struct context{
  @<Attributes (struct context)@>
};
@
\fimcodigo


And as seen above, one of the contents in \monoespaco{struct metafont}
is the file name from where the font was read. We also will store the
functions that will be use to allocate and disallocate the structure
and its elements:

\iniciocodigo
@<Data Structures (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Attributes (struct metafont)@>
};
@
\fimcodigo

Both data structures will have a function that initializes them and
also finalizes them (but the function that destroys a metafont struct
was already declared):

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_context(struct metafont *mf, struct context *cx);
@
\fimcodigo

The structure \monoespaco{metafont} needs to store more informations,
as it could be allocated both using permanent or temporary memory
allocations. Meanwhile, the context always will be temporary and will
be allocated with temporary functions.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Initialization (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Initialization (struct context)@>
  return cx;
}
@
\fimcodigo

And this is the definition for the functions that frees the memory
occupied by these structures:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void _Wdestroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalization (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct metafont *mf, struct context *cx){
  if(temporary_free != NULL){
    @<Finalization (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo

How fast do we execute our initialization and finalization compared to
the original METAFONT program? To give an answer, we created a
benchmark comparing the execution of i=an empty program composed just
by the string ``end''. It was interpreted by the original METAFONT and
by our Weaver Metafont implementation. The test was done in a machine
with Ubuntu 20.04.4 running in a  Intel(R) Core(TM) i5-3210M CPU @
2.50GHz with 4GB RAM. The result is given below:

\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#&\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Versão\hidewidth&&\omit\hidewidth
Time (s)\hidewidth&&
\omit\hidewidth Versão\hidewidth&&Time (s)&\cr\linha
&&METAFONT&&0,121&&Weaver Metafont&&0.001&\cr\linha}}

This huge difference probably is because the original METAFONT always
write messages in the screen and has a bigger list of variables to be
initialized. Besides this, it was written in a primitive Pascal that
had no portable way to deal with strings, and had no floating point
implementation. All this required that the original METAFONT had to
prepare routines to do a lot of basic tasks, which required much more
bureaucracy in the initialization. This is not necessary in our
implementation that runs in a richer environment with more
capabilities. All we need to do is memory allocation and more basic
initialization.

\secao{5. List of Statements}

A list of potentially empty statements delimited by a semicolon:

\alinhaverbatim
<List of Statements> -> <Empty> | <Statement> ; <List of Statements>
\alinhanormal

The function that will evaluate and interpret a list of statements is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

This function will iterate over each declaration and execute for all
them, in the order thay appear, the function that evaluates individual
statements. For this, the function will find all semicolons and use
them to detect where each statement begins and where they end:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  @<Before Evaluating Code@>
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
        if(!ret)
          return false;
      begin = end -> next;
    }
  }
  @<After Evaluating Code@>
  return ret;
}
@
\fimcodigo

The function above iterates over each statement, ignoring empty
statements. For each non-empty statement, it assures that the
pointers \monoespaco{begin} and \monoespaco{end} delimit the
individual statement. During the iteration we always ensure that we do
not go outside the region delimited by \monoespaco{begin\_token\_list}
and \monoespaco{end\_token\_list}.

\secao{6. Compound Statements: Compound Block}

An individual statement in the language can be composed by many other
statements. The syntax for this is:

\alinhaverbatim
<Statement> -> <Simple> | <Compound>
<Simple> -> <Empty> | <Declaration> | <Assignment> | <Command>
<Compound> -> <Compound Block> | <Conditional> | <Character Definition>
<Compound Block> -> begingroup <List of Statements> endgroup
<Conditional> -> if <Boolean Expression> :
                   <List of Statements>
                 fi
<Character Definition> -> beginchar <Character Description>
                            <List of Statements>
                          endchar
\alinhanormal

By the above grammar, we have simple and compound statements. The
simple statements could be empty, variable declaration, assignment and
commands. The compound statements are the compound blocks (begin
with \monoespaco{begingroup} and end with \monoespaco{endgroup}),
conditionals (begin with \monoespaco{if}, end with \monoespaco{fi}) or
charactere definition (begin with \monoespaco{beginchar}, end
with \monoespaco{endchar}).

The compound statements are composed by multiple other statements, as
they contain a list of statements inside them. We could have multiple
simple and compound statements inside each compound statement. Each
compound statement must be closed in the right order. If we read
a \monoespaco{begingroup} and no other beginning of compound
statement, andif the next token is a \monoespaco{fi} or
a \monoespaco{endchar}, then we are reading an incorrect program.

To read correctly compound statements, we need to take into account
their delimiting tokens, which we define below:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_BEGINGROUP,            // Symbolic token 'begingroup'
TYPE_ENDGROUP,              // Symbolic token 'endgroup'
TYPE_IF,                    // Symbolic token 'if'
TYPE_FI,                    // Symbolic token 'fi'
TYPE_BEGINCHAR,             // Symbolic token 'beginchar'
TYPE_ENDCHAR,               // Symbolic token 'endchar'
@
\fimcodigo

And we add them to the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"begingroup", "endgroup", "if", "fi", "beginchar", "endchar",
@
\fimcodigo

And now the function that will evaluate individual statements. As
seen, there are 8 different kinds of statements:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Statement: Empty@>
  @<Statement: Compound@>
  @<Statement: Declaration@>
  @<Statement: Assignment@>
  @<Statement: Command@>
  // If we are here, we could not identify the statement:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

In the case of an empty statement, probably we will not need to deal
with them. The function \monoespaco{eval\_list\_of\_statements}
silently ignore them before calling this function. But just in case an
empty statement appear by different means, we will explicitly accept
them with the code below:

\iniciocodigo
@<Statement: Empty@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Now let's deal with the compound statement. The first thing to recall
is that it will be important for the language to know in which nesting
level we are to know the scope of each declared variable. Because of
this, our context will store the current nesting level. Each beginning
of compound statement
(\monoespaco{begingroup}, \monoespaco{if}, \monoespaco{beginchar})
should increase by 1 the nesting level and each ending of compound
statement
(\monoespaco{endgroup}, \monoespaco{fi}, \monoespaco{endchar}) should
decrease by 1. Therefore, we also must to know which token should end
the most recent nesting level. We should store in a stack the expected
tokens that should end our nestings. Therefore, we will know if a
compound statement is closed correctly. We declare the nesting level
and the stack of expected ending tokens below:

\iniciocodigo
@<Attributes (struct context)@>=
  int nesting_level;
  struct generic_token *end_token_stack;
@
\fimcodigo

The nesting level should be initialized to zero and the ending token
stack should begin empty:

\iniciocodigo
@<Initialization (struct context)@>=
  cx -> nesting_level = 0;
  cx -> end_token_stack = NULL;
@
\fimcodigo

To help us to manage nesting levels, we will create two auxiliary
functions. Both of them get as argument a \monoespaco{struct context}
with the evaluation context and a token. The first will begin a new
nesting level using that token and the second will end the current
nesting level. Both of them will return error if an invalid token is
supplied:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok);
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok);
@
\fimcodigo

The first function implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok){
  struct generic_token *end_token;
  end_token = (struct generic_token *)
                    temporary_alloc(sizeof(struct generic_token));
  if(end_token == NULL){
    fprintf(stderr, "ERROR: No memory.");
    return false;
  }
  switch(tok -> type){
  case TYPE_BEGINGROUP:
    end_token -> type = TYPE_ENDGROUP;
    break;
  case TYPE_IF:
    end_token -> type = TYPE_FI;
    break;
  case TYPE_BEGINCHAR:
    end_token -> type = TYPE_ENDCHAR;
    break;
  default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Invalid token beginning"
              " compound statement.\n", mf -> file,
              ((struct generic_token *) tok) -> line);
#endif
      return false;
  }
  cx -> nesting_level ++;
  end_token -> next = cx -> end_token_stack;
  cx -> end_token_stack = end_token;
  return true;
}
@
\fimcodigo

And the second function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok){
  struct generic_token *end_tok = cx -> end_token_stack;
  if(end_tok == NULL || end_tok-> type != tok -> type){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Invalid token ending"
            " compound statement.\n", mf -> file,
            ((struct generic_token *) tok) -> line);
#endif
    return false;
  }
  cx -> nesting_level --;
  cx -> end_token_stack = end_tok -> next;
  if(temporary_free != NULL)
    temporary_free(end_tok);
  return true;
}
@
\fimcodigo

How exactly a statement is evaluated? First, recall that the
function \monoespaco{eval\_list\_of\_statements} splits the code using
semiconlons as delimiters. Next, each part is given to
function \monoespaco{eval\_statement}. This behaviour may be a little
naive, as compound statements are full statements that can contain
semicolons and other statements. Besides this, consider the following
list of tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;][T5];
\alinhanormal

In this sequence, the first three tokens would be passed to be
evaluated. Next would be \monoespaco{[T3][T4]}. And
finally, \monoespaco{[endgroup][T5]}. This is wrong, as we ideally
should evaluate first the beginning of a new nesting block
with \monoespaco{[begingroup]}. Next, each statement in the
block. Next, we end the nesting with \monoespaco{[endgroup]}. And only
then we evaluate \monoespaco{[T5]}.

Fortunately, it's easy to evaluate things in this order. This can be
done because the function \monoespaco{eval\_statement} can change the
pointer for the end of the expression. If it did not evaluate all
tokens given to it, it should place the pointer in the last evaluated
token. Therefore, when getting the first three tokens above, where the
first one is a \monoespaco{[begingroup]}, the function can just create
a new nesting and return, setting the end of the evaluated expression
to the first token. This makes the
function \monoespaco{eval\_list\_of\_statements} send again the
tokens \monoespaco{[T1][T2]} to be evaluated.

The code to deal with any statement that begins
with \monoespaco{begingroup} is:

\iniciocodigo
@<Statement: Compound@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  begin_nesting_level(mf, cx, begin_token_list);
  *end_token_list = begin_token_list;
  return true;
}
@
\fimcodigo

In the same way, if we get an statement that begins
with \monoespaco{endgroup}, we evaluate only this first token
finishing the current nesting level:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_ENDGROUP){
  if(!end_nesting_level(mf, cx, begin_token_list))
    return false;
  *end_token_list = begin_token_list;
  return true;
}
@
\fimcodigo

This is also a good moment to evaluate the end of the program, when we
find an \monoespaco{end} token (despite not being an compound
statement). In this case, we should generate an error if we are inside
a some nesting in a compound statement:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_END){
  if(cx -> nesting_level > 0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Program ending with unclosed "
                    "compound statement.\n", mf -> file);
#endif
    return false;
  }
  @<End of Code: 'end' or 'dump'@>
  return true;
}
@
\fimcodigo


\secao{7. Variable Declarations}

The syntax to declare variables is:

\alinhaverbatim
<Declaration> -> <Type> <List of Declarations>
<Type> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<List of Declarations> -> <Tag> | <Tag> , <List of Declarations>
\alinhanormal

A ``tag'' is basically a symbolic token without a predefined meaning
in the language. For example, ``\monoespaco{tag}'' is a tag, but
``\monoespaco{begingroup}'' is not.

To interpret a declaration, we will introduce the following special
tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_T_BOOLEAN,               // Symbolic token 'boolean'
TYPE_T_PATH,                  // Symbolic token 'path'
TYPE_T_PEN,                   // Symbolic token 'pen'
TYPE_T_PICTURE,               // Symbolic token 'picture'
TYPE_T_TRANSFORM,             // Symbolic token 'transform'
TYPE_T_PAIR,                  // Symbolic token 'pair'
TYPE_T_NUMERIC,               // Symbolic token 'numeric'
@
\fimcodigo

And then we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


When a variable is declared, we need to do two things:

1) If the variable do not exist in the current nesting level, we
should allocate a new structure to store its content. If it already
exist in the current nesting level, an error is returned. A default
value depending of its type if stored in the variable. But it should
not be used before being initialized.

2) We iterate over the following tokens in the list of tokens until
the end of the list or until the current nesting level ends. When we
find a symbolic token with the variable name, we update its pointer to
the newly allocated variable.


As each variable type has its own information and content, the
specifics about how the variable is created can be different. What all
variables have in common is the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
// Generic variable
struct variable{
  int type;
  int nesting_level;
  void *next;
};
@
\fimcodigo

All variables first store their type, then their nesting level, and
finally, a ponter for the next variable. Depending on the variable
type, more information could be stored after the pointer for the next
variable.

If we are dealing with a global variable, we could want to preserve
and store its name, just in case if later the user would want to
change the variable content indentifying it by the name. In this case,
we would want to use the following structure to store the name with
the variable:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

And the metafont structure will have pointers for these global
variables, with names and without:

\iniciocodigo
@<Attributes (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

These pointers are initialized with NULL:

\iniciocodigo
@<Initialization (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

To disallocate a list of global variables, we just iterate over the
linked list that they create. Some variables, which are more complex,
could need additional operations before removing them, but we will
deal with them later:

\iniciocodigo
@<Finalization (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Global Variable 'v'@>
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

And to disallocate a list with preserved names, we act in a similar
way:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) named -> var;
    next = (struct named_variable *) (named -> next);
    mf -> free(named -> name);
    @<Finalize Global Variable 'v'@>
    mf -> free(v);
    mf -> free(named);
    named = next;
  }
}
@
\fimcodigo

In the case of variables that are not global, they will be stored in
contexts, not in the metafont struct. After all, their duration always
will be temporary:

\iniciocodigo
@<Attributes (struct context)@>=
  void *variables;
@
\fimcodigo

The list of variables is initialized as empty:

\iniciocodigo
@<Initialization (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

And we finalize it exactly as the list of global variables:

\iniciocodigo
@<Finalization (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Local Variable 'v'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

And now let's interpret the variable declaration:

\iniciocodigo
@<Statement: Declaration@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // All kinds of declarations
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insert Declared Variable@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

Inserting a new variable follows the logic below:

\iniciocodigo
@<Insert Declared Variable@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

The function that inserts a new global variable without its name is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

It will allocate a new variable and store it in the local pointed
by \monoespaco{target}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    case TYPE_T_PAIR:
      var_size = sizeof(struct pair_variable);
      break;
    case TYPE_T_PATH:
      var_size = sizeof(struct path_variable);
      break;
    case TYPE_T_PEN:
      var_size = sizeof(struct pen_variable);
      break;
    case TYPE_T_PICTURE:
      var_size = sizeof(struct picture_variable);
      break;
    case TYPE_T_TRANSFORM:
      var_size = sizeof(struct transform_variable);
      break;
    case TYPE_T_BOOLEAN:
      var_size = sizeof(struct boolean_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Initializing New Variable@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Inserting a named variable is done with the following function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

The function works in a similar way, first allocating the structure
with the variable nam and then placing the variable there:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));

  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL)
    mf -> named_variables = named;
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

Anf finally, the function that search in a list of tokens for symbolic
tokens with the same name that the allocated new variable and updating
each one to make them point to the newly allocated variable position:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

The function will walk in the linked list starting in the token next
to the declared variable. And t will stop only when there is no more
tokens or when the variable do not exist anymore because we are not
more in its nesting level (it happens when we find
the \monoespaco{endgroup} which ends the current nesting level):

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP || p -> type == TYPE_IF ||
       p -> type == TYPE_BEGINCHAR)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP || p -> type == TYPE_FI ||
            p -> type == TYPE_ENDCHAR)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Numeric Variables}

A numeric variable will be stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparing numeric variables with generic variables, the difference is
that we have an additional floating point variable in the structure
called \monoespaco{value}. It will store the numeric value. When we
create a numeric variable, we initialize it with NaN, which represents
an unknown value:

\iniciocodigo
@<Initializing New Variable@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

Using the macro \monoespaco{NAN} requires the mathematical header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

In the case of numeric variables, nothing additional is needed when we
deallocate them, as they have no additional structure besides a single
floating-point number.

However, besides the variables declared by the users, our version of
the Metafont language will have some additional internal
variables. They always will be present and do not need to be
declared. We will have exactly three of
them: \monoespaco{pt}, \monoespaco{cm} and \monoespaco{mm}. Basically
they will store how many pixels correspond to 1pt, 1cm and 1mm
respectively.

Such internal numeric variables will be declared in the metafont
struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

During the initialization we will allocate space for the three
variables and fill their values:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   ((double) dpi) / 72.0; // 1in = 72 pt
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   ((double) dpi) / 2.54; // 1in = 2.54cm
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   ((double) dpi) / 25.4; // 1in = 25.4mm
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;

  }
}
@
\fimcodigo

We also will create the following macros to access each one of these
variables more easily:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

To finalize the metafont structure, we need to deallocate these
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> free != NULL)
  mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

When our lexer creates a new symbolic token which is not a reserved
word, it should check if this token have the same name than an
internal variable. If so, we can then set correctly the pointer to the
variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\subsecao{7.2. Pair Variables}

A pair variable will store point coordinates. They will be stored in
the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct pair_variable{
  int type; // Must be 'TYPE_T_PAIR'
  int nesting_level;
  void *next;
  float x, y;
};
@
\fimcodigo

The difference is that they have space for two floating point values
instead of one. Initially we will represent the first of them with NaN
to represent a non-initialized pair:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Transform Variables}

If a pair variable is a tuple with two numeric values, then a
transform variable is a tuple with six different values. Let's assume
that a transform variable is $(a, b, c, d, e, f)$, what it represents
is a linear transformation in which the pair $(x, y)$ is transformed
in $(x', y')$ by the following matrix multiplication:

$$\left[x\; y\;
      1\right]\matrix{c}{e}{0}{d}{f}{0}{a}{b}{1}=\left[x'\;\; y'\;\;
      1\right]
$$

Or: $(x', y') = (a+cx+dy, b+ex+fy)$.

The order in which we store and use the elements may appear strange,
but we store them in that order for compatibility with the notation
from original METAFONT created by Knuth.

A transform variable therefore, needs to store a linear transformation
in a matrix form:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct transform_variable{
  int type; // Deve ser 'TYPE_T_TRANSFORM'
  int nesting_level;
  void *next;
  float value[9];
};
@
\fimcodigo

A non-initialized transform variable, by default, has its first value marked
as NAN:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_TRANSFORM)
  ((struct transform_variable *) var) -> value[0] = NAN;
@
\fimcodigo

There is an internal transform variable that always is presente and
that represents no transformation at all.  A transform that do not
change the point, that in the metrix notation represents multiplying
by the identity matrix. This transform is represented by the tuple
$(0, 0, 1, 0, 0, 1)$.

The internal transform variables will be stored here:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct transform_variable *internal_transform_variables;
@
\fimcodigo

During initialization we allocate memory for the internal variables
and initialize them:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_transform_variables =
  (struct transform_variable *)
    mf -> alloc(sizeof(struct transform_variable));
if(mf -> internal_transform_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL; //ERRO: Sem memória suficiente
}
// The transform variable 'identity':
mf -> internal_transform_variables[0].type = TYPE_T_TRANSFORM;
INITIALIZE_IDENTITY_MATRIX(mf -> internal_transform_variables[0].value);
@
\fimcodigo

The variable \monoespaco{identity} will be stored as the first
position in the array of internal transform variables:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_TRANSFORM_IDENTITY 0
@
\fimcodigo

And when reading the source code, we can set correctly the pointer
each time we find a token referencing this internal variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>+=
else if(!strcmp(buffer, "identity"))
  new_token -> var =
          &(mf -> internal_transform_variables[INTERNAL_TRANSFORM_IDENTITY]);
@
\fimcodigo


\subsecao{7.4. Path Variables}

A path variable store a sequence of points and control
points. Together they compose a sequence of Cubic Beziér Curves.

A Cubic Beziér Curve is defined by two extremity points ($z_1$ and
$z_4$) and two control points ($z_2'$ and $z_3'$). The two extremity
curves are always part of the curve. To obtain the other curve points
given the four points $(z_1, z_2', z_3', z_4)$, we use the following
procedure:

1) Get three intermediate points: $z_{12}'$ is the point halfway the
points $z_1$ and $z_2'$, $z_{23}'$ is the point halfway between $z_2'$
and $z_3'$ and $z_{34}$ is the point halfway between $z_3'$ and $z_4$.

2) Get two intermediate points: $z_{123}'$ is the point halfway
between $z_{12}'$ and $z_{23}'$ while $z_{234}'$ is the point halfway
between $z_{23}'$ and $z_{34}'$.

3) Get the new curve point $z_{1234}$ located halfway between
$z_{123}'$ and $z_{234}'$.

4) Generate the remaining curve points repeating this procedure
recursively over the points $(z_1, z_{12}', z_{123}', z_{1234})$ and
over $(z_{1234}, z_{234}', z_{34}', z_4)$.

It is also possible to define such curves using a formula. Given the
extremity points and the control points, a Cubic Beziér Curve is
defined by the following formula if we vary $t$ between 0 and 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

The data structure that will represent a sequence of Cubic Beziér
Curves is:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct path_points{
  float x, y; // Extremity point
  float u_x, u_y, v_x, v_y;   // Control Points
  void *subpath;
};
struct path_variable{
  int type; // Must be 'TYPE_T_PATH'
  int nesting_level;
  void *next;
  bool cyclic;
  int length, total_length;
  struct path_points *points;
};
@
\fimcodigo

Basically its points will be stored in the
pointer \monoespaco{points}, an array of structs whose number of
elements is equal \monoespaco{length}. Each structure will represent a
point $(x, y)$ or a subpath (if \monoespaco{subpath} is not null, and
in this case we ignore $x$ and $y$). To check the number of points in
a path variable, one could read variable \monoespaco{total\_length}
that considers the points stored recursively in other linked path
variables. The variable \monoespaco{length} stores only the size of
array \monoespaco{points}.

The control points defined
by \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
and \monoespaco{v\_y} are the control points between the current point
or subpath and the next one if it exists. If we have a cyclic path,
the control points in the last point or subpath show how it is
connected to the first point in the path. If we are not in a cyclic
path, then the control points of the last point is ignored.

We will represent a non-initialized oath variable setting its length
as -1:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
}
@
\fimcodigo

When we remove a global variable, if it is a path variable and if it
is initialized, then we also need to remove the allocated list of
points:

\iniciocodigo
@<Finalize Global Variable 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && mf -> free != NULL)
    path_recursive_free(mf -> free, path, false);
}
@
\fimcodigo

If the variable is not global we do the same, but using a different
disallocation function:

\iniciocodigo
@<Finalize Local Variable 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL)
    path_recursive_free(temporary_free, path, false);
}
@
\fimcodigo

As a path can contain subpaths and each subpath also can contain more
subpaths, we will use a recursive function to disallocate their
memory. Given a disallocation function and a pointer to a path
variable, we disalloc all its subpaths, and then we disalloc the path
variable. The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].subpath != NULL)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath, true);
    }
    free_func(path -> points);
    if(free_first_pointer)
      free_func(path);
  }
}
@
\fimcodigo

\subsecao{7.5. Pen Variables}

A pen variable stores the structure needed to draw lines and forms in
METAFONT. The pens specify the diameter and format of all drawed lines
and points. They are stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct pen_variable{
  int type; // Must be 'TYPE_T_PEN'
  int nesting_level;
  void *next;
  struct path_variable *format; // The format as a cyclic path
  int flags;
  struct pen_variable *referenced; // Not null only in 'currentpen'
  float gl_matrix[9]; // OpenGL matrix transformation
  // The variables below will be manipulated only in Section 10
  GLuint gl_vbo; // The OpenGL vertices after triangulation
  GLsizei indices; // Number of vertices stored above
  // This will store how detailed is our triangulation, which will help us
  // to decide if we need a retriangulation in some cases:
  float triang_resolution;
};
@
\fimcodigo

Here we will give a brief explanation about these variables and why do
we need them:

The variables \monoespaco{type}, \monoespaco{nesting\_level}
are \monoespaco{next} common for all variable types and are not
something new. They are needed so that we will know which variable
type we have, its scope and which is the next variable if we are in a
linked list.

The variable \monoespaco{format} specifies the pen format as a cyclic
path. In the original METAFONT, the format needed to be both cyclic
and convex. Here, we will require that the path must be cyclic and
also should be simple. A simple path is a path whose perimeter do not
crosss over itself. If the restriction is not respected, then the
result will be undefined and we will not ensure that the pen will have
the specified format.

It does not matter how complex is the pen format, to draw it in the
screen, we need to convert it to a set of triangles in a process
called triangulation. Details about how to triangulate or if we need
to triangulate at all, will be stored in the
variable \monoespaco{flags}. Some of the possible flags are:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define FLAG_CONVEX   1
#define FLAG_STRAIGHT 2
#define FLAG_CIRCULAR 4
#define FLAG_SQUARE   8
#define FLAG_NULL    16
@
\fimcodigo

The flag \monoespaco{FLAG\_CONVEX} stores if our pen is convex. If so,
we can use very simple triangulation algorithms that will perform the
computations in O(n).

The flag \monoespaco{FLAG\_STRAIGHT} stores if the pen format is
composed only by straight lines. If so, we can represent it exactly by
triangulation, the result is perfect, not just approximated. This
means that we do not need to redo the triangulation if the pen changes
its size, for example. Conversely, if our pen has non-straight curves,
then the triangulation needs to be redone to show more details if the
pen size is increased. 

The flag \monoespaco{FLAG\_CIRCULAR} stores if we know that the pen has
a circular format. In this case, we can generate the triangulation
without looking at the path variable format.

The flag \monoespaco{FLAG\_SQUARE} stores if this is a square pen. If
so, we also do not need points from the path variable and probably we
can use a premade triangulation.

The flag \monoespaco{FLAG\_NULL} stores if this is a null pen. If so,
it never will need to be triangulated, as it represents a point
without height nor width.

The variable \monoespaco{referenced} will be non-NULL if we are
dealing with a temporary pen which is not stored in a variable and if
this pen references another pen format and vertices. In this case, we
will use if possible the same path format and the same triangulation
than the referenced pen variable. This also means that if the pen is
deallocated, we should not destroy its format nor throw away the
triangulation vertices.

The variable \monoespaco{gl\_matrix} stores the OpenGL matrix
transformation. As the pens will have a more definitive format which
will not be subdivided nor concatenated as in the subpath operations,
then we can represent their linear transformations using this matrix
instead of updating manually their points.

The other variables will me used more on Section 10. The
variable \monoespaco{gl\_vbo} will reference the pen vertices after
the triangulation, when the pen is ready to be drawn. Such vertices,
if they exist, will be stored in the video card. Otherwise, this
variable will be equal 0. The
variables \monoespaco{pen\_lft}, \monoespaco{pen\_rt}, \monoespaco{pen\_top}
and
\monoespaco{pen\_bot} will store respectively the maximum coordinate $x$,
minimum coordinate $x$, maximum coordinate $y$ and minimum coordinate
$y$ for all the points in the
pen. Finally, \monoespaco{triang\_resolution} will store an internal
measure of how detailed is the pen triangulation. It will help us to
choose if we need a more detailed triangulation or if what we have is
enough.

A pen variable that was declared but not initialized will have its
format set as the null pointer, will be non-circular and not
triangulated:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PEN){
  ((struct pen_variable *) var) -> format = NULL;
  ((struct pen_variable *) var) -> gl_vbo = 0;
  ((struct pen_variable *) var) -> indices = 0;
  ((struct pen_variable *) var) -> flags = false;
  ((struct pen_variable *) var) -> referenced = NULL;
}
@
\fimcodigo


Which means that when we remove a global variable and it is a pen
variable, we need to deallocate the format and throw away its vertices:

\iniciocodigo
@<Finalize Global Variable 'v'@>+=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && mf -> free != NULL)
    path_recursive_free(mf -> free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
}
@
\fimcodigo

If the variable is not global we do the same, but using a different
disallocation function:

\iniciocodigo
@<Finalize Local Variable 'v'@>=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && temporary_free != NULL)
    path_recursive_free(temporary_free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
  @<Finalize Local Pen 'pen'@>
}
@
\fimcodigo

Besides the pen variables declared by users, we will also support
two other internal pen variables that can be used by the users that
will always be declared and initialized. One of them will
be \monoespaco{currentpen} variable that always will store the pen
that we currently are using to draw. The other variable will be a pen
with square format that will be already initialized to obtain better
performance when used.

Such variables will be stored in the Metafont structure:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct pen_variable *internal_pen_variables;
@
\fimcodigo

During initialization we will allocate space for both and we will
initialize them. The variable \monoespaco{currentpen} by default will
begin as an empty pen and \monoespaco{pensquare} will be a square
with side 1:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_pen_variables = (struct pen_variable *)
                                 mf -> alloc(2 * sizeof(struct pen_variable));
if(mf -> internal_pen_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL;
}
mf -> internal_pen_variables[0].format = NULL; // The pen 'currentpen'
mf -> internal_pen_variables[0].type = TYPE_T_PEN;
mf -> internal_pen_variables[0].flags = FLAG_NULL;
mf -> internal_pen_variables[0].referenced = NULL;
mf -> internal_pen_variables[0].gl_vbo = 0;
mf -> internal_pen_variables[0].indices = 0;
mf -> internal_pen_variables[1].format = NULL; // A caneta 'pensquare'
mf -> internal_pen_variables[1].type = TYPE_T_PEN;
mf -> internal_pen_variables[1].flags = FLAG_CONVEX | FLAG_STRAIGHT |
                                        FLAG_SQUARE;
mf -> internal_pen_variables[1].referenced = NULL;
mf -> internal_pen_variables[1].gl_vbo = 0;
mf -> internal_pen_variables[1].indices = 4;
{ // Inicializando a matriz de transformação de ambas
  int j;
  for(j = 0; j < 2; j ++)
    INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[j].gl_matrix);
}
@
\fimcodigo

The following macro will help us to access more easily the position
for each of these internal variables:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_PEN_CURRENTPEN 0
#define INTERNAL_PEN_PENSQUARE  1
@
\fimcodigo

And to finalize the Metafont structure, we need to deallocate the
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> free != NULL){
  if(mf -> internal_pen_variables[1].format != NULL){
    mf -> free(mf -> internal_pen_variables[1].format -> points);
    mf -> free(mf -> internal_pen_variables[1].format);
  }
  mf -> free(mf -> internal_pen_variables);
}
@
\fimcodigo

And when we read a source code, we need to adjust correctly the
variable pointers when we find reference for internal variables:


\iniciocodigo
@<Set Pointer to Internal Variable@>+=
else if(!strcmp(buffer, "currentpen"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]);
else if(!strcmp(buffer, "pensquare"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_PENSQUARE]);
@
\fimcodigo

The pen '\monoespaco{currentpen}' is special because it can store a
pointer for other pen instead of its own content. But what happens if
we free the memory of a local pen variable that was pointed
by \monoespaco{currentepen}? Easy. In this
case, \monoespaco{currentpen} bacomes a null pen again, restoring its
default values:

\iniciocodigo
@<Finalize Local Pen 'pen'@>=
if(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced == pen){
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].format = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].type = TYPE_T_PEN;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].flags = FLAG_NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].gl_vbo = 0;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].indices = 0;
}
@
\fimcodigo

\subsecao{7.6. Picture Variables}

A picture variable will store a rendered image, possibly created using
pens and Weaver Metafont drawing commands. Contrary to original
METAFONT, Weaver Metafont requires all pictures to have a known width
and height. Therefore, we need to store in this variable its size and
also an OpenGL identifier to a texture:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct picture_variable{
  int type; // Must be 'TYPE_T_PICTURE'
  int nesting_level;
  void *next;
  int width, height;
  GLuint texture;
};
@
\fimcodigo

A declared, but not initialized picture variable will have negative
height and width. Its texture also will be zero:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PICTURE){
  ((struct picture_variable *) var) -> width = -1;
  ((struct picture_variable *) var) -> height = -1;
  ((struct picture_variable *) var) -> texture = 0;
}
@
\fimcodigo

When removing a global variable, if it is a picture variable, we need
to destroy its texture with OpenGL if the texture exists:

\iniciocodigo
@<Finalize Global Variable 'v'@>+=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

If the variable is not global we do the same:

\iniciocodigo
@<Finalize Local Variable 'v'@>=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

We will have a single internal picture variable, which we will call
``\monoespaco{currentpicture}''. In the beginning of all program, this
variable will be declared, but not initialized. To create a list of
our internal picture variables, we declare it in the Metafont
structure:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct picture_variable *internal_picture_variables;
@
\fimcodigo

In the initialization we let the variable as non-initialized:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_picture_variables = (struct picture_variable *)
                                   mf-> alloc(sizeof(struct picture_variable));
if(mf -> internal_picture_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL;
}
// The picture 'currentpicture':
mf -> internal_picture_variables[0].type = TYPE_T_PICTURE;
mf -> internal_picture_variables[0].width = -1;
mf -> internal_picture_variables[0].height = -1;
mf -> internal_picture_variables[0].texture = 0;
@
\fimcodigo

To keep consistency with other internal variables, we create a macro
to reference its position in the array:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define INTERNAL_PICTURE_CURRENTPICTURE 0
@
\fimcodigo

When the time to deallocate intrnal variables comes, we should
eliminate its texture if it exists:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> internal_picture_variables[0].texture != 0)
  glDeleteTextures(1, &(mf -> internal_picture_variables[0].texture));
if(mf -> free != NULL)
  mf -> free(mf -> internal_picture_variables);
@
\fimcodigo

And when we read a source code, we need to adjust correctly the
variable pointers when we find reference for
``\monoespaco{currentpicture}'':

\iniciocodigo
@<Set Pointer to Internal Variable@>+=
else if(!strcmp(buffer, "currentpicture"))
  new_token -> var =
          &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE]);
@
\fimcodigo

\subsecao{7.7. Boolean Variables}

The simplest variable type, a boolean variable can store only true or
false. Its struct format is:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct boolean_variable{
  int type; // Deve ser 'TYPE_T_BOOLEAN'
  int nesting_level;
  void *next;
  short value;
};
@
\fimcodigo

The value stored by the variable will be 0 if false, 1 if true or -1
if non-initialized:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_BOOLEAN)
  ((struct boolean_variable *) var) -> value = -1;
@
\fimcodigo


\secao{8. Assignments}

Assignments are how we initialize variables, how we modify their
values and how we store the result of expressions.

The syntax for an assignment is:

\alinhaverbatim
<Assignment> -> <Variable> = <Right Side> |
                <Variable> := <Right Side> |
<Right Side> -> <Expression> | <Assignment>
\alinhanormal

This means that we can chain assignments, for example, in the code
below, all variables, if numeric, will store the value 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

If in the beginning of a statement we find a variable, then certainly
we are dealing with an assignment.

We will begin teaching our lexer that both tokens ``\monoespaco{=}''
and ``\monoespaco{:=}'' are equivalent, represent the same thing and
have an special meaning:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_ASSIGNMENT,            // Symbolic token '='
TYPE_ASSIGNMENT2,           // Symbolic token ':='
@
\fimcodigo

Both types are added to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"=", ":=",
@
\fimcodigo

But to simplify the code, we will transform the second type in the
first and consider only the first kind of assignment:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>+=
else if(token_type == TYPE_ASSIGNMENT2)
  token_type = TYPE_ASSIGNMENT;
@
\fimcodigo


Now that we have this new kind of token, the code to evaluate
assignments is described below. What it does is walk over the tokens
in the assignment detecting all variables that should pass by the
assignment. While it does it, it checks if all them are declared, if
all them have the same type, if we are assigning to something that is
not a variable, if we forget the assignment symbol, or if we are
missing an expression after the assignment. If one of these things are
detected, an error is generated.

The part that we still will not show is how we evaluate the expression
after the last assignment symbol and how in the end we update the
value for each variable to be equal what was evaluated. How we do
these things change depending on the variable types, each type have
its own expressions and its own way of storing the value in the
variables. These details will be shown in the next subsections.

\iniciocodigo
@<Statement: Assignment@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  struct generic_token *begin_expression;
  int type = 0; // Type for the variables being assigned
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment.\n", mf -> file,
              var -> line);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Assignment for Numeric Variables@>
  @<Assignment for Pair Variables@>
  @<Assignment for Transform Variables@>
  @<Assignment for Path Variables@>
  @<Assignment for Pen Variables@>
  @<Assignment for Picture Variables@>
  @<Assignment for Boolean Variables@>
  return true;
}
@
\fimcodigo

\subsecao{8.1. Numeric Assignments and Expressions}

How do we assign numeric variables given the code above? We use the
following code:

\iniciocodigo
@<Assignment for Numeric Variables@>=
if(type == TYPE_T_NUMERIC){
  int i;
  bool ret;
  struct numeric_variable result;
  ret = eval_numeric_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                               &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_numeric_variable((struct numeric_variable *) var -> var,
                            &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The function that makes the assignment is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source);
@
\fimcodigo

And its simple implementation is given below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source){
  target -> value = source -> value;
}
@
\fimcodigo

Now we will write how to interpret numeric expressions.

\subsubsecao{8.1.1. Sum and Subtraction: Normal and Pythagorean}

The rules for numeric expressions begins as:

\alinhaverbatim
<Numeric Expression> -> <Numeric Tertiary>
<Numeric Tertiary> -> <Numeric Secondary> |
                      <Numeric Tertiary> <T-Op> <Numeric Secondary>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

The symbols \monoespaco{+} and \monoespaco{-} represent the usual
addition and subtraction. The symbol \monoespaco{++} should not be
confused with C language increment and means the pythagorean sum:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

This can be easily computed in C using the
function \monoespaco{hypot} from the standard math library.

The symbol \monoespaco{+-+} is the ``pythagorean subtraction'' defined
below:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

We will compute the pythagorean subtraction using the last definition,
as the multiplication of two square roots. This is the computation
that minimizes errors involving overflows and underflows.

The four operators above are the ones with smaller precedence. These
operations will be done only after all other mathematical operations.

Now we will improve our lexer making it identify and create the new
tokens for these operators. We also will create new token types for
``['' and ``]'', as we will need to identify these tokens in our
parser:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_SUM,                   // Symbolic token '+'
TYPE_SUBTRACT,              // Symbolic token '-'
TYPE_PYTHAGOREAN_SUM,       // Symbolic token '++'
TYPE_PYTHAGOREAN_SUBTRACT,  // Symbolic token '+-+'
TYPE_OPEN_BRACKETS,         // Symbolic token '['
TYPE_CLOSE_BRACKETS,        // Symbolic token ']'
TYPE_OPEN_BRACES,           // Symbolic token '{'
TYPE_CLOSE_BRACES,          // Symbolic token '}'
@
\fimcodigo

And we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo

Now let's evaluate numeric expressions, which means evaluating
tertiary numeric expressions. The function is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

The tertiary numeric expressions is where we solve additions and
subtractions. By the syntax rules, what we need to do is walk over the
tokens in the expression until find the last tertiary operator that is
not delimited by parenthesis, brackets or braces.

To help with this, the following macros will store, check and count
the nesting level for parenthesis, braces and brackets:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define DECLARE_NESTING_CONTROL() int nesting_parenthesis = 0, \
                                      nesting_brackets = 0, \
                                      nesting_braces = 0;
#define COUNT_NESTING(p) if(p -> type == TYPE_OPEN_PARENTHESIS)           \
                               nesting_parenthesis ++;                    \
                             else if(p -> type == TYPE_CLOSE_PARENTHESIS) \
                               nesting_parenthesis --;                    \
                             else if(p -> type == TYPE_OPEN_BRACKETS)     \
                               nesting_brackets ++;                       \
                             else if(p -> type == TYPE_CLOSE_BRACKETS)    \
                               nesting_brackets --;                       \
                             else if(p -> type == TYPE_OPEN_BRACES)       \
                               nesting_braces ++;                         \
                             else if(p -> type == TYPE_CLOSE_BRACES)      \
                               nesting_braces --;
#define IS_NOT_NESTED() (nesting_parenthesis == 0 && nesting_brackets == 0 && \
                         nesting_braces == 0)
#define RESET_NESTING_COUNT() nesting_parenthesis = 0; \
                              nesting_brackets = 0; \
                              nesting_braces = 0;
@
\fimcodigo


Everything in the left side should be recursively evaluated as another
tertiary expression. Everything in the right side should be
interpreted as a secondary numeric expression. Finally, if we did not
find any tertiary operator, the entire expression is evaluated as a
secondary numeric expression.

However, there are some exceptions, cases in which the
symbols \monoespaco{+} and \monoespaco{-} should not be treated as a
sum or subtraction. This happens if they are in the beginning of the
numeric expression, or if before them there is a comma, an opening
bracket, a multiplication or division symbol, another tertiary
operator, or one of the following tokens that we will define later:
\monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}.

If we have a previous token (\monoespaco{prev}) and the current one
(\monoespaco{cur}), we can check if it represents a valid sum or
subtraction with the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_OF &&                    \
          prev -> type != TYPE_POINT &&                 \
          prev -> type != TYPE_PRECONTROL &&            \
          prev -> type != TYPE_POSTCONTROL &&           \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo
\iniciocodigo
@<Operador Secundário de Pares: Escala-X@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

The following code interprets tertiary numeric expressions and
identify correctly the tertiary operators with the help of the macro:


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_PYTHAGOREAN_SUM ||
                          p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
                          IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_numeric_secondary(mf, cx, begin_secondary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM)
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT)
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM)
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Negative square root "
                " in pythagorean subtraction.\n", mf -> file,
                last_sum -> line);
#endif
        return false;
      }
    }
    return true;
  }
  else
    return eval_numeric_secondary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.2. Multiplication and Division}

The rules to deal with secondary numeric expressions are:

\alinhaverbatim
<Numeric Secondary> -> <Numeric Primary> |
                       <Numeric Secondary> <S-Op> <Numeric Primary>
<S-Op> -> * | /
\alinhanormal

The operators \monoespaco{*} and \monoespaco{/} are respectively the
multiplication and division.

Let's add these operators as reserved tokens and define their types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_MULTIPLICATION,        // Symbolic token '*'
TYPE_DIVISION,              // Symbolic token '/'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"*", "/",
@
\fimcodigo

The function that will evaluate numeric secondary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

And its definition is very similar with the function that evaluates
tertiary expressions, except that this function computes
multiplication and division.

However, there is an additional rule that we should be aware: the
token ``/'' will be considered division only if it is not delimited by
two numeric tokens. If so, then it represents a fraction and it should
be computed with a higher precedence than what we deal here. However,
if the token before the previous one already was considered part of a
fraction, then in this case we have a division despide being
surrounded by numeric tokens. This way the code \monoespaco{1/3/1/3}
is interpreted as a division between two fractions $(1/3)/(1/3)$:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
                          p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_token_list &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ // Valid multiplication or division
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secondary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secondary(mf, cx, begin_expression, end_secondary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end_token_list, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION)
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){
      if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.\n",
                mf -> file, last_mul -> line);
#endif
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else
    return eval_numeric_primary(mf, cx, begin_expression,
                                end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.3. Modulus,
  Trigonometric Functions,  Exponentials, Floor and
  Random Uniform Values}

The rules for primary numeric expressions are:

\alinhaverbatim
<Numeric Primary> -> <Numeric Atom> |
                     length <Numeric Primary> | (...) |
                     <Numeric Operator> <Numeric Primary>
<Numeric Operator> -> sqrt | sind | cosd | mlog | mexp | floor |
                       uniformdeviate |
                       <Scalar Multiplication Operator>
<Scalar Multiplication Operator> -> + | - |
                       <Primary Numeric Token Before Variable>
<Primary Numeric Token> -> <Numeric Token> / <Numeric Token> |
                           <Numeric Token>
\alinhanormal

The operator \monoespaco{length}, when appearing before a numeric
primery means that we want its modulus. If it appears before another
kind of primary expression, it could mean different things.

The new modulus operator should be added to the list of reserved
words. We will add also the other new operators from the list of
numeric operators. The brackets are already in this list:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_LENGTH,         // Symbolic token 'length'
TYPE_SQRT,           // Symbolic token 'sqrt'
TYPE_SIND,           // Symbolic token 'sind'
TYPE_COSD,           // Symbolic token 'cosd'
TYPE_LOG,            // Symbolic token 'log'
TYPE_EXP,            // Symbolic token 'exp'
TYPE_FLOOR,          // Symbolic token 'floor'
TYPE_UNIFORMDEVIATE, // Symbolic token 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

The function that evaluates a primary numeric expression is this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result);
@
\fimcodigo


We can decide which syntax rule should be applied while evaluating the
primary numeric expression using seven different interpretation rules:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result){
  @<Numeric Primary: Rule 1@>
  @<Numeric Primary: Rule 2@>
  @<Numeric Primary: Rule 3@>
  @<Numeric Primary: Additional Operators@>
  @<Numeric Primary: Rule 4@>
  return true;
}
@

The rules are:

1) If the expression is composed by a single token, or if it begins
with ``('' and ends with ``)'', or if it is composed by three tokens,
a numeric, a division and another numeric, then the entire expression
is a numeric atom:

\iniciocodigo
@<Numeric Primary: Rule 1@>=
if(begin_expression == end_expression ||
   (begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
    end_expression -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin_expression -> type == TYPE_NUMERIC &&
     begin_expression -> next != end_expression &&
     ((struct generic_token *) begin_expression -> next) -> type ==
       TYPE_DIVISION &&
     ((struct generic_token *) begin_expression -> next) -> next ==
       end_expression &&
     end_expression -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin_expression, end_expression,
                          result);
}
@
\fimcodigo

2) If we find operator \monoespaco{length}, then we check if the
expression after it is numeric. If so, we compute its modulus. If the
expression have another type, we will define later how the operator
will proceed. We assume that we have a function that discovers the
type of a primary expression.

\iniciocodigo
@<Numeric Primary: Rule 2@>=
else if(begin_expression -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx,
                                             (struct generic_token *)
                                             begin_expression -> next,
                                             end_expression);
  if(expr_type == TYPE_T_NUMERIC){
    bool ret;
    struct numeric_variable num;
    ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                               begin_expression -> next,
                               end_expression, &num);
    if(!ret)
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Evaluate 'length'@>
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "primary expression after 'length'.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;
  }
}
@
\fimcodigo

Notice that identifying if we have or not a numeric primary expression
involves calling \monoespaco{get\_primatry\_expression\_type}. This
function will be defined in Subsection 8.8. For now, we just need to
know that given the beginning and ending tokens for some expression,
it returns the expression type.


3) If we find some of the numeric operators, we have a numeric
operator followed by a numeric primary expression.

The first numeric operator is the square root:

\iniciocodigo
@<Numeric Primary: Rule 3@>=
else if(begin_expression -> type == TYPE_SQRT){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value < 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Square root "
            "of negative number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;
}
@
\fimcodigo

Next we have the operator \monoespaco{sind}, which interprets the next
number in degrees (because of this it has the letter ``d'' in the end)
and computes the sine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SIND){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = sinf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the cosine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_COSD){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the logarithm in $e$ basis:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_LOG){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value <= 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Computing logarithm of "
            "non-positive number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = logf(num.value);
  return true;
}
@
\fimcodigo

And the exponential which means $exp x = e^x$:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_EXP){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = expf(num.value);
  return true;
}
@
\fimcodigo

The floor of a given value:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_FLOOR){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = floorf(num.value);
  return true;
}
@
\fimcodigo

About the operator \monoespaco{uniformdeviate}, it generates a number
uniform and random between 0 and the value passed as operand. We can
compute this generating a number between 0 and 1 and then multiply
this value with the operand.

Generating a floating point number between 0 and 1 following a
distribution near to uniform can be done generating a random 64-bit
number and then multiplying it with $2^{-64}$. Not all possible
floating-point numbers could be represented generating them this
way. Numbers smaller than $2^{-64}$ would be ignored and the rounding
would make some numbers near 1 more probable, but we also would have
less density in the range near 1. However, despithe these drawbacks,
the result would be sufficiently precise for our purposes:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_UNIFORMDEVIATE){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;
  }
  return true;
}
@
\fimcodigo

If the next operator is the symbol \monoespaco{+}, this means a
multiplication by 1. This operation can be ignored:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUM){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  return true;
}
@
\fimcodigo

But if the operator is a symbol \monoespaco{-}, hen this means a
multiplication by -1:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUBTRACT){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  result -> value *= -1;
  return true;
}
@
\fimcodigo

4) In the remaining cases, we have a scalar multiplicationwhere the
scalar is a primary numeric token that is not followed
by \monoespaco{+}, \monoespaco{-} or another numeric token. To deal
with this, we needto identify the beginning and end of the primary
numeric token. BY the rules it is a single numeric token, or three
tokens (two numeric ones separated by a \monoespaco{/}). After
separating the parts, the first part is multiplied by the second (a
numeric primary expression):

\iniciocodigo
@<Numeric Primary: Rule 4@>=
else{
  bool ret;
  float token_value;
  struct generic_token *after_token;
  if(begin_expression -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  token_value = ((struct numeric_token *) begin_expression) -> value;
  after_token = (struct generic_token *) (begin_expression -> next);
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    after_token = (struct generic_token *) (after_token -> next);
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = (struct generic_token *) (after_token -> next);
  }
  ret = eval_numeric_primary(mf, cx, after_token, end_expression, result);
  if(!ret)
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Isolated Numbers and Random Normal Values}

The final rules for numeric expressions are:

\alinhaverbatim
<Numeric Atom> -> <Numeric Variable> |
                  <Primary Numeric Token> |
                  ( <Numeric Expression> ) |
                  normaldeviate
\alinhanormal

The only new token in this part is \monoespaco{normaldeviate}:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_NORMALDEVIATE,   // O token simbólico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"normaldeviate",
@
\fimcodigo

This operator creates a new random number taken from a n ormal
distribution with mean 0 and standard deviation 1.

The function that evaluates numeric atoms is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result);
@
\fimcodigo

We will decide which rule to apply while evaluating the numeric atom
first checking if we have a single token or not, and then applying
different rules based on this:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result){
  if(begin_expression == end_expression){
    @<Numeric Atom: Rule 1@>
    @<Numeric Atom: Rule 2@>
    @<Numeric Atom: Rule 3@>
  }
  else{
    @<Numeric Atom: Rule 4@>
    @<Numeric Atom: Rule 5@>
  }
  return true;
}
@

1) If we have a single token and it is a numeric token, we just return
its value:

\iniciocodigo
@<Numeric Atom: Rule 1@>=
if(begin_expression -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin_expression) -> value;
  return true;
}
@
\fimcodigo

2) If we have a single token and it is a variable, we return its
content. But we first need to check if the variable was declared, if
it is numeric and if it was initialized:

\iniciocodigo
@<Numeric Atom: Rule 2@>=
if(begin_expression -> type == TYPE_SYMBOLIC){
  struct numeric_variable *var;
  var = ((struct symbolic_token *) begin_expression) -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric variable "
            "'%s' in numeric expression.\n", mf -> file,
            begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(isnan(var -> value)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

3) Finally, if we have a single token and it is
a \monoespaco{normaldeviate}, then we need to generate a random number
taken from a normal distribution. Given that we already have a
function to generate random bits, we can simulate a normal
distribution following these steps:

a) First we generate two random numbers between -1 and 1. We will call
them $u$ and $v$. e can generate them getting 64 random bits,
multiplying the first 63 by $2^{-63}$ and using the remaining bit to
choose the signal. The result is sufficiently close to uniform.

b) If $u^2+v^2\geq 1$, the numbers form a point outside a circle with
radius 1. In this case, the result should be discarded and we try to
generate numbers again. We also discard the result if both numbers are
zero, as in this case our method do not work.

c) After this, we can produce two numbers following a normal
distribution computing:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

One of the values will be returned. The other can be stored to be
returned next time we need a random normal value. We store it in the
Metafont struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Initially the structure will have no value stored. We will store
values there only after using the procedure descrbed above:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

So, when we need to generate a normal rando value, we always check
first if we already have a pre-generated value, and if not, we
generate two values:

\iniciocodigo
@<Numeric Atom: Rule 3@>=
if(begin_expression -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    random_bits = random_func();
    do{
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Now the cases where we have more than one token. If the first token
in ``('' and the last one is ``)'', we compute the inner expression as
a numeric expression, and then return the result discarding the
parenthesis:

\iniciocodigo
@<Numeric Atom: Rule 4@>=
if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
   end_expression -> type == TYPE_CLOSE_PARENTHESIS){
   bool ret;
   struct generic_token *p = begin_expression;
   while(p -> next != end_expression)
     p = (struct generic_token *) p -> next;
   if(p == begin_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.",
            mf -> file, begin_expression -> line);
#endif
     return false;
   }
   ret = eval_numeric_expression(mf, cx, (struct generic_token *)
                                         begin_expression -> next, p,
                                         result);
   if(!ret)
     return false;
   return true;
}
@
\fimcodigo

5) Finally, the case when the numeric atom is a fraction composed by a
numeric token, \monoespaco{/} and another numeric token. The result is
obtained dividing both tokens:

\iniciocodigo
@<Numeric Atom: Rule 5@>=
if(begin_expression -> type == TYPE_NUMERIC &&
   end_expression -> type == TYPE_NUMERIC &&
   ((struct generic_token * ) begin_expression -> next) -> type ==
   TYPE_DIVISION){
  result -> value = ((struct numeric_token *) begin_expression) -> value /
           ((struct numeric_token *) end_expression) -> value;
  return true;
}
@
\fimcodigo

\subsecao{8.2. Pair Assignments and Expressions}

To make the assignment to pair variables, we use the code below:

\iniciocodigo
@<Assignment for Pair Variables@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pair_variable((struct pair_variable *) var -> var, &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The declaration for the assignment function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source){
  target -> x = source -> x;
  target -> y = source -> y;
}
@
\fimcodigo

Now let's see how to evaluate  pair expressions.

\subsubsecao{8.2.1. Sum and Subtraction}

The grammar rules for pair tertiary expressions begin with sum and
subtraction:

\alinhaverbatim
<Pair Expression> -> <Pair Tertiary>
<Pair Tertiary> -> <Pair Secondary> | (...) |
                   <Pair Tertiary> <PT-Op> <Pair Secondary>
<PT-Op> -> + | -
\alinhanormal

Sum and subtraction is evaluated exactly as expected from vector sum
and subtraction.

The function that evaluates pair expressions is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result);
@
\fimcodigo

The method to evaluate tertiary pair expressions are not different
from what we already defined with numeric expressions. We just have
fewer tertiary operators here.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct pair_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_pair_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_pair_secondary(mf, cx, begin_secondary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM){
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else
    return eval_pair_secondary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.2.2. Transformers and Scalar Multiplication and Division}

The grammar for secondary pair expressions is:

\alinhaverbatim
<Pair Secondary> -> <Pair Primary> |
                    <Pair Secondary><Mul or Div><Numeric Primary> |
                    <Numeric Secondary> * <Pair Primary> |
                    <Pair Secondary><Transformer>
<Mul or Div> -> * | /
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary> | (...)
\alinhanormal

Let's add the seven new keywords representing transformers:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_ROTATED,  // Symbolic token 'rotated'
TYPE_SCALED,   // Symbolic token 'scaled'
TYPE_SHIFTED,  // Symbolic token 'shifted'
TYPE_SLANTED,  // Symbolic token 'slanted'
TYPE_XSCALED,  // Symbolic token 'xscaled'
TYPE_YSCALED,  // Symbolic token 'yscaled'
TYPE_ZSCALED,  // Symbolic token 'zscaled'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo


The function that evaluates secondary pair expressions is declared
below:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct pair_variable *result);
@
\fimcodigo

Evaluating a secondary expression here is very similar to what we did
for numeric expressions. We also walk over the token list searching
for the rightmost secondary operator, ignoring anything nested inside
parenthesis and brackets. We follow the same rules to check when we
have a division and when the symbol \monoespaco{/} is just a fraction
separator. The difference is that here we have a total of nine
secondary operators including the transformers. Because of the big
quantity, we will show each of them separately instead of all them in
the code block below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct pair_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             // Operator 'transformed' still not defined. We will see
             // it in Subsubsection 8.3.4.
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ //  Divisão ou operadores válidos
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secondary != NULL){
    bool ret;
    begin_primary = (struct generic_token *) (last_mul -> next);
    @<Secondary Pair Operator: Multiplication@>
    @<Secondary Pair Operator: Division@>
    @<Secondary Pair Operator: Rotation@>
    @<Secondary Pair Operator: Scaling@>
    @<Secondary Pair Operator: Shifting@>
    @<Secondary Pair Operator: Slanting@>
    @<Secondary Pair Operator: X-Scaling@>
    @<Secondary Pair Operator: Y-Scaling@>
    @<Secondary Pair Operator: Z-Scaling@>
    @<Secondary Pair Operator: Additional Operators@>
  }
  else
    return eval_pair_primary(mf, cx, begin_expression,
                             end_expression, result);
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

The first operator is the multiplication. Notice that we can have two
different multiplications: a pair multiplicated by a numeric or a
numeric multiplicated by a pair. To identify which of the two should
be applied, we must check the primary expression to the right of the
operator. It is a primary expression and we have a function that
identifies the type of a primary expression:

\iniciocodigo
@<Secondary Pair Operator: Multiplication@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end_expression) ==
     TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    if(!eval_numeric_secondary(mf, cx, begin_expression, end_secondary,
                               &a))
      return false;
    if(!eval_pair_primary(mf, cx, begin_primary, end_expression, &b))
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary,
                              &a);
    if(!ret)
      return false;
    ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }
}
@
\fimcodigo

If we have a division, then this always will be a pair divided by a
numeric. We should generate an error in case of division by zero:

\iniciocodigo
@<Secondary Pair Operator: Division@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.",
            mf -> file, last_mul -> line);
#endif
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

If we have a rotation, we rotate our pair counter-clockwise using the
origin as the axis. We interpret angles in degrees, not in radians:

\iniciocodigo
@<Secondary Pair Operator: Rotation@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  theta = 0.0174533 * b.value;
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

A scaling is the same thing than a multiplication:

\iniciocodigo
@<Secondary Pair Operator: Scaling@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

A shifting is equal a sum, but this operator have a higher precedence:

\iniciocodigo
@<Secondary Pair Operator: Shifting@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

The slanting operator shifts a point more to the right depending on
how above the axis $x$ it is and more to the left depending on how
below the axis $x$ it is:

\iniciocodigo
@<Secondary Pair Operator: Slanting@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

A x-scaling multiplies a numeric scalar to the first value in the
pair:

\iniciocodigo
@<Secondary Pair Operator: X-Scaling@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Likewise a y-scaling multiplies a numeric scalar to the second value
in the pair:

\iniciocodigo
@<Secondary Pair Operator: Y-Scaling@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Finally, a z-scaling interprets two pairs as complex numbers and
multiply them:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Secondary Pair Operator: Z-Scaling@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Pair Intermediary Values, Literals and Variables}

The final grammar rules for pair expressions are:

\alinhaverbatim
<Pair Primary> -> <Pair Variable> |
                  ( <Numeric Expression> , <Numeric Expression> ) |
                  ( <Pair Expression> ) |
                  (...) |
                  <Numeric Atom> [ <Pair Expression, <Pair Expression>] |
                  <Scalar Multiplication Operator><Pair Primary>
\alinhanormal

The novel operator is the constructionn $a[b, c]$, where $b$ and $c$
are pairs. It represents intermediary values between $b$ end $c$. It
is evaluated as $a(b+c)$. This means that $.5[a,b]$ is half the path
between $b$ and $c$.

The other rules are analogous to what we already described in the
grammar for numeric expressions.

The function that will evaluate pair primary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result);
@
\fimcodigo

Each one of the five grammar rules will be tested separately to
discover which one we should apply when we find a primary expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result){
  if(begin_expression == end_expression){
    @<Pair Primary: Rule 1@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Pair Primary: Rule 2@>
    @<Pair Primary: Rule 3@>
  }
  @<Pair Primary: Other Rules to Be Defined Later@>
  @<Pair Primary: Rule 4@>
  @<Pair Primary: Rule 5@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

The first rule will be applied when we have a single token in the
expression. The only case when it happens is when we are evaluating a
pair variable:

\iniciocodigo
@<Pair Primary: Rule 1@>=
if(begin_expression == end_expression){
  struct symbolic_token *tok = (struct symbolic_token *) begin_expression;
  struct pair_variable *var;
  if(tok -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable token "
            "in pair expression.",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
  var = (struct pair_variable *) tok -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            tok -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_PAIR){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-pair variable "
            "'%s' in pair expression.\n", mf -> file,
            begin_expression -> line, tok -> value);
#endif
    return false;
  }
  result -> x = var -> x;
  result -> y = var -> y;
  return true;
}
@
\fimcodigo

If the expression is delimited by parenthesis, we could be facing a
literal representation of a pair in the form $(a, b)$, or we could be
dealing with a pair expression inside parenthesis. We can
differentiate the two cases checking the presence of a comma inside
the parenthesis, but not inside any other internal parenthesis or
bracket.

\iniciocodigo
@<Pair Primary: Rule 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression (empty parenthesis).\n ", mf -> file,
              begin_expression -> line);
#endif
    return false;
  }
  begin_a = (struct generic_token *) begin_expression -> next;
  end_a = begin_a;
  DECLARE_NESTING_CONTROL();
  bool literal = true;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    bool ret;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    ret = eval_numeric_expression(mf, cx, begin_a, end_a, &a);
    if(!ret)
      return false;
    ret = eval_numeric_expression(mf, cx, begin_b, end_b, &b);
    if(!ret)
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

In the code above we identify if we are dealing with a literal
checking for a comma and we set in the boolean
variable \monoespaco{literal} if we found it. If this variable is not
true, immediately after the last \monoespaco{if} above, we run the
following \monoespaco{else} as the next rule:

\iniciocodigo
@<Pair Primary: Rule 3@>=
else{
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
}
@
\fimcodigo

If the last token is a \monoespaco{]}, then we have a construction of
type $a[b,c]$. Our task is separate the three parts $a$, $b$ and $c$, evaluate them and return $a(b+c)$:

\iniciocodigo
@<Pair Primary: Rule 4@>=
else if(end_expression -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  DECLARE_NESTING_CONTROL();
  begin_a = begin_expression;
  end_a = begin_a;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type ==
        TYPE_OPEN_BRACKETS)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_b = (struct generic_token *) end_a -> next;
  begin_b = (struct generic_token *) begin_b -> next;
  if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_b = begin_b;
  while(end_b != end_expression){
    COUNT_NESTING(end_b);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_b -> next) -> type == TYPE_COMMA)
      break;
    if(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_c = (struct generic_token *) end_b -> next;
  begin_c = (struct generic_token *) begin_c -> next;
  if(begin_c == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_c = begin_c;
  while(end_c -> next != end_expression)
    end_c = (struct generic_token *) end_c -> next;
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c))
    return false;
  result -> x = (b.x + c.x) * a.value;
  result -> y = (b.y + c.y) * a.value;
  return true;
}
@
\fimcodigo

The last rule is when we have a scalar multiplication operator. The
operator can be \monoespaco{+}, \monoespaco{-}, a single numeric token
or a fraction:

\iniciocodigo
@<Pair Primary: Rule 5@>=
else{
  bool ret;
  if(begin_expression -> type == TYPE_SUM)
    return eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
  else if(begin_expression -> type == TYPE_SUBTRACT){
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin_expression -> type == TYPE_NUMERIC){
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin_expression) -> value;
    tok = (struct generic_token *) begin_expression -> next;
    if(tok -> type == TYPE_DIVISION){
      tok = (struct generic_token *) begin_expression -> next;
      if(tok == end_expression || tok -> next == end_expression ||
         tok -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "expression.\n ", mf -> file, begin_expression -> line);
#endif
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = (struct generic_token *) tok -> next;
    }
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pairs in Numeric Expressions}

Numeric subexpressions can appear inside pair expressions. For
example, in $a[b,c]$, $a$ is a numeric atom. Likewise, pair
subexpressions can appear inside numeric expressions. We did not
define this in the section about numeric expressions because we still
had not defined how to evaluate pair expressions. There are four
numeric primary operators involving pairs:

\alinhaverbatim
<Numeric Primary> -> length <Pair Primary> | xpart <Pair Primary> |
                       ypart <Pair Primary> | angle <Pair Primary>
\alinhanormal

This require defining the following three new token types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_XPART,  // Symbolic token 'xpart'
TYPE_YPART,  // Symbolic token 'ypart'
TYPE_ANGLE,  // Symbolic token 'angle'
@
\fimcodigo

They correspond to the following keywords:

\iniciocodigo
@<List of Keywords@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

The first case, which did not need a new token, othe
operator \monoespaco{length} was already being used to get the modulus
of a given number and we had written that it could be used on other
types, not only in numerics. In the case of pairs, this operators
returns the euclidean norm:

\iniciocodigo
@<Evaluate 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) hypot(p.x * p.x, p.y * p.y);
  return true;
}
@
\fimcodigo

The operator \monoespaco{xpart} returns the first value in a
pair. However, we must take an additioonal care: this operator can be
use in contexts other than getting value from a pair, as we will still
see in Sub-subsection 8.3.3. Therefore, first we must check if what we
have after the operator is a pair. If so, we return the first value:

\iniciocodigo
@<Numeric Primary: Additional Operators@>=
else if(begin_expression -> type == TYPE_XPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, (struct generic_token *)
                                                      begin_expression -> next,
                                                      end_expression);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                  begin_expression -> next, end_expression,
                                  &p))
      return false;
    result -> value = p.x;
    return true;
  }
  else{
    @<Numeric Primary: X-Part in Non-Pair@>
  }
}
@
\fimcodigo

While the operator \monoespaco{ypart} returns the second value in a
pair. In this case we also must take care to check if we have as
operand is a pair or some other thing:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_YPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, (struct generic_token *)
                                                      begin_expression -> next,
                                                      end_expression);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                  begin_expression -> next, end_expression,
                          &p))
      return false;
    result -> value = p.y;
    return true;
  }
  else{
    @<Numeric Primary: Y-Part in Non-Pair@>
  }
}
@
\fimcodigo

Finally, the last operator, \monoespaco{angle}, measure the angle of a
pair. Which means the angle between the segment that connects the
origin to the pair coordintate and the segment that connects the
origin to $(1,0)$. An error will be generated if you try to measure
the angle of $(0,0)$:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Measuring the angle "
            "of (0,0).\n ", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = (float) asin(p.y / (hypot(p.x * p.x, p.y * p.y)));
  result -> value *= 57.2958; // Radianos para graus
  return true;
}
@
\fimcodigo

\subsecao{8.3. Transform Assignments and Expressions}

One of the moments where we expect to eval a transform expression is
when making assignments to transform variables. In this case, we apply
a function to evaluate the expression and get the result. Then, we
assign the result for each variable in the left side of the assignment
expression:

\iniciocodigo
@<Assignment for Transform Variables@>=
else if(type == TYPE_T_TRANSFORM){
  int i;
  struct transform_variable result;
  if(!eval_transform_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    memcpy(((struct transform_variable *) var -> var) -> value, result.value,
           sizeof(float) * 9);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Now let's see how do we evaluate a transform expression.

\subsubsecao{8.3.1. Transforming Transformers}

The grammar rules to evaluate a transform expression begins with:

\alinhaverbatim
<Transform Expression> -> <Transform Tertiary>
<Transform Tertiary> -> <Transform Secondary>
<Transform Secondary> -> <Transform Secondary> <Transformer> |
                         <Transform Primary>
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary>
                 transformed <Transform Primary>
\alinhanormal

We have here a new type of token, representing the last type of
transformer that we ommited in the last subsection about pair
expressions:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_TRANSFORMED,  // Symbolic token 'transformed'
@
\fimcodigo

This token correspond to the following keyword:

\iniciocodigo
@<List of Keywords@>+=
"transformed",
@
\fimcodigo


About the grammar rules, they mean that there is no tertiary operators
for transform expressions. Anyway, we will define a function to
evaluate tertiary expressions just to keep our API uniform between
different functions that evaluate expressions and also to keep a
function ready to be modified if in the future a tertiary operator is
added to the language:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expression,
                               struct generic_token *end_expression,
                               struct transform_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expression,
                               struct generic_token *end_expression,
                               struct transform_variable *result){
  return eval_transform_secondary(mf, cx, begin_expression, end_expression,
                                  result);
}
@
\fimcodigo

The function that evaluates secondary transform expressions is this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin_expression,
                              struct generic_token *end_expression,
                              struct transform_variable *result);
@
\fimcodigo

This function works walking over the list os tokens in the expression,
ignoring tokens nested in parenthesis, brackets and braces. Each time
it finds a secondary operator, it stores its position. After walking
all tokens, if we did not find a secondary operator, we evaluate the
entire expression as a primary transform expression. Otherwise,
everything before the last operator is evaluated as a secondary
expression and we apply the operator over the resulting transform that
we find after evaluating the expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin_expression,
                              struct generic_token *end_expression,
                              struct transform_variable *result){
  struct generic_token *p, *last_transform = NULL, *last_token = NULL,
                       *end_secondary = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() &&
       (p -> type == TYPE_ROTATED || p -> type == TYPE_SCALED ||
        p -> type == TYPE_SHIFTED || p -> type == TYPE_SLANTED ||
        p -> type == TYPE_XSCALED || p -> type == TYPE_YSCALED ||
        p -> type == TYPE_ZSCALED || p -> type == TYPE_TRANSFORMED)){
      last_transform = p;
      end_secondary = last_token;
    }
    last_token = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(last_transform == NULL)
    return eval_transform_primary(mf, cx, begin_expression, end_expression,
                                  result);
  else{
    if(end_secondary == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Transform expression began "
              "with transformer.",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_transform_secondary(mf, cx, begin_expression, end_secondary,
                                 result))
      return false;
    @<Apply Secondary Transformer over Transforms@>
 #if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer "
            "in transform expression.",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Now let's apply the different transformer operators over our transform
variables and results. The first kind of transformer is the rotation,
which we apply with the code below:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>=
if(last_transform -> type == TYPE_ROTATED){
  struct numeric_variable theta;
  double angle_radian;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                           &theta))
    return false;
  // 1 degree = 0,0174533 radians
  angle_radian = theta.value * 0.0174533;
  TRANSFORM_ROTATE(result -> value, angle_radian);
  return true;
}
@
\fimcodigo

Changing the scale for a transform means running the folllowing code:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_SCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                           &scale))
    return false;
  TRANSFORM_SCALE(result -> value, scale.value);
  return true;
}
@
\fimcodigo

The next transformer makes a translation, or shifting over a distance
$(x, y)$.

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_SHIFTED){
  struct pair_variable shift;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end_expression,
                        &shift))
    return false;
  TRANSFORM_SHIFT(result -> value, shift.x, shift.y);
  return true;
}
@
\fimcodigo


Now the transformer that slants a transform with intensity $s$:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_SLANTED){
  struct numeric_variable slant;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &slant))
    return false;
  TRANSFORM_SLANT(result -> value, slant.value);
  return true;
}
@
\fimcodigo

Changing the scale only in axis $x$ shrinks or expand the transform in
that axis by some factor $s$. This operation is done by the following
code:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_XSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  TRANSFORM_SCALE_X(result -> value, scale.value);
  return true;
}
@
\fimcodigo

We can also change the scale only in the axis $y$ by some factor $s$:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_YSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  TRANSFORM_SCALE_Y(result -> value, scale.value);
  return true;
}
@
\fimcodigo

Finally, we can change the scale in the complex plane, multiplying
each point by $(s, t)$, interpreting everything as complex
numbers. The result is a simultaneous rotation and scaling. This
transformer is implemented by the code below:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_ZSCALED){
  struct pair_variable scale;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  TRANSFORM_SCALE_Z(result -> value, scale.x, scale.y);
  return true;
}
@
\fimcodigo

Finally, the last transformer combines two transforms in a single
one. This is done multiplying both transforms like in the matrix
multiplication below:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{c' \atop d'}\atop
      {0\atop a'}}{{e' \atop f'}\atop {0 \atop
      b'}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
=
\left[{{cc'+ed' \atop dc'+fd'} \atop  {0\atop ac'+bd'+a'}}
      {{ce'+ef' \atop de'+ff'}\atop   {0 \atop ae'+bf'+b'}}
      {{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

This is implemented in the code below:

\iniciocodigo
@<Apply Secondary Transformer over Transforms@>+=
else if(last_transform -> type == TYPE_TRANSFORMED){
  struct transform_variable b;
  if(!eval_transform_primary(mf, cx, last_transform -> next, end_expression,
                            &b))
    return false;
  MATRIX_MULTIPLICATION(result -> value, b.value);
  return true;
}
@
\fimcodigo

\subsecao{8.3.2 Transform Tertiary Expressions: Literals and Variables}

The remaining rules in the grammar for transform expressions are:

\alinhaverbatim
<Transform Primary> -> <Transform Variable> |
                       ( <Transform Tertiary> ) |
                       ( <Numeric Expression> , <Numeric Expression> ,
                         <Numeric Expression> , <Numeric Expression> ,
                         <Numeric Expression> , <Numeric Expression> )
\alinhanormal

In the first case, we have a single symbolic token with a transform
variable. In the other two cases, we have more than one token where
the first one is an open parenthesis. In one we have a single
transform expression in the parenthesis and in the other we have
comma-separated six numeric expressions expressing a transform
literal.

The function that evaluates primary transform expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct transform_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct transform_variable *result){
  if(begin_expression == end_expression &&
     begin_expression -> type == TYPE_SYMBOLIC){
    @<Primary Transform: Variable@>
  }
  else if(begin_expression != end_expression &&
          begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS &&
          begin_expression -> next != end_expression){
    struct generic_token *p = begin_expression -> next;
    DECLARE_NESTING_CONTROL();
    bool has_comma = false;
    do{
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() && p -> type == TYPE_COMMA){
        RESET_NESTING_COUNT();
        has_comma = true;
        break;
      }
      if(p != end_expression)
        p = (struct generic_token *) p -> next;
      else
        p = NULL;
    } while(p != NULL);
    if(has_comma){
      @<Primary Transform: Literal@>
    }
    else{
      @<Primary Transform: Parenthesis@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transform primary "
          "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
}
@
\fimcodigo

The simplest case is evaluating a transform variable:

\iniciocodigo
@<Primary Transform: Variable@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct transform_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not allocated variable: "
          "%s.\n", mf -> file, v -> line, v -> value);
#endif
  return false;
}
memcpy(result -> value, content -> value, sizeof(float) * 9);
return true;
@
\fimcodigo

The next case is when we have a subexpression between parenthesis:

\iniciocodigo
@<Primary Transform: Parenthesis@>=
struct generic_token *end_expr;
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis in transform "
          "expression.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
for(end_expr = begin_expression -> next; end_expr -> next != end_expression;
    end_expr = end_expr -> next);
return eval_transform_expression(mf, cx, begin_expression -> next, end_expr,
                                 result);
@
\fimcodigo

And finally, the last case, where we need to interpret six numeric
expressions to obtain a transform literal:

\iniciocodigo
@<Primary Transform: Literal@>=
int i;
struct generic_token *begin_numeric_expr, *end_numeric_expr;
struct numeric_variable numeric_result;
begin_numeric_expr = begin_expression -> next;
end_numeric_expr = begin_numeric_expr;
float values[6];
for(i = 0; i < 6; i ++){
  p = begin_numeric_expr;
  do{
    if(p != end_expression){
      COUNT_NESTING(p);
    }
    if(IS_NOT_NESTED() && ((i < 5 && p -> type == TYPE_COMMA) ||
                            (i == 5 && p -> type == TYPE_CLOSE_PARENTHESIS)))
      break;
    end_numeric_expr = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(p == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Invalid transform literal in "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_numeric_expression(mf, cx, begin_numeric_expr, end_numeric_expr,
                              &numeric_result))
    return false;
  values[i] = numeric_result.value;
  begin_numeric_expr = p -> next;
  end_numeric_expr = begin_numeric_expr;
}
// Storing in the correct order inside the matrix:
result -> value[0] = values[2]; result -> value[1] = values[4];
result -> value[2] = 0.0;
result -> value[3] = values[3]; result -> value[4] = values[5];
result -> value[5] = 0.0;
result -> value[6] = values[0]; result -> value[7] = values[1];
result -> value[8] = 1.0;
return true;
@
\fimcodigo

\subsubsecao{8.3.3. Transforms in Numeric Expressions}

Transforms can be placed in primary numeric expressions. The following
grammar rules allow them:

\alinhaverbatim
<Numeric Primary> -> <Transform Part><Transform Primary>
<Transform Part> -> xpart | ypart | xxpart | xypart | yxpart | yypart
\alinhanormal

The six operators above extract each one of the six numeric values
in a transform, in the same order that they are listed.

As \monoespaco{xpart} and \monoespaco{ypart} already were defined when
we were defining pair expressions, we just need to define the next
four new tokens for the new operators:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_XXPART,  // Symbolic token xxpart'
TYPE_XYPART,  // Symbolic token xypart'
TYPE_YXPART,  // Symbolic token yxpart'
TYPE_YYPART,  // Symbolic token yypart'
@
\fimcodigo

And the keywords associated with them:

\iniciocodigo
@<List of Keywords@>+=
"xxpart", "xypart", "yxpart", "yypart",
@
\fimcodigo

These four new operators are evaluated in the function that evaluates
primary numeric expressions:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type >= TYPE_XXPART &&
         begin_expression -> type <= TYPE_YYPART){
  struct transform_variable t;
  if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                       begin_expression -> next, end_expression,
                             &t))
    return false;
  if(begin_expression -> type == TYPE_XXPART)
    result -> value = t.value[0];
  else if(begin_expression -> type == TYPE_XYPART)
    result -> value = t.value[3];
  else if(begin_expression -> type == TYPE_YXPART)
    result -> value = t.value[1];
  else if(begin_expression -> type == TYPE_YYPART)
    result -> value = t.value[4];
  return true;
}
@
\fimcodigo

But what about \monoespaco{xpart} and \monoespaco{ypart}? They were
already treated when we were evaluating primary numeric expressions in
Sub-subsection 8.2.4. But we need to augment the definition of this
operator present there to also deal with cases where the operand is
not a pair, but a transform. This is how we do this for
the \monoespaco{xpart} operator:

\iniciocodigo
@<Numeric Primary: X-Part in Non-Pair@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &t))
  return false;
result -> value = t.value[6];
return true;
@
\fimcodigo

And the same must be done for the \monoespaco{ypart} operator:

\iniciocodigo
@<Numeric Primary: Y-Part in Non-Pair@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &t))
  return false;
result -> value = t.value[7];
return true;
@
\fimcodigo

\subsubsecao{8.3.4. Transforms in Pair Expressions}

Transforms also appear in grammar rules about pair expressions. It is
needed to deal woth transform expressions in pair secondary
expressions:

\alinhaverbatim
<Pair Secondary> -> <Pair Secondary><Transformer>
<Transformer> -> (...) | transformed <Transform Primary>
\alinhanormal

This operator apply the linear transform in the right-side to the pair
in the left-side. We can implement it with the code below that augment
the already written code about transformers in Subsection 8.2.2. about
pair secondary expressions.

\iniciocodigo
@<Secondary Pair Operator: Additional Operators@>=
else if(last_mul -> type == TYPE_TRANSFORMED){
  struct pair_variable a;
  struct transform_variable b;
  if(!eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a))
    return false;
  if(!eval_transform_primary(mf, cx, begin_primary, end_expression, &b))
    return false;
  result -> x = LINEAR_TRANSFORM_X(a.x, a.y, b.value);
  result -> y = LINEAR_TRANSFORM_Y(a.x, a.y, b.value);
  return true;
}
@
\fimcodigo


\subsecao{8.4. Path Assignments and Expressions}

To assign a path to a variable with the right type, we use the
following code:

\iniciocodigo
@<Assignment for Path Variables@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  if(!eval_path_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_path_variable(mf, (struct path_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &result, false);
}
@
\fimcodigo

The declaration for the assignment function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> length != -1 && disalloc != NULL)
    path_recursive_free(disalloc, target, false);
  recursive_copy_points(alloc, &target, source, false);
}
@
\fimcodigo

Copying a path recursively means allocating space for the new path and
copying the data. While copying the points, we should also check if
there are other subpaths that should be copyied recursively. To do
this, we use the following auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target);
@
\fimcodigo

This function will make the allocation for the new variable if
necessary, will also get the pointers por the point array in the
destiny and will call another auxiliary function to walk recursively
over the destiny while copying the points:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target){
  struct path_points *p;
  if(alloc_target)
    *target = (struct path_variable *) alloc(sizeof(struct path_variable));
  (*target) -> cyclic = source -> cyclic;
  (*target) -> length = source -> total_length;
  (*target) -> total_length = source -> total_length;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> total_length);
  p = (*target) -> points;
  recursive_aux_copy(&p, source);
}
@
\fimcodigo

The function that will walk over the origin recursively copying the
points:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin){
  int index = 0;
  while(index <= origin -> length - 1){
    if(origin -> points[index].subpath == NULL &&
       !isnan(origin -> points[index].x)){
      // Copy:
      memcpy(*dst, &(origin -> points[index]),  sizeof(struct path_points));
      (*dst) -> subpath = NULL;
      (*dst) ++;
    }
    else if(origin -> points[index].subpath != NULL)
      recursive_aux_copy(dst, (struct path_variable *)
                              (origin -> points[index].subpath));
    index  ++;
  }
  return;
}
@
\fimcodigo


Now we can examine the path expressions.

\subsubsecao{8.4.1. Joining Paths}

The grammar for path expressions begin with:

\alinhaverbatim
<Path Expression> -> <Pair Expression> | <Path Tertiary> |
                     <Path Subexpression><Direction Specifier> |
                     <Path Subexpression><Path Join> cycle
<Path Join> -> <Direction Specifier><Basic Join><Direction Specifier>
<Basic Join> -> & | .. | .. <Tension> .. | .. <Controls> .. | --
<Tension> -> tension <Tension Amount> |
             tension <Tension Amount> and <Tension Amount>
<Tension Amount> -> <Numeric Primary> | atleast <Numeric Primary>
<Controls> -> controls <Pair Primary> |
              controls <Pair Primary> and <Pair Primary>
<Direction Specifier> -> Empty |
                         { <Pair Expression } |
                         { <Numeric Expression> , <Numeric Expression> }
<Path Subexpression> -> <Path Expression> |
                        <Path Subexpression><Path Join><Path Tertiary>
\alinhanormal

This requires the register of these new types of tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_CYCLE,          // Symbolic token 'cycle'
TYPE_AMPERSAND,      // Symbolic token '&'
TYPE_JOIN,           // Symbolic token '..'
TYPE_TENSION,        // Symbolic token 'tension'
TYPE_AND,            // Symbolic token 'and'
TYPE_ATLEAST,        // Symbolic token 'atleast'
TYPE_CONTROLS,       // Symbolic token 'controls'
TYPE_CURL,           // Symbolic token 'curl' (still not supported)
TYPE_STRAIGHT_JOIN,  // Symbolic token '--'
@
\fimcodigo

And for each one we register a new correspondent keyword:

\iniciocodigo
@<List of Keywords@>+=
"cycle", "&", "..", "tension", "and", "atleast", "controls", "curl", "--",
@
\fimcodigo

The first thing that we will define is how to count the number of
joins in a path expression. For this we will use the following
function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end);
@
\fimcodigo

The function works counting the number of ``\&'', ``--'' and also
counting the ``..'' that appear alone or that appear for the second
time in a join that specifies tension or control points:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end){
int count = 0;
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin;
  while(p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_AMPERSAND)
        count ++;
      else if(p -> type == TYPE_STRAIGHT_JOIN)
        count ++;
      else if(p -> type == TYPE_JOIN){
        struct generic_token *next = (struct generic_token *) p -> next;
        if(p == end || (next -> type !=  TYPE_TENSION &&
                        next -> type != TYPE_CONTROLS))
          count ++;
      }
    }
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }
  return count;
}
@
\fimcodigo

Now we can begin the expression evaluation.

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result);
@
\fimcodigo

Knowing the number of joins is the first step to discover the size of
our new variable and how should we allocate space for it. The number
of points is always the number of joins plus one:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result){
  int expected_length;
  int number_of_joins = count_path_joins(begin_expression, end_expression);
  expected_length = number_of_joins + 1;
  @<Path Expression: When There is No Joins@>
  @<Path Expression: Allocating Path Variable@>
  @<Path Expression: Iterating over Joins@>
  return true;
}
@
\fimcodigo

And what if the number of joins is zero? In this case we could have a
pair expression or a path tertiary expression. Anyway, we could have
in the end a direction specifier, which should be ignored in the case
of a single point or element without a join. We check if we have a
direction specifier checking if the last token is ``$\}$''. In this case,
we change the position of the end of expression for the last token
before the direction specifier:

\iniciocodigo
@<Path Expression: When There is No Joins@>=
if(number_of_joins == 0){
  if(end_expression -> type == TYPE_CLOSE_BRACES){
    struct generic_token *p = begin_expression;
    DECLARE_NESTING_CONTROL();
    while(p != end_expression){
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() &&
         ((struct generic_token *) p -> next) -> type == TYPE_OPEN_BRACES)
        break;
      p = (struct generic_token *) p -> next;
    }
    end_expression = p;
  }
  return eval_path_tertiary(mf, cx, begin_expression, end_expression,
                           result);
}
@
\fimcodigo

If there are one or more joins, then we need to allocate the new
points in our path variable. The number of allocated points is given
by variable \monoespaco{expected\_length}:

\iniciocodigo
@<Path Expression: Allocating Path Variable@>=
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points) *
                     expected_length);
if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
          begin_expression -> line);
#endif
    return false;
}
result -> length = 0; // Initialization
result -> total_length = 0;
result -> points[0].x = NAN;
result -> cyclic = false;
@
\fimcodigo

Now we will evaluate the joins. We need to iterate over all the tokens
finding the joins in the format:

$$
z_1{d} j {e}\_2
$$

Therefore, we need variables to store the begin and end of each part
while we perform the iteration. And then we create a loop where we
will iterate over each join in the format above:

\iniciocodigo
@<Path Expression: Iterating over Joins@>=
{
  struct generic_token *begin_z1, *end_z1 = NULL, *begin_z2, *end_z2;
  struct generic_token *begin_d = NULL, *end_d = NULL, *begin_e, *end_e;
  struct generic_token * begin_j, *end_j;
  struct path_points *z1_point = NULL, *z2_point = NULL;
  @<Path Expression: Additional Variables Declaration@>
  begin_z1 = begin_expression;
  end_z1 = begin_z1;
  while(begin_z1 != end_expression || result -> length < expected_length){
    @<Path Expression: Delimit Join Tokens@>
    @<Path Expression: Interpret Join Extremities@>
    @<Path Expression: Interpret Direction Specifiers@>
    @<Path Expression: Interpret the Join@>
    @<Path Expression: Determine Curve Shape@>
    @<Path Expression: End of Each Iteration@>
    begin_z1 = begin_z2;
    end_z1 = end_z2;
  }
}
@
\fimcodigo

We need to delimit the first element $z_1$ only in the first
iteration, when we are still in the beginning of the expression. In
the other iterations the element is already delimited in the beginning
as seen in the code above. To correctly delimit the token, we just
walk over the token list until we find the last token before ``$\{$'',
``\&'', ``\-\-'' or ``..'' assuming that we are not inside parenthesis or
brackets.

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>=
if(begin_z1 == begin_expression){
  DECLARE_NESTING_CONTROL();
  int next_type;
  end_z1 = begin_z1;
  while(end_z1 != end_expression){
    COUNT_NESTING(end_z1);
    next_type = ((struct generic_token *) end_z1 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z1 = (struct generic_token *) end_z1 -> next;
  }
}
@
\fimcodigo

Now we will delimit the first direction specifier. First we check if
we are in the end of an expression. If so, we interrupt the loop and
exit, as there are no more specifiers and we finished to read and
obtain the path. Otherwise, we read the next token to check if we have
a ``$\{$''. If not, there is no first direction specifier.  If so, then
we delimit it until finding the closing ``$\}$'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_z1 == end_expression)
  return true;
begin_d = (struct generic_token *) end_z1 -> next;
if(begin_d -> type != TYPE_OPEN_BRACES){
  begin_d = NULL;
  end_d = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_d = begin_d;
  while(end_d != end_expression){
    COUNT_NESTING(end_d);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_d) -> type == TYPE_CLOSE_BRACES)
      break;
    end_d = (struct generic_token *) end_d -> next;
  }
  if(begin_d == end_d){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_d -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Now we will delimit the join. If the join is ``\&'' or a ``--'', then
it is a single token. If the join begins with ``..'', then it could be
a single token if the next token is not ``\monoespaco{controls}'' or
``\monoespaco{tension}''. But if the next token is these specifiers,
then the join is delimited by the first ``..'' and the second ``..'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_d == NULL)
  begin_j = (struct generic_token *) end_z1 -> next;
else{
  if(end_d == end_expression)
    return true;
  begin_j = (struct generic_token *) end_d -> next;
}
end_j = begin_j;
if(begin_j -> type == TYPE_JOIN){
  struct generic_token *next_token;
  next_token = (struct generic_token *) begin_j -> next;
  if(next_token -> type == TYPE_CONTROLS || next_token -> type == TYPE_TENSION){
    DECLARE_NESTING_CONTROL();
    end_j = next_token;
    while(end_j != end_expression){
      COUNT_NESTING(end_j);
      if(IS_NOT_NESTED() && end_j -> type == TYPE_JOIN)
        break;
      end_j = (struct generic_token *) end_j -> next;
    }
  }
}
else if(begin_j -> type != TYPE_AMPERSAND &&
        begin_j -> type != TYPE_STRAIGHT_JOIN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, begin_j -> line);
#endif
  return false;
}
@
\fimcodigo

The next direction delimiter may exist or not, depending if the next
token is ``$\{$'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_j == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, end_j -> line);
#endif
  return false;
}
begin_e = (struct generic_token *) end_j -> next;
if(begin_e -> type != TYPE_OPEN_BRACES){
  begin_e = NULL;
  end_e = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_e = begin_e;
  while(end_e  != end_expression){
    COUNT_NESTING(end_e);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_e) ->  type == TYPE_CLOSE_BRACES)
      break;
    end_e = (struct generic_token *) end_e -> next;
  }
  if(begin_e == end_e){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_e -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Finally, the last join element is the next point or subpath joining
the previous one. This is always a tertiary path expression. This last
element will have its end delimited by an ampersand, opening braces or
by a join token:

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
{
  DECLARE_NESTING_CONTROL();
  int next_type;
  if(end_e == NULL)
    begin_z2 = (struct generic_token *) end_j -> next;
  else{
    if(end_e == end_expression)
      return true;
    begin_z2 = (struct generic_token *) end_e -> next;
  }
  end_z2 = begin_z2;
  while(end_z2 != end_expression){
    COUNT_NESTING(end_z2);
    next_type = ((struct generic_token *) end_z2 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z2 = (struct generic_token *) end_z2 -> next;
  }
}
@
\fimcodigo

Once we delimited each part of the join, now we need to interpret the
parts. First we will care about the extremity curve points. For this,
first we get the result of $z_1$, a path tertiary expression, and copy
it to our result. We need to do this only when we are in the beginning
of an expression, in the other cases we already interpreted this point
or subpath in the previous iteration:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>=
if(begin_z1 == begin_expression){
  bool ret;
  struct path_variable z1;
  ret = eval_path_tertiary(mf, cx, begin_z1, end_z1, &z1);
  if(!ret)
    return false;
  if(z1.length == 1 && z1.points[0].subpath == 0){
    result -> points[0].subpath = NULL;
    result -> points[0].x = z1.points[0].x;
    result -> points[0].y = z1.points[0].y;
    result -> total_length ++;
  }
  else{
    recursive_copy_points(temporary_alloc, (struct path_variable **)
                                           &(result -> points[0].subpath), &z1,
                                           true);
    result -> total_length += ((struct path_variable *)
                                result -> points[0].subpath) -> total_length;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z1, false);
}
@
\fimcodigo

And we need to do the same with $z_2$, the other extremity. But in
this case, we need to recall that the next point may be
a \monoespaco{cycle} token. If so, we copy the first point. Otherwise,
we interpret the value like we did for $z_1$:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  struct path_points *p = result -> points;
  while(p[0].subpath != NULL)
    p = ((struct path_variable *) p[0].subpath) -> points;
  result -> points[result -> length].subpath = NULL;
  result -> points[result -> length].x = p[0].x;
  result -> points[result -> length].y = p[0].y;
  result -> points[result -> length].u_x = p[0].u_x;
  result -> points[result -> length].u_y = p[0].u_y;
  result -> points[result -> length].v_x = p[0].v_x;
  result -> points[result -> length].v_y = p[0].v_y;
  result -> length ++;
  result -> total_length ++;
  result -> cyclic = true;
}
else{
  bool ret;
  struct path_variable z2;
  ret = eval_path_tertiary(mf, cx, begin_z2, end_z2, &z2);
  if(!ret)
    return false;
  if(z2.length == 1 && z2.points[0].subpath == 0){
    result -> points[result -> length].subpath = NULL;
    result -> points[result -> length].x = z2.points[0].x;
    result -> points[result -> length].y = z2.points[0].y;
    result -> total_length ++;
  }
  else{
    recursive_copy_points(temporary_alloc,
                         (struct path_variable **)
                         &(result -> points[result -> length].subpath), &z2,
                         true);
    result -> total_length +=
        ((struct path_variable *)
            result -> points[result -> length].subpath) -> total_length;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z2, false);
}
@
\fimcodigo

After running the code above, our result variable that stores the
expression result already has the extremity points from this join. But
we still do not have the control points. But before compute them, we
will set the pointers \monoespaco{z1\_point}
and \monoespaco{z2\_point} to point to the current extremity points of
the current join. We read this information from the
variable \monoespaco{result} that we are filling:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>+=
z1_point = &(result -> points[result -> length - 2]);
while(z1_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z1_point -> subpath;
  z1_point = &(p -> points[p -> length - 1]);
}
z2_point = &(result -> points[result -> length - 1]);
while(z2_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z2_point -> subpath;
  z2_point = &(p -> points[0]);
}
@
\fimcodigo

Now we need to interpret both direction specifiers. They can be empty
(which is equivalent to have direction $(0, 0)$) or they can be a pair
specifying a direction vector.

We will store them in the variables \monoespaco{(w0\_x,
w0\_y)} and \monoespaco{(w1\_x, w1\_y)}.  We also
will store the previous direction specifier from last iteration and
also we will reserve space to store the next direction specifier if we
need to peek it ahead of time. This could be necessary to take in
consideration a broader picture when deciding the curve shape:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>=
float w0_x = NAN, w0_y = NAN, w1_x = NAN, w1_y = NAN;
float prev_w_x = NAN, prev_w_y = NAN;
float next_w_x = NAN, next_w_y = NAN;
@
\fimcodigo

During this iteration where we are delimiting and interpreting the
join operator and its points, we need to reinitialize such values. The
current specifiers are set as null, except that if the previous
iteration stored a next specifier, this specifier is our first one and
we do not need to read it again. After this, the next value is
erased. And finally, after this, we read the second direction
specifier from the tokens:

\iniciocodigo
@<Path Expression: Interpret Direction Specifiers@>=
w0_x = w0_y = w1_x = w1_y = NAN;
if(!isnan(next_w_x)){
  w0_x = next_w_x;
  w0_y = next_w_y;
}
else if(!eval_direction_specifier(mf, cx, begin_d, end_d, &w0_x, &w0_y))
  return false;
next_w_x = next_w_y = NAN;
if(!eval_direction_specifier(mf, cx, begin_e, end_e, &w1_x, &w1_y))
  return false;
@
\fimcodigo

The function that evaluates direction specifiers is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y);
@
\fimcodigo

And the function works checking for 4 different cases: when there is
no direction specifier, when it is a curl specification, when it is a
direction specified by two numbers and when it is a direction
specified by a pair:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y){
  @<Direction Specifier: Case 1@>
  @<Direction Specifier: Case 2@>
  @<Direction Specifier: Case 3@>
  return false;
}
@
\fimcodigo

When a specifier does not exist, we store nothing and return letting
the values as indefinide:

\iniciocodigo
@<Direction Specifier: Case 1@>=
if(begin == NULL || end == NULL){
  return true;
}
@
\fimcodigo

Now we will check if we have the case ``$\{ a , b\}$'' where $a$ and
$b$ are numbers. To check for this case, we will try to delimit $a$
and $b$ searching for the comma. We will interpret this case only if
the comma is found:

\iniciocodigo
@<Direction Specifier: Case 2@>=
DECLARE_NESTING_CONTROL();
struct generic_token *begin_a, *end_a, *begin_b = NULL, *end_b;
begin_a = (struct generic_token *) begin -> next;
end_a = begin_a;
while(end_a -> next != end){
  COUNT_NESTING(end_a);
  if(IS_NOT_NESTED() && end_a -> type == TYPE_COMMA){
    begin_b = (struct generic_token *) end_a -> next;
    break;
  }
  end_a = (struct generic_token *) end_a -> next;
}
if(begin_b != NULL){
  struct numeric_variable a, b;
  end_b = begin_b;
  while(end_b -> next != end)
    end_b = (struct generic_token *) end_b -> next;
  if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(a.value != 0.0 || b.value != 0.0){
    *w_x = a.value;
    *w_y = b.value;
  }
  return true;
}
@
\fimcodigo

And finally, the last case, where we have an element $\{a\}$, where
$a$ is a pair expression. To deal with this case, recall that in the
previous case we already delimited $a$. If a comma was not found, we
did not delimited $b$, but still delimited $a$. Therefore, we can
interpret the tokens as a pair expression:

\iniciocodigo
@<Direction Specifier: Case 3@>=
else{ // if in the previous case there was no comma
  struct pair_variable a;
  if(!eval_pair_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(a.x != 0.0 || a.y != 0.0){
    *w_x = a.x;
    *w_y = a.y;
  }
  return true;
}
@
\fimcodigo

Now finally we will interpret the join itself. As the direction
specifier can be represented in two ways, as a direction vector or as
a curl, the join can be represented by two numbers representing the
tension or two pairs $u$ and $v$ representing directly the control
points. We will declare then variables that will hold these values:

\iniciocodigo
@<Path Expression: Interpret the Join@>=
float tension0 = NAN, tension1 = NAN, u_x = NAN, u_y = NAN, v_x = NAN,
      v_y = NAN;
bool atleast0 = false, atleast1 = false; // If our tension is just an inferior limit
@
\fimcodigo

First we will deal with the simplest cases. If our join is a
concatenation, characterized by the ``\&'' token, we are concatenating
tow points or (more probably) two sub-paths. In this case we should
check is the two joining points occupy the same place (which means
having a distance lesser than 0.00002). If not, we should raise an
error. If so, we join both paths removing the second copy of the point
where the join is happening.

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
  double dif_x = z1_point -> x - z2_point -> x;
  double dif_y = z1_point -> y - z2_point -> y;
  if(hypot(dif_x * dif_x, dif_y * dif_y) > 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Concatenating discontinuous paths.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  v_x = u_x = z1_point -> x;
  v_y = u_y = z1_point -> y;
  // This will overwrite the second extremity point
  // and also the control points below in the case of a next iteration:
  result -> total_length --;
  z1_point -> x = NAN;
  z1_point -> y = NAN;
}
@
\fimcodigo

Another simple case is when we use the ``\monoespaco{--}'' join. In
this case, we make the control points evenly spaced between both
extremity points. This will create a straight line between them:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN){
  u_x = z1_point -> x + (1.0/3.0) * (z2_point -> x - z1_point -> x);
  u_y = z1_point -> y + (1.0/3.0) * (z2_point -> y - z1_point -> y);
  v_x = z1_point -> x + (2.0/3.0) * (z2_point -> x - z1_point -> x);
  v_y = z1_point -> y + (2.0/3.0) * (z2_point -> y - z1_point -> y);
}
@
\fimcodigo


If our join is composed just by the token ``..'', then it will be
defined as having a tension of exactly 1 and 1:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_JOIN){
  tension0 = 1.0;
  tension1 = 1.0;
  atleast0 = false;
  atleast1 = false;
}
@
\fimcodigo

The join could be specifying directly the control points in the form
``.. controls $c_0$ ..'' or ``.. controls $c_0$ and $c_1$ .. '', where
$c_0$ and $c_1$ are pair expressions. In this case we try to delimit
the values of $c_0$ and $c_1$ (if it exists) and use them directly as
control points. If $c_1$ does not exist, then we use as the second
control point a point equal $c_0$:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_c0, *end_c0, *begin_c1 = NULL, *end_c1 = NULL;
  struct pair_variable c0, c1;
  begin_c0 = (struct generic_token *) begin_j -> next;
  begin_c0 = (struct generic_token *) begin_c0 -> next;
  if(begin_c0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  end_c0 = begin_c0;
  while(end_c0 -> next != end_j){
    COUNT_NESTING(end_c0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_c0 -> next) -> type == TYPE_AND)
      break;
    end_c0 = (struct generic_token *) end_c0 -> next;
  }
  if(end_c0 -> next != end_j){
    begin_c1 = end_c0 -> next;
    begin_c1 = (struct generic_token *) begin_c1 -> next;
    if(begin_c1 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    end_c1 = begin_c1;
    while(end_c1 -> next != end_j)
      end_c1 = (struct generic_token *) end_c1 -> next;
  }
  if(!eval_pair_primary(mf, cx, begin_c0, end_c0, &c0))
    return false;
  u_x = c0.x;
  u_y = c0.y;
  if(begin_c1 != NULL){
    if(!eval_pair_primary(mf, cx, begin_c1, end_c1, &c1))
      return false;
     v_x = c1.x;
     v_y = c1.y;
  }
  else{
    v_x = c0.x;
    v_y = c0.y;
  }
}
@
\fimcodigo

The last join type have the format ``.. tension $t_0$ ..'' or
``.. tension $t_0$ and $t_1$ .. '' where $t_0$ and $t_1$ are primary
numeric expressions that should evaluate to a value greater or equal
than 3/4 and which can optionally be preceded by the token
``\monoespaco{atleast}''. If just $t_0$ is defined but not $t_1$, we
assume that $t_1$ have the same value than $t_0$. We can then
interpret this join with the code below:


\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_TENSION){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_t0, *end_t0, *begin_t1 = NULL, *end_t1 = NULL;
  struct numeric_variable t0, t1;
  begin_t0 = (struct generic_token *) begin_j -> next;
  begin_t0 = (struct generic_token *) begin_t0 -> next;
  if(begin_t0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  if(begin_t0 == end_j ||
     (begin_t0 -> type == TYPE_ATLEAST && begin_t0 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  else
    atleast0 = false;
  end_t0 = begin_t0;
  while(end_t0 -> next != end_j){
    COUNT_NESTING(end_t0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_t0 -> next) -> type == TYPE_AND)
      break;
    end_t0 = (struct generic_token *) end_t0 -> next;
  }
  if(end_t0 -> next != end_j){
    begin_t1 = end_t0 -> next;
    begin_t1 = (struct generic_token *) begin_t1 -> next;
    if(begin_t1 == end_j ||
       (begin_t1 -> type == TYPE_ATLEAST && begin_t1 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    if(begin_t1 -> type == TYPE_ATLEAST){
      atleast1 = true;
      begin_t1 = (struct generic_token *) begin_t1 -> next;
    }
    else
      atleast1 = false;
    end_t1 = begin_t1;
    while(end_t1 -> next != end_j)
      end_t1 = (struct generic_token *) end_t1 -> next;
  }
  if(!eval_numeric_primary(mf, cx, begin_t0, end_t0, &t0))
    return false;
  tension0 = t0.value;
  if(begin_t1 != NULL){
    if(!eval_numeric_primary(mf, cx, begin_t1, end_t1, &t1))
      return false;
    tension1 = t1.value;
  }
  else{
    tension1 = t0.value;
  }
  if(tension0 < 0.75 || tension1 < 0.75){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
          "METAFONT: Error: %s:%d: Improper tension. Should be >= 0.75\n",
          mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

After interpreting the join, either we have a pair of control points,
in which case we do not need to do anything more to determine the
curve shape, or we havetwo numbers representing the curve tension. In
this case, it will be important to take into consideration the
direction specifiers to choose the final curve shape.

However, the direction specifiers could be empty. In this case, there
are several rules that we should follow to choose the default direction.

%The first rule is that in the beginning and end of a non-cyclic path,
%we always will have an implicit ``\monoespaco{$\{$curl 1$\}$}''.
%The same happens before and after a concatenation. Therefore:

%$$
%z_0 .. z_1 .. z_2 = \{\monoespaco{curl}\ 1\}z_0 .. z_1 .. z_2\{\monoespaco{curl}\ 1\}
%$$

%And also:

%$$
%.. z_n \& z_{n+1} .. = .. z_n\{\monoespaco{curl}\ 1\} \& \{\monoespaco{curl}\ 1\}z_{n+1} ..
%$$

%This means that in the first iteration, if we are not in a cyclic
%path, we need to consider that the previous direction specifier
%is \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>=
%if(begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE)
%  prev_curl = 1.0;
%
%\fimcodigo

%If we are in a concatenation, if ee have no direction specifier, then
%we consider them as \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>+=
%if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
%  if(isnan(curl0) && isnan(w0_x))
%    curl0 = 1.0;
%  if(isnan(curl1) && isnan(w1_x))
%    curl1 = 1.0;
%}
%
%\fimcodigo

%And finally, if we are not in a cyclic path and we do not have a
%direction specifier after the second current point, we must check if
%we are in the last path join. We check this looking at the tokens and
%looking if there are a next join after the second current point and
%before the end of the expression. If this is the last join, we
%consider the last delimiter as \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>+=
%if(end_z1 == end_expression)
%  next_curl = 1.0;
%else if(end_expression -> type != TYPE_CYCLE &&
%        ((struct generic_token *) (end_z1 -> next)) -> type !=
%        TYPE_OPEN_BRACES){
%  bool last_join = true;
%  struct generic_token *p = (struct generic_token *) end_z1 -> next;
%  DECLARE_NESTING_CONTROL();
%  while(p != end_expression){
%    COUNT_NESTING(p);
%    if(IS_NOT_NESTED() &&
%       (p -> type == TYPE_AMPERSAND || p -> type == TYPE_JOIN)){
%      last_join = false;
%      break;
%    }
%    p = (struct generic_token *) p -> next;
%  }
%  if(last_join)
%    next_curl = 1.0;
%}
%
%\fimcodigo

%These rules by themselves do not do anything. The beginning and end
%points in a non-cyclic path are discontinuous, we do not need control
%points after them. Likewise, in a concatenation we have equal points
%joining. We do not need anything between them. However, these previous
%rules became relevant when combined with the next rules.

If there is a direction specifier after a point, but not before, we
copy the direction specifier. We do the same when there is a direction
specifier before, but not after it. Therefore:

$$
.. z_0 .. z_1\{d\} ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

And also:

$$
.. z_0 .. \{d\}z_1 ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

The cyclic nature of a path must be taken into consideration.

For the case where we want to copy the direction specifier in the left
side to the right side of a point, we need to preserve this value
between iterations. By our rules, it is important to preserve the
value only when we read it explicitly between braces. Then, when we
are in the end of each iteration, we preserve the specifier in these
cases, otherwise we erase it:

\iniciocodigo
@<Path Expression: End of Each Iteration@>=
if((begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE) ||
   (begin_j == end_j && begin_j -> type == TYPE_AMPERSAND) ||
   (begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN) ||
   (begin_e != NULL && end_e != NULL)){
  prev_w_x = w1_x;
  prev_w_y = w1_y;
}
else{
  prev_w_x = NAN;
  prev_w_y = NAN;
}
@
\fimcodigo

Now to apply the rule where we copy the specifier from the left of a
point to its right, we use the code:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(w0_x) && isnan(w0_y)){
  w0_x = prev_w_x;
  w0_y = prev_w_y;
}
@
\fimcodigo

Now we copy the direction specifier from the right to the left. We do
this only if we already do not have a defined specifier and if the
specifier to the right is given explicitly between braces:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(w1_x) && isnan(w1_y)               ){
  if(end_z2 -> next != NULL && end_z2 != end_expression &&
     ((struct generic_token *) (end_z2 -> next)) -> type ==
     TYPE_OPEN_BRACES){
    struct generic_token *next0, *next1;
    DECLARE_NESTING_CONTROL();
    next0 = (struct generic_token *) end_z2 -> next;
    next1 = next0;
    while(next1 != end_expression){
      COUNT_NESTING(next1);
      if(IS_NOT_NESTED() && next1 -> type == TYPE_CLOSE_BRACES)
        break;
      next1 = (struct generic_token *) next1 -> next;
    }
    if(next0 -> type == TYPE_OPEN_BRACES && next1 -> type == TYPE_CLOSE_BRACES){
      if(!eval_direction_specifier(mf, cx, next0, next1, &next_w_x,
                                   &next_w_y))
        return false;
      w1_x = next_w_x;
      w1_y = next_w_y;
    }
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
              mf -> file, begin_j -> line);
#endif
      return false;
    }
  }
}
@
\fimcodigo

But we also need to deal with the cyclic case. By the grammar rules,
there will be no direction specifier before the first point. But a
direction specifier can be placed before the token \monoespaco{cycle}
if it exists. And in this case, this specifier could be copied to the
right side of the first point. Likewise, the direction specifier can
be copied from the right side of the first point to the place before
the \monoespaco{cycle} token if we do not have an explicit specifier
there.

First the simplest case: there is an explicit direction specifier
after the first point in the beginning of a cyclic path. In this case,
we need to store it to use when choosing the last control points in
the curve. To store it, we will need the following new variables:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float first_w_x = NAN, first_w_y = NAN;
@
\fimcodigo

And then, in the first iteration over the joins, if we are in a cyclic
path and if exists an explicit specifier, we store it:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d != NULL && end_d != NULL){
  first_w_x = w0_x;
  first_w_y = w0_y;
}
@
\fimcodigo

After, when we arrive at the last iteration of a cyclic path, we will
take into account the stored value:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  if(!isnan(first_w_x) && isnan(w1_x)){
    w1_x = first_w_x;
    w1_y = first_w_y;
  }
}
@
\fimcodigo

To make copies in the opposite direction, when we are in the first
iteration, we need to look at the last join. First we walk over the
expression until the end (until finding \monoespaco{cycle}) always
storing the last direction specifier and the last join. If the
token \monoespaco{cycle} appear after the last specifier, then we need
to check its value and copy it.

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d == NULL && isnan(w0_x) && isnan(u_x)){
  struct generic_token *begin_last_spec = NULL, *end_last_spec = NULL,
                       *last_join = NULL, *second_last_join = NULL, *p;
  DECLARE_NESTING_CONTROL();
  p = end_z1 -> next;
  while(p != end_expression){
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_OPEN_BRACES){
        begin_last_spec = p;
      }
      else if(p -> type == TYPE_CLOSE_BRACES)
        end_last_spec = p;
      else if(p -> type == TYPE_JOIN || p -> type == TYPE_AMPERSAND ||
              p -> type == TYPE_STRAIGHT_JOIN){
        second_last_join = last_join;
        last_join = p;
      }
      else if(p -> type == TYPE_CYCLE)
        break;
      else
        COUNT_NESTING(p);
    }
    else
      COUNT_NESTING(p);
    p = (struct generic_token *) p -> next;
  }
  if(end_last_spec != NULL && end_last_spec -> next == p &&
     p -> type == TYPE_CYCLE){
    if(!eval_direction_specifier(mf, cx, begin_last_spec, end_last_spec,
                                 &w0_x, &w0_y))
      return false;
  }
  @<Code After Peeking the Last Join in Cyclic Path@>
}
@
\fimcodigo

The next rule applies when we have a join like:

\alinhaverbatim
.. z .. controls  u  and  v ..  = .. z{u-z} .. controls  u  and  v ..
\alinhanormal

And also:

\alinhaverbatim
.. controls u and v .. z =  .. controls u and v .. z{z-v} ..
\alinhanormal

But only if the result of subtracting the pairs $u-z$ and $z-v$ is
different than zero. If equal zero, we will raise an erros as we still
do not support this.

First the easiest case: the explicit control points appear before the
current join. In this case we already read these control points in the
previous iteration. We just need variables to store this control point:


\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float previous_point_x = NAN, previous_point_y = NAN;
@
\fimcodigo

If we have some value stored in these variables and if we do not have
an explicit direction specifier, then we generate our specifier with
the described rules. Just observe that we consider as equals points
whose distance is lesser or equal than 0.00002.

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_d == NULL && end_d == NULL && !isnan(previous_point_x) &&
   !isnan(previous_point_y) && isnan(w0_x)){
  w0_x = z1_point -> x - previous_point_x;
  w0_y = z1_point -> y - previous_point_y;
  if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

After possibly using the previous direction specifier, we do not need
it anymore and we can update the variables with current values for the
case that we need them in the next iteration:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  previous_point_x = v_x;
  previous_point_y = v_y;
}
else{
  previous_point_x = NAN;
  previous_point_y = NAN;
}
@
\fimcodigo

About the second direction specifier, if we still do not have a value,
we should check the next join and see if we find explicit control
points. If we find it, we read the first of these points, interpret it
and use its value like described in the rules above:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_e == NULL && end_e == NULL &&  isnan(w1_x) &&
   end_z2 != end_expression){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_point, *end_point;
  begin_point = (struct generic_token *) end_z2 -> next;
  while(begin_point != end_expression){
    COUNT_NESTING(begin_point);
    if(IS_NOT_NESTED() && (begin_point -> type == TYPE_JOIN ||
                          begin_point -> type == TYPE_AMPERSAND ||
                          begin_point -> type == TYPE_STRAIGHT_JOIN))
      break;
    begin_point = (struct generic_token *) begin_point -> next;
  }
  if(begin_point != end_expression &&
     begin_point -> type != TYPE_AMPERSAND &&
     begin_point -> type != TYPE_STRAIGHT_JOIN){
    begin_point = (struct generic_token *) begin_point -> next;
    if(begin_point != end_expression && begin_point -> type == TYPE_CONTROLS){
      begin_point = (struct generic_token *) begin_point -> next;
      end_point = begin_point;
      while(end_point != end_expression){
        struct generic_token *next = (struct generic_token *) end_point -> next;
        COUNT_NESTING(end_point);
        if(IS_NOT_NESTED() && next != NULL &&
           (next -> type == TYPE_AND || next -> type == TYPE_JOIN))
          break;
        end_point = (struct generic_token *) end_point -> next;
      }
      if(end_point != end_expression){
        struct pair_variable var;
        if(!eval_pair_primary(mf, cx, begin_point, end_point, &var))
          return false;
        w1_x = var.x - z2_point -> x;
        w1_y = var.y - z2_point -> y;
        if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                          "direction specifier.\n",  mf -> file,
                          begin_j -> line);
#endif
          return false;
        }
      }
    }
  }
}
@
\fimcodigo

Now let's deal with the cyclic case. If we are in the first iteration,
our path is cyclic and we have explicit control points, then we need
additional variables to store que explicit control point:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float first_point_x = NAN, first_point_y = NAN;
@
\fimcodigo

And we initialize the variable if necessary in the first iteration:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  first_point_x = u_x;
  first_point_y = u_y;
}
@
\fimcodigo

After, when we need to choose the shape of the join in the cyclic
extremity, we take into account the existance of this variable:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE && begin_d == NULL &&
   end_d == NULL && isnan(w1_x) && !isnan(first_point_x) && isnan(w1_x)){
  w1_x = first_point_x - z2_point -> x;
  w1_y = first_point_y - z2_point -> y;
  if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

And now the opposite direction. If we are in the first iteration in a
cyclic path, we peek the last join and check if we have explicit
control points to apply this rule. But in the previous rule we already
wrote code to peek between other things the last join. Therefore, we
can just append additional logic to the previous rule, after getting
the last join:


\iniciocodigo
@<Code After Peeking the Last Join in Cyclic Path@>=
if(last_join != NULL && last_join -> type == TYPE_JOIN){
  struct generic_token *p = (struct generic_token *) second_last_join -> next;
  if(p -> type == TYPE_CONTROLS){
    struct generic_token *p_end;
    p = (struct generic_token *) p -> next;
    p_end = p;
    while(p_end != end_expression){
      struct generic_token *next = (struct generic_token *) p_end -> next;
      COUNT_NESTING(p_end);
      if(IS_NOT_NESTED()){
        if(next -> type == TYPE_AND)
          p = (struct generic_token *) next -> next;
        else if(next -> type == TYPE_JOIN)
          break;
      }
      p_end = next;
    }
    if(p_end != end_expression){
      struct pair_variable var;
      if(!eval_pair_primary(mf, cx, p, p_end, &var))
        return false;
      w0_x = z1_point -> x - var.x;
      w0_y = z1_point -> y - var.y;
      if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                        "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
        return false;
      }
    }
  }
}
@
\fimcodigo

After applying the rules, we expect to have either defined control
points or direction specifiers well-defined. If we have neither, we
raise an error and exit:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  if(isnan(w0_x) || isnan(w0_y) || isnan(w1_x) || isnan(w1_y)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

If no error happened, we either already have our control points or we
need to discover the control points having a path segment as below:

$$
z_n\{w_n\}..\ {\hskip2mm \monoespaco{tension}\hskip2mm } \alpha {\hskip2mm \monoespaco{and}\hskip2mm } \beta .. \{w_{n+1}\}z_{n+1}
$$

To compute the control points given these informations, we regard the
points as complex numbers and compute:

$$
\theta = arg(w_n/(z_{n+1}-z_n))
$$

$$
\phi = arg((z_{n+1}-z_n)/w_{n+1})
$$

Next we compute the control points $u$ and $v$ with:


$$
u = z_{n} + e^{i\theta}(z_{n+1}-z_n)f(\theta, \phi)/\alpha
$$

$$
v = z_{n+1} - e^{-i\phi}(z_{n+1}-z_n)f(\phi, \theta)/\beta
$$

Except when the keyword ``atleast'' is used. In this case, if
necessary, we increase the value of $\alpha$ or $\beta$ in a way that
the control points lies inside the triangle defined by the two
extremity points and the angles given by each direction specifier. If
the triangle is invalid, we keep the original tension values.

The function $f$ used above is defined as:

$$
f(\theta, \phi) = {{2+\sqrt{2}(\sin\theta-{{1}\over{16}}\sin\phi)(\sin\phi-{{1}\over{16}}\sin\theta)(\cos\theta-\cos\phi)}\over{3(1+{1\over 2}(\sqrt 5 - 1)\cos\theta+{1\over 2}(3-\sqrt 5)\cos\phi)}}
$$

First we will define it as an auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
double compute_f(double theta, double phi);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
double compute_f(double theta, double phi){
  double n = 2 + sqrt(2) * (sin(theta) - 0.0625 * sin(phi)) *
             (sin(phi) - 0.0625 * sin(theta)) * (cos(theta) - cos(phi));
  double d = 3 * (1 + 0.5 * (sqrt(5) - 1) * cos(theta) + 0.5 * (3 - sqrt(5)) *
                  cos(phi));
  return n/d;
}
@
\fimcodigo

Now we can compute the control points if we already do not know
them. As we should regard the points as complex numbers, we will need
the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <complex.h>
@
\fimcodigo

And with the help of the C99 functions to deal with complex numbers,
we compute the formula for the control points:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  double complex u, v;
  double complex z0 = z1_point -> x + z1_point -> y * I;
  double complex z1 = z2_point -> x + z2_point -> y * I;
  double theta = carg((w0_x + w0_y * I) / (z1 - z0));
  double phi = carg((z1 - z0)/(w1_x + w1_y * I));
  u = z0 + (cexp(theta * I) * (z1 - z0) * compute_f(theta, phi)) / tension0;
  v = z1 - (cexp(-phi * I) * (z1 - z0) * compute_f(phi, theta)) / tension1;
  u_x = creal(u);
  u_y = cimag(u);
  v_x = creal(v);
  v_y = cimag(v);
  @<Adjust tension in case of 'atleast'@>
}
@
\fimcodigo

The first thing to compute is if we have a valid triangle. For this,
we first should check the internal angles. Given three pairs of
coordinates, where the first one is the vertex where we want to get
the angle, we can compute the angle there using the following
auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y){
  double v0_x, v0_y, v1_x, v1_y;
  v0_x = c0_x - v_x;
  v0_y = c0_y - v_y;
  v1_x = c1_x - v_x;
  v1_y = c1_y - v_y;
  if(fabs(v0_x) <= 0.00002 &&  fabs(v0_y) <= 0.00002)
    return INFINITY;
  if(fabs(v1_x) <= 0.00002 &&  fabs(v1_y) <= 0.00002)
    return INFINITY;
  return acos((v0_x * v1_x + v0_y * v1_y) /
                (hypot(v0_x * v0_x, v0_y * v0_y) *
                 hypot(v1_x * v1_x, v1_y * v1_y)));
}
@
\fimcodigo

Knowing how to measure the angles, we can check if the triangle is
valid. And with this we can write the function that checks if the
control points are inside the triangle. And if not, we correct its
coordinate. First we measure all the internal angles, then we get the
coordinates of the third vertex usinf the Law of Sines (the two other
vertices are known). The function is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y){
  double internal_angle0, internal_angle1, internal_angle2;
  double triangle_angle;
  double p2_x, p2_y;
  internal_angle0 = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + d0_x, p0_y + d0_y);
  internal_angle1 = get_angle(p1_x, p1_y, p0_x, p0_y, p1_x + d1_x, p1_y + d1_y);
  internal_angle2 = M_PI - internal_angle0 - internal_angle1;
  if(internal_angle0 + internal_angle1 >= M_PI - 0.00002)
    return; // Not a valid triangle
  { // Discover the third vertex coordinate:
    // First compute the triangle side that goes from p0 to the unknown vertex
    double known_side = hypot((p1_x - p0_x) * (p1_x - p0_x),
                              (p1_y - p0_y) * (p1_y - p0_y));
    double triangle_side = known_side * sin(internal_angle0) /
                           sin(internal_angle2);
    // Knowing the triangle side and the angle, we compute the coordinates:
    triangle_angle = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + 1.0, p0_y);
    p2_x = p0_x + triangle_side * cos(triangle_angle + internal_angle0);
    p2_y = p0_y + triangle_side * sin(triangle_angle + internal_angle0);
  }
  {
    @<Check if the point is inside the triangle@>
    @<If Not, Adjust the Tension@>
  }
}
@
\fimcodigo

How do we check that a point is inside a triangle? There are several
ways, what we will use is a technique that computes the signed area of
three triangles composed by the point and two of the vertex points
from the triangle, whose vertices we will pass always in the same
clockwise or counter-clockwise order. The signed area of a triangle is
its area, but the result is positive or negative, depending if we
passed the vertices in clockwise or counter-clockwise order. If all
the signed areas are positive, or if all them are negative, then the
point is inside the triangle. If not, the point is outside:

\iniciocodigo
@<Check if the point is inside the triangle@>=
bool s1, s2, s3; // O sinal das áreas
s1 = ((*control_x - p1_x) * (p0_y - p1_y) -
      (p0_x - p1_x) * (*control_y - p1_y)) < 0;
s2 = ((*control_x - p2_x) * (p1_y - p2_y) -
      (p1_x - p2_x) * (*control_y - p2_y)) < 0;
s3 = ((*control_x - p0_x) * (p2_y - p0_y) -
      (p2_x - p0_x) * (*control_y - p0_y)) < 0;
if(s1 == s2 && s2 == s3)
  return;
@
\fimcodigo

An advantage of the above method is that the signed area that have a
different sign than others represents the side which is near the
target point. Therefore, if we did not exit the function, we can check
the closest side, get its line equation and compute the nearest point
in the line. If the point is in the triangle side, this is the new
point or our control point. Otherwise, we choose the nearest vertex to
the point.

\iniciocodigo
@<If Not, Adjust the Tension@>=
{
  double x0, y0, x1, y1;
  if(s1 != s2 && s1 != s3){
    x0 = p0_x; y0 = p0_y;
    x1 = p1_x; y1 = p1_y;
  }
  else if(s2 != s1 && s2 != s3){
    x0 = p1_x; y0 = p1_y;
    x1 = p2_x; y1 = p2_y;
  }
  else{
    x0 = p2_x; y0 = p2_y;
    x1 = p0_x; y1 = p0_y;
  }
  if(x1 < x0){ // x1 must be >= x0 (assuming this the logic becames simpler)
    double tmp;
    tmp = x1; x1 = x0; x0 = tmp;
    tmp = y1; y1 = y0; y0 = tmp;
  }
  if(x0 == x1){ // Vertical line (do not use line equation, or we divide by zero)
    *control_x = x0;
    if(*control_y > y0 && *control_y > y1){
      if(y0 > y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
    else if(*control_y < y0 && *control_y < y1){
      if(y0 < y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
  }
  else if(y0 == y1) // Horizontal line
    *control_y = y0;
  else{ // Use line equation
    // m0 x + b0 = y is the line that contains the triangle side
    double m0 = (y1 - y0) / (x1 - x0);
    double b0 = y1 - m0 * x1;
    // m1 x + b1 = y is the perpendicular line that crosses the point
    double m1 = - m0;
    double b1 = *control_y - m1 * *control_x;
    *control_x = (b1 - b0) / (m0 - m1);
    *control_y = m0 * *control_x + b0;
  }
  if(*control_x > x1){
    *control_x = x1;
    *control_y = y1;
  }
  else if(*control_x < x0){
    *control_x = x0;
    *control_y = y0;
  }
}
@
\fimcodigo

This ends our function to adjust control points if we are adealing
with the ``\monoespaco{atleast}'' keyword. Now we can just use this
function if we are dealing with this case:

\iniciocodigo
@<Adjust tension in case of 'atleast'@>=
if(atleast0)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &u_x, &u_y);
if(atleast1)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &v_x, &v_y);
@
\fimcodigo

And with this we get the control points and we can update its value in
the path variable that we are building. If we are in the last
iteration of a non-cyclic curve, then we also fill the last control
points turning them equal the last extremity point:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
z1_point -> u_x = u_x;
z1_point -> u_y = u_y;
z1_point -> v_x = v_x;
z1_point -> v_y = v_y;
if(result -> length >= expected_length && result -> cyclic == false){
  struct path_points *final_point =
                           &(result -> points[result -> length - 1]);
  while(final_point -> subpath != NULL){
    struct path_variable *p = (struct path_variable *)
                                (final_point -> subpath);
    final_point = &(p -> points[p -> length - 1]);
  }
  final_point -> u_x = final_point -> x;
  final_point -> u_y = final_point -> y;
  final_point -> v_x = final_point -> x;
  final_point -> v_y = final_point -> y;
}
@
\fimcodigo

This finalizes how a curve should be built given its points and
subpaths. Now we will see how we read the points and subpaths.

\subsubsecao{8.4.2. Tertiary Path Expressions}

The grammar for tertiary path expressions is:

\alinhaverbatim
<Path Tertiary> -> <Pair Tertiary> | <Path Secondary>
\alinhanormal

And it is only this. Therefore, to interpret a tertiary path
expression, we should walk over the expression and check if we find a
tertiary pair expression. If so, we should interpret the entire
expression like a pair expression. Otherwise, we interpret as a
secondary path expression. If we interpret the expression like a pair,
we should convert the result from a pair to a path with a single
point.

Anyway, after interpreting the expression and obtain a path as result,
we return the result.

The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  struct generic_token *p, *prev = NULL;
  bool this_expression_is_pair = false;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      this_expression_is_pair = true;
      break;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(this_expression_is_pair){
    struct pair_variable pair;
    if(!eval_pair_expression(mf, cx, begin_expression, end_expression,
                            &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> total_length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> x = pair.x;
    result -> points -> y = pair.y;
    result -> points -> u_x = pair.x;
    result -> points -> u_y = pair.y;
    result -> points -> v_x = pair.x;
    result -> points -> v_y = pair.y;
    result -> points -> subpath = NULL;
    return true;
  }
  else
    return eval_path_secondary(mf, cx, begin_expression, end_expression,
                               result);
}
@
\fimcodigo

\subsubsecao{8.4.3. Secondary Path Expressions: Transformers}

The grammar for secondary path expressions is:

\alinhaverbatim
<Path Secondary> -> <Pair Secondary> | <Path Primary> |
                    <Path Secondary><Transformer>
\alinhanormal

The transformers are the same that were presented for pair expressions
plus the \monoespaco{transformed} operator introduced in the section
about transforms. The first thing that we should test in theses
expressions is if we have a transformer at the end of the
expression. If so, then we should apply the last rule in the grammar
above. If not, we should check if we have a secondary pair operator
(multiplication or division). If so, we apply the second rule,
treating the path secondary expression as a pair secondary. Otherwise
we apply the first rule and interpret the expression as a primery path
expression.

Applying a transformer to rotate, scale and others means applying the
transformation in each extremity point and each control point in the
path.

The declaration for the function that evaluates path secondary
expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

And the implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  bool have_transform = false, have_pair_operator = false;
  struct generic_token *p, *last_fraction = NULL, *transform_op = NULL,
                       *before_transform = NULL, *prev = NULL,
                       *prev_prev = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else if(p -> type == TYPE_DIVISION || p -> type == TYPE_MULTIPLICATION)
         have_pair_operator = true;
       else{
         have_transform = true;
         transform_op = p;
         before_transform = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(have_transform){
    if(transform_op -> next == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_path_secondary(mf, cx, begin_expression, before_transform, result))
      return false;
    @<Path Transform: Rotate@>
    @<Path Transform: Scale@>
    @<Path Transform: Shift@>
    @<Path Transform: Slant@>
    @<Path Transform: X-Scale@>
    @<Path Transform: Y-Scale@>
    @<Path Transform: Z-Scale@>
    @<Path Transform: Generic Transform@>
  }
  else if(have_pair_operator){
    struct pair_variable pair;
    if(!eval_pair_secondary(mf, cx, begin_expression, end_expression, &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> total_length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points[0].x = pair.x;
    result -> points[0].y = pair.y;
    result -> points[0].u_x = pair.x;
    result -> points[0].u_y = pair.y;
    result -> points[0].v_x = pair.x;
    result -> points[0].v_y = pair.y;
    result -> points[0].subpath = NULL;
    return true;    
  }
  else
    return eval_path_primary(mf, cx, begin_expression, end_expression,
                             result);
}
@
\fimcodigo

In the code above, when we check if we have a transformer in the
expression, we always store the last transformer in the
variable \monoespaco{transform\_op} and the last token before the
transformer in the variable \monoespaco{before\_transform}. This allow
us to divide the expression in its parts and interpret the code to
obtain the path to be transformed, as is shown above.

If we have a rotation, to interpret the totation transformer after we
got the path to be rotated in the \monoespaco{result} variable, we can
use the code below:

\iniciocodigo
@<Path Transform: Rotate@>=
if(transform_op -> type == TYPE_ROTATED){
  struct numeric_variable a;
  double theta, sin_theta, cos_theta;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  theta = 0.0174533 * a.value; // Converting degrees to radians
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  path_rotate(result, sin_theta, cos_theta);
  return true;
}
@
\fimcodigo

The code above assumes that we have a recursive function that applies
the rotation once we pass it the sine and cosine of the rotation
angle. We will use the function below for this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_rotate((struct path_variable *) (p -> points[i].subpath),
                  sin_theta, cos_theta);
    else{
      double x = p -> points[i].x, y = p -> points[i].y;
      p -> points[i].x = x * cos_theta - y * sin_theta;
      p -> points[i].y = x * sin_theta + y * cos_theta;
      x = p -> points[i].u_x;
      y = p -> points[i].u_y;
      p -> points[i].u_x = x * cos_theta - y * sin_theta;
      p -> points[i].u_y = x * sin_theta + y * cos_theta;
      x = p -> points[i].v_x;
      y = p -> points[i].v_y;
      p -> points[i].v_x = x * cos_theta - y * sin_theta;
      p -> points[i].v_y = x * sin_theta + y * cos_theta;
    }
  }
}
@
\fimcodigo

Now we will interpret the scaling operator. It shoult interpret a
numeric value and then multiply all points in the path by such value:

\iniciocodigo
@<Path Transform: Scale@>=
if(transform_op -> type == TYPE_SCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_xyscale(result, a.value, a.value);  
  return true;
}
@
\fimcodigo

The recursive function that applies this for every point in the path
is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y);
@
\fimcodigo

Notice that by the function signature we can pass different values to
stretch the path horizontally and vertically. This transformer
stretches the path always in the same proportion, but other
transformers will also use this function to stretch not preserving
proportions. Its implementation is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_xyscale((struct path_variable *) (p -> points[i].subpath), x,
                   y);
    else{
      p -> points[i].x *= x;
      p -> points[i].y *= y;
      p -> points[i].u_x *= x;
      p -> points[i].u_y *= y;
      p -> points[i].v_x *= x;
      p -> points[i].v_y *= y;
    }
  }
}
@
\fimcodigo

The next transformer translate, or shift a given path. We first read a
pair and this pair sets how the path should be shifted in the $x$ and
$y$ axis:

\iniciocodigo
@<Path Transform: Shift@>=
if(transform_op -> type == TYPE_SHIFTED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_shift(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

And the recursive function that performs the shifting:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_shift((struct path_variable *) (p -> points[i].subpath), x, y);
    else{
      p -> points[i].x += x;
      p -> points[i].y += y;
      p -> points[i].u_x += x;
      p -> points[i].u_y += y;
      p -> points[i].v_x += x;
      p -> points[i].v_y += y;
    }
  }
}
@
\fimcodigo

Now to the slanting transformer. This transformer shifts to the right
the points based on how above the origin they are in tha $y$ axis and
shifts to the left based on how below the origin they are in the $y$
axis:

\iniciocodigo
@<Path Transform: Slant@>=
if(transform_op -> type == TYPE_SLANTED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_slant(result, a.value);  
  return true;
}
@
\fimcodigo

And the function that slants recursively:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_slant(struct path_variable *p, float s);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_slant(struct path_variable *p, float s){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_slant((struct path_variable *) (p -> points[i].subpath), s);
    else{
      p -> points[i].x += s * p -> points[i].y;
      p -> points[i].u_x += s * p -> points[i].u_y;
      p -> points[i].v_x += s * p -> points[i].v_y;
    }
  }
}
@
\fimcodigo


The next transformer change the horizontal size of the path while
preserving the vertical size. We need to read a numeric value and it
determines how much the path should be horizontally stretched:

\iniciocodigo
@<Path Transform: X-Scale@>=
else if(transform_op -> type == TYPE_XSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, a.value, 1.0);  
  return true;
}
@
\fimcodigo

Here we are using a recursive function already defined. We do not need
to redefine it again. And we also can stretch the path vertically:

\iniciocodigo
@<Path Transform: Y-Scale@>=
else if(transform_op -> type == TYPE_YSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, 1.0, a.value);  
  return true;
}
@
\fimcodigo

The last but one transformer is the Z-scale which reads a pair,
interprets it as a complex number, interpret all points in the path as
complex numbers and multiply them:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

We interpret and make the transformation below, remembering that this
is the last transformation and that an error should be raised if we
need to apply a transformation and this is not the correct:


\iniciocodigo
@<Path Transform: Z-Scale@>=
else if(transform_op -> type == TYPE_ZSCALED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_zscale(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

And the recursive function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_zscale((struct path_variable *) (p -> points[i].subpath),
                  x, y);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = x0 * x - y0 * y;
      p -> points[i].y = x0 * y + y0 * x;
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = x0 * x - y0 * y;
      p -> points[i].u_y = x0 * y + y0 * x;
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = x0 * x - y0 * y;
      p -> points[i].v_x = x0 * y + y0 * x;
    }
  }
}
@
\fimcodigo

The last transformer is a generic linear transform, where we will get
a transform specifying how each point in the path should be
transformed. We deal with this case as below:

\iniciocodigo
@<Path Transform: Generic Transform@>=
else if(transform_op -> type == TYPE_TRANSFORMED){
  struct transform_variable a;
  if(!eval_transform_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_transform(result, a.value);
  return true;
}
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer\n",
          mf -> file, transform_op -> line);
#endif
  return false;
}
@
\fimcodigo

For this, we use the recursive function below:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M);
@
\fimcodigo

Which is defined as below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_transform((struct path_variable *) (p -> points[i].subpath), M);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].y = LINEAR_TRANSFORM_Y(x0, y0, M);
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].u_y = LINEAR_TRANSFORM_Y(x0, y0, M);
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].v_x = LINEAR_TRANSFORM_Y(x0, y0, M);
    }
  }
}
@
\fimcodigo


\subsubsecao{8.4.4. Primary Path Expressions}

The grammar for primary path expressions is:

\alinhaverbatim
<Path Primary> -> <Pair Primary> | <Path Variable> |
                  ( <Path Expression> ) |
                  reverse <Path Primary> |
                  subpath <Pair Expression> of <Pair Primary> |
                  ...
\alinhanormal

This means that we need to register the new
tokens \monoespaco{reverse}, \monoespaco{subpath} and \monoespaco{of}:


\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_REVERSE,        // O token simbólico 'reverse'
TYPE_SUBPATH,        // O token simbólico 'subpath'
TYPE_OF,             // O token simbólico 'of'
@
\fimcodigo

And for each one of them, we add its string to the list of reserved
words:

\iniciocodigo
@<List of Keywords@>+=
"reverse", "subpath", "of",
@
\fimcodigo

What the grammar rules say is that in the end of each path
expression,we will find a path variable, a parenthesis, some of these
new path operators or, in all other cases, a pair primary. Therefore,
we should first test these first cases and if we are not in one of
them, we are with a primary pair.

The function that will interpret primary path expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result){
  if(begin_expression -> type == TYPE_REVERSE){
    @<Primary Path: Reverse@>
  }
  else if(begin_expression -> type == TYPE_SUBPATH){
    @<Primary Path: Subpath@>
  }
  else if(begin_expression == end_expression &&
          begin_expression -> type == TYPE_SYMBOLIC){
    @<Primary Path: Variable@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Primary Path: Parenthesis@>
  }
  @<Primary Path: Other Expressions@>
  { // If we still did not return, then it is a primary pair
    @<Primary Path: Primary Pair@>
  }
  return false;
}
@
\fimcodigo

The first case: we must compute the reverse of a path. For this, we
need to reverse the order for all extremity points and move the
control points for its new posisiton.

Given the recursive nature of path variables, we need a recursive
function that given an already allocated path variable destiny, it
copies the source points content in the reverse order.

This auxiliary recursive function will need to know for each function
call the destiny pointer where the next point need to be copied. At
first, as we are copying in the reverse order, the pointer represent
the last possible position for points in the path variable.  After
copying each value, we decrement the pointer, copying values from
right to left.

To manipulate the original path and extract its points, the recursive
function must get as argument the current path variable, and the
current index in the point array in that variable. The function will
walk over the points from left to right.

Doing this we will get as result a variable with all its points in the
same array, without recursive path variables inside the initial path
variable. The function definition can be seen below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool aux_reverse(struct path_points **right_dst,
                 struct path_variable *pointer, int *index,
                 int *copied_points, int total_points){
  while(*copied_points < total_points){
    if(pointer -> points[*index].subpath == NULL &&
       !isnan(pointer -> points[*index].x)){
      // Copy:
      memcpy(*right_dst, &(pointer -> points[*index]),
             sizeof(struct path_points));
      (*right_dst) -> subpath = NULL;
      (*right_dst) --;
      (*copied_points) ++;
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].subpath != NULL){
      int new_index = 0;
      aux_reverse(right_dst, (struct path_variable *)
                  (pointer -> points[*index].subpath),
                  &new_index, copied_points, total_points);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

This auxiliary function will help us to define the true function that
will reverse a path variable. The reversion function will be called
below, when we detect the reverse operator:

\iniciocodigo
@<Primary Path: Reverse@>=
struct path_variable tmp;
if(begin_expression -> next == NULL ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                      &tmp))
  return false;
result -> length = tmp.total_length;
result -> total_length = tmp.total_length;
result -> points =
     (struct path_points *)
     temporary_alloc(sizeof(struct path_points) * tmp.total_length);
reverse_path(&tmp, result);
if(temporary_free != NULL)
  path_recursive_free(temporary_free, &tmp, false);
return true;
@
\fimcodigo

Now wee need now to define the true function that makes the
reversion. The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst){
  int index = 0, i, copied_points = 0;
  struct path_points *right = &(dst -> points[dst -> length - 1]);
  struct path_variable *l = src;
  aux_reverse(&right, l, &index, &copied_points, dst -> length);
  for(i = 0; i < dst -> length - 1; i ++){
    dst -> points[i].u_x = dst -> points[i + 1].v_x;
    dst -> points[i].u_y = dst -> points[i + 1].v_y;
    dst -> points[i].v_x = dst -> points[i + 1].u_x;
    dst -> points[i].v_y = dst -> points[i + 1].u_y;
  }
  dst -> points[i].u_x = dst -> points[i].x;
  dst -> points[i].u_y = dst -> points[i].y;
  dst -> points[i].v_x = dst -> points[i].x;
  dst -> points[i].v_y = dst -> points[i].y;
  dst -> cyclic = src -> cyclic;
}
@
\iniciocodigo

The next step is compute the subpath. A subpath creates a new path
that is part of another known bigger path. For example:

\alinhaverbatim
subpath (0, 2) of p1 -- p2 -- p3;
\alinhanormal

The code above evaluates to the new path \monoespaco{p1 -- p2},
assuming that both \monoespaco{p1} and \monoespaco{p2} represent a
single point.

In the original METAFONT, we could pass non-integer point
positions. For example, we could select a subpath between the conrol
points 0.5 and 1.8. With such positions, METAFONT would generate new
intermediary control points betwwen the first and the second and
between the second and third as indicated. New extemity and control
points would be generated. But as this is a little messy computation,
here we will support only subpaths between integer positions.

In the case of a non-cyclic path, if we try to specify a subpath using
an index lesser than zero, this index will be considered zero. If we
try to use an index greater than the maximum allowed index, it will be
treated as the maximum index.

In the case of a cyclic path, negative indices are counted walking
over the cycle in the path opposite direction. And there is no maximum
allowed index. This way, you can create a subpath from a cyclic path
that is bigger than the original path. The cyclic nature also will
always be lost after the operation.

\iniciocodigo
@<Primary Path: Subpath@>=
DECLARE_NESTING_CONTROL();
struct pair_variable a;
struct path_variable b;
struct generic_token *of, *end_pair_expr = begin_expression;
struct generic_token *begin_subexpr;
if(begin_expression -> next == NULL ||  end_pair_expr -> type == TYPE_OF ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
of = (struct generic_token *) (end_pair_expr -> next);
while(of != NULL && of != end_expression){
  COUNT_NESTING(of);
  if(IS_NOT_NESTED() && of -> type == TYPE_OF)
    break;
  end_pair_expr = of;
  of = (struct generic_token *) (of -> next);
}
if(of == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_expression(mf, cx, (struct generic_token *) begin_expression -> next,
                         end_pair_expr, &a))
  return false;
begin_subexpr = of -> next;
if(!eval_path_primary(mf, cx, begin_subexpr, end_expression, &b))
  return false;
{
  int final_path_size, offset;
  result -> cyclic = false;
  if(a.x < 0 && !b.cyclic)
    a.x = 0;
  if(a.y < 0  && !b.cyclic)
    a.y = 0;
  if(a.x >= b.total_length  && !b.cyclic)
    a.x = b.total_length - 1;
  if(a.y >= b.total_length  && !b.cyclic)
    a.y = b.total_length - 1;
  final_path_size = a.y - a.x;
  if(final_path_size < 0)
    final_path_size *= -1;
  final_path_size ++;
  offset = (a.x <= a.y)?(a.x):(a.y);
  if(b.cyclic)
    offset = offset % (b.total_length - 1);
  else
    offset = offset % b.total_length;
  if(offset < 0)
    offset *= -1;
  result -> length = final_path_size;
  result -> total_length = final_path_size;
  result -> points = (struct path_points *)
                       temporary_alloc(final_path_size *
                                       sizeof(struct path_points));
  if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  copy_subpath(result -> points, &b, offset, final_path_size);
  // Adjust final control points if we lost the cyclcic property:
  result -> points[result -> length - 1].u_x =
                                      result -> points[result -> length - 1].x;
  result -> points[result -> length - 1].u_y =
                                      result -> points[result -> length - 1].y;
  result -> points[result -> length - 1].v_x =
                                      result -> points[result -> length - 1].x;
  result -> points[result -> length - 1].v_y =
                                      result -> points[result -> length - 1].y;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  if(a.x > a.y){
    struct path_variable c;
    c.length = result -> total_length;
    c.total_length = result -> total_length;
    c.points = (struct path_points *) temporary_alloc(sizeof(struct path_points) *
                                                      c.total_length);
    if(c.points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
              begin_expression -> line);
#endif
      return false;
    }
    reverse_path(result, &c);
    temporary_free(result -> points);
    result -> points = c.points;
  }
  return true;
}
@
\fimcodigo

We need now to present the function \monoespaco{copy\_subpath} that
will copy a path to another path as seen in the code above. This
function gets a pointer to the array where we will copy the points, a
path variable as origin, an offset representing the number of initial
points to be ignored and the number of points to be copied:


\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size);
@
\fimcodigo

The function definition is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size){
  struct path_points *dst_pointer = dst;
  while(size > 0){
    int index = 0;
    int initial_offset = offset, initial_size = size;
    recursive_copy_subpath(&dst_pointer, src, &index, &offset, &size);
    // If we copied the last point and we are copying a cyclic path:
    if(offset <= 0 && src -> cyclic &&
       initial_offset + initial_size >= src -> total_length){
      dst_pointer --; // The last point is redundant, it is equal the first.
      size ++;
    }
  }
}
@
\fimcodigo

And finally the function that will walk over the origin path to copy
it:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size){
  while(*size > 0){
    if(pointer -> points[*index].subpath == NULL &&
       !isnan(pointer -> points[*index].x)){
      if(*offset > 0)
        (*offset) --;
      else{
        // Copy:
        memcpy(*dst, &(pointer -> points[*index]),
               sizeof(struct path_points));
        (*dst) -> subpath = NULL;
        (*dst) ++;
        (*size) --;
      }
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].subpath != NULL){
      int new_index = 0;
      recursive_copy_subpath(dst, (struct path_variable *)
                                  (pointer -> points[*index].subpath),
                             &new_index, offset, size);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

The next step is the path primary expression when we read a pair
variable or a path variable. In this case, we allocate the memory for
the result points and copy the variable content to the result:

\iniciocodigo
@<Primary Path: Variable@>=
{
  struct symbolic_token *v = (struct symbolic_token *) begin_expression;
  void *content = v -> var;
  if(((struct pair_variable *) content) -> type == TYPE_T_PAIR){
    result -> length = 1;
    result -> total_length = 1;
    result -> cyclic = false;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    result -> points[0].x = ((struct pair_variable *) content) -> x;
    result -> points[0].y = ((struct pair_variable *) content) -> y;
    result -> points[0].u_x = ((struct pair_variable *) content) -> x;
    result -> points[0].u_y = ((struct pair_variable *) content) -> y;
    result -> points[0].v_x = ((struct pair_variable *) content) -> x;
    result -> points[0].v_y = ((struct pair_variable *) content) -> y;
    result -> points[0].subpath = NULL;
    return true;
  }
  else if(((struct path_variable *) content) -> type == TYPE_T_PATH){
    recursive_copy_points(temporary_alloc, &result,
                          (struct path_variable *) content, false);
    return true;
  }
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Variable is not pair nor path!\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

The next primary path expression is when we have an expression between
parenthesis. And this expression is not a pair, it is another path
expression that need to be evaluated. First we check if there is
nothing between parenthesis and produce and error in this case. Next,
we check if we do not have a non-nested comma inside the
parenthesis. If so, we ignore the expression because we have a pair
primary. In all other cases, we evaluate whatever expression we have
inside the parenthesis as a path expression:

\iniciocodigo
@<Primary Path: Parenthesis@>=
struct generic_token *t = begin_expression -> next;
bool found_comma = false;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  if(IS_NOT_NESTED() && t -> type == TYPE_COMMA){
    found_comma = true;
    break;
  }
  t = t -> next;
}
if(!found_comma){
  return eval_path_expression(mf, cx, begin_expression -> next, t, result);
}
@
\fimcodigo

And finally, the last kind of primary expression for pairs is when we
have a pair primary expression. In this case, we just interpret the
expression, allocate the single point in our path and copy the result
of the expression to that point:

\iniciocodigo
@<Primary Path: Primary Pair@>=
struct pair_variable v;
if(!eval_pair_primary(mf, cx, begin_expression, end_expression, &v))
  return false;
result -> length = 1;
result -> total_length = 1;
result -> cyclic = false;
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points));
result -> points[0].subpath = NULL;
result -> points[0].x = v.x;
result -> points[0].y = v.y;
result -> points[0].u_x = v.x;
result -> points[0].u_y = v.y;
result -> points[0].v_x = v.x;
result -> points[0].v_y = v.y;
return true;
@
\fimcodigo

\subsubsecao{8.4.5. Path in Numeric Expressions}

We can nuse the numeric expression with the
operator \monoespaco{length} to obtain the number of extremity points
in a path minus one. The syntax is:

\alinhaverbatim
<Numeric Primary> -> length <Path Primary>
\alinhanormal
%                       turningnumber <Caminho Primário> |
%                       directiontime <Expressão de Par> of <Caminho Primário>

We do not need a new type of token. The expression \monoespaco{length}
was already used to compute modulus for numbers and pairs. For the
case in which this operator gets a path, the implementation is even
simpler:

\iniciocodigo
@<Evaluate 'length'@>+=
else if(expr_type == TYPE_T_PATH){
  struct path_variable p;
  if(!eval_path_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) (p.total_length - 1);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &p, false);
  return true;
}
@
\fimcodigo

\subsubsecao{8.4.6. Path in Pair Expressions}

Given a path, we can extract pairs from it. The pair can be an
extremity point or some of the control points. The syntax for this is:

\alinhaverbatim
<Pair Primary> -> point <Numeric Expression> of <Path Primary> |
                     precontrol <Numeric Expression> of <Path Primary> |
                     postcontrol <Numeric Expression> of <Path Primary>
\alinhanormal

This requires adding the following new token types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_POINT,             // O token simbólico 'point'
TYPE_PRECONTROL,        // O token simbólico 'precontrol'
TYPE_POSTCONTROL,       // O token simbólico 'postcontrol'
@
\fimcodigo

And we add them also to the list of reserved words:

\iniciocodigo
@<List of Keywords@>+=
"point", "precontrol", "postcontrol",
@
\fimcodigo

All these operators require that we get a point in a given position
$n$ inside a path. For this, it will be helpful to have an auxiliary
function that will get a path variable and an index to return the
point in the path corresponding to that index. The function first will
check if the length and the total lenght in the path are the same. If
so, we will assume that we are in a path without recursive subpaths
and in this case, returning the correct point is easy and
fast. Otherwise, we will call a recursive function to get for us the
correct point:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n){
  if(v -> length == v -> total_length){
    struct path_points *ret = (struct path_points *) &(v -> points[n]);
    while(ret -> subpath != NULL)
      ret = &(((struct path_variable *) (ret -> subpath)) -> points[0]);
    return ret;
  }
  else{
    int count = 0;
    return _get_point(v, n, &count);
  }
}
@
\fimcodigo

This auxiliar recursive fnction that will get the point for
recursively defined paths will walk over each point in the path in the
usual order and will return the current point when it walks over the
correct number of points. For this, it needs the path variable
pointer, the point index and also how many points it already visited:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count);
@
\fimcodigo

The function definition is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count){
  int i;
  for(i = 0; i < v -> length; i ++){
    if(v -> points[i].subpath == NULL) {
      if(*count == n && !isnan(v -> points[i].x))
	return ((struct path_points *) &(v -> points[i]));
      else if(!isnan(v -> points[i].x))
	(*count) ++;
    }
    else{
      struct path_points *r =
	_get_point((struct path_variable *) (v -> points[i].subpath),
		   n, count);
      if(r != NULL)
	return r;
    }
  }
  return NULL;
}
@
\fimcodigo


For the first operator, \monoespaco{point}, it returns a given
extremity point from a path. In a non-cyclic path, indices lesser than
zero are interpreted as zero (the first index) and indices greater or
equal than the number of extremity points will be interpreted as the
last point's index. If the path is cyclic, we count the indices
following the cycle. In the original METAFONT language, non-integer
indices were allowed, but here we will interpret all indices as
integers, casting them to C int type.

The operator \monoespaco{postcontrol} is similar, but it gets the
first control point after the given extremity point pointed by the
index. And the operator \monoespaco{precontrol} gets the control point
before the given extremity point.

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>=
if(begin_expression -> type == TYPE_POINT ||
   begin_expression -> type == TYPE_PRECONTROL ||
   begin_expression -> type == TYPE_POSTCONTROL){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_num, *end_num , *of = NULL, *begin_path, *end_path;
  struct numeric_variable a;
  struct path_variable b;
  begin_num = begin_expression -> next;
  end_num = begin_num;
  int index;
  while(end_num != NULL && end_num -> next != end_expression){
    COUNT_NESTING(end_num);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_num -> next) -> type == TYPE_OF){
      of = end_num -> next;
      break;
    }
    end_num = end_num -> next;
  }
  if(of == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'of' in 'point' expression\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(of -> next == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing path expression in "
            "'point' expression\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  begin_path = of -> next;
  end_path = end_expression;
  if(!eval_numeric_expression(mf, cx, begin_num, end_num, &a))
    return false;
  if(!eval_path_primary(mf, cx, begin_path, end_path, &b))
    return false;
  if(b.cyclic){
    index = ((int)(a.value)) % (b.total_length - 1);
    if(begin_expression -> type == TYPE_PRECONTROL)
      index = (index - 1) % (b.total_length - 1);
  }
  else{
    index = (int) (a.value);
    if(index < 0) index = 0;
    if(index >= b.total_length) index = b.total_length - 1;
    if(begin_expression -> type == TYPE_PRECONTROL)
      index --;
  }
  if(begin_expression -> type == TYPE_POINT){
    result -> x = get_point(&b, index) -> x;
    result -> y = get_point(&b, index) -> y;
  }
  else if(begin_expression -> type == TYPE_PRECONTROL){
    if(index < 0){
      result -> x = get_point(&b, 0) -> x;
      result -> y = get_point(&b, 0) -> y;
    }
    else{
      result -> x = get_point(&b, index) -> v_x;
      result -> y = get_point(&b, index) -> v_y;
    }
  }
  else{
    result -> x = get_point(&b, index) -> u_x;
    result -> y = get_point(&b, index) -> u_y;
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  return true;
}
@
\fimcodigo

\subsecao{8.5. Pen Assignments and Expressions}

To assign a pen to a variable with the right type, we use the
following code:

\iniciocodigo
@<Assignment for Pen Variables@>=
else if(type == TYPE_T_PEN){
  int i;
  struct pen_variable result;
  if(!eval_pen_expression(mf, cx, begin_expression,
                         (struct generic_token *) *end_token_list,
                         &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pen_variable(mf, (struct pen_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL && result.format !=  NULL)
    path_recursive_free(temporary_free, result.format, true);
  if(result.gl_vbo != 0 && result.referenced == NULL)
    glDeleteBuffers(1, &(result.gl_vbo));
}
@
\fimcodigo

The declaration for the function that makes the assignment:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_pen_variable(struct metafont *mf,
                        struct pen_variable *target,
                        struct pen_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_pen_variable(struct metafont *mf,
                          struct pen_variable *target,
                          struct pen_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> format != NULL && disalloc != NULL)
    path_recursive_free(disalloc, target -> format, true);
  if(target -> gl_vbo != 0)
    glDeleteBuffers(1, &(target -> gl_vbo));
  memcpy(target, source, sizeof(struct pen_variable));
  target -> type = TYPE_T_PEN;
  if(! (source -> flags & (FLAG_CIRCULAR | FLAG_SQUARE | FLAG_NULL)))
    recursive_copy_points(alloc, &(target -> format), source -> format, true);
  target -> gl_vbo = 0;
  target -> indices = 0;
  target -> referenced = NULL;
  // If we are assigning to 'currentpen', then we need to retriangulate
  // the pen, as will be described in Section 10:
  if(target == &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]))
    triangulate_pen(mf, target, target -> gl_matrix);
}
@
\fimcodigo

\subsubsecao{8.5.1. Pen Tertiary Expression}

For now we have no tertiry operator for pen expressions:

\alinhaverbatim
<Pen Expression> -> <Pen Tertiary>
<Pen Tertiary> -> <Pen Secondary>
\alinhanormal

So the function that evaluates tertiary expression, for now, can just
call directly the funtion that evaluates secondary pen expressions:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result){
  return eval_pen_secondary(mf, cx, begin_expression, end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.5.2. Pen Transformers}

The syntax for secondary pen expressions is:

\alinhaverbatim
<Pen Secondary> -> <Pen Primary> | <Pen Secondary> <Transformer>
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary>
                 transformed <Transform Primary>
\alinhanormal

Transformers are not new, they were already used in pair, transforms
and path expressions. But apply them over pens is a little different,
as instead of modifying each one of its points, we modify only its
OpenGL matrix transformation.

The declaration for the function that evaluates pen secondary
expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

And its implementation consists in trying to find the last transformer
in the expression. If it is not found, the function just calls another
function to evaluate primary expression. If a transformer is found,
then everything before it is evaluated as a secondary expression and
then we apply the transformer. Rotate a pen never requires the
retriangulation of that pen.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct pen_variable *pen){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_pen_primary(mf, cx, begin_expression, end_expression, pen);
  else{
    if(!eval_pen_secondary(mf, cx, begin_expression, before_last_transformer, pen))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Pen Secondary: Rotation@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Pen Secondary: Scaling@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Pen Secondary: Shift@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Pen Secondary: Slanting@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Pen Secondary: X-Scaling@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Pen Secondary: Y-Scaling@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Pen Secondary: Z-Scaling@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Pen Secondary: Generic Transform@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

First we will take care of rotation by an algle $\theta$. First we
perform the conversion between degrees used by WeaveFONT and radians,
used by the C sandard library. Rotating means applying the rotation
linear transform over the pen transform matrix:

\iniciocodigo
@<Pen Secondary: Rotation@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(pen -> gl_matrix, rotation);
return true;
@
\fimcodigo

To perform the scaling tranformation, we also apply such linear
transform over the pen matrix:

\iniciocodigo
@<Pen Secondary: Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(pen -> gl_matrix, a.value);
// Curved pens need retriangulation if the size increase:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

The shift transformer shifts each point in the pen adding a pair to
it.

\iniciocodigo
@<Pen Secondary: Shift@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SHIFT(pen -> gl_matrix, p.x, p.y);
return true;
@
\fimcodigo

The next transformer is the slanting operator. 

\iniciocodigo
@<Pen Secondary: Slanting@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(pen -> gl_matrix, a.value);
// Slant non-circular curved pens always require retriangulation:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT) &&
   !(pen -> flags & FLAG_CIRCULAR)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Scaling in the $x$-axis is analogous to the general scaling, but the pen
is stretched only in the $x$-axis:

\iniciocodigo
@<Pen Secondary: X-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(pen -> gl_matrix, a.value);
// Curved pens need retriangulation if the size increase:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Likewise, changing the scale only in the vertical axis, is done by
the code below:

\iniciocodigo
@<Pen Secondary: Y-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(pen -> gl_matrix, a.value);
// Curved pens need retriangulation if the size increase:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Scaling in $z$-index means interpreting the point and a pair
as complex numbers and multiply them:

$$
(x+yi)(a+bi) = ax + (bx)i + (ay)i + (by)i^2 = (ax - by) + (bx+ay)i
$$

We can perform the operation above with the following code:

\iniciocodigo
@<Pen Secondary: Z-Scaling@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(pen -> gl_matrix, p.x, p.y);
// Curved pens need retriangulation in this case:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Finally, the last transform is the generic one, which applies
whichever transform is stored in a transformer:

\iniciocodigo
@<Pen Secondary: Generic Transform@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression, &t))
  return false;
MATRIX_MULTIPLICATION(pen -> gl_matrix, t.value);
// Curved pens need retriangulation in this case:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

\subsubsecao{8.5.3. Pen Primary Expressions}

The grammar for pen primary expressions are defined as:

\alinhaverbatim
<Primário de Caneta> -> <Variável de Caneta> |
                        nullpen | ( <Expressão de Caneta> ) |
                        pencircle | makepen <Primário de Caminho>
\alinhanormal

This requires three new reserved words:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_NULLPEN,        // The symbolic token 'nullpen'
TYPE_PENCIRCLE,      // The symbolic token 'pencircle'
TYPE_MAKEPEN,        // The symbolic token 'makepen'
@
\fimcodigo

And we add a string with their names in the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"nullpen", "pencircle", "makepen",
@
\fimcodigo

The function that will interpret the primary pen expressions:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Pen Primary: Variable@>
    }
    else if(begin_expression -> type == TYPE_NULLPEN){
      @<Pen Primary: Null Pen@>
    }
    else if(begin_expression -> type == TYPE_PENCIRCLE){
      @<Pen Primary: Circle Pen@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Pen Primary: Parenthesis@>
    }
    else if(begin_expression -> type == TYPE_MAKEPEN){
      @<Pen Primary: Custom Format@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

If the expression evaluates to a variable, we need to copy the
variable content to the result of the evaluation. If the evaluation
return a variable that points to other (the \monoespaco{currentpen}),
instead we copy the content of the referenced pen. But after the copy
we multiply the obtained matrix by the pointer matrix.

\iniciocodigo
@<Pen Primary: Variable@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct pen_variable *content = v -> var, *to_copy = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-pen variable in pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(content -> referenced != NULL)
  to_copy = content -> referenced;
memcpy(result, to_copy, sizeof(struct pen_variable));
if(to_copy -> format != NULL)
  recursive_copy_points(temporary_alloc, &(result -> format),
                        to_copy -> format, true);
if(to_copy != content)
  MATRIX_MULTIPLICATION(result -> gl_matrix, content -> gl_matrix);
return true;
@
\fimcodigo

If the expression evaluates to a null pen, we should just create a new
pen with the flag \monoespaco{FLAG\_NULL} active. This pen never will
be triangulated and never will produce any drawing:

\iniciocodigo
@<Pen Primary: Null Pen@>=
result -> format = NULL;
result -> flags = FLAG_NULL;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

If the expression evaluates to a circular pen, we generate a new pen
with circular and convex flags. We also initialize the transform
matrix as an identity matrix:

\iniciocodigo
@<Pen Primary: Circle Pen@>=
result -> format = NULL;
result -> flags = FLAG_CONVEX | FLAG_CIRCULAR;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

Evaluate parenthesis requires to evaluate as a pen expression every
token after the open parenthesis until the position before the closing
of the parenthesis:

\iniciocodigo
@<Pen Primary: Parenthesis@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_pen_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

The last case of pen expression is when the user chooses a custom
format for the pen. In this case, we should evaluate the path
expression and create a new pen with that given format:

\iniciocodigo
@<Pen Primary: Custom Format@>=
struct generic_token *p = begin_expression -> next;
result -> format =
        (struct path_variable *) temporary_alloc(sizeof(struct path_variable));
if(result -> format == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, p, end_expression, result -> format))
  return false;
if(!(result -> format -> cyclic)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr,
          "METAFONT: Error: %s:%d: Using 'makepen' with non-cyclic path.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
result -> flags = read_flags(result -> format); // To be implemented
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

To the functioon above work correctly, we need a function that walks
over the points in a path and return the flags that a pen with that
format would have:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int read_flags(struct path_variable *path);
@
\fimcodigo

We already know that the pen never will be circular, as perfect
circles cannot be expressed using Beziér curves. We will verify only
if the pen is straight or convex:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int read_flags(struct path_variable *path){
  int i, positive_cross_product = -1;
  int flag = FLAG_CONVEX | FLAG_STRAIGHT;
  for(i = 0; i < path -> total_length - 1; i ++){
    struct path_points *current, *next;
    current = get_point(path, i);
    next = get_point(path, i + 1);
    if(flag & FLAG_STRAIGHT){
      // It is straight if the auxiliary and control points are colinear.
      // They are colinear if they form a triangle with area zero (or
      // sufficiently next to zero):
      double area =  current -> x * (current -> u_y - next -> y) +
                     current -> u_x * (next -> y - current -> y) +
                     next -> x * (current -> y - current -> u_y);
      if(area > 0.00002)
        flag -= FLAG_STRAIGHT;
      area =  current -> x * (current -> v_y - next -> y) +
              current -> v_x * (next -> y - current -> y) +
              next -> x * (current -> y - current -> v_y);
      if((flag & FLAG_STRAIGHT) && area > 0.00002)
        flag -= FLAG_STRAIGHT;        
    }
    if(flag & FLAG_CONVEX){
      // It is convex only if the z component of the cross product of vectors
      // composed by the extremity and control points in the drawing order
      // is always non-negative or always non-positive
      int j;
      double d1_x, d1_y, d2_x, d2_y, z_cross_product;
      double p1_x, p1_y, p2_x, p2_y, p3_x, p3_y; // Pontos
      for(j = 0; j < 3; j ++){
        switch(j){
          case 0:
            p1_x = current -> x; p1_y = current -> y;
            p2_x = current -> u_x; p2_y = current -> u_y;
            p3_x = current -> v_x; p3_y = current -> v_y;
            break;
          case 1:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> x; p3_y = next -> y;
            break;
          default:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> u_x; p3_y = next -> u_y;
            break;
        }
        d1_x = p2_x - p1_x;
        d1_y = p2_y - p1_y;
        d2_x = p3_x - p2_x;
        d2_y = p3_y - p2_y;
        z_cross_product = d1_x * d2_y - d1_y * d2_x;
        if(z_cross_product > 0.00002 || z_cross_product < -0.00002){
          if(positive_cross_product == -1)
            positive_cross_product = (z_cross_product > 0);
          else if((z_cross_product > 0) != positive_cross_product){
            flag -= FLAG_CONVEX;
            break;
          }
        }
      }
    }
  }
  return flag;
}
@
\fimcodigo

\subsubsecao{8.5.4. Pens in Path Expressions}

Primary pen expressions also can appear inside path primary
expressions. This happens when we try to extract a pen format as a
path. The grammar for this operation is:

\alinhaverbatim
<Path Primary> -> makepath <Pen Primary>
\alinhanormal

We need to register a new token for ``makepath'':

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_MAKEPATH,       // O token simbólico 'makepath'
@
\fimcodigo

And we add the string with the token name to the list of reserved
words:

\iniciocodigo
@<List of Keywords@>+=
"makepath",
@
\fimcodigo

The operator ``makepath'' evaluates all tokens after itself as a pen
primary expression. After this, it takes the resulting pen and extract
its format as a path. Sometimes the pen variable will already have its
format stored as a path and we just need to extract and copy it. But
in some cases, if we have a \monoespaco{nullpen} or
a \monoespaco{circlepen}, or even if we have a square pen, we need to
generate a path with a correct format:

\iniciocodigo
@<Primary Path: Other Expressions@>=
else if(begin_expression -> type == TYPE_MAKEPATH){
  struct pen_variable tmp;
  if(begin_expression -> next == NULL ||
     begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_pen_primary(mf, cx, begin_expression -> next, end_expression,
                       &tmp))
    return false;
  if(tmp.flags & FLAG_NULL){ // nullpen: Avalia para ponto único (0, 0)
    @<'makepath': 'nullpen'@>
  }
  else if(tmp.flags & FLAG_CIRCULAR){ // circlepen: Cria aproximação de círculo
    @<'makepath': 'pencircle'@>
  }
  else if(tmp.flags & FLAG_SQUARE){ // Caneta quadrada
    @<'makepath': 'pensquare'@>
  }
  else{ // Caneta com formato personalizado
    @<'makepath': Formato Personalizado@>
  }
  @<'makepath': Apply Linear Transform@>
  return true;
}
@
\fimcodigo

As in the original METAFONT language, the \monoespaco{nullpen}
represents a single point in position $(0, 0)$ that never will be
drawn:

\iniciocodigo
@<'makepath': 'nullpen'@>=
result -> length = 1;
result -> total_length = 1;
result -> cyclic = false;
result -> points =
  (struct path_points *) temporary_alloc(sizeof(struct path_points));
result -> points[0].x = 0.0;
result -> points[0].y = 0.0;
result -> points[0].u_x = 0.0;
result -> points[0].u_y = 0.0;
result -> points[0].v_x = 0.0;
result -> points[0].v_y = 0.0;
result -> points[0].subpath = NULL;
@
\fimcodigo

If we have a circular pen, then we use as a circle approximation the
same values that the original METAFONT uses in a macro to represent
its \monoespaco{fullcircle} path. The result is close enough to a
circle:

\iniciocodigo
@<'makepath': 'pencircle'@>=
result -> length = 9;
result -> total_length = 9;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 9);
result -> points[0].subpath = NULL;
result -> points[0].x = 0.5; result -> points[0].y = 0.0;
result -> points[0].u_x = 0.5; result -> points[0].u_y = 0.13261;
result -> points[0].v_x = 0.44733; result -> points[0].v_y = 0.2598;
result -> points[1].subpath = NULL;
result -> points[1].x = 0.35356; result -> points[1].y = 0.35356;
result -> points[1].u_x = 0.2598; result -> points[1].u_y = 0.44733;
result -> points[1].v_x = 0.13261; result -> points[1].v_y = 0.5;
result -> points[2].subpath = NULL;
result -> points[2].x = 0.0; result -> points[2].y = 0.5;
result -> points[2].u_x = -0.13261; result -> points[2].u_y = 0.5;
result -> points[2].v_x = -0.2598; result -> points[2].v_y = 0.44733;
result -> points[3].subpath = NULL;
result -> points[3].x = -0.35356; result -> points[3].y = 0.35356;
result -> points[3].u_x = -0.44733; result -> points[3].u_y = 0.2598;
result -> points[3].v_x = -0.5; result -> points[3].v_y = 0.13261;
result -> points[4].subpath = NULL;
result -> points[4].x = -0.5; result -> points[4].y = 0.0;
result -> points[4].u_x = -0.5; result -> points[4].u_y = -0.13261;
result -> points[4].v_x = -0.44733; result -> points[4].v_y = -0.2598;
result -> points[5].subpath = NULL;
result -> points[5].x = -0.35356; result -> points[5].y = -0.35356;
result -> points[5].u_x = -0.2598; result -> points[5].u_y = -0.44733;
result -> points[5].v_x = -0.13261; result -> points[5].v_y = -0.5;
result -> points[6].subpath = NULL;
result -> points[6].x = 0.0; result -> points[6].y = -0.5;
result -> points[6].u_x = 0.13261; result -> points[6].u_y = -0.5;
result -> points[6].v_x = 0.2598; result -> points[6].v_y = -0.44733;
result -> points[7].subpath = NULL;
result -> points[7].x = 0.35356; result -> points[7].y = -0.35356;
result -> points[7].u_x = 0.44733; result -> points[7].u_y = -0.2598;
result -> points[7].v_x = 0.5; result -> points[7].v_y = -0.13261;
result -> points[8].subpath = NULL;
result -> points[8].x = 0.5; result -> points[8].y = 0.0;
result -> points[8].u_x = 0.5; result -> points[8].u_y = 0.13261;
result -> points[8].v_x = 0.44733; result -> points[8].v_y = 0.2598;
result -> cyclic = true;
@
\fimcodigo

If we have a square pen, we generate its true format filling its
extremity and control points:

\iniciocodigo
@<'makepath': 'pensquare'@>=
result -> length = 5;
result -> total_length = 5;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 5);
result -> points[0].subpath = NULL;
result -> points[0].x = -0.5; result -> points[0].y = -0.5;
result -> points[0].u_x = (-0.5+(1.0/3.0)); result -> points[0].u_y = -0.5;
result -> points[0].v_x = (-0.5+(2.0/3.0)); result -> points[0].v_y = -0.5;
result -> points[1].subpath = NULL;
result -> points[1].x = 0.5; result -> points[1].y = -0.5;
result -> points[1].u_x = 0.5; result -> points[1].u_y = (-0.5+(1.0/3.0));
result -> points[1].v_x = 0.5; result -> points[1].v_y = (-0.5+(2.0/3.0));
result -> points[2].subpath = NULL;
result -> points[2].x = 0.5; result -> points[2].y = 0.5;
result -> points[2].u_x = (0.5-(1.0/3.0)); result -> points[2].u_y = 0.5;
result -> points[2].v_x = (0.5-(2.0/3.0)); result -> points[2].v_y = 0.5;
result -> points[3].subpath = NULL;
result -> points[3].x = -0.5; result -> points[3].y = 0.5;
result -> points[3].u_x = -0.5; result -> points[3].u_y = (0.5-(1.0/3.0));
result -> points[3].v_x = -0.5; result -> points[3].v_y = (0.5-(2.0/3.0));
result -> points[4].subpath = NULL;
result -> points[4].x = -0.5; result -> points[4].y = -0.5;
result -> points[4].u_x = (-0.5+(1.0/3.0)); result -> points[4].u_y = -0.5;
result -> points[4].v_x = (-0.5+(2.0/3.0)); result -> points[4].v_y = -0.5;
result -> cyclic = true;
@
\fimcodigo

Finally, if we have a pen with a custom format, then it already stores
its format as a path variable. We just need to copy it and then
deallocate the temporary pen evaluation:

\iniciocodigo
@<'makepath': Formato Personalizado@>=
recursive_copy_points(temporary_alloc, &result, tmp.format, false);
if(temporary_free != NULL && tmp.referenced == NULL)
  temporary_free(tmp.format);
@
\fimcodigo

And finally, after obtaining the path, we need to apply all the linear
transformations stored in the transform matrix, applying any rotation,
shifting, slanting, scaling or other transformations stored there:

\iniciocodigo
@<'makepath': Apply Linear Transform@>=
{
  int i;
  for(i = 0; i < result -> length; i ++){
    float x0 = result -> points[i].x, y0 = result -> points[i].y;
    result -> points[i].x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].u_x;
    y0 = result -> points[i].u_y;
    result -> points[i].u_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].u_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].v_x;
    y0 = result -> points[i].v_y;
    result -> points[i].v_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].v_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
  }
}
@
\fimcodigo

\subsecao{8.6. Picture Assignments and Expressions}

To make a picture assignment, we use the code below. It first
evaluates a picture expression and get a picture variable as
result. The picture variable has an initialized and filled OpenGL
texture. If our assignment has a single variable, we can just copy the
texture identifier and the other variable information. If we have more
than one variables as destiny in our assignment, then for the first
variable we just copy the texture identifier, and for the other we
will need to generate new textures and copy the content.

\iniciocodigo
@<Assignment for Picture Variables@>=
else if(type == TYPE_T_PICTURE){
  int i;
  struct picture_variable result;
  if(!eval_picture_expression(mf, cx, begin_expression,
                              (struct generic_token *) *end_token_list,
                              &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    if(i == 0){
      struct picture_variable *pic = (struct picture_variable *) var -> var;
      if(pic -> texture != 0)
        glDeleteTextures(1, &(pic -> texture));
      memcpy(pic, &result, sizeof(struct picture_variable));
      pic -> type = TYPE_T_PICTURE;
      // If assigning to 'currentpicture', additional code is executed
      if(pic ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
        // The code below will be defined in Subsection 11.2:
        @<Create new 'currentpicture'@>
      }
    }
    else 
      assign_picture_variable(mf, (struct picture_variable *) var -> var,
                              &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The function \monoespaco{assign\_picture\_variable} above needs to
generate a new texture in the destiny (removing the existing texture
if it exists) and copy the content of the origin texture in the
destiny. This means that we need to render the content of one texture
in the other.

To render something, we first need vertices. As all that we will
render will be rectangular textures, we will need only the following
vertices for all the rendering:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
const static float square[20] = {
  -1.0, -1.0, // First vertice
  0.0, 0.0,  // Texture coordinate
  1.0, -1.0, // Second vertice
  1.0, 0.0, // Texture
  1.0, 1.0, // Third vertice
  1.0, 1.0, // Texture
  -1.0, 1.0, // Fourth vertice
  0.0, 1.0}; // Texture
static GLuint vbo; // OpenGL Vertex Buffer Object
@
\fimcodigo

Each vertice above also stores information about the texture
coordinate. So we can sent to the GPU both informations at
once. Notice that we defined above a square with length 2 centered at
the origin. This is the correct size to render the vertices occupying
all the available space according with OpenGL conventions. We also
defined the vertices in counter-clockwise order, which means that we
are looking at the front side os the polycon according with OpenGL
conventions. This is necessary so that the polygon will be rendered
even if optimizations to avoid rendering the back of polygons are
active.

When initializing Weaver Metafont, we sent these vertices to the
graphics card:

\iniciocodigo
@<Weaver Metafont Initialization@>=
glGenBuffers(1, &vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// Sending vertices to the graphics card
glBufferData(GL_ARRAY_BUFFER, sizeof(square), square, GL_STATIC_DRAW);
@
\fimcodigo

And during finalization, we remove and erase these vertices:

\iniciocodigo
@<Weaver Metafont Finalization@>=
glDeleteBuffers(1, &vbo);
@
\fimcodigo

To render the vertices, we need a vertex shader running in the
GPU. Our vertex shader must be versatile enough to get as argument a
matrix with linear transformation to be done over the
vertices. Besides the matrix, the input will be the vertex coordinate,
and the associated texture coordinate. The output that will be passed to
the fragment shader os the final coordinate after the linear
transformation and the texture coordinate.

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "  texture_coordinate = vertex_data.zw;\n"
  "}\n";
@
\fimcodigo

The fragment shader get as input the vertex shader output and a
texture:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  vec4 texture = texture2D(texture1, texture_coordinate);\n"
  "  gl_FragColor = texture;"
  "}\n";
static GLuint program; // Store the program after compiling the above shaders
GLint uniform_matrix; // Stores the matrix position in the program above
GLint uniform_texture; // Stores the texture position in the above code
@
\fimcodigo

These simple shaders must be compiled during initialization. Let's
create a local auxiliary function to help us with the compilation:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source);
@
\fimcodigo

This function will return the compiled program's identifier given the
shader source code passed as argument. In case of error, it will
return zero.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source){
  GLuint vertex, fragment, prog;
  GLint status = GL_TRUE;
  // Creating vertex and fragment shader
  vertex = glCreateShader(GL_VERTEX_SHADER);
  fragment = glCreateShader(GL_FRAGMENT_SHADER);
  // Passing their source code
  glShaderSource(vertex, 1, &vertex_shader_source, NULL);
  glShaderSource(fragment, 1, &fragment_shader_source, NULL);
  // Compiling vertex shader:
  glCompileShader(vertex);
  glGetShaderiv(vertex, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont vertex shader compilation failed!\n");
    return 0;
  }
  // Compiling fragment shader:
  glCompileShader(fragment);
  glGetShaderiv(fragment, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont fragment shader compilation failed!\n");
    return 0;
  }
  // Creating the program:
  prog = glCreateProgram();
  // Linking the program:
  glAttachShader(prog, vertex);
  glAttachShader(prog, fragment);
  glBindAttribLocation(prog, 0, "vertex_data");
  glLinkProgram(prog);
  glGetProgramiv(prog, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr, "ERROR: Weaver Metafont shader linking failed!\n");
    return false;
  }
  // Finalization:
  glDeleteShader(vertex);
  glDeleteShader(fragment);
  return prog;
}
@
\fimcodigo


And we can use now this function to compile our default shader
program:

\iniciocodigo
@<Weaver Metafont Initialization@>+=
{
  program = compile_shader_program(vertex_shader, fragment_shader);
  uniform_matrix = glGetUniformLocation(program, "model_view_matrix");
  uniform_texture = glGetUniformLocation(program, "texture1");
}
@
\fimcodigo

During finalization we will delete the program:

\iniciocodigo
@<Weaver Metafont Finalization@>+=
glDeleteProgram(program);
@
\fimcodigo

To render the content of one texture in another, we will need to
create a new framebuffer with a new texture attached using a given
width and height. The function below will help us to achieve this. It
will create a new framebuffer with a new attached texture and activate
both. Everything that will be rendered after this, will be rendered in
the texture instead of the screen.

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height){
  glGenFramebuffers(1, new_framebuffer);
  glGenTextures(1, new_texture);
  glBindTexture(GL_TEXTURE_2D, *new_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
               GL_UNSIGNED_BYTE, NULL);
  glBindFramebuffer(GL_FRAMEBUFFER, *new_framebuffer);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                         *new_texture, 0);
  if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: OpenGL cannot create framebuffer!\n");
#endif
    glBindTexture(GL_TEXTURE_2D, 0);
    return false;
  }
  glBindTexture(GL_TEXTURE_2D, 0);
  return true;
}
@
\fimcodigo

We also need code to render a picture variable in the current
framebuffer using the defined shader program. The function that will
perform this is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background);
// XXX:
void print_picture(struct picture_variable *pic);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background){
  glColorMask(true, true, true, true);
  glViewport(0, 0, dst_width, dst_height);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *) 0);
  glEnableVertexAttribArray(0);
  glUseProgram(program);
  glUniformMatrix3fv(uniform_matrix, 1, true, matrix);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, pic -> texture);
  glUniform1i(uniform_texture, 0);
  if(clear_background){
    // Clearing the destiny to transparent white before drawing
    glClearColor(1.0, 1.0, 1.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
  }
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBindTexture(GL_TEXTURE_2D, 0);
}
// XXX:
void print_picture(struct picture_variable *pic){
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  GLuint framebuffer;
  GLuint texture;
  unsigned char data[100000];
  get_new_framebuffer(&framebuffer, &texture, pic -> width, pic -> height);
  render_picture(pic, model_view_matrix, pic -> width, pic -> height, true);
  // Ler dados do framebuffer:
  glFinish();
  glReadPixels(0, 0, pic -> width, pic -> height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    int i, j;
    for(i = pic -> width * (pic -> height - 1) * 4;
        i >= 0; i -= (pic -> width * 4)){
      for(j = 0; j < (pic -> width * 4); j += 4)
        printf("(%hu %hu %hu %hu)", (unsigned char) data[i + j], (unsigned char) data[i+j+1], (unsigned char) data[i+j+2], (unsigned char) data[i+j+3]);
        printf("\n");
    }
  }
}
@
\fimcodigo

Now let's declare the function that assigns the content of a source
variable to a target variable, generating a new texture and copying
the contents os one texture to the other:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source){
  GLuint temporary_framebuffer;
  GLint previous_framebuffer;
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(target -> texture != 0)
    glDeleteTextures(1, &(target -> texture));
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(target -> texture),
                      source -> width, source -> height);
  render_picture(source, model_view_matrix, source -> width, source -> height, true);
  // Finalization:
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glBindTexture(GL_TEXTURE_2D, 0);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  if(target ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
    // The code below will be defined on Subsection 11.2:
    @<Create new 'currentpicture'@>
  }
}
@
\fimcodigo

\subsubsecao{8.6.1. Picture Tertiary Expressions: Sum and Subtraction}

The tertiary picture expressions invoves sums and subtractions:

\alinhaverbatim
<Picture Expression> -> <Picture Tertiary>
<Picture Tertiary> -> <Picture Tertiary><'+' or '-'> <Picture Secondary>
<'+' or '-'> -> + | -
\alinhanormal

Pictures can be added or subtracted. The result of $p_1+p_2$
represents a new image composed by the pixels from the first image
plus the pixels in the second image. And $p_1-p_2$ means erasing from
the first image the pixels from the second.  The resulting image always
will have the biggest height and width from the operands. And the
pixel adding or subtracting will happen when the two images are
centered.

The function that evaluates picture tertiary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct picture_variable *result);
@
\fimcodigo

The function implementation tries to identify the last operator $+$ or
$-$ in the expression. If it does not exist, then we need to evaluate
the entire expression as a secondary expression. If it exists, then
the left side of the operator is evaluated as a tertiary expression
and the right side as a secondary expression. After this, the two
results are added or subtracted:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct picture_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_SUM || p -> type == TYPE_SUBTRACT) &&
       prev -> type != TYPE_SUM && prev -> type != TYPE_SUBTRACT){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL || before_last_operator == NULL){
    struct picture_variable a;
    struct picture_variable *sec = &a;
    @<Picture: Evaluate Secondary Expression in 'sec'@>
    return true;
  }
  else{
    struct picture_variable a, b;
    struct picture_variable *sec = &b;
    if(last_operator == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Incomplete picture expression "
                      "ending with '+' or '-'.\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_picture_expression(mf, cx, begin_expression, before_last_operator, &a))
      return false;
    @<Picture: Evaluate Secondary Expression in 'sec'@>
    @<Image Expression: Sum or Subtract@>
    if(a.texture != 0)
      glDeleteTextures(1, &(a.texture));
    if(b.texture != 0)
      glDeleteTextures(1, &(b.texture));
    return true;
  }
}
@
\fimcodigo

To add or subtract images, we first need to determine the final image
area. It will have the biggest width and height from the combined
images. After this, we create and initialize it as a transparent
image. Both in the sum as in the subtraction we begin drawing the
first operand to the destination. After this, in the case of a sum, we
just draw the second image blending with the initial image by
multiplying the new color $(y_R, y_G, y_B, y_A)$ by its alpha value
and adding with the previous color $(x_R, x_G, x_B, x_A)$ multiplied
by the complement of the alpha component of the new color:

$$(1-y_A)(x_R, x_G, x_B, x_A) + y_A(y_R, y_G, y_B, y_A)$$

The subtraction case is more complex and to understand it, we need to
understand the rules about how the textures are represented and how
Weaver Metafont deals with them. Weaver Metafont assumes that an empty
initialized picture of a given size has a fully transparent white
color (represented by $(1, 1, 1 ,0)$ following OpenGL convention). If
we put ink in a image, we are putting a fully opaque black color
(represented by $(0, 0, 0, 1)$ following OpenGL conventions). To
Weaver Metafont, white transparent is the neutral operator in a
subtraction: removing transparent white from a picture changes
nothing. And removint opaque black removes all the color. These rules
contrast with white being represented by 1 and black being represented
by 0 in OpenGL. Because of this, our blending equation to combine an
existing color $(x_R, x_G, x_B, x_A)$ with a new color $(y_R, y_G,
y_B, y_A)$ is:

$$
(max(x_R, 1-y_R), max(x_G, 1-y_G), max(x_B, 1-y_B), x_A-y_A)
$$

Unfortunately, it is not possible to compute the above equation using
only OpenGL blending equations. Open GL ES 3.0 and 4 supports the
usage of $max$ function, but when using it, the blending factors are
ignored. This means that it is possible to compute $max(x_R, y_R)$,
but not $max(x_R, 1- y_R)$. This inversion neeeds to be done in the
shader. The fragment shader that invert the colors, but not the image
alpha is:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char fragment_shader_inverse[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  vec4 texture = texture2D(texture1, texture_coordinate);\n"
  "  gl_FragColor = vec4(1.0 - texture.r, 1.0 - texture.g, 1.0 - texture.b, \n"
  "                      texture.a);\n"
  "}\n";
static GLuint inv_program; // The compiled program whose code is above
static GLint uniform_inv_texture; // Texture position in the program
static GLint uniform_inv_matrix; // Matrix position in the program
@
\fimcodigo

A new shader program to render the inverse RGB must be compiled during
initialization:

\iniciocodigo
@<Weaver Metafont Initialization@>+=
{
  inv_program = compile_shader_program(vertex_shader, fragment_shader_inverse);
  uniform_inv_matrix = glGetUniformLocation(program, "model_view_matrix");
  uniform_inv_texture = glGetUniformLocation(program, "texture1");
}
@
\fimcodigo

In the finalization, we destroy the program:

\iniciocodigo
@<Weaver Metafont Finalization@>+=
glDeleteProgram(inv_program);
@
\fimcodigo


\iniciocodigo
@<Image Expression: Sum or Subtract@>=
// Allocating and declaring data, creating transparent initial image
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
result -> width = ((a.width >= b.width)?(a.width):(b.width));
result -> height = ((a.height >= b.height)?(a.height):(b.height));
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Rendering image 'a'
model_view_matrix[0] = (double) a.width / (double) result -> width;
model_view_matrix[4] = (double) a.height / (double) result -> height;
render_picture(&a, model_view_matrix, result -> width, result -> height, true);
// Rendering image 'b'
model_view_matrix[0] = (double) b.width / (double) result -> width;
model_view_matrix[4] = (double) b.height / (double) result -> height;
if(last_operator -> type == TYPE_SUBTRACT){
  glEnable(GL_BLEND);
  // The factors in the blending equation
  glBlendFunc(GL_ONE, GL_ONE);
  // Max function for RGB and subtraction for A:
  glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  glUseProgram(inv_program);
  glUniformMatrix3fv(uniform_inv_matrix, 1, true, model_view_matrix);
  glUniform1i(uniform_inv_texture, 0);
  glBindTexture(GL_TEXTURE_2D, b.texture);
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBlendEquation(GL_FUNC_ADD);
  glDisable(GL_BLEND);
}
else{ // Sum:
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glBlendEquation(GL_FUNC_ADD);
  render_picture(&b, model_view_matrix, result -> width, result -> height, false);
  glDisable(GL_BLEND);
}
// Finalization
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glBindTexture(GL_TEXTURE_2D, 0);
glDeleteFramebuffers(1, &temporary_framebuffer);
@
\fimcodigo

\subsubsecao{8.6.2. Picture Secondary Expressions: Transformers}

A picture secondary expression has the following syntax:

\alinhaverbatim
<Picture Seconary> -> <Picture Primary> |
                      <Picture Secondary><Transformer>
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary> |
                 transformed <Transform Primary>
\alinhanormal

The same transformers that we can use in pairs, transforms, paths and
pens also can be used in images. But how we do apply them is a little
different. Like what we do for pens, we first store all the required
transformations in a matrix to accumulate transformations before
applying them. But contrary to pens, picture variables do not store
their transform matrix.

The matrix will exist only when evaluating secondary and tertiary
picture expressions. And they will be applied only after evaluating a
secondary expression in the tertiary expression. This way, if we had
the following code:

\alinhaverbatim
a = img totated 45 slanted 0.2 zscaled(2, 3)
\alinhanormal

Instead of making three potentially expensive transforms, we will
accumulate all the three transforms in a matrix. When we have no more
transforms, which is when we return from all secondary expression
evaluations to a tertiary evaluation, we finally apply the transforms
stored in the matrix. This means that the function that evaluates
picture secondary expressions will have two additional parameters: a
matrix pre-initialized as the identity matrix and a pointer to a
boolean variable pre-initialized to false. The boolean variable will
became true only if the matrix is changed during secondary evaluation.

\iniciocodigo
@<Picture: Evaluate Secondary Expression in 'sec'@>=
{
  float matrix[9];
  bool modified = false;
  INITIALIZE_IDENTITY_MATRIX(matrix);
  if(last_operator == NULL){
     if(!eval_picture_secondary(mf, cx, begin_expression, end_expression, sec,
                             matrix, &modified))
      return false;
  }
  else if(!eval_picture_secondary(mf, cx, last_operator -> next,
                                  end_expression, sec, matrix, &modified))
    return false;
  if(modified){
    if(!apply_image_transformation(mf, result, sec, matrix))
      return false;
    if(sec -> texture != 0)
      glDeleteTextures(1, &(sec -> texture));
  }
  else{
    result -> width = sec -> width;
    result -> height = sec -> height;
    result -> texture = sec -> texture;
  }
}
@
\fimcodigo

The function that evaluates secondary expressions for pictures is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct picture_variable *result,
                            float *matrix, bool *modified);
@
\fimcodigo

And its implementation involves looping over each token in the
expression until finding the last secondary transform operator. If we
do not find any, we evaluate everything as a primary
expression. Otherwise, we evaluate everything before the last operator
as a secondary expression and then we apply the transformation in the
matrix:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct picture_variable *result,
                            float *matrix, bool *modified){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_picture_primary(mf, cx, begin_expression, end_expression, result);
  else{
    if(!eval_picture_secondary(mf, cx, begin_expression,
                               before_last_transformer, result, matrix, modified))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Picture Secondary: Rotation@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Picture Secondary: Scaling@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Picture Secondary: Shifting@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Picture Secondary: Slanting@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Picture Secondary: X-Scaling@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Picture Secondary: Y-Scaling@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Picture Secondary: Z-Scaling@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Picture Secondary: Generic Transform@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Evaluating each different linear transformation means modifying the
secondary expression matrix, multiplying its previous value by a new
matrix. Exactly like we did for pens. Like described in code from
Subsection X.Y.

This is scale changing:

\iniciocodigo
@<Picture Secondary: Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

This is the code for rotation:

\iniciocodigo
@<Picture Secondary: Rotation@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(matrix, rotation);
*modified = true;
return true;
@
\fimcodigo

The code that shifts the image by coordinate $(x, y)$ in
pixels. Before performing the linear transform in the matrix, we
conver the pixels in OpenGL coordinates that depend on the picture
size:

\iniciocodigo
@<Picture Secondary: Shifting@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
p.x = 2.0 * (p.x / result -> width);
p.y = 2.0 * (p.y / result -> height);
TRANSFORM_SHIFT(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

The code that slants an image:

\iniciocodigo
@<Picture Secondary: Slanting@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

The code that scales an image only in the $x$-axis:

\iniciocodigo
@<Picture Secondary: X-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

The code that scales the image only in axis $y$:

\iniciocodigo
@<Picture Secondary: Y-Scaling@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

The z-scaling which changes the scale in the complex plane:

\iniciocodigo
@<Picture Secondary: Z-Scaling@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

Finally, the generic transform that applies the linear transform
stored in a transformer:

\iniciocodigo
@<Picture Secondary: Generic Transform@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression,
                           &t))
  return false;
MATRIX_MULTIPLICATION(matrix, t.value);
*modified = true;
return true;
@
\fimcodigo

Now we just need to define how do we apply the linear transformation
over an image given the transform matrix, the origin picture variable
and the destiny picture variable. This is done with the help of the
following auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *org,
                                float *matrix);
@
\fimcodigo

Apply the image transformation means using the transformation matrix
to transform the original image to generate the new image in the
destiny. For this, we need the following steps:

1) First we need to discover the size in pixels for the final
image. To discover the values, we multiply the coordinates in the
origin by the transformation matrix. But in this case, we measure the
coordinates in pixels, not using OpenGL coordinates. If our image is a
square measuring 5, one of its vertices is $(-5/2, -5/2)$ and the
other will be $(5/2, 5/2)$. The resulting transformation will be the
coordinates in pixels, from which we obtain the final size in
pixels. We can ignore the translation in this step.

2) To take into account the translation, we should add twice the
translation distance in pixels to the image size. Recall that the
translation should not change the central pixel in the
image. Therefore, if we shift an original image composed by a single
black pixel by $(1, 1)$, we would obtain a new image $3 \times 3$,
with the black pixel in the upper corner. The image center now is a
white transparent pixel, which is the black pixel position before the
shift.

3) Changing the size and scale is done just rendering the image in a
texture with different size. So we do not need anymore the information
in the matrix about scaling. We remove this from tha matrix and also
correct the shifting coordinates, so that if the original image is
shifted a single pixel,in the final image we get it after changing a
simple pixel. This is done applying a correction over $x$ and $y$
positions in the matrix.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix){
  int i;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  // To compute the final size, we store the greatest and smallest
  // coordinates found in the picture vertices in both axisafter
  // the transformation. (Step 1):
  float min_x = INFINITY, min_y = INFINITY, max_x = -INFINITY, max_y = -INFINITY;
  float origin_coordinates[8];
  origin_coordinates[0] = -((float) origin -> width) / 2.0;
  origin_coordinates[1] = -((float) origin -> height) / 2.0;
  origin_coordinates[2] = ((float) origin -> width) / 2.0;
  origin_coordinates[3] = -((float) origin -> height) / 2.0;
  origin_coordinates[4] = ((float) origin -> width) / 2.0;
  origin_coordinates[5] = ((float) origin -> height) / 2.0;
  origin_coordinates[6] = -((float) origin -> width) / 2.0;
  origin_coordinates[7] = ((float) origin -> height) / 2.0;
  for(i = 0; i < 8; i += 2){
    float x = LINEAR_TRANSFORM_X(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    float y = LINEAR_TRANSFORM_Y(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    if(x > max_x) max_x = x;
    if(x < min_x) min_x = x;
    if(y > max_y) max_y = y;
    if(y < min_y) min_y = y;
  }
  // Adjusting the image size according with translation (Step 2):
  dst -> width = (int) (max_x - min_x) +
                 (int) (origin -> width * matrix[6]);
  dst -> height = (int) (max_y - min_y) +
                  (int) (origin -> height * matrix[7]);
  // Removing from the matrix scaling data and correcting the translation
  // (Step 3):
  {
    double x_correction = ((double) origin -> width) / (double) dst -> width;
    double y_correction = ((double) origin -> height) / (double) dst -> height;
    matrix[0] = matrix[0] * x_correction;
    matrix[3] = matrix[3] * x_correction;
    matrix[6] = matrix[6] * x_correction;
    matrix[1] = matrix[1] * y_correction;
    matrix[4] = matrix[4] * y_correction;
    matrix[7] = matrix[7] * y_correction;
  }
  // Generating framebuffer and initial texture
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(dst -> texture), dst -> width,
                    dst -> height);
  // Rendering:
  render_picture(origin, matrix, dst -> width, dst -> height, true);
  // Finalization:
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.3. Primary Picture Expressions: Inverters, Identity and Empty Images}

The grammar for primary picture expressions is:

\alinhaverbatim
<Picture Primary> -> <Picture Variable> |
                     nullpicture <Pair Primary> |
                     ( <Picture Expression> ) |
                     <'+' or '-'> <Picture Primary> |
                     subpicture <Pair Primary> and <Pair Primary> of
                                <Picture Primary>
\alinhanormal

This means that we need to register a new token for ``nullpicture'' and
``subpicture'':

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_NULLPICTURE,        // Symbolic token 'nullpicture'
TYPE_SUBPICTURE,         // Symbolic token 'subpicture'
@
\fimcodigo

And this also requires adding these strings to the list of reserved
keywords:

\iniciocodigo
@<List of Keywords@>+=
"nullpicture", "subpicture",
@
\fimcodigo

The function that evaluates primary picture expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct picture_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct picture_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Primary Picture: Variable@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Primary Picture: Parenthesis@>
    }
    else if(begin_expression -> type == TYPE_NULLPICTURE){
      @<Primary Picture: 'nullpicture'@>
    }
    else if(begin_expression -> type == TYPE_SUM){
      @<Primary Picture: Identity@>
    }
    else if(begin_expression -> type == TYPE_SUBTRACT){
      @<Primary Picture: Inverse@>
    }
    else if(begin_expression -> type == TYPE_SUBPICTURE){
      @<Primary Picture: Subpicture@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

The first kind of primary expression is reading an image from a
variable. In this case, we need to copy the content of the variable
rendering it in the destiny:

\iniciocodigo
@<Primary Picture: Variable@>=
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct picture_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PICTURE){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-picture variable (%d) in "
                  "picture expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
// Preparing the rendering:
result -> width = content -> width;
result -> height = content -> height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Rendering
render_picture(content, identity_matrix, result -> width, result -> height, true);
// Finalization:
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

Dealing with parenthesis is exactly like what we did in other
expressions. We walk over the token list until we find the last token
before the closing parenthesis. The tokens between the two parenthesis
are evaluated as a new picture expression:

\iniciocodigo
@<Primary Picture: Parenthesis@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_picture_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

The next picture primary expression is creating an empty picture with
a given size. We first evaluate the tokens
after \monoespaco{nullpicture} token as a primary pair
expression. Then, we obtain the picture size from the pair and create
the texture:

\iniciocodigo
@<Primary Picture: 'nullpicture'@>=
struct generic_token *begin_pair_expression, *end_pair_expression;
struct pair_variable p;
unsigned char *data;
begin_pair_expression = begin_expression -> next;
end_pair_expression = end_expression;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing pair expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_primary(mf, cx, begin_pair_expression, end_pair_expression, &p))
  return false;
result -> width = p.x;
result -> height = p.y;
data = temporary_alloc(p.x * p.y * 4);
if(data == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
  return false;
}
// Making the new texture fully white
memset(data, 255, result -> width * result -> height * 4);
{ // And making it fully transparent:
  int i, size = result -> width * result -> height * 4;
  for(i = 3; i < size; i += 4)
    data[i] = 0;
}
glGenTextures(1, &(result -> texture));
glBindTexture(GL_TEXTURE_2D, result -> texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, result -> width, result -> height, 0,
             GL_RGBA, GL_UNSIGNED_BYTE, data);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glBindTexture(GL_TEXTURE_2D, 0);
if(temporary_free != NULL)
  temporary_free(data);
return true;
@
\fimcodigo

Now the antepenultimate case: when we have a token \monoespaco{+}
before the picture. In this case the operator is not doing
anything. It is an identity operator. So we just ignore it and
evaluate the next tokens as the resulting picture:

\iniciocodigo
@<Primary Picture: Identity@>=
struct generic_token *p = begin_expression -> next;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing image expression "
                  "after '+'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
return eval_picture_primary(mf, cx, p, end_expression, result);
@
\fimcodigo

For the operator \monoespaco{-}, which generates the inverse of a
picture, we will again render activating a blend equation. This time,
we will obtain the final color usaing opaque white $(1, 1, 1, 1)$ as
the initial color and we render subtracting from this the new
color. This is done choosing the blend factors to be one (GL\_ONE) e
usando subtraction as the operator (GL\_FUNC\_SUBTRACT):

\iniciocodigo
@<Primary Picture: Inverse@>=
struct picture_variable p;
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                  "'-'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_picture_primary(mf, cx, begin_expression -> next, end_expression, &p))
  return false;
// Preparing to render:
result -> width = p.width;
result -> height = p.height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Initializing the new texture to opaque white (1, 1, 1, 1)
glClearColor(1.0, 1.0, 1.0, 1.0);
glClear(GL_COLOR_BUFFER_BIT);
// Adjusting the blending equation to subtract the color from white opaque:
glEnable(GL_BLEND);
glBlendFuncSeparate(GL_ONE, GL_ONE, GL_ONE, GL_ONE);
glBlendEquationSeparate(GL_FUNC_REVERSE_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT);
// Rendering:
render_picture(&p, identity_matrix, result -> width, result -> height, false);
// Ending:
glDisable(GL_BLEND);
glDeleteTextures(1, &(p.texture));
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

FInally, the primary expression to compute subpictures. This
expression begins with token \monoespaco{subpicture}, get a primary
pair (offset in pixels), a token \monoespaco{and}, a second pair (with
subpicture size), a token \monoespaco{of} and a primary expression
with a picture (from where the subpicture will be extracted).

The first part for evaluate this expression is reading the two pairs
and the picture from the subexpressions. The second part is extract
the subpicture as requested:

\iniciocodigo
@<Primary Picture: Subpicture@>=
struct pair_variable pair_offset, subpicture_size;
struct picture_variable original_picture;
@<Subpicture: Extract Subexpressions@>
@<Subimagem: Extract Subpicture@>
return false;
@
\fimcodigo

Extract the subexpressions involves delimiting the begin and end for
each subexpression while searching for the auxiliary
tokens \monoespaco{of} and \monoespaco{and}. We also store an state to
check if we are reading the tokens in the right order, or if we are in
a malformed expressions where the tokens are present, but in the wrong
order, or without subexpressions:

\iniciocodigo
@<Subpicture: Extract Subexpressions@>=
{
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_pair1 = NULL, *end_pair1 = NULL,
                       *begin_pair2 = NULL, *end_pair2 = NULL,
                       *begin_pic = NULL, *end_pic = NULL,
                       *p = begin_expression -> next,
                       *last_token = begin_expression;
  int state = 0;
  begin_pair1 = p;
  while(p != end_expression && p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p -> type == TYPE_AND){
      if(state != 0 || last_token -> type == TYPE_SUBPICTURE){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair1 = last_token;
      state ++;
      begin_pair2 = p -> next;
    }
    else if(IS_NOT_NESTED() && p -> type == TYPE_OF){
      if(state != 1 || last_token -> type == TYPE_AND){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair2 = last_token;
      state ++;
      begin_pic = p -> next;
    }
    last_token = p;
    p = p -> next;
  }
  if(p == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
            mf -> file, p -> line);
#endif
    return false;
  }
  end_pic = p;
  if(!eval_pair_primary(mf, cx, begin_pair1, end_pair1, &pair_offset))
    return false;
  if(!eval_pair_primary(mf, cx, begin_pair2, end_pair2, &subpicture_size))
    return false;
  if(!eval_picture_primary(mf, cx, begin_pic, end_pic, &original_picture))
    return false;
}
@
\fimcodigo

Extract the subpicture requires generating a new texture with the size
indicated by the second pair and rendering the original image in the
new texture changing its size and offset according with what is stored
in the two pairs:

\iniciocodigo
@<Subimagem: Extract Subpicture@>=
{
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  float render_matrix[9];
  INITIALIZE_IDENTITY_MATRIX(render_matrix);
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                      subpicture_size.x, subpicture_size.y);
  result -> width = subpicture_size.x;
  result -> height = subpicture_size.y;
  // Initializing the new texture as transparent white (1, 1, 1, 0)
  glClearColor(1.0, 1.0, 1.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT);
  // Adjusting the size to render in the new texture
  render_matrix[0] = original_picture.width / subpicture_size.x;
  render_matrix[4] = original_picture.height / subpicture_size.y;
  // Adjusting the offset in the render matrix
  render_matrix[6] = -2.0 * (pair_offset.x +
                      0.5 * (subpicture_size.x - original_picture.width)) /
                      subpicture_size.x;
  render_matrix[7] = -2.0 * (pair_offset.y +
                      0.5 * (subpicture_size.y - original_picture.height)) /
                      subpicture_size.y;
  // Rendering:
  render_picture(&original_picture, render_matrix, result -> width, result -> height,
                 false);
  
  // Finalization:
  glDisable(GL_BLEND);
  glDeleteTextures(1, &(original_picture.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.4. Pictures in Numeric Expressions}

There are cases where we need to evaluate a picture expression inside
expressions of other types. We have three additional numeric
expressions:

\alinhaverbatim
<Numeric Primary> -> totalweight <Picture Primary> |
                     width <Picture Primary> |
                     height <Picture Primary>
\alinhanormal

The two last operators just return respectively the picture width and
height. The operator \monoespaco{totalweight} does is evaluate a
picture expression, get the resulting picture and return the sum of
its pixels weight. Each pixel weight is computed as the euclidean
distance between its RGB component and the color white, and then
normalizing the result dividing by $\sqrt{3}$. So the color white has
weight 0 and the black color has weight 1. The computed value is then
multiplied by the alpha component.

First we need a new token types for the three new operators:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_TOTALWEIGHT,        // Symbolic token 'totalweight'
TYPE_WIDTH,              // Symbolic token 'width'
TYPE_HEIGHT,             // Symbolic token 'height'
@
\fimcodigo

And we add their names to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"totalweight", "width", "height",
@
\fimcodigo

For the first operator, we will recover the pixels from a texture
first rendering the texture to a temporary framebuffer and then
reading the valuesd using function \monoespaco{glReadPixels} to get
the framebuffer content:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_TOTALWEIGHT){
  struct picture_variable p;
  char *data;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  GLuint temporary_texture = 0;
  float identity_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'totalweight'.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &p))
    return false;
  data = temporary_alloc(p.width * p.height * 4);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Not enough memory!\n", mf -> file);
#endif
    return false;
  }
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(temporary_texture),
                    p.width, p.height);
  // Rendering:
  render_picture(&p, identity_matrix, p.width, p.height, true);
  // Reading framebuffer data:
  glReadPixels(0, 0, p.width, p.height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    int i, size = p.width * p.height * 4;
    double sum = 0.0;
    for(i = 0; i < size; i += 4){
      // If the values are equal, let's avoid rounding errors:
      if(data[i] == data[i+1] && data[i+1] == data[i+2]){
        sum += ((255 - (unsigned char) data[i]) / 255.0) *
               (((unsigned char) data[i+3]) / 255.0);
      }
      else{
        double r = (255 - (unsigned char) data[i]) / 255.0,
               g = (255 - (unsigned char) data[i+1]) / 255.0,
               b = (255 - (unsigned char) data[i+2]) / 255.0,
               a = ((unsigned char) data[i+3]) / 255.0;
        double v = sqrt(r*r + g*g + b*b) / sqrt(3.0);
        sum += (v * a);
      }
    }
    result -> value = sum;
  }
  // Ending:
  if(temporary_free != NULL)
    temporary_free(data);
  glDeleteTextures(1, &temporary_texture);
  glDeleteTextures(1, &(p.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

For the next two operators, \monoespaco{width}
and \monoespaco{height}, everything is simpler. We just need to get
the image and get their width and height respectively. For the width:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_WIDTH){
  struct picture_variable p;
  if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'width'.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &p))
    return false;
  result -> value = (float) p.width;
  return true;
}
@
\fimcodigo

And for the height:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_HEIGHT){
  struct picture_variable p;
  if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'height'.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &p))
    return false;
  result -> value = (float) p.height;
  return true;
}
@
\fimcodigo


\subsecao{8.7. Boolean Assignments and Expressions}

Like for all other expressions and assignments, we begin defining the
code to assign variables after evaluate an expression:

\iniciocodigo
@<Assignment for Boolean Variables@>=
else if(type == TYPE_T_BOOLEAN){
  int i;
  bool ret;
  struct boolean_variable result;
  ret = eval_boolean_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    ((struct boolean_variable *) var -> var) -> value = result.value;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Now that we can assign the result of expressions, we can write the
code to proper evaluate the expressions.

\subsubsecao{8.7.1. Comparisons}

Comparisons are made using relations. They allow us to check if two
values are equal or not, and also which value is bigger or
smaller. The grammar rules to compare values are:

\alinhaverbatim
<Boolean Expression> -> <Boolean Tertiary> |
                        <Numeric Expression> <Relation> <Numeric Tertiary> |
                        <Pair Expression> <Relation> <Pair Tertiary>       |
                        <Boolean Expression> <Relation> <Boolean Tertiary> |
                        <Transform Expression> <Relation> <Transform Tertiary>
<Relation> -> < | <= | > | >= | = | <>
\alinhanormal

This mean that comparisons using these relations are in fact
quarternary expressions. They have a precedence order even smaller
that tertiary operators. For other types of expressions, we considered
a tertiary expression as synonym for expressions of that type. But for
boolean expressions, tertiary expressions are an inner type for
general boolean expressions.

The relations above require new token types to represent them:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_LT,                    // O token simbólico '<'
TYPE_LEQ,                   // O token simbólico '<='
TYPE_GT,                    // O token simbólico '>'
TYPE_GEQ,                   // O token simbólico '>='
TYPE_NEQ,                   // O token simbólico '<>'
@
\fimcodigo

And we also add their names to the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"<", "<=", ">", ">=", "<>",
@
\fimcodigo

The declaration for the funtion that will evaluate boolean expressions
is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct boolean_variable *result);
@
\fimcodigo

This function shall check if we have one of the relation operators. If
not, the entire expression is evaluated as a tertiary booleana
expression. If we have one, we first need to take the rightmost
operator and evaluate it after evaluating the other two expressions
that produce its operands. But to evaluate an expression, we need to
know its type. We will assume that we have a function that, given an
tertiary expression, returns its type. We will call
it \monoespaco{get\_tertiary\_expression\_type}. We will define it
later, in Subsection 8.8. But for now we will just assume that the
function exists.

The implementation is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_LT || p -> type == TYPE_LEQ ||
        p -> type == TYPE_GT || p -> type == TYPE_GEQ ||
        p -> type == TYPE_NEQ || p -> type == TYPE_ASSIGNMENT)){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_tertiary(mf, cx, begin_expression, end_expression,
                                 result);
  else{
    int type;
    if(before_last_operator == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Relational operator without "
                      "l-value.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    type = get_tertiary_expression_type(mf, cx,  last_operator -> next,
                                        end_expression);
    switch(type){
    case TYPE_T_NUMERIC:
    {
      struct numeric_variable a, b;
      if(!eval_numeric_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_numeric_expression(mf, cx, last_operator -> next,
                                  end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_ASSIGNMENT:
        result -> value = a.value == b.value;
        return true;
      case TYPE_NEQ:
        result -> value = a.value != b.value;
        return true;
      }
      break;
    }
    case TYPE_T_PAIR:
    {
      struct pair_variable a, b;
      if(!eval_pair_expression(mf, cx, begin_expression,
                               before_last_operator, &a))
        return false;
      if(!eval_pair_expression(mf, cx, last_operator -> next,
                               end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y < b.y);
        return true;
      case TYPE_LEQ:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y <= b.y);
        return true;
      case TYPE_GT:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_GEQ:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_ASSIGNMENT:
        result -> value = (a.x == b.x && a.y == b.y);
        return true;
      case TYPE_NEQ:
        result -> value = (a.x != b.x || a.y != b.y);
        return true;
      }
      break;
    }
    case TYPE_T_TRANSFORM:
    {
      struct transform_variable a, b;
      int i, order[6] = {6, 7, 0, 3, 1, 4};
      if(!eval_transform_expression(mf, cx, begin_expression,
                                    before_last_operator, &a))
        return false;
      if(!eval_transform_expression(mf, cx, last_operator -> next,
                                    end_expression, &b))
        return false;
      switch(last_operator -> type){
        case TYPE_LT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] < b.value[order[i]]);
          return true;
        case TYPE_LEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] <= b.value[order[i]]);
          return true;
        case TYPE_GT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] > b.value[order[i]]);
          return true;
        case TYPE_GEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] >= b.value[order[i]]);
          return true;
        case TYPE_ASSIGNMENT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = false;
              return true;
            }
          result -> value = (a.value[order[i]] == b.value[order[i]]);
          return true;
        case TYPE_NEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = true;
              return true;
            }
          result -> value = (a.value[order[i]] != b.value[order[i]]);
          return true;
      }          
      break;
    }
    case TYPE_T_BOOLEAN:
    {
      struct boolean_variable a, b;
      a.value = b.value = -1;
      if(!eval_boolean_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_boolean_tertiary(mf, cx, last_operator -> next,
                                end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_ASSIGNMENT:
        result -> value = (a.value == b.value);
        return true;
      case TYPE_NEQ:
        result -> value = (a.value != b.value);
        return true;
      }
      break;
    }
    default:
    }
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.2. Operation OR}

The boolean operator OR is the sole tertiary boolean operator. The
grammar for boolean tertiary expressions is:

\alinhaverbatim
<Boolean Tertiary> -> <Boolean Tertiary> or <Boolean Secondary> |
                      <Boolean Secondary>
\alinhanormal

To implement the operator, we need to define a new symbolic token
representing the \monoespaco{or} opeartor:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_OR,                    // Symbolic token 'or'
@
\fimcodigo

Which should be stored in the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"or",
@
\fimcodigo

Now we declare the function that evaluates secondary boolean
expressions:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result);
@
\fimcodigo

This function implementation follows the expected model from previous
similar functions. It walks over the list of tokens trying to find the
last non-nested \monoespaco{or} operator. Then, it applies the
operator over the results of the two subexpressions that delimits
it. If there ire no \monoespaco{or} operators, then the entire
expression is evaluated as a secondary boolean operator:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_OR){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_secondary(mf, cx, begin_expression, end_expression,
                                  result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_tertiary(mf, cx, begin_expression,
                             before_last_operator, &a))
      return false;
    if(!eval_boolean_secondary(mf, cx, last_operator -> next,
                               end_expression, &b))
      return false;
    result -> value =  (a.value || b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.3. Operator AND}

The boolean operator AND is the sole boolean secondary operator. The
grammar for secondary boolean expressions is:

\alinhaverbatim
<Boolean Secondary> -> <Boolean Secondary> and <Boolean Primary> |
                       <Boolean Primary>
\alinhanormal

The token \monoespaco{and} was aleready defined. We used it to
separate two control points when describing a path curve.

The function that evaluates secondary boolean operators is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result);
@
\fimcodigo

The function works exactly as the tertiary function that evaluates the
operator OR. The difference is that it works searching for AND
operators and applying the leftmost AND operator over the delimiting
subexpressions. If there are no AND operators, the entire expression
is evaluated as a primary boolean expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_AND){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_primary(mf, cx, begin_expression, end_expression,
                                result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_secondary(mf, cx, begin_expression,
                               before_last_operator, &a))
      return false;
    if(!eval_boolean_primary(mf, cx, last_operator -> next,
                             end_expression, &b))
      return false;
    result -> value = (a.value && b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.4. Primary Boolean Expressions}

The grammar for boolean primary expressions is:

\alinhaverbatim
<Boolean Primary> -> <Boolean Variable> | true | false |
                     cycle <Path Primary> | odd <Numeric Primary> |
                     not <Boolean Primary> |
                     ( <Boolean Expression> )
\alinhanormal

Most of these expressions have obvious meanings. A boolean variable is
evaluated to what vaue it has stored. The values \monoespaco{true}
and \monoespaco{false} evaluated to the boolean value correspinding to
their names. The \monoespaco{not} operator is the boolean
NOT. Parenthesis can be used to change the order of evaluation for
operators. The token \monoespaco{odd} checks if the following numeric
is odd after rounding it to the nearest
integer. And \monoespaco{cycle} checks if a path is cyclic.

The following new tokens are defined:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_TRUE,                    // O token simbólico 'true'
TYPE_FALSE,                   // O token simbólico 'false'
TYPE_ODD,                     // O token simbólico 'odd'
TYPE_NOT,                     // O token simbólico 'not'
@
\fimcodigo

Each of their names should be added to the list of reserved kyewords:

\iniciocodigo
@<List of Keywords@>+=
"true", "false", "odd", "not",
@
\fimcodigo

The function that evaluates boolean primaries is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result);
@
\fimcodigo

In boolean primary expressions, it is possible to determine which
grammar rule to follow just checking the first token. Therefore, this
function just checks the first token and apply the correct rule:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result){
  switch(begin_expression -> type){
    case TYPE_SYMBOLIC: // Variável
      struct boolean_variable *var;
      var = ((struct symbolic_token *) begin_expression) -> var;
      if(var -> value == -1){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
                "'%s'.\n", mf -> file, begin_expression -> line,
                ((struct symbolic_token *) begin_expression) -> value);
#endif
        return false;
      }
      result -> value = var -> value;
      return true;
    break;
    case TYPE_TRUE: // Verdadeiro
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        return false;
      }
      result -> value = 1;
      return true;
    break;
    case TYPE_FALSE: // Falso
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        return false;
      }
      result -> value = 0;
      return true;
    break;
    case TYPE_CYCLE: // 'cycle'
      struct path_variable path;
      if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                            &path))
        return false;
      result -> value = path.cyclic;
      if(temporary_free != NULL)
        path_recursive_free(temporary_free, &path, false);
      return true;
    break;
    case TYPE_ODD: // 'odd'
      struct numeric_variable num;
      if(!eval_numeric_primary(mf, cx, begin_expression -> next, end_expression,
                               &num))
        return false;
      result -> value = (((int) round(num.value)) % 2);
      return true;
    break;
    case TYPE_NOT: // 'not'
      struct boolean_variable b;
      if(!eval_boolean_primary(mf, cx, begin_expression -> next, end_expression,
                              &b))
        return false;
      result -> value = !(b.value);
      return true;
    break;
    case TYPE_OPEN_PARENTHESIS: // '('
      if(end_expression -> type != TYPE_CLOSE_PARENTHESIS){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
        return false;
      }
      struct generic_token *last_token = begin_expression;
      while(last_token -> next != end_expression)
        last_token = last_token -> next;
      return eval_boolean_expression(mf, cx, begin_expression -> next,
                                     last_token, result);
    break;
    default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo


\subsecao{8.8. Identifying Expression Types}

Several times we have an expression and want to identify its type. For
example, in boolean expressions we can compare values from numeric,
pair, transform and boolean expressions. In a numeric expression we
can use \monoespaco{length} operator over numeric or pair
expressions. We can multiply between two numeric expressions or
between a numeric and a pair expression. Operators
like \monoespaco{xpart} works in pairs and transforms.

Notice that in none of the cases above we expect to identify a path,
picture or pen expression. Therefore, we will ignore these expressions
when trying to identiy the type.

Identify the type of some expression can be complex. But the most
common cases are simple and can be evaluated fast. We will use
different functions to evaluate the type for primary, secondary and
tertiary expressions:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr);
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr);
@
\fimcodigo

To identify primary expressions, first we can treat the simplest cases
(the expression have a single token) and then we deal with the more
complex cases. The rules that allow us to identify the types are:

1) A variable is an expression with the variable type.

2) The expression is boolean if it is the single
 token \monoespaco{true} or \monoespaco{false}. Or if it begins
 with \monoespaco{cycle}, \monoespaco{odd} or
\monoespaco{not}.

3) The expression is a pair if it begins
 with \monoespaco{point}, \monoespaco{precontrol}
 or \monoespaco{postcontrol}. Or if in the expression we have
 a \monoespaco{[}. And also if it begins with a numeric token and have
 parenthesis or the beginning of a primary pair.

4) The expresison is numeric if it has a ingle numeric token or the
token \monoespaco{normaldeviate}. Or if it is a numeric token followed
by \monoespaco{/}. Or if it begins
with \monoespaco{length}, \monoespaco{xpart}, \monoespaco{ypart},
\monoespaco{xxpart},
\monoespaco{xypart}, \monoespaco{yxpart}, \monoespaco{yypart}, \monoespaco{angle},
\monoespaco{sqrt}, \monoespaco{sind}, \monoespaco{cosd}, \monoespaco{log},
\monoespaco{mexp}, \monoespaco{floor}, \monoespaco{uniformdeviate}.

5) If we have a \monoespaco{+} ou \monoespaco{-}, we discover the type
ignoring this first token and checking the type of the remaining
expression.

6) If we begin and end with parenthesis, and have no comma, we should
evaluate the type of the tertiary expression inside the
parenthesis. If we have a single comma, we have a pair. If we have
five commas, we have a transform.

7) In the other cases, we have an unknown expression and some error
may be occurred.

The code that tries to encompass these rules (but not in the above
order) is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_SYMBOLIC){ // Case 1
      struct variable *var = (struct variable *)
                               ((struct symbolic_token *) begin_expr) -> var;
      return var -> type;
    }
    if(begin_expr -> type == TYPE_TRUE || begin_expr -> type == TYPE_FALSE ||
       begin_expr -> type == TYPE_NOT) // Case 2
      return TYPE_T_BOOLEAN;
    if(begin_expr -> type == TYPE_NUMERIC ||
       begin_expr -> type == TYPE_NORMALDEVIATE) // Case 4
      return TYPE_T_NUMERIC;
    else
      return -1;
  }
  else{
    if(begin_expr -> type == TYPE_CYCLE || begin_expr -> type == TYPE_ODD ||
       begin_expr -> type == TYPE_NOT) // Case 2
      return TYPE_T_BOOLEAN;
    // Pair expression (case 3):
    if(begin_expr -> type == TYPE_POINT ||
       begin_expr -> type == TYPE_PRECONTROL ||
       begin_expr -> type == TYPE_POSTCONTROL)
      return TYPE_T_PAIR;    
    // Numeric expression (Case 4):
    if(begin_expr -> type == TYPE_LENGTH || begin_expr -> type == TYPE_XPART ||
       begin_expr -> type == TYPE_YPART || begin_expr -> type == TYPE_ANGLE ||
       begin_expr -> type == TYPE_XXPART || begin_expr -> type == TYPE_FLOOR ||
       begin_expr -> type == TYPE_XYPART || begin_expr -> type == TYPE_SIND ||
       begin_expr -> type == TYPE_YXPART || begin_expr -> type == TYPE_SQRT ||
       begin_expr -> type == TYPE_YYPART || begin_expr -> type == TYPE_LOG ||
       begin_expr -> type == TYPE_COSD ||   begin_expr -> type == TYPE_EXP ||
       begin_expr -> type == TYPE_UNIFORMDEVIATE) // Caso 4
      return TYPE_T_NUMERIC;
    // Case 5:
    if(begin_expr -> type == TYPE_SUM || begin_expr -> type == TYPE_SUBTRACT)
      return get_primary_expression_type(mf, cx, begin_expr -> next, end_expr);
    // Numeric token, it could be a numeric or pair expression:
    if(begin_expr -> type == TYPE_NUMERIC){
      struct generic_token *t = begin_expr;
      while(t != NULL && t != end_expr){
        if(t -> type == TYPE_OPEN_BRACKETS || t -> type == TYPE_PRECONTROL ||
           t -> type == TYPE_OPEN_PARENTHESIS || t -> type == TYPE_POINT ||
           t -> type == TYPE_POSTCONTROL)
          return TYPE_T_PAIR;
        t = t -> next;
      }
      return TYPE_T_NUMERIC;
    }
    
    // The remaining cases not encompassed by the more general rules 
    // are expressions that begins with parenthesis but do not end
    // with them: (1+1)[p1, p1] and also: normaldeviate[p1, p2]
    if((begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
        end_expr -> type != TYPE_CLOSE_PARENTHESIS) ||
       begin_expr -> type == TYPE_NORMALDEVIATE)
      return TYPE_T_PAIR;
    if(begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
       end_expr -> type == TYPE_CLOSE_PARENTHESIS &&
       begin_expr -> next != end_expr){
      DECLARE_NESTING_CONTROL();
      int number_of_commas = 0;
      struct generic_token *t = begin_expr -> next;
      while(t != NULL && t -> next != end_expr){
        COUNT_NESTING(t);
        if(IS_NOT_NESTED() && t -> type == TYPE_COMMA)
          number_of_commas ++;
        t = t -> next;
      }
      if(number_of_commas == 0)
        return get_tertiary_expression_type(mf, cx, begin_expr -> next, t);
      else if(number_of_commas == 1)
        return TYPE_T_PAIR;
      else if(number_of_commas == 5)
        return TYPE_T_TRANSFORM;
    }
    return -1;
  }
}
@
\fimcodigo

Now the secondary expressions. The rules that we will use are:

1) If we have a single token, we evaluate everything as a primary
expression.

2) If we have \monoespaco{and}, the expression is boolean.

3) If we have a transformer (\monoespaco{transformed}, \monoespaco{rotated},
\monoespaco{scaled}, \monoespaco{shifted}, \monoespaco{slanted},
\monoespaco{xscaled}, \monoespaco{yscaled}, \monoespaco{zscaled}), we ignore it
and all the tokens after it and re-evaluate the expression. In this case
we will have a transform or a pair.

4) In case of multiplications and divisions, the most important is the
operator more at the right. In the case of multiplication, if one of
the operands is a pair, then we have a pair expression. If both are
numeric, we have a numeric expression. In the case of division, the
left operand type is the operation type. A token \monoespaco{/} is a
division when it is not delimited by numeric tokens. If it is, then we
have a fraction, not a division operator. Except when one of the
tokens is already part of some fraction: in this case, we have a
division operator. Therefore, 1/3 is a fraction, not a division. But
1/3/1/3 is a single division that divide two fractions.

5) In the other cases, if we cannot identify the type, we try again
interpreting the entire expression as a primary expression.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  struct generic_token *last_fraction = NULL;
  struct generic_token *before_last_op = NULL, *prev_prev = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_AND)
        return TYPE_T_BOOLEAN;
      if(t -> type == TYPE_TRANSFORMED || t -> type == TYPE_ROTATED ||
         t -> type == TYPE_SCALED || t -> type == TYPE_SHIFTED ||
         t -> type == TYPE_SLANTED || t -> type == TYPE_XSCALED ||
         t -> type == TYPE_YSCALED || t -> type == TYPE_ZSCALED){
        if(prev == NULL)
          return -1;
        return get_secondary_expression_type(mf, cx, begin_expr, prev);
      }
      if(t -> type == TYPE_MULTIPLICATION || t -> type == TYPE_DIVISION){
        if(t -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
           t != end_expr &&
           ((struct generic_token *) t -> next) -> type != TYPE_NUMERIC &&
           last_fraction != prev_prev)
          last_fraction = t;
        else{
          last_op = t;
          before_last_op = prev;
        }
      }
    }
    prev_prev = prev;
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL){
    int s = get_primary_expression_type(mf, cx, last_op -> next, end_expr) +
            get_secondary_expression_type(mf, cx, begin_expr, before_last_op);
    if(s == 2 * TYPE_T_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(s == TYPE_T_NUMERIC + TYPE_T_PAIR)
      return TYPE_T_PAIR;
    else return -1;
  }
  else return get_primary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

Finally, the tertiary expressions. In this case, the rules are:

1) If we have a single token, evaluate its type as a primary expression.

2) If we have an \monoespaco{or} or a relation
(\monoespaco{<}, \monoespaco{<=}, \monoespaco{>}, \monoespaco{>=},
\monoespaco{=}, \monoespaco{<>}), then it is a boolean expression.
Technically, the relations are not tertiary expressions, but
quarternary ones. But we can deal with them here, as we are not
evaluating the expression value, where it is mandatory to follow
precedence rules.

3) If we have a pyhtagoric sum or subtraction,
(\monoespaco{++}, \monoespaco{+-+}), it is a numeric expression.

4) In the case of a sum or subtraction, the expression type is the
same that its operands type.

5) I other cases, we try again to check the type, but interpreting the
expression as a secondary expression.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_OR || t -> type == TYPE_LT ||
           t -> type == TYPE_GT || t -> type == TYPE_GEQ ||
           t -> type == TYPE_LEQ || t -> type == TYPE_ASSIGNMENT ||
           t -> type == TYPE_NEQ)
        return TYPE_T_BOOLEAN;
      if(t -> type == TYPE_PYTHAGOREAN_SUM ||
         t -> type == TYPE_PYTHAGOREAN_SUBTRACT)
        return TYPE_T_NUMERIC;
      if(IS_VALID_SUM_OR_SUB(prev, t) && t != end_expr)
        last_op = t;
    }
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL)
    return get_secondary_expression_type(mf, cx, last_op -> next, end_expr);
  else return get_secondary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

\secao{9. Compound Statements: Conditional Statement}

A conditional statement is a \monoespaco{if}, it ensures that some
piece of code will be evaluated only if some conditions are true. The
complete gramamr for these statements is:

\alinhaverbatim
<Conditional Block> -> if <Boolean Expression> :
                          <List of Statements>
                         <Alternatives>
                       fi
<Alternativas> -> <Empty> |
                  elseif <Boolean Expression>:
                    <List of Statements>
                  <Alternatives> |
                  else: <List of Statements>
\alinhanormal

We need to declare two new kinds of tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_ELSEIF,  // Symbolic token 'elseif'
TYPE_ELSE,    // Symbolic token 'else'
TYPE_COLON,   // Symbolic token ':'
@
\fimcodigo

Which should be associated with the following reserved words:

\iniciocodigo
@<List of Keywords@>+=
"elseif", "else", ":",
@
\fimcodigo

In Section 6, we introduced the first compound statement: the one that
begins with \monoespaco{begingroup} and ends
with \monoespaco{endgroup}. The conditional statement
using \monoespaco{if} is also a compound statement, which can contain
other inner statements.

Remember thar the code is first read in teh
function \monoespaco{eval\_list\_of\_statement}, which splits the
tokens using semicolons as delimiters and give each part to the
function \monoespaco{eval\_statement}. This second function evaluates
the given code, but it can also change the pointer that delimits the
last evaluated token, which is used to determine the next tokens to be
evaluated. It's in this function that our \monoespaco{if} will be
evaluated.

Like in the \monoespaco{begingroup} case, seen in Section 6, when we
find a \monoespaco{if} in the first position in the list of tokens to
be evalueated, we increase the nesting level and correct the position
of the end pointer, ensuring that the next tokens to be evaluated will
be the right ones. Here we do the same, but the logic to choose the
right pointer is more complex and involves evaluating boolean
expressions.

Given a \monoespaco{if}, we first evaluate the boolean expression next
to it. If true, the position for the pointer will be the colon after
the expression. Otherwise, we walk over the tokens trying to find
a \monoespaco{elseif}, \monoespaco{else} or \monoespaco{fi}. In the
first case, we treat like we did with the \monoespaco{if}, checking
and evaluating the boolean expression next to it to decide if we place
the pointer in its colon. In the second case, we place the pointer in
the colon next to \monoespaco{else}. And in the last case, we found
the end of the compound statement and no true boolean expression. We
place the pointer in the \monoespaco{fi}, and doing this, we skip all
the statements inside the \monoespaco{if}.

However, the code that we ignore and do not evaluate because it is
inside a block with a false boolean expression in a conditional
statement also need to be checked for some critical syntax errors. For
example, we could have tokens \monoespaco{endgroup}
or \monoespaco{endchar} inside a \monoespaco{if} that were not
preceded by a \monoespaco{begingroup} or \monoespaco{beginchar}. These
errors could indicate that the user wrote an
incorrect \monoespaco{if}, perhaps placing the \monoespaco{fi} in the
wrong place. Therefore, these errors should not be ignorated. While we
walk over the non-evaluated tokens in a \monoespaco{if}, we still
would run code to update the nesting level when we find tokens
like \monoespaco{begingroup}, \monoespaco{if}, \monoespaco{beginchar}
and their corresponding closing tokens.

The code that evaluates our \monoespaco{if} statement is:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_IF){
  struct generic_token *begin_bool, *end_bool;
  struct boolean_variable b;
  int current_nesting_level;
  // Beginning the nesting
  begin_nesting_level(mf, cx, begin_token_list);
  current_nesting_level = cx -> nesting_level;
  // Delimiting boolean expression
  begin_bool = ((struct generic_token *) begin_token_list) -> next;
  end_bool = begin_bool;
  while(end_bool != *end_token_list &&
        ((struct generic_token *) (end_bool -> next)) -> type != TYPE_COLON)
    end_bool = end_bool -> next;
  if(end_bool == *end_token_list){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Error delimiting boolean "
                    "condition.\n", mf -> file, end_bool -> line);
#endif
    return false;
  }
  // Evaluating boolean expression:
  if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
    return false;
  if(b.value == 1){ // True: Code inside this 'if' must be evaluated
    *end_token_list = end_bool -> next;
    return true;
  }
  else{ // False: We skip code in this 'if'
    struct generic_token *t = end_bool -> next;
    while(t -> next != NULL){
      if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
        // We found the 'fi' corresponding to this 'if'
        if(!end_nesting_level(mf, cx, t))
          return false;
        *end_token_list = t;
        return true;
      }
      else if(t -> type == TYPE_ELSE &&
              cx -> nesting_level == current_nesting_level){
        // We found the 'else' corresponding to this 'if'
        *end_token_list = t -> next;
        if(((struct generic_token *) *end_token_list) -> type != TYPE_COLON){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Expected ':' after "
                  "'else'.\n", mf -> file,
                  ((struct generic_token *) *end_token_list) -> line);
#endif
          return false;
        }
        return true;
      }
      else if(t -> type == TYPE_ELSEIF &&
              cx -> nesting_level == current_nesting_level){
        // We found the 'elseif' corresponding to our 'if'
        begin_bool = t -> next;
        end_bool = begin_bool;
        while(end_bool != *end_token_list &&
              ((struct generic_token *)
                (end_bool -> next)) -> type != TYPE_COLON)
          end_bool = end_bool -> next;
        if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
          return false;
        if(b.value == 1){ // True: Code in 'elseif' must be evaluated
          *end_token_list = end_bool -> next;
          return true;
        }
      }
      // Other tokens that change our nesting level:
      else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
              t -> type == TYPE_BEGINCHAR)
        begin_nesting_level(mf, cx, t);
      else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
              t -> type == TYPE_ENDCHAR)
        if(!end_nesting_level(mf, cx, t))
          return false;
      t = t -> next;
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'if' statement.\n", mf -> file,
          ((struct generic_token *) begin_token_list) -> line);
#endif  
  return false;
}
@
\fimcodigo

Find the correct code to be evaluated is the above code
responsability. If we find a \monoespaco{elseif} or \monoespaco{else}
in the beginning of a new statement, one of two things is happening:
we either are dealing with a syntax error, where these tokens do not
have a corresponding \monoespaco{if}, or we are inside
some \monoespaco{if} where we already evaluated the right conditional
code and found the other conditional expression with code that should
not be evaluated. In the second case, we should ignore the following
tokens until we find the \monoespaco{fi} corresponding to
our \monoespaco{ìf}:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_ELSEIF ||
        ((struct generic_token *) begin_token_list) -> type ==
        TYPE_ELSE){
  int current_nesting_level;
  struct generic_token *t;
  if(cx -> end_token_stack == NULL ||
     cx -> end_token_stack -> type != TYPE_FI){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Token 'elseif' or 'else' should "
          "have a corresponding 'if'.\n", mf -> file,
          ((struct generic_token *) begin_token_list) -> line);
#endif  
    return false;
  }
  current_nesting_level = cx -> nesting_level;
  t = begin_token_list;
  while(t != NULL){
    if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
      // We found the 'fi' corresponding to our 'if'
      if(!end_nesting_level(mf, cx, t))
        return false;
      *end_token_list = t;
      return true;
    }
    else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
            t -> type == TYPE_BEGINCHAR)
      begin_nesting_level(mf, cx, t);
    else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
            t -> type == TYPE_ENDCHAR)
      if(!end_nesting_level(mf, cx, t))
        return false;
    t = t -> next;
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'else' or 'elseif' statement.\n", mf -> file,
          ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

Finally, we also can find a \monoespaco{fi} in the beginning of a new
statement to be evaluated. In this case, we lower the nesting level
and mark as the end of our evaluated tokens this \monoespaco{fi}
token:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type == TYPE_FI){
  if(!end_nesting_level(mf, cx, begin_token_list))
    return false;
  *end_token_list = begin_token_list;
  return true;
}
@
\fimcodigo

\secao{10. The \monoespaco{pickup} Command}

Npw we can begin defining our first command. The syntax for
command \monoespaco{pickup} is:

\alinhaverbatim
<Command> -> <'pickup' Command>
<'pickup' Command> -> pickup <Pen Variable, 'nullpen' or 'pencircle'>
                             <Optional Transformers>
<Pen Variable or 'nullpen'> -> nullpen | pencircle | <Pen Variable>
<Optional Transformers> -> <Empty> |
                           <Transformer><Optional Transformers>
\alinhanormal

The command requires a new token and reserver keyword:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_PICKUP,  // Symbolic token 'pickup'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"pickup",
@
\fimcodigo

What this command does is store a new value in the
variable \monoespaco{currentpen}, which we will use to make drawings
(which we will define in the following Section).

\subsecao{10.1. Extremity Points in Pens}

When we pick a pen, we will store internally 4 values related to the
pen. Two of them will store the biggest and smallest values in the
axis $x$ when the pen is rendered and the two others will store the
smallest and biggest values in the axis $y$. Storing these values will
be useful to better adjust the points that we will draw. For example,
we could want to draw with our pen the nearest possible to the left
lower corner of the image, without the pen drawing outside the image
area. Such control requires to know the pen size. Because of this, we
will store globally such information
in \monoespaco{pen\_lft}, \monoespaco{pen\_rt}, \monoespaco{pen\_top}
e \monoespaco{pen\_bot}. We store globally in \monoespaco{struct
metafont} because \monoespaco{currentpen} has a global scope:

\iniciocodigo
@<Attributes (struct metafont)@>+=
float pen_lft, pen_rt, pen_top, pen_bot;
@
\fimcodigo

These values begin as zero, because \monoespaco{currentpen} begins as
a \monoespaco{nullpen}:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> pen_lft = mf -> pen_rt = mf -> pen_top = mf -> pen_bot = 0.0;
@
\fimcodigo

An operation very common in this Section will be update these 4
variables in a pen when we are preparing their points. Assume that we
will be able to iterate over the points in their perimeter. For each
point, we will check if it is at the left of \monoespaco{pen\_lft}, at
the right of \monoespaco{pen\_rt}, above \monoespaco{pen\_top} or
below \monoespaco{pen\_bot}. In these cases, we need to update the
information about the extremity points in the pen.

To reduce our code size, we will create the macro below that will
declare the temporary variables where we store the biggest and
smallest value in axis $x$ and $y$ that we found in a pen perimeter:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define DECLARE_PEN_EXTREMITIES() float _max_x = -INFINITY, _min_x = INFINITY,\
                                  _max_y = -INFINITY, _min_y = INFINITY;
@
\fimcodigo

Given a new perimeter point, we will use the macro below to get its
coordinate $(x, y)$, multiply by its transform matrix and check if we
found a point with the biggest or smallest value in axis $x$ or $y$:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define CHECK_PEN_EXTREMITIES(x, y, matrix) {\
   float _x, _y;\
   _x = LINEAR_TRANSFORM_X(x, y, matrix);\
   _y = LINEAR_TRANSFORM_Y(x, y, matrix);\
   if(_x < _min_x) _min_x = _x;\
   if(_x > _max_x) _max_x = _x;\
   if(_y < _min_y) _min_y = _y;\
   if(_y > _max_y) _max_y = _y;\
  }
// If the matrix is the identity, we can use this:
#define CHECK_PEN_EXTREMITIES_I(x, y) {\
   if(x < _min_x) _min_x = x;\
   if(x > _max_x) _max_x = x;\
   if(y < _min_y) _min_y = y;\
   if(y > _max_y) _max_y = y;\
  }

@
\fimcodigo

After checking all the points in the pen perimeter, we can update
which are its extremity coordinates:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define UPDATE_PEN_EXTREMITIES() {\
  mf -> pen_lft = _min_x;\
  mf -> pen_rt = _max_x;\
  mf -> pen_top = _max_y;\
  mf -> pen_bot = _min_y;\
}
@
\fimcodigo

The previous macros is enough if we will iterate over each point in
the pen perimeter. Doing this, we can
call \monoespaco{CHECK\_PEN\_EXTREMITIES} in all points and then we
get who has the biggest and smallest value in each axis. But in cases
when we will not iterate over each point, we will need more functions
to deduce their values. For example, if we are using
a \monoespaco{pickup} command over \monoespaco{pencircle} with a
linear transform stored in a matrix. The function below can be used to
get this pen extremity points:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix);
@
\fimcodigo

A default \monoespaco{pencircle}, with no linear transform is a
circular pen with radius $1/2$. Which means that every pen coordinate
$(x, y)$ follows the formula:

$$
x^2+y^2= 0.25
$$

Or, equivalently:

$$
x=\pm\sqrt{0.25-y^2}
$$

$$
y=\pm\sqrt{0.25-x^2}
$$

Given a linear transform defined by matrix $N$, we get new values
$(x,y)$ using th formulas:

$$
f_x(x) = M_{11}x \pm M_{21}\sqrt{0.25-x^2} + M_{31}
$$

$$
f_y(y) = M_{22}y \pm M_{12}\sqrt{0.25-y^2} + M_{32}
$$

When $M_{11}=0$, the most extreme points in axis $x$ will be $(-0.5,
0)$ and $(0.5, 0)$ after passing by the linear transform defined by
our matrix. When $M_{21}=0$, the most extreme points in axis $x$ will
be $(0, -0.5)$ and $(0, 0.5)$ after applying the linear transform. The
same logic applies for the axis $y$ if $M_{22}=0$ or $M_{12}=0$. In
all these cases, we get the biggest and smallest values maximizing or
minimizing a single coordinate.

For all other cases, finding the maximum and minimum values in these
functions requires getting the derivative of the function and
equalizing to zero:

$$
f_x'(x)=M_{11} \pm (M_{21}x)/(\sqrt{0.25-x^2})=0
$$

$$
f_y'(y)=M_{22} \pm (M_{12}y)/(\sqrt{0.25-y^2})=0
$$

As there is no closed formula to compute the soluction directly, we
need to employ an interactive method to find the solution. We will
first try the Newton Method. To use this method, we need to compute
the second order derivative for the functions:

$$
f_x''(x)= \pm (M_{21}\sqrt{0.25-x^2}+(M_{21}x^2)/(\sqrt{0.25-x^2}))
$$

$$
f_y''(y)= \pm (M_{12}\sqrt{0.25-x^2}+(M_{12}x^2)/(\sqrt{0.25-x^2}))
$$

And using these values, by the Newton method, if we have a good guess
$x_n$ or $y_n$ for the solution, we can find an even better guess
$x_{n+1}$ or $y_{n+1}$ computing:

$$
x_{n+1} = x_{n} - (f'_x(x_n)/f''_x(x_n))
$$

$$
y_{n+1} = y_{n} - (f'_y(y_n)/f''_y(y_n))
$$

The problem of Newton Method in this function is that it is defined
only in the interval between -0.5 and +0.5. If the value that we are
searching is near the extremity, it is possible that we step outside
the function Domain. If this happens, we will change to another
method. We will use the slowerBissection Method. For this method,
notice that $f'(-0.5)$ and $f'(+0.5)$ has opposite signals. The root
of this functions is in this interval. Next, we make the interval
slower computing $f'$ in the middle of the interval and checking the
signal. And we repeat until we find the value or the interval becames
too small.

After reviewing the theory, we finally can write the function that
gets the extremity points for \monoespaco{pencircle}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix){
  DECLARE_PEN_EXTREMITIES();
  int i, index[4] = {0, 3, 4, 1};
  for(i = 0; i < 2; i ++){ // i=0 computes axis x, i=1 computes axis y
    // Primeiro os casos mais simples:
    if((i == 0 && matrix[3] == 0.0) ||
       (i == 1 && matrix[4] == 0.0)){
      CHECK_PEN_EXTREMITIES(-0.5, 0.0, matrix);
      CHECK_PEN_EXTREMITIES(0.5, 0.0, matrix);
    }
    else if((i == 0 && matrix[0] == 0.0) ||
            (i == 1 && matrix[1] == 0.0)){
      CHECK_PEN_EXTREMITIES(0.0, 0.5, matrix);
      CHECK_PEN_EXTREMITIES(0.0, -0.5, matrix);
    }
    else{
      // Newton Method
      float x0 = INFINITY, x1 = 0.0;
      do{
        x0 = x1;
        x1 = x0 - ((matrix[index[2*i]]+(matrix[index[2*i+1]]*
                  x0/sqrt(0.25-x0*x0))) /
             (matrix[index[2*i+1]]*sqrt(0.25-x0*x0)+
                  ((matrix[index[2*i+1]]*x0*x0)/
             (sqrt(0.25-x0*x0)))));
        if(x1 <= -0.5 || x1 >= 0.5){
          // Failed, using Bissection Method
          float y1;
          x0 = -0.5;
          x1 = 0.5;
          y1 = matrix[3-i*2] * sqrt(0.25-x1*x1) +
               (matrix[index[3-i*2]]*x1/sqrt(0.25-x1*x1));
          while(x0 != x1){
            float x2 = (x0+x1)/2;
            float y2 = matrix[index[3-i*2]] * sqrt(0.25-x2*x2) +
                       (matrix[index[3-i*2]]*x2/sqrt(0.25-x2*x2));
            if(y2 == 0.0 || x0 == x2 || x1 == x2)
              x0 = x1 = x2;
            else if(y2 > 0){
              if(y1 > 0)
                x1 = x2;
              else
                x0 = x2;
            }
            else{
              if(y1 > 0)
                x0 = x2;
              else
                x1 = x2;
            } 
          }
        }
      } while(x0 != x1);
      if(i == 0){
        CHECK_PEN_EXTREMITIES(x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(x0, -sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, -sqrt(0.25-x0*x0), matrix);
      }
      else{
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), -x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), -x0, matrix);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo

We also could want to find the extremity points in a pen defined as a
list of Bézier Curves:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix);
@
\fimcodigo

Curiously, in this case, the formulas are simpler. A cubic Bézier
Curve like the ones that we use have the following formula, with $t$
ranging between 0 and 1 and with $z_1$, $z_4$ being the extremity
points and with $z_2$ and $z_3$ being the control points:

$$
z(t) = (1-t)^3z_1+3(1-t)^2tz_2+3(1-t)t^2z_3+t^3z_4
$$

The function derivative is:

$$
z'(t) = (-3z_1+9z_2-9z_3+3z_4)t^2+(6z_1-12z_2+6z_3)t+(-3z_1+3z_2)
$$

Discovering in which points we have a zero requires just using
Bhaskara formula.

Finding the extremity points will be done iterating over the extremity
points and computing the roots of $z'(t)$. If we find a root between 0
and 1, we check the value if it is an extremity point. The points
$z_1, z_2, z_3, z_4$ that we use are the stored ones in the pen, after
applying the linear transform of the corresponding matrix:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix){
  int i, j, length = p -> length;
  DECLARE_PEN_EXTREMITIES();
  for(i = 0; i < length; i ++){
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    CHECK_PEN_EXTREMITIES(p -> points[i].x, p -> points[i].y, matrix);
    x0 = LINEAR_TRANSFORM_X(p -> points[i].x, p -> points[i].y, matrix);
    y0 = LINEAR_TRANSFORM_Y(p -> points[i].x, p -> points[i].y, matrix);
    u_x = LINEAR_TRANSFORM_X(p -> points[i].u_x, p -> points[i].u_y, matrix);
    u_y = LINEAR_TRANSFORM_Y(p -> points[i].u_x, p -> points[i].u_y, matrix);
    v_x = LINEAR_TRANSFORM_X(p -> points[i].v_x, p -> points[i].v_y, matrix);
    v_y = LINEAR_TRANSFORM_Y(p -> points[i].v_x, p -> points[i].v_y, matrix);    
    x1 = LINEAR_TRANSFORM_X(p -> points[(i+1)%length].x, p -> points[i].y,
                            matrix);
    y1 = LINEAR_TRANSFORM_Y(p -> points[(i+1)%length].y, p -> points[i].y,
                            matrix);
    // Bhaskara Formula (axis x)
    float a, b, c, deltah, t;
    a = (-3*x0+9*u_x-9*v_x+3*x1);
    b = (6*x0-12*u_x+6*v_x);
    c = (-3*x0+3*u_x);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(deltah)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
    // Bhaskara Formula (axis y)
    a = (-3*y0+9*u_y-9*v_y+3*y1);
    b = (6*y0-12*u_y+6*v_y);
    c = (-3*y0+3*u_y);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(b * b - 4 * a * c)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo


\subsecao{10.2. Triangulation}

Now let's deal with the triangulation code. Video cards and OpenGL
works drawing triangles in the screen. Therefore, each pen should be
transformed in a set of triangles before drawing them. This was
mentioned in Subsection 7.5. about pen variables. But the code for
triangulation still needs to be defined.

To recap, these are the relevant variables stored inside
a \monoespaco{struct pen\_variable} that we will use during
triangulation:

* \monoespaco{struct path\_variable *format}: A cyclic path with the
  pen shape.

* \monoespaco{GLuint gl\_vbo}: References que vertices stored in the
  video card. Will store 0 if the pen was not triangulated.

* \monoespaco{float triang\_resolution}: An internal measure of the
 detail level in our triangulation. Relevant to know if we need to
 retriangulate to generate a more precise representation if our pen has
 curves and now will be rendered in a different size.


* \monoespaco{int flags}: Stores information if the above shape is
  null, is concave or convex, it is a polycon or a shape with curves,
  if it is a square or a circle. Besides these flags that were already
  presented,we will also define and use here two other flags:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define FLAG_ORIENTATION      32
#define FLAG_COUNTERCLOCKWISE 64
@
\fimcodigo

The second flag above will store if we are storing the shape of the
pen in the counterclockwise order (if the flag is set) or in the
clockwise order (if the flag is not set). But this information is
initialized and is reliable only if the first flag above is set.

We will use the following function to check the pen orientation:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen);
@
\fimcodigo

The function works checking if we already have the information stored
in the flag and returning it if so. Otherwise, it tries to discover
the orientation. This is done searching for the vertex with the
smallest $y$ coordinate (and biggest $x$ in case of tie) Let $A$ be
this vertex, $P$ the previous vertex and $N$ the next. The signal of
the scalar product between $AP$ and $AN$ inform the orientation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen){
  int i, index = 0;
  int size = pen -> format -> length;
  float smallest_y = INFINITY, biggest_x = -INFINITY;
  if(pen -> flags & FLAG_ORIENTATION)
    return (pen -> flags & FLAG_COUNTERCLOCKWISE);
  for(i = 0; i < size; i ++){
    if(pen -> format -> points[i].y < smallest_y ||
       (pen -> format -> points[i].y == smallest_y &&
        pen -> format -> points[i].y > biggest_x)){
      smallest_y = pen -> format -> points[i].y;
      biggest_x = pen -> format -> points[i].x;
      index = i;
    }
  }
  {
    int n = (index - 1) % size, p = (index + 1) % size;
    while(pen -> format -> points[index].x == pen -> format -> points[n].x &&
          pen -> format -> points[index].y == pen -> format -> points[n].y)
      n = (n + 1) % size;
    while(pen -> format -> points[index].x == pen -> format -> points[p].x &&
          pen -> format -> points[index].y == pen -> format -> points[p].y)
      p = (p - 1) % size;
    float ap_x = pen -> format -> points[p].x -
                 pen -> format -> points[index].x;
    float ap_y = pen -> format -> points[p].y -
                 pen -> format -> points[index].y;
    float an_x = pen -> format -> points[n].x -
                 pen -> format -> points[index].x;
    float an_y = pen -> format -> points[n].y -
                 pen -> format -> points[index].y;
    float prod = ap_x * an_x + ap_y * an_y;
    pen -> flags += FLAG_ORIENTATION;
    pen -> flags += FLAG_COUNTERCLOCKWISE * (prod > 0);
    return (prod > 0);
  }
}
@
\fimcodigo

The function that will perform the triangulation is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix){
  @<Triangulation: Null Pen@>
  @<Triangulation: Square Pen@>
  @<Triangulation: Convex Polygon@>
  @<Triangulation: Circle@>
  @<Triangulation: Convex Shape@>
  @<Triangulation: Concave Shape@>
}
@
\fimcodigo

The simplest case is when we have a null pen created
by \monoespaco{nullpen}. These pens never will draw anything, so they
do not need to be triangulated. They are considered points at the $(0,
0)$ coordinate, but a transform matrix can shift the point to some
other position. We deal with this simplest case below:

\iniciocodigo
@<Triangulation: Null Pen@>=
if((pen -> flags & FLAG_NULL)){
  pen -> indices = 0;
  DECLARE_PEN_EXTREMITIES();
  CHECK_PEN_EXTREMITIES(0, 0, transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

The next case is when we need to triangulate a square pen. This kind
of pen do not need to be triangulated because during initialization we
will create a single triangulation that will be used for all square
pen. The vertices will be stored here:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static GLuint pensquare_vbo;
@
\fimcodigo

The triangulation code thet will be run in the initialization:

\iniciocodigo
@<Weaver Metafont Initialization@>+=
{
  float square_vertices[8] = {-0.5, -0.5,
                               +0.5, -0.5,
                               +0.5, +0.5,
                               -0.5, +0.5};
  glGenBuffers(1, &pensquare_vbo);
  glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  glBufferData(GL_ARRAY_BUFFER, 8 * sizeof(float), square_vertices,
               GL_STATIC_DRAW);
}
@
\fimcodigo

And in the finalization we can remove the vertices:

\iniciocodigo
@<Finalização de Weaver Metafont@>+=
glDeleteBuffers(1, &pensquare_vbo);
@
\fimcodigo

So, when asked to triangulate a square pen, we do not need to
triangulate it. Nevertheless, we still need to compute the extremity
points:

\iniciocodigo
@<Triangulation: Square Pen@>=
if((pen -> flags & FLAG_SQUARE)){
  float square_vertices[8] = {-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5};
  pen -> indices = 4;
  DECLARE_PEN_EXTREMITIES();
  int i;
  for(i = 0; i < 4; i ++)
    CHECK_PEN_EXTREMITIES(square_vertices[2 * i], square_vertices[2 * i + 1],
                          transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

The next simplest case is when we have a convex polygon. For them, we
can use a very simple algorithm. We choose any vertex as the pivot and
perform a triangulation creating triangles that always use this vertex
and each other adjacent pair of vertices in our shape. It's the fan
triangulation:

\imagem{images/triangulacao_leque.eps}

To use this, we can just pass all the pen vertices in the same order
that they are stored and later, when drawing them, we will tell OpenGL to use
fan triangulation:

\iniciocodigo
@<Triangulation: Convex Polygon@>=
if((pen -> flags & FLAG_STRAIGHT) && (pen -> flags & FLAG_CONVEX)){
  int i, index, increment;
  DECLARE_PEN_EXTREMITIES();
  GLsizei size = sizeof(float) * 2 * pen -> format -> length;
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  if(is_pen_counterclockwise(pen)){
    index = 0;
    increment = 1;
  }
  else{
    index = pen -> format -> length - 1;
    increment = -1;
  }
  for(i = 0; i < pen -> format -> length; i ++){
    data[2 * i] = pen -> format -> points[index].x;
    data[2 * i + 1] = pen -> format -> points[index].y;
    CHECK_PEN_EXTREMITIES(data[2 * i], data[2 * i + 1], transform_matrix);
    index += increment;
  }
  if(pen -> gl_vbo == 0){
    glGenBuffers(1, &(pen -> gl_vbo));
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
    glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
    pen -> indices = pen -> format -> length;
  }
  if(temporary_free != NULL)
    temporary_free(data);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

Now let's deal with the next case for triangulation: circles. A
circular pen is created using expression \monoespaco{pencircle}. For
this kind of pen, we must generate its vertices during triangulation:
we will not use the stored vertices. But how many vertices should be
generated? If the circle have a single pixel as diameter, perhaps 4
vertices in the perimeter is enough, nobody would notice that this is
a square instead of a circle. But if the circle becames bigger, we
would need more vertices to correctly approximate its shape.

The number of required vertices is given by the circle circumference,
in pixels: we need $2\pi r$ vertices in the perimeter. The angle
between them is given by the formula $L=\theta r$ to compute the arc
length in the circle. If we want 1 pixel as arc, then, the angle
between them is $1/r$ in radians, where $r$ is the radius.

We will use the same fan triangulation as before. But we will use as
axis the center of the circle. Therefore, we will store $2\pi r +1$
vertices.

The radius will be approximated as half the biggest side of the square
where our circle is inscribed. We compute this after performing the
linear transformation in the square using the circle transform
matrix. Therefore, we will get a suitable upper bound for the radius,
considering that our circle could have been transformed in a ellipse
after the linear transformation.

This biggest side of the rectangle where our circle is inscribed after
the linear transformation is also how we compute the resolution of a
circle triangulation. If our circle is already triangulated and we
need to draw using a smaller circle, then we do not need to
triangulate it again. But if we need to draw a bigger circle, then we
need to triangulate, even if we already had a triangulation before.

The code to triangulate the circle is:

\iniciocodigo
@<Triangulation: Circle@>=
if((pen -> flags & FLAG_CIRCULAR)){
  float radius;
  // Get extremity points:
  pencircle_extremity_points(mf, transform_matrix);
  // Checking resolution (radius):
  {
    float side1, side2;
    side1 = abs(mf -> pen_rt - mf -> pen_lft);
    side2 = abs(mf -> pen_top - mf -> pen_bot);
    radius = ((side1 >= side2)?(side1):(side2))/ 2.0;
  }
  // Need to retriangulate only if radius is bigger than already triangulated:
  if(pen -> gl_vbo != 0){
    if(radius > pen -> triang_resolution)
      glDeleteBuffers(1, &(pen -> gl_vbo));
    else
      return true;
  }
  pen -> triang_resolution = radius;
  GLsizei size = sizeof(float) * 2 * (((int) (2 * M_PI * radius)) + 4);
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    int i;
    float angle = 0.0;
    data[0] = 0.0;
    data[1] = 0.0; // Circle center
    for(i = 2; i < (size / sizeof(float)); i ++){
      data[i] = 0.5 * sin(angle);
      i ++;
      data[i] = 0.5 * cos(angle);
      angle += 1/radius;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
  pen -> indices = (size / (2 * sizeof(float)));
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

Now we will deal with the last possible shape for a convex pen: when
the pen is not a polygon, it has curves. In this case, like in the
circle, we need to consider the size of our shape, including the
matrix transformation, to decide how many vertices we should use to
approximate correctly our curve. But this time, we need to do this
iterating over the extremity points and control points that form the
shape of our pen.

For each pair of extremity points $(A, D)$, with the control points
$(B, C)$, we will use the sum of the distances $AB$, $BC$ and $CD$ to
decide the number of vertices. This estimation should produce
reasonable values, except when our curve crosses itself. However, we
do not support pens with non-simple forms, therefore we should not
care about this unsupported case.

The sum of all the distances, when we iterate over the pen curves is
how we measure the pen triangulation resolution. If we are
triangulating an already triangulated pen and the resolution is lesser
or equal than the current triangulation, we do not need to triangulate
the pen again.

If the sum of the distances $AB+BC+CD$ is equal the distance $AD$,
then we have a straight line. In this case, we just need to consider
the vertices for the extremity points, not the intermediate points.

After deciding the number of vertices that should be generated, if we
need intermediate points between the extremities, then we can use the
following formula, where we change the $t$ value between 0 and 1 (with
values 0 and 1 corresponding to the extremity points):

$$
P(t) = (1-t)^3A + 3(1-t)^2tB + 3(1-t)t^2C + t^3D
$$

Naturally, we should walk over the points in the counterclockwise
orientation, which non necessarily is the stored orientation. When
measuring the distances, we should also consider the linear transform
stored in the transform matrix, but when generating the vertices we
should ignore the transform, as it will be performed by the video card
when rendering the pen.

The code to triangulate a pen in this case is:

\iniciocodigo
@<Triangulation: Convex Shape@>=
if((pen -> flags & FLAG_CONVEX)){
  bool counterclockwise = is_pen_counterclockwise(pen);
  int i, number_of_vertices = 1;
  // Get extremity points:
  path_extremity_points(mf, pen -> format, transform_matrix);
  for(i = 0; i < pen -> format -> length - 1; i ++){
    int distance = 0;
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    float dx, dy;
    x0 = LINEAR_TRANSFORM_X(pen -> format -> points[i].x,
                            pen -> format -> points[i].y, transform_matrix);
    y0 = LINEAR_TRANSFORM_Y(pen -> format -> points[i].x,
                            pen -> format -> points[i].y, transform_matrix);
    u_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].u_x,
                            pen -> format -> points[i].u_y, transform_matrix);
    u_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].u_x,
                            pen -> format -> points[i].u_y, transform_matrix);
    dx = u_x - x0;
    dy = u_y - y0;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    v_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].v_x,
                            pen -> format -> points[i].v_y, transform_matrix);
    v_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].v_x,
                            pen -> format -> points[i].v_y, transform_matrix);
    dx = v_x - u_x;
    dy = v_y - u_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    x1 = LINEAR_TRANSFORM_X(pen -> format -> points[i + 1].x,
                            pen -> format -> points[i + 1].y,
                            transform_matrix);
    y1 = LINEAR_TRANSFORM_Y(pen -> format -> points[i + 1].x,
                            pen -> format -> points[i + 1].y,
                            transform_matrix);
    dx = x1 - v_x;
    dy = y1 - v_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = x1 - x0;
    dy = y1 - y0;
    if(distance == (int) round(sqrt(dx * dx + dy * dy)))
      number_of_vertices ++; // Linha reta
    else
      number_of_vertices += distance;
  }
  if(pen -> gl_vbo != 0){
    if(number_of_vertices <= pen -> triang_resolution)
      return true; // No need to triangulate again
    else
      glDeleteBuffers(1, &(pen -> gl_vbo)); // Need to retriangulate
  }
  pen -> triang_resolution = number_of_vertices;
  float *data = (float *) temporary_alloc(number_of_vertices * 2 *
                                          sizeof(float));
    if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    struct path_points *p0, *p1;
    int v;
    if(counterclockwise)
      p0 = &(pen -> format -> points[0]);
    else
      p0 = &(pen -> format -> points[pen -> format -> length - 1]);
    data[0] = p0 -> x;
    data[1] = p0 -> y;
    v = 2;
    for(i = 0; i < pen -> format -> length - 1; i ++){
      float b_x, b_y, c_x, c_y, dx, dy, x0, y0, x1, x2, y1, y2;
      int distance = 0;
      if(counterclockwise){
        p1 = &(pen -> format -> points[1 + i]);
        b_x = p0 -> u_x;
        b_y = p0 -> u_y;
        c_x = p0 -> v_x;
        c_y = p0 -> v_y;
      }
      else{
        p1 = &(pen -> format -> points[pen -> format -> length - 2 - i]);
        b_x = p1 -> v_x;
        b_y = p1 -> v_y;
        c_x = p1 -> u_x;
        c_y = p1 -> u_y;
      }
      x0 = LINEAR_TRANSFORM_X(p0 -> x, p0 -> y, transform_matrix);
      y0 = LINEAR_TRANSFORM_Y(p0 -> x, p0 -> y, transform_matrix);
      x2 = LINEAR_TRANSFORM_X(b_x, b_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(b_x, b_y, transform_matrix);
      dx = x2 - x0;
      dy = y2 - y0;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(c_x, c_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(c_x, c_y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(p1 -> x, p1 -> y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(p1 -> x, p1 -> y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      dx = x2 - x0;
      dy = y2 - y0;
      if(distance == (int) round(sqrt(dx * dx + dy * dy))){
        data[v++] = p1 -> x;
        data[v++] = p1 -> y;
      }
      else{
        int j;
        float dt = 1.0 / ((float) distance);
        for(j = 1; j <= distance; j ++){
          float t = dt * j;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> x + 3*(1-t)*(1-t)*t * b_x +
                      3*(1-t)*t*t * c_x + t * t * t * p1 -> x;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> y + 3*(1-t)*(1-t)*t * b_y +
                      3*(1-t)*t*t * c_y + t * t * t * p1 -> y;
        }
      }
      p0 = p1;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, number_of_vertices * 2 *
                                sizeof(float), data, GL_STATIC_DRAW);
  pen -> indices = number_of_vertices;
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

For now, we will not support concave shapes, but this may change in
the future:

\iniciocodigo
@<Triangulation: Concave Shape@>=
if(!(pen -> flags & FLAG_CONVEX)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Concave pens still not supported.\n");
#endif
  return false;
}
return false;
@
\fimcodigo

\subsecao{10.3. Reading the 'pickup' Command}

Now we will define what will happen when we read
the \monoespaco{pickup} command.

1) First we read the next token. If it is a \monoespaco{nullpen}, we
transform \monoespaco{currentpen} in a null pen, and if it is
a \monoespaco{pencircle}, we transform in a circular pen. If it is a
pen variable, we set \monoespaco{currentpen} to point to that given
variable. In either case, we reset \monoespaco{currentpen} to an
identity matrix. IN the other cases, or if the variable is not
initialized, we return an error.

\iniciocodigo
@<Statement: Command@>=
else if(((struct generic_token *) begin_token_list) -> type == TYPE_PICKUP){
  struct generic_token *end_expression = *end_token_list;
  struct generic_token *next_token =
                           ((struct generic_token *) begin_token_list) -> next;
  if(begin_token_list == end_token_list ||
     (next_token -> type != TYPE_NULLPEN &&
      next_token -> type != TYPE_SYMBOLIC &&
      next_token -> type != TYPE_PENCIRCLE)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Expected 'nullpen' or pen "
                    "variable after 'pickup'. Not an arbitrary "
                    "expression.\n",
            mf -> file, next_token -> line);
#endif
    return false;
  }
  if(mf -> internal_pen_variables[0].gl_vbo != 0)
    glDeleteBuffers(1, &(mf -> internal_pen_variables[0].gl_vbo));
  if(next_token -> type == TYPE_NULLPEN){
    mf -> internal_pen_variables[0].flags = FLAG_NULL;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else if(next_token -> type == TYPE_PENCIRCLE){
    mf -> internal_pen_variables[0].flags = FLAG_CONVEX | FLAG_CIRCULAR;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else{
    struct pen_variable *var = ((struct symbolic_token *) next_token) -> var;
    if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-initialized variable after "
                      "after 'pickup' command.\n",
              mf -> file, next_token -> line);
#endif
      return false;
    }
    if(var -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable '%s' is not a "
                      "pen variable.\n",
              mf -> file, next_token -> line,
              ((struct symbolic_token *) next_token) -> value);
#endif
      return false;
    }
    mf -> internal_pen_variables[0].referenced = var;
  }
  INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[0].gl_matrix);
  @<'pickup' Command: Continue@>
  return true;
}
@
\fimcodigo

After gettting the pen basis form, now we read the linear transforms
specific to be applied to the \monoespaco{currentpen}. While we are
not in the end of the expression, we read the next token, which should
describe a linear transform
like \monoespaco{shifted}, \monoespaco{rotated} or something like
this. Based in the transform, we read and evaluate the following
tokens as a numeric, pair or transform expression. And finally perform
the given transform in the \monoespaco{currentpen} matrix. We keep
doing this until we find no more new transforms to be performed.

\iniciocodigo
@<'pickup' Command: Continue@>=
while(next_token != end_expression){
  struct generic_token *begin_subexpr, *end_subexpr;
  DECLARE_NESTING_CONTROL();
  next_token = next_token -> next;
  if(next_token == NULL || next_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                      "command format.\n",
              mf -> file, next_token -> line);
#endif
    return false;
  }
  begin_subexpr = next_token -> next;
  end_subexpr = begin_subexpr;
  while(end_subexpr != end_expression){
    struct generic_token *next = end_subexpr -> next;
    COUNT_NESTING(end_subexpr);
    if(IS_NOT_NESTED() &&
       (next -> type == TYPE_ROTATED || next -> type == TYPE_SCALED ||
        next -> type == TYPE_SHIFTED || next -> type == TYPE_SLANTED ||
        next -> type == TYPE_XSCALED || next -> type == TYPE_YSCALED ||
        next -> type == TYPE_ZSCALED || next -> type == TYPE_TRANSFORMED))
      break;
    end_subexpr = next;
  }
  switch(next_token -> type){
    struct numeric_variable a;
    struct pair_variable p;
    struct transform_variable t;
  case TYPE_ROTATED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_ROTATE(mf -> internal_pen_variables[0].gl_matrix, a.value);
    break;
  case TYPE_SCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_SHIFTED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SHIFT(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    break;
  case TYPE_SLANTED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SLANT(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Slant non-circular curved pens always require retriangulation:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT) &&
         !(v -> flags & FLAG_CIRCULAR)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_XSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_X(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_YSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_Y(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_ZSCALED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SCALE_Z(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_TRANSFORMED:
    if(!eval_transform_expression(mf, cx, begin_subexpr, end_subexpr, &t))
      return false;
    MATRIX_MULTIPLICATION(mf -> internal_pen_variables[0].gl_matrix, t.value);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  default:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                    "command format.\n",
            mf -> file, next_token -> line);
#endif
    return false;  
  }
  next_token = end_subexpr;
}
@
\fimcodigo

After getting the new current pen shape, if it is a pointer for an
existing pen or not, and its linear transform represented as a matrix,
we just need to triangulate the current pen if needed. For this, we
need to obtain the final transform matrix: if the current pen is a
pointer for another pen, then the final transform matrix is obtained
multiplicating the \monoespaco{currentpen} matrix by the pointed pen
matrix. Otherwise, the final transform matrix is just the current pen
matrix, After getting the final transform matrix, we just pass it to
the triangulation function:

\iniciocodigo
@<'pickup' Command: Continue@>+=
{
  float final_transform_matrix[9];
  if(mf -> internal_pen_variables[0].referenced == NULL){
    memcpy(final_transform_matrix, mf -> internal_pen_variables[0].gl_matrix,
           9 * sizeof(float));
    if(!triangulate_pen(mf, &(mf -> internal_pen_variables[0]),
                        final_transform_matrix))
      return false;
  }
  else{
    memcpy(final_transform_matrix,
           mf -> internal_pen_variables[0].referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(final_transform_matrix,
                          mf -> internal_pen_variables[0].gl_matrix);
    if(!triangulate_pen(mf, mf -> internal_pen_variables[0].referenced,
                        final_transform_matrix))
      return false;
  }
}
@
\fimcodigo

\subsecao{10.4. Operators \monoespaco{bot}, \monoespaco{top}, \monoespaco{lft},
\monoespaco{rt}}

We defined most pair operators in Subsection 8.2, but there are still
4 missing operators that we will define here. Their grammar is:

\alinhaverbatim
<Pair Primary> -> bot <Pair Primary> | top <Pair Primary> |
                  lft <Pair Primary> | rt <Pair Primary>
\alinhanormal

This requires 4 new tokens for such operators:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_BOT,  // Symbolic token 'bot'
TYPE_TOP,  // Symbolic token 'top'
TYPE_LFT,  // Symbolic token 'lft'
TYPE_RT,   // Symbolic token 'rt'
@
\fimcodigo

And we also need to add the token names to the list of reserved
keywords:

\iniciocodigo
@<List of Keywords@>+=
"bot", "top", "lft", "rt",
@
\fimcodigo

These operators shift a pair for a distance that depends on the
current pen size. If we have a point $(x_0, y_0)$,
then \monoespaco{bot (x0, y0)} represents $(x_0, y_0)$ shifted down,
such that it is now positioned below the pen when we center it in
point $(x_0, y_0)$. Assuming that the pen coordinates are centered on
the origin, then its lower points are negative in axis $y$. Therefore,
we can do it adding the initial point with the lowest $y$ value in the
pen:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin_expression -> type == TYPE_BOT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> y += mf -> pen_bot;
  return true;
}
@
\fimcodigo

The operator \monoespaco{top} shifts up a quantity equal to the
biggest coordinate $y$ in the current pen perimeter. This means that
\monoespaco{top (x0, y0)} will be positioned such that it will be above
the pen when the pen is placed in $(x_0, y_0)$:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin_expression -> type == TYPE_TOP){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> y += mf -> pen_top;
  return true;
}
@
\fimcodigo

The operator \monoespaco{lft} shifts left a quantity equal the
smallest coordinate $x$ in the current pen
perimeter. Therefore, \monoespaco{lft (x0, y0)} will be positioned at
left of the pen if the pen is centered in $(x_0, y_0)$. As in a pen
centered in the origin the leftmost points will have a negative $x$
coordinate, we just need to add to the $x$ coordinate of the point the
leftmost $x$ coordinate in the pen:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin_expression -> type == TYPE_LFT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> x += mf -> pen_lft;
  return true;
}
@
\fimcodigo

The last operator, \monoespaco{rt}, shifts right the pair $(x_0, y_0)$
a quantity equivalent to the rightmost coordinate in the pen
perimeter, such that the point coordinate will be placed at
right of the pen when centered in $(x_0, y_0)$:

\iniciocodigo
@<Pair Primary: Other Rules to Be Defined Later@>+=
else if(begin_expression -> type == TYPE_RT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> x += mf -> pen_rt;
  return true;
}
@
\fimcodigo


\secao{11. The \monoespaco{draw} and \monoespaco{erase} Command}

Finally we can begin specifying two of the most important command in
the language. The command that uses a pen to draw a path in a picture
and the command that erases a path in a picture. The command syntax
is:

\alinhaverbatim
<Command> -> <'draw' Command> | <'erase' Command> | ...
<'draw' Command> -> draw <Path Expression>
<'erase' Command> -> erase <Path Expression>
\alinhanormal

Which requires a new token type and a new reserved word:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
TYPE_DRAW,  // Symbolic token 'draw'
TYPE_ERASE, // Symbolic token 'erase'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"draw", "erase",
@
\fimcodigo


\subsecao{11.1. Preparing Framebuffer}

To draw or erase with a pen in the
picture \monoespaco{currentpicture}, we need a framebuffer associated
with this picture. This is not much different than when we define
several operations over picture variables. In several of them, we
created a new framebuffer, stored the previous framebuffer, changed to
the new framebuffer, rendered, erased the new framebuffer and changed
to the old one. But for the \monoespaco{currentpicture} framebuffer,
we will keep a single variable to store it:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static GLuint currentpicture_fb;
@
\fimcodigo

Which is initialized as zero:

\iniciocodigo
@<Weaver Metafont Initialization@>+=
currentpicture_fb = 0;
@
\fimcodigo

Before rendering to \monoespaco{currentpicture}, we should execute the
following code to check if the framebuffer is initialized and if not,
initializes it:

\iniciocodigo
@<Prepare 'currentpicture' for Drawing@>=
{
  if(currentpicture_fb == 0){
    int width, height;
    GLuint texture;
    width = mf ->
             internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].width;
    height = mf ->
            internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].height;
    texture = mf ->
           internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].texture;
    glGenFramebuffers(1, &currentpicture_fb);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
                 GL_UNSIGNED_BYTE, NULL);
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                           texture, 0);
  }
  else
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
}
@
\fimcodigo

If for some reason we change the contents
of \monoespaco{currentpicture}, we must remove the old framebuffer:

\iniciocodigo
@<Create new 'currentpicture'@>=
{
  if(currentpicture_fb != 0){
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glBindTexture(GL_TEXTURE_2D, 0);
    glDeleteFramebuffers(1, &currentpicture_fb);
  }
  currentpicture_fb = 0;
}
@
\fimcodigo

Before rendering to \monoespaco{currentpicture}, we do not store the
old framebuffer. And after the rendering, we do not restore the old
framebuffer. This is different than what de do when we render in other
picture variabes using picture operators. We do it this way because
rendering to \monoespaco{currentpicture} should be a much more common
operation. Because of this, we will try to keep as the current
framebuffer the framebuffer associated
with \monoespaco{currentpicture}.

But before beginning to evaluate code, we store the previous
framebuffer that the program was using before calling our code. It
will be stored in the variable below:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static GLint previous_fb;
@
\fimcodigo

And here is where we save the previous framebuffer before evaluating
the code in \monoespaco{eval\_list\_of\_expressions}:

\iniciocodigo
@<Before Evaluating Code@>=
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_fb);
@
\fimcodigo

And this restores the old framebuffer after code evaluation:

\iniciocodigo
@<After Evaluating Code@>=
glBindFramebuffer(GL_FRAMEBUFFER, previous_fb);
@
\fimcodigo

\subsecao{11.2. Drawing Shaders}

Drawing and erasing will require two new shaders (one for each
operation) that we will define. The previous shaders were defined to
perform operations between picture variables, and all them required a
texture. But for our pen, instead of a texture, we will need to pass a
drawing color. For now, the color will always be opaque black, but if
this changes in the future, our shader code will be ready.

Our vertex shader code is presented below:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char pen_vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "}\n";
@
\fimcodigo

It is identical the previous vertex shader, except by the fact that
this one does not receive nor try to extract values from a
texture. The two new fragment shader is:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static const char pen_erase_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, \n"
  "                      color.a);\n"
  "}\n";
static const char pen_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = color;"
  "}\n";
static GLuint pen_program, pen_erase_program; // The program after compilation
static GLint pen_uniform_matrix, pen_erase_uniform_matrix; // Matrix
static GLint pen_uniform_color, pen_erase_uniform_color; // Color
@
\fimcodigo

During initialization, we compile these shaders and get the uniform
locations:

\iniciocodigo
@<Weaver Metafont Initialization@>+=
{
  pen_program = compile_shader_program(pen_vertex_shader, pen_fragment_shader);
  pen_uniform_matrix = glGetUniformLocation(pen_program, "model_view_matrix");
  pen_uniform_color = glGetUniformLocation(pen_program, "color");
  pen_erase_program = compile_shader_program(pen_vertex_shader,
                                            pen_erase_fragment_shader);
  pen_erase_uniform_matrix = glGetUniformLocation(pen_erase_program,
                                                  "model_view_matrix");
  pen_erase_uniform_color = glGetUniformLocation(pen_erase_program, "color");
}
@
\fimcodigo

And in the finalization we destroy these programs:

\iniciocodigo
@<Weaver Metafont Finalization@>+=
glDeleteProgram(pen_program);
glDeleteProgram(pen_erase_program);
@
\fimcodigo

\subsecao{11.3. Drawing Paths}

After finishing preparing the triangulation, the framebuffer and
shaders, we finally can write the drawing code.

\iniciocodigo
@<Statement: Command@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_DRAW || ((struct generic_token *) begin_token_list) -> type ==
        TYPE_ERASE){
  int i, j;
  struct path_variable path;
  float transform_matrix[9];
  // Part 1: Initialization
  bool erasing = (((struct generic_token *) begin_token_list) -> type ==
    TYPE_ERASE);
  struct pen_variable *currentpen = &(mf -> internal_pen_variables[0]);
  struct picture_variable *currentpicture =
                                        &(mf -> internal_picture_variables[0]);
  // Part 2: Evaluating path expression
  if(!eval_path_expression(mf, cx,
                          ((struct generic_token *) begin_token_list) -> next,
                          (struct generic_token *) *end_token_list,
                           &path))
    return false;
  // Part 3: Preparing the pen, destiny picture and OpenGL parameters
  if(currentpen -> referenced != NULL){
    memcpy(transform_matrix, currentpen -> referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(transform_matrix, currentpen -> gl_matrix);
    currentpen = currentpen -> referenced;
  }
  else
    memcpy(transform_matrix, currentpen -> gl_matrix, 9 * sizeof(float));
  @<Prepare 'currentpicture' for Drawing@>
  if(erasing){
    glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  }
  else{
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  }
  // Part 4: Drawing loop
  for(i = 0; i < path.length - 1; i ++){
    int distance = 0;
    float dx, dy, dt;
    dx = path.points[i].u_x - path.points[i].x;
    dy = path.points[i].u_y - path.points[i].y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = path.points[i].v_x - path.points[i].u_x;
    dy = path.points[i].v_y - path.points[i].u_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = path.points[(i+1) % (path.length)].x - path.points[i].v_x;
    dy = path.points[(i+1) % (path.length)].y - path.points[i].v_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dt = 1 / ((float) distance);
    for(j = 0; j <= distance; j ++){
      float t = dt * j;
      float x = (1-t)*(1-t)*(1-t) * path.points[i].x +
                3*(1-t)*(1-t)*t * path.points[i].u_x +
                3*(1-t)*t*t * path.points[i].v_x +
                t*t*t * path.points[(i + 1) % (path.length)].x;
      float y = (1-t)*(1-t)*(1-t) * path.points[i].y +
                3*(1-t)*(1-t)*t * path.points[i].u_y +
                3*(1-t)*t*t * path.points[i].v_y +
                t*t*t * path.points[(i + 1) % (path.length)].y;
      drawpoint(mf, currentpen, currentpicture, x, y, transform_matrix,
                erasing);
    }
  }
  // When it is a single point and the loop above was not executed:
  if(path.length == 1)
    drawpoint(mf, currentpen, currentpicture, path.points[0].x,
              path.points[0].y, transform_matrix, erasing);
  // Part 5: Finalization
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &path, false);
  return true;
}
@
\fimcodigo

The above code in part 1 get the relevant variables for the command
(\monoespaco{currentpen}, \monoespaco{currentpicture}) and in part 2
evaluates the path expression to be drawn.

Then, in part 3, we get the correct pen that we shpuld use,
triangulate it and we initialize OpenGL parameters for this kind of
draw, some of them we defined in previous Subsections. One of the two
single places where we differentiate between
commands \monoespaco{draw} and \monoespaco{erase} appears
here. Depending on the command, we change the OpenGL blending
function. The blending follows the same logic than we used when adding
and subtracting images.

In part 4 we have the drawing loop, where the path is drawn, point by
point using the function \monoespaco{drawpoint} that we still did not
define. To get each individual point, we use the Bezier curve formula
$z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4$. And to
know how many intermediate points we should draw between two extremity
points, we add the distance between all four points that compose the
curve: the two extremity points and two control points. After the
drawing, we deallocate the temporary path variable that stored our
drawned curve in part 5.

Now we just need to define \monoespaco{drawpoint}. Its header is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing);
@
\fimcodigo

The pen knows all the coordinates of its triangulated vertices, and
stores them in pixels. The picture stores its own width and height in
pixels. But to render using OpenGL, we should convert this to OpenGL
coordinates, where the destiny texture will always have width and
height equal 2. This means that we need to create a new matrix to
perform this last linear transformation.

Let $h$ be the picture height in pixels and $w$ its width. This means
that 1 horizontal pixel is $2/w$ and 1 vertical pixel is $2/h$. Then,
we just need to multiply the transform matrix stored in the pen by a
diagonal matrix with $2/w$ and $2/h$ as the two first elements in the
diagonal (the other diagonals will be 1).

Next, after performing the conversion for OpenGL coordinates, we
should not use pixels anymore. But we need to shif each vertex by $(x,
y)$, the coordinate passed as argument for the \monoespaco{drawpoint}
function. Their values are $2x/w$ and $2y/h$ in OpenGL
coordinates. But we also need another shifting to make a correction
because we store the coordinates assuming that the origin is the lower
left corner of the image, while OpenGL assumes that the origin is the
center of the image.

However, in fact, we have another detail: it is not entirely true that
we always assume that our origin is the left lower corner of the
image. We could also assume that this origin is shifted vertically
using an internal value $d$ stored here:

\iniciocodigo
@<Attributes (struct metafont)@>+=
int current_depth;
@
\fimcodigo

Its initial value is zero:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> current_depth = 0;
@
\fimcodigo

This value $d$ stores in pixels how much our axis $x$ is shifted
vertically. Therefore, in OpenGL coordinates, we should convert it to
$2d/h$. If it is zero, then the origin indeed will be the lower left
corner of the picture before converting to OpenGL origin. Otherwise,
we shift the origin according with $d$ value.

The multiplication that converts the pen transform matrix to OpenGL
coordinates is given below:

$$
\left[{{a \atop c}\atop
      {0\atop e}}{{b \atop d}\atop {0 \atop
      f}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{2/w \atop 0}\atop
      {0\atop 2x/w-1}}{{0 \atop 2/h}\atop {0 \atop
      2d/h+2y/w-1}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=
\left[{{2a/w \atop 2c/w}\atop
      {0\atop (2e+2x)/w-1}}{{2b/h \atop 2d/h}\atop {0 \atop
      (2f+2d+2y)/h-1}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
$$


All this is done by the function \monoespaco{drawpoint} before
drawing. After getting the correct matrix, we can render the result,
using different shader programs if we are drawing or erasing:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing){
  float gl_matrix[9];
  gl_matrix[0] = (2 * matrix[0]) /  pic -> width;  // 2a/w
  gl_matrix[1] = (2 * matrix[1]) /  pic -> height; // 2b/h
  gl_matrix[2] = 0.0;
  gl_matrix[3] = (2 * matrix[3]) /  pic -> width;  // 2c/w
  gl_matrix[4] = (2 * matrix[4]) /  pic -> height; // 2d/h
  gl_matrix[5] = 0.0;
  gl_matrix[6] = 2 * (matrix[6] + x) /  pic -> width - 1.0;
  gl_matrix[7] = 2 * (matrix[7] + mf -> current_depth + y) / pic -> width -
                 1.0;
  gl_matrix[8] = 1.0;
  glViewport(0, 0, pic -> width, pic -> height);
  // Se a caneta for quadrada, usamos a triangulação padrão de quadrado.
  // Se não for, usamos a triangulação da própria caneta.
  if(pen -> flags & FLAG_SQUARE)
    glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  else 
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, (void *) 0);
  if(erasing){
    glUseProgram(pen_erase_program);
    glUniformMatrix3fv(pen_erase_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_erase_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  else{
    glUseProgram(pen_program);
    glUniformMatrix3fv(pen_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  glEnableVertexAttribArray(0);
  glDrawArrays(GL_TRIANGLE_FAN, 0, pen -> indices);
}
@
\fimcodigo

\secao{12. Compound Statement: Character Definition}

Now we are in the part that is the main objective of the language:
defining new characters for typographical fonts, or defining a new
image to be used as static illustration or an animation.

The syntax for this is:

\alinhaverbatim
<Compound> -> <Character Definition>
<Character Definition> -> beginchar ( <String Token> ,
                                      <Numeric Expression> ,
                                      <Numeric Expresison> ,
                                      <Numeric Expression> )
                           <'beginchar' Body>
                           endchar
<'beginchar' Body> -> <Statement, except 'beginchar'>
<Statement, except 'beginchar'> -> <Simple> | <Compound, except 'beginchar'>
<Compound, except 'beginchar'> -> <Compound Block> | <Conditional>
\alinhanormal

The token \monoespaco{beginchar} begins a new character definition
and \monoespaco{endchar} ends the definition. The string token is the
character name. For typographical fonts, it must be the UTF-8
character that it is being represented. For animations and
illustrations, the value will be ignored and can be any string. The
numeric values after the string are teh character width, height and
depth. The depth is its height below the baseline, for characters like
``p'' or ``q'', with parts extending below the line.

The language WEAVEFONT has two modes of operation: it can be loading
or running. The mode changes how we deal with the code in
a \monoespaco{beginchar} statement. If loading, the code inside
the \monoespaco{beginchar} body will not be interpreted and
executed. Instead, this code will be stored in an adequate place to be
interpreted later, when we need to render the character. When running,
then the language will interpret and execute the code because we need
to render such character.

We store the operation mode in the following variable:

\iniciocodigo
@<Attributes (struct metafont)@>+=
bool loading;
@
\fimcodigo

During initialization, we begin in loading mode:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> loading = true;
@
\fimcodigo

We finish the loading mode and begin the running mode when we arrive
at the end of the program source, when interpreting a \monoespaco{end}
or \monoespaco{dump} token:

\iniciocodigo
@<End of Code: 'end' or 'dump'@>=
mf -> loading = false;
@
\fimcodigo

But where should we store the code for each character when in the
loading mode? For this, we will define the following structure that
will hold information about a single glyph or image. It will store the
code, the glyph dimensions, the OpenGL texture and an extra variable
that says if we need to render the glyph, or we could just use the
already rendered texture:

\iniciocodigo
@<General Declarations (metafont.h)@>=
struct _glyph;
@
\fimcodigo

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct _glyph{
  struct generic_token *begin, *end;
  int width, height, depth;
  GLuint texture;
  bool need_rendering;
};
#define INITIALIZE_GLYPH(a) {a.begin = NULL; \
                            a.end = NULL; \
                            a.width = 0; \
                            a.height = 0;\
                            a.depth = 0; \
                            a.texture = 0; \
                            a.need_rendering = true; \
                            }

@
\fimcodigo

The list of all glyphs and a pointer to the first defined glyph will
be stored here:

\iniciocodigo
@<Attributes (struct metafont)@>+=
struct _glyph *glyphs[332];
struct _glyph *first_glyph;
int number_of_glyphs;
@
\fimcodigo

The number 332 is enough to store all existing 327 Unicode blocks plus
some other regions that currently are not in use, but could still be
standardized in future years. Each block can store between 1 and
thousands of different glyphs, typically, belonging to the same
writting system. Initially all these blocks will be initialized as
empty, but when we find new character definitions for glyphs belonging
to them, we will need to allocate them:

\iniciocodigo
@<Initialization (struct metafont)@>+=
memset(mf -> glyphs, 0, sizeof(struct _glyph *) * 332);
mf -> first_glyph = NULL;
mf -> number_of_glyphs = 0;
@
\fimcodigo

The function that allocates and returns the struct of a new or an
existing glyph is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *utf8,
                                bool create_if_not_exist);
@
\fimcodigo

The function first converts the UTF-8 representation to UTF-32, making
the value identical to the Unicode code point. After this, we check a
table where we store the biggest value stored in each block
sequentially. We use the table to check which block doest the glyph
belong, its position inside the block and the block size. If the block
does not exist and the last parameter is true, we allocate the
block. In the end, we return the glyph associated with the UTF-8
character (the glyph can be unitialized). Or NULL if it was not
possible to get glyph (the block does not exist and we asked to not
allocate it, the UTF-8 code is invalid, the Unicode point does not
exist or is not supported or we had no memory enough to allocate the
block).


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
static const uint32_t greatest_point[332] = {
  // Basic Multilingual Plane  (164 blocks)
0x7f, 0xff, 0x17f, 0x24f, 0x2af, 0x2ff, 0x36f, 0x3ff, 0x4ff, 0x52f,
0x58f, 0x5ff, 0x6ff, 0x74f, 0x7ff, 0x7bf, 0x7ff, 0x83f, 0x85f, 0x86f,
0x89f, 0x8ff, 0x97f, 0x9ff, 0xa7f, 0xaff, 0xb7f, 0xbff, 0xc7f, 0xcff,
0xd7f, 0xdff, 0xe7f, 0xeff, 0xfff, 0x109f, 0x10ff, 0x11ff, 0x137f, 0x139f,
0x13ff, 0x167f, 0x169f, 0x16ff, 0x171f, 0x173f, 0x175f, 0x177f, 0x17ff, 0x18af,
0x18ff, 0x194f, 0x197f, 0x19df, 0x19ff, 0x1a1f, 0x1aaf, 0x1aff, 0x1b7f, 0x1bbf,
0x1bff, 0x1c4f, 0x1c7f, 0x1c8f, 0x1cbf, 0x1ccf, 0x1cff, 0x1d7f, 0x1dbf, 0x1dff,
0x1eff, 0x1fff, 0x206f, 0x209f, 0x20cf, 0x20ff, 0x214f, 0x218f, 0x21ff, 0x22ff,
0x23ff, 0x243f, 0x245f, 0x24ff, 0x257f, 0x259f, 0x25ff, 0x26ff, 0x27bf, 0x27ef,
0x27ff, 0x28ff, 0x297f, 0x29ff, 0x2aff, 0x2bff, 0x2c5f, 0x2c7f, 0x2cff, 0x2d2f,
0x2d7f, 0x2ddf, 0x2dff, 0x2eff, 0x2fdf, 0x2fff, 0x303f, 0x309f, 0x30ff, 0x312f,
0x318f, 0x319f, 0x31bf, 0x31ef, 0x31ff, 0x32ff, 0x33ff, 0x4dbf, 0x4dff, 0x9fff,
0xa48f, 0xa4cf, 0xa4ff, 0xa63f, 0xa69f, 0xa69f, 0xa6ff, 0xa71f, 0xa7ff, 0xa82f,
0xa83f, 0xa87f, 0xa8df, 0xa8ff, 0xa92f, 0xa95f, 0xa97f, 0xa9df, 0xa9ff, 0xaa5f,
0xaa7f, 0xaadf, 0xaaff, 0xab2f, 0xab6f, 0xabbf, 0xabff, 0xd7af, 0xd7ff, 0xdb7f,
0xdbff, 0xdfff, 0xf8ff, 0xfaff, 0xfb4f, 0xfdff, 0xfe0f, 0xfe1f, 0xfe2f, 0xfe4f,
0xfe6f, 0xfeff, 0xffef, 0xffff,
  // Supplementary Multilingual Plane (151 blocks)
0x1007f, 0x100ff, 0x1013f, 0x1018f, 0x101cf, 0x101ff, 0x1029f, 0x102df,
0x102ff, 0x1032f, 0x1034f, 0x1037f, 0x1039f, 0x103df, 0x1044f, 0x1047f,
0x104af, 0x104ff, 0x1052f, 0x1056f, 0x105bf, 0x1077f, 0x107bf, 0x1083f,
0x1085f, 0x1087f, 0x108af, 0x108ff, 0x1091f, 0x1093f, 0x1099f, 0x109ff,
0x10a5f, 0x10a7f, 0x10a9f, 0x10aff, 0x10b3f, 0x10b5f, 0x10b7f, 0x10baf,
0x10c4f, 0x10cff, 0x10d3f, 0x10e7f, 0x10ebf, 0x10eff, 0x10f2f, 0x10f6f,
0x10faf, 0x10fdf, 0x10fff, 0x1107f, 0x110cf, 0x110ff, 0x1114f, 0x1117f,
0x111df, 0x111ff, 0x1124f, 0x112af, 0x112ff, 0x1137f, 0x1147f, 0x114df,
0x115ff, 0x1166f, 0x1167f, 0x116cf, 0x1174f, 0x1184f, 0x118ff, 0x1195f,
0x119ff, 0x11a4f, 0x11aaf, 0x11abf, 0x11aff, 0x11b5f, 0x11c6f, 0x11cbf,
0x11d5f, 0x11daf, 0x11eff, 0x11f5f, 0x11fbf, 0x11fff, 0x123ff, 0x1247f,
0x1254f, 0x12fff, 0x1342f, 0x1345f, 0x1467f, 0x16a3f, 0x16a6f, 0x16acf,
0x16aff, 0x16b8f, 0x16e9f, 0x16f9f, 0x16fff, 0x187ff, 0x18aff, 0x18cff,
0x18d7f, 0x1afff, 0x1b0ff, 0x1b12f, 0x1b16f, 0x1b2ff, 0x1bc9f, 0x1bcaf,
0x1cfcf, 0x1d0ff, 0x1d1ff, 0x1d24f, 0x1d2df, 0x1d2ff, 0x1d35f, 0x1d37f,
0x1d7ff, 0x1daaf, 0x1dfff, 0x1e02f, 0x1e08f, 0x1e14f, 0x1e2bf, 0x1e2ff,
0x1e4ff, 0x1e7ff, 0x1e8df, 0x1e95f, 0x1ecbf, 0x1ed4f, 0x1eeff, 0x1f02f,
0x1f09f, 0x1f0ff, 0x1f1ff, 0x1f2ff, 0x1f5ff, 0x1f64f, 0x1f67f, 0x1f6ff,
0x1f77f, 0x1f7ff, 0x1f8ff, 0x1f9ff, 0x1fa6f, 0x1faff, 0x1fbff,
  // Unused
  0x1ffff,
  // Supplementary Ideographic Plane
  0x2a6df, 0x2b73f, 0x2b81f, 0x2ceaf, 0x2ebef, 0x2fa1f,
  // Unused
  0x2ffff,
  // Tertiary Ideographic Plane
  0x3134f, 0x323af,
  // Unused
  0xdffff,
  // Supplementary Special-purpose Plane (unused middle region)
  0xe007f, 0xe00ff, 0xe01ef,
  // Unused
  0xeffff,
  // Supplementary Private Use Area-A
  0xfffff,
  // Supplementary Private Use Area-B
  0x10ffff
};
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *c,
                                bool create_if_not_exist){
  uint32_t code_point;
  int block, block_size, index;
  // UTF-8 -> UTF-32
  if(c[0] < 128)
    code_point = c[0];
  else if(c[0] >= 192 && c[0] <= 223 && c[1] >= 128 && c[1] <= 159){
    code_point = c[1] - 128;
    code_point += (c[0] - 192) * 64;
  }
  else if(c[0] >= 224 && c[0] <= 239 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159){
    code_point = c[2] - 128;
    code_point += (c[1] - 128) * 64;
    code_point += (c[0] - 224) * 4096;
  }
  else if(c[0] >= 240 && c[0] <= 247 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159 && c[3] >= 128 && c[3] <= 159){
    code_point = c[3] - 128;
    code_point += (c[2] - 128) * 64;
    code_point += (c[1] - 128) * 4096;
    code_point += (c[0] - 240) * 262144;
  }
  else return NULL; // Invalid  UTF-8 string
  if(code_point > greatest_point[331])
    return NULL; // Unicode point not existent or not supported
  for(block = 0; code_point > greatest_point[block]; block ++);
  if(block == 0){
    block_size = greatest_point[block] + 1;
    index = code_point;
  }
  else{
    block_size = greatest_point[block] - greatest_point[block - 1];
    index = code_point - greatest_point[block - 1] - 1;
  }
  if(mf -> glyphs[block] == NULL){
    int i;
    if(!create_if_not_exist)
      return NULL;
    mf -> glyphs[block] = permanent_alloc(sizeof(struct _glyph) * block_size);
    if(mf -> glyphs[block] == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s: No memory to allocate "
                      "Unicode block.\n", mf -> file);
#endif
      return NULL;
    }
    for(i = 0; i < block_size; i ++)
      INITIALIZE_GLYPH(mf -> glyphs[block][i]);
  }
  return &(mf -> glyphs[block][index]);
}
@
\fimcodigo

When the language finds a \monoespaco{beginchar} token while in the
loading mode, it will read the next string token and interpret it as a
UTF-8 code. Based on tis value, the above function is executed to
return the correct glyph and allocate it if necessary. If a glyph for
that charactere already is fully initialized, an error will be raised:
this would mean that the same glyph was defined twice. Otherwise, all
the code between \monoespaco{beginchar} and \monoespaco{endchar} will
be stored in the glyph and this will turn the glyph in a fully
initialized one (but not a renderized one). The string token used to
identify the glyph will also be update to point to the newly created
glyph using its internal variables. An error also should be raised if
we find another \monoespaco{beginchar} inside the
initial \monoespaco{beginchar}:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINCHAR && mf -> loading){
  DECLARE_NESTING_CONTROL();
  struct _glyph *glyph;
  struct generic_token *t = ((struct generic_token *) begin_token_list) -> next;
  if(t -> type != TYPE_OPEN_PARENTHESIS || begin_token_list == *end_token_list){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing '(' "
                    "after 'beginchar'.\n", mf -> file,
                    ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(t != *end_token_list)
    t = t -> next;
  if(t -> type != TYPE_STRING){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing UTF-8 string "
                    "after 'beginchar('.\n", mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  {
    struct string_token *str = (struct string_token *) t;
    glyph = get_glyph(mf, (unsigned char *) str -> value, true);
    if(glyph == NULL)
      return false;
    if(mf -> first_glyph == NULL)
      mf -> first_glyph = glyph;
    if(glyph -> begin != NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Glyph \"%s\" is defined "
                      "twice.\n", mf -> file,
              ((struct generic_token *) begin_token_list) -> line,
              str -> value);
#endif
      return false;
    }
    glyph -> begin = begin_token_list;
    str -> glyph = glyph;
  }
  {
    int number_of_commas = 0;
    struct generic_token *prev = t;
    while(t != NULL && t != *end_token_list){
      COUNT_NESTING(t);
      if(IS_NOT_NESTED()){
        if(t -> type == TYPE_COMMA && prev -> type != TYPE_COMMA)
          number_of_commas ++;
      }
      prev = t;
      t = t -> next;
      if(IS_NOT_NESTED() && t -> type == TYPE_CLOSE_PARENTHESIS)
        break;
    }
    if(t == NULL || number_of_commas != 3 ||
       t -> type != TYPE_CLOSE_PARENTHESIS){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Malformed 'beginchar' "
                      "compound command.\n", mf -> file,
              ((struct generic_token *) begin_token_list) -> line);
#endif
      return false;
    }
    t = t -> next;
    while(t != NULL && t -> type != TYPE_ENDCHAR){
      if(t -> type == TYPE_BEGINCHAR){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Nested 'beginchar'.\n",
                mf -> file, t -> line);
#endif
        return false;
      }
      t = t -> next;
    }
    if(t == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'endchar' "
                      "after'beginchar' command.\n", mf -> file,
              ((struct generic_token *) begin_token_list) -> line);
#endif
      return false;
    }
    glyph -> end = t;
    *end_token_list = t;
  }
  mf -> number_of_glyphs ++;
  return true;
}
@
\fimcodigo

If we are in loading mode, and we read a \monoespaco{endchar} token,
this is always an error: it means that we have an \monoespaco{endchar}
without a previous \monoespaco{beginchar}. Tokens that end character
definition are treated in the same loop than \monoespaco{beginchar}
when in loading mode:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_ENDCHAR && mf -> loading){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Found 'endchar' token "
                  "without previous 'beginchar'.\n", mf -> file,
          ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

After, when not in loading mode, we will read all this code
between \monoespaco{beginchar} and \monoespaco{endchar} again. And it
will be important to know and memorize which glyph we are
rendering. So we will create a variable to store this information in
the context struct:

\iniciocodigo
@<Attributes (struct context)@>+=
struct _glyph *current_glyph;
@
\fimcodigo

Finally, let's write code to handle \monoespaco{beginchar} when in
running mode. First we read the string token in the statement. As we
already executed this code in the loading mode, this string token
points to some corresponding glyph, which was already allocated and
initialized. We just need to render it.

The next step will be getting the numeric values in
the \monoespaco{beginchar} header, where we get information about the
width, height and depth and use these values to
reinitialize \monoespaco{currentpicture}. We will use the read values
multiplied by 2, rendering the glyph with twice the size that we will
use in the screen. This way, we get more precise results, rendering in
the screen each pixel as a result multisampled from 4 other
pixels. But we will not use this technique if the
macro \monoespaco{W\_WEAVEFONT\_DISABLE\_MULTISAMPLE} is
defined. Finally, the current pen is modified to be equal
a \monoespaco{nullpen}.

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINCHAR){
  DECLARE_NESTING_CONTROL();
  begin_nesting_level(mf, cx, begin_token_list);
  struct generic_token *t, *begin_expr, *end_expr;
  struct string_token *str;
  struct numeric_variable width, height, depth;
  // Getting the glyph to be rendered
  t = ((struct generic_token *) begin_token_list) -> next;
  t = t -> next;
  str = (struct string_token *) t;
  cx -> current_glyph = str -> glyph;
  // Reading numeric values in the statement header
  t = t -> next;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(IS_NOT_NESTED() && t -> type == TYPE_COMMA);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &width))
    return false;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(IS_NOT_NESTED() && t -> type == TYPE_COMMA);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &height))
    return false;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(IS_NOT_NESTED() && t -> type == TYPE_CLOSE_PARENTHESIS);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &depth))
    return false;
  *end_token_list = t;
  { // Setting currentpicture = nullpicture(width, height + depth):
    unsigned char *data;
    size_t size;
    struct picture_variable *pic = &(mf -> internal_picture_variables[0]);
    if(pic -> texture != 0)
      glDeleteTextures(1, &(pic -> texture));
#ifdef W_WEAVEFONT_DISABLE_MULTISAMPLE
    mf -> current_depth = depth.value;
    pic -> width = width.value;
    pic -> height = (height.value + depth.value);
#else
    mf -> current_depth = 2 * depth.value;
    pic -> width = 2 * width.value;
    pic -> height = 2 * (height.value + depth.value);
#endif
    size = pic -> width * pic -> height * 4;
    data = temporary_alloc(size);
    if(data == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
      return false;
    }
    // The new picture will be white
    memset(data, 255, size);
    { // And also transparent:
      int i;
      for(i = 3; i < size; i += 4)
        data[i] = 0;
    }
    glGenTextures(1, &(pic -> texture));
    glBindTexture(GL_TEXTURE_2D, pic -> texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, pic -> width, pic -> height, 0,
                 GL_RGBA, GL_UNSIGNED_BYTE, data);
    glBindTexture(GL_TEXTURE_2D, 0);
    if(temporary_free != NULL)
      temporary_free(data);
  }
  { // Setting currentpen = nullpen:
    mf -> internal_pen_variables[0].format = NULL; // A caneta 'currentpen'
    mf -> internal_pen_variables[0].type = TYPE_T_PEN;
    mf -> internal_pen_variables[0].flags = FLAG_NULL;
    mf -> internal_pen_variables[0].referenced = NULL;
    if(mf -> internal_pen_variables[0].gl_vbo != 0)
      glDeleteBuffers(1, &(mf -> internal_pen_variables[0].gl_vbo));
    mf -> internal_pen_variables[0].gl_vbo = 0;
    mf -> internal_pen_variables[0].indices = 0;
    mf -> pen_lft = mf -> pen_rt = mf -> pen_top = mf -> pen_bot = 0.0;
  }
}
@
\fimcodigo

FInally, when we read an \monoespaco{endchar} token not in the loading
mode, this means that we finished to render a new glyph. Then we copy
the rendered picture from \monoespaco{currentpicture} to the new glyph
and get the new glyph dimensions reading
the \monoespaco{currentpicture} size and also the current depth
stored. If we are using multisampling, we adjust the final glyph size
to half the stored value, so that it will always be rendered with half
the actual texture size. Finally, we mark the glyph as already rendered
and erase all \monoespaco{currentpicture} content:

\iniciocodigo
@<Statement: Compound@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_ENDCHAR){
  struct picture_variable *currentpicture =
                                        &(mf -> internal_picture_variables[0]);

  end_nesting_level(mf, cx, begin_token_list);
  cx -> current_glyph -> texture = currentpicture -> texture;
#ifndef W_WEAVEFONT_DISABLE_MULTISAMPLE
  cx -> current_glyph -> width /= 2;
  cx -> current_glyph -> depth /= 2;
  cx -> current_glyph -> height /= 2;
#endif
  cx -> current_glyph -> need_rendering = false;
  currentpicture -> width = -1;
  currentpicture -> height = -1;
  currentpicture -> texture = 0;
  *end_token_list = begin_token_list;
}
@
\fimcodigo

\secao{13. API Functions to Use the Fonts}

A WEAVEFONT code can have its global variables changed and this will
change the rendering of the next glyphs, without needing to change the
source code or reload the code. To read and update numeric global
variables, we will export the following functions:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
bool _Wupdate_numeric_variable(struct metafont *mf, char *name, float value);
float _Wread_numeric_variable(struct metafont *mf, char *name);
@
\fimcodigo

This function will change the given global variable assigning the
given value to it and also will mark all glyphs as needing to be
rendered again. If a numeric global variable with such name does not
exist, the function returns false. Otherwise, it returns true:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
bool _Wupdate_numeric_variable(struct metafont *mf, char *name, float value){
  struct named_variable *var = (struct named_variable *) mf -> named_variables;
  while(var != NULL){
    if(!strcmp(name, var -> name)){
      struct numeric_variable *n = (struct numeric_variable *) var -> var;
      if(n -> type != TYPE_T_NUMERIC)
        return false;
      n -> value = value;
      {
        int i, j;
        for(i = 0; i < 332; i ++){
          struct _glyph *g = mf -> glyphs[i];
          int size = ((i == 0)?(greatest_point[0] + 1):
                               (greatest_point[i] - greatest_point[i - 1]));
          if(g != NULL){
            for(j = 0; j < size; j ++)
                g[j].need_rendering = true;
          }
        }
      }
    }
    var = var -> next;
  }
  return false;
}
@
\fimcodigo

The code to read a gloabal numeric variable is similar. If such
variable does not exist, we return NAN:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
float _Wread_numeric_variable(struct metafont *mf, char *name){
  struct named_variable *var = (struct named_variable *) mf -> named_variables;
  while(var != NULL){
    if(!strcmp(name, var -> name)){
      struct numeric_variable *n = (struct numeric_variable *) var -> var;
      if(n -> type != TYPE_T_NUMERIC)
        return NAN;
      return n -> value;
    }
    var = var -> next;
  }
  return NAN;
}
@
\fimcodigo

The function that reads a file with WEAVEFONT code and creates a new
metafont is:

\iniciocodigo
@<API Functions Definition (metafont.c)@>+=
struct metafont *_Wnew_metafont(char *filename){
  void *p;
  struct metafont *mf;
  struct context *cx;
  bool ret;
  mf = init_metafont(permanent_alloc, permanent_free, filename);
  p = lexer(mf, permanent_alloc, permanent_free, filename);
  cx = init_context();
  ret = eval_program(mf, cx, p);
  destroy_context(mf, cx);
  if(!ret){
    _Wdestroy_metafont(mf);
    return NULL;
  }
  return mf;
}
@
\fimcodigo


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim
