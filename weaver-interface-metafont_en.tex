\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}

\secao{1. Introduction}

The original METAFONT is a language made to describe typographical
fonts. It was created on 1984 by Donald Knuth and differs from other
formats for allowing a designer to create different fonts merely by
changing basic parameters in the base description of the font. This
way, a designer should not create a single typographic font, but a
meta-font from which new fonts could be obtained changing these basic
parameters.

The original specification for the METAFONT language can be found in
[KNUTH, 1989], but the implementation described here will not be
compatible with that language. Instead, a new language will be
defined, strongly based on the original METAFONT, but with a different
grammar. The new language will have similar objectives, but it will be
focused on defining typographical fonts that could be interpreted and
rendered on the fly.

As this article defines a subsystem for Weaver Game Engine, and more
specifically a subsystem for the user interface modulus, our objective
here will be define the following function that will interpret a file
with METAFONT source code and load as user interface using the letters
read as texture:

\iniciocodigo
@<Function Declaration (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
@
\fimcodigo

And we will need the header for Weaver user interfaces:

\iniciocodigo
@<Include General Headers (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

But besides loading the typographical fonts to a texture, we also want
to create a font structure that could be used to render text for other
functions:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Before acalling any of these function, it is necessary to call a
initialization function that sets which functions will be called in
some contexts and also sets how many pixels correspond to ``1pt'':

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
void Winit_metafont(void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *),
                    void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    uint64_t (*rand)(void), int pt);
@
\fimcodigo

The functions passed as parameters are respectivelly the one that
allocates memory temporarily , other to free what was allocated by it,
a function to make more permanent allocation, the function that frees
what was allocated by it, a function that returns 64 random bits and
finally how many pixels are ``1pt''. The disallocation functions can
be set to NULL.

\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{metafont.h}.

We can show the structure of the file \monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif
@<Include General Headers (metafont.h)@>
//@<General Macros (metafont.h)@>
@<Data Structures (metafont.h)@>
@<Function Declaration (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Function Declaration
(weaver.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{metafont.c} file related
with this header, its structure is:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Local Headers (metafont.c)@>
@<Local Macros (metafont.c)@>
@<Local Data Structures (metafont.c)@>
@<Local Variables (metafont.c)@>
@<Local Function Declaration (metafont.c)@>
@<Auxiliary Local Functions (metafont.c)@>
@<API Functions Definition (metafont.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\secao{2. Initialization}

First we will define the initialization function. What it will do is
set some static variables with some functions that we will use in the
program. It also will set in a variable how many pixels correspond to
1pt. The variables that will store these information are:

\iniciocodigo
@<Local Variables (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

And the initialization function that sets these variables:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
void Winit_metafont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
}
@
\fimcodigo


\secao{3. Lexer}

The first thing to be created for a language is its lexer. It will
read the source code in a file and will output a list of tokens, where
tokens are the most basic unit in the language. A token is like a
word.

METAFONT recognizes three kind of tokens: numeric, strings and
symbolic. In practice we will subdivide the symbolic tokens in several
kind of subtokens to store and read them in a more efficient way.

A numeric token will be represented internally as a floating point
number. This is different than specified in the original METAFONT,
where a custom numeric representation was used. As here we are
interested in more speed, we will choose floating point numbers
because they have nowadays more hardware support. This is how a
numeric token is represented:

\iniciocodigo
@<Local Data Structures (metafont.c)@>=
#define TYPE_NUMERIC 1
struct numeric_token{
  int type;   // Should be equal 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

And this is how we will represent string tokens:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_STRING 2
struct string_token{
  int type;   // Should be equal 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

We will store only the first 5 bytes of each given string, even if in
the source code the string is bigger. This is so because unlike in the
original METAFONT, our only use for strings are saying wich Unicode
character each glyph should represent. For this we need only 5 bytes
(at most 4 for the character and a final byte 0). But we could use
them to associate a glyph with ligatures like ``ff'', which also fits
in these 5 bytes.

In the case of symbolic tokens, we need to store their entire name to
know which symbolic token we have. We shoul allocate dynamically
a string to store its name:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_SYMBOLIC 3
struct symbolic_token{
  int type;   // Should be equal 'TYPE_SYMBOLIC'
  void *next, *var;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char *value;
};
@
\fimcodigo

We also added in this token a pointer \monoespaco{var}, because the
token can represent a variable, and therefore could need to point to
the memory region with its content.

But this could consume much more memory than needed. Some symbols are
very common and are embedded in the language. These symbols could use
less space. For example, parenthesis, semicolon and commas. We can
represent them with the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_OPEN_PARENTHESIS  4 // '('
#define TYPE_CLOSE_PARENTHESIS 5 // ')'
#define TYPE_COMMA             6 // ','
#define TYPE_SEMICOLON         7 // ';'
@<METAFONT: Symbolic Token Definition@>
// (...)
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

We can define later more reserved symbolic tokens. We just need to
define them to an unique number greater than 6. Any token whose type
is a number greater or equal than 3 is a symbolic token.

Every token have a pointer to a next token. THis happens because
usually they will be part of a linked list. To deallocate the memory
occupied by a token list given a deallocation function and the given
list, we can use the following function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Now the funtion that represents our lexer. It will get as argument an
allocation function and a string with a path for the file with
METAFONT source code. It will return a linked list of tokens:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Lexer: Rule 1@>
    @<Lexer: Rule 2@>
    @<Lexer: Rule 3@>
    @<Lexer: Rule 4@>
    @<Lexer: Rule 5@>
    @<Lexer: Rule 6@>
    // No rule applied: error
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, we used the struct \monoespaco{FILE}, this means that we need to
include the header with data about input/output to be able to read
files:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

The rules to read tokens consist in reading each line in the source
code applying the following rules for each character in the line:

1) If the next character is a space or a period and is not followed by
a period or a decimal digit, then ignore this character and go to the
next one.

\iniciocodigo
@<Lexer: Rule 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

As we are using \monoespaco{isdigit} function, we need to insert the
following header that declares this function:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) If the character is a percent sign, ignore it and also ignore all
other following characters in this line. Percentage sign is how we
start comments in the language.

\iniciocodigo
@<Lexer: Rule 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) If the next character is a decimal digit or a period, then the next
token in numeric. It will be interpreted from the biggest sequence of
decimal digests and a single optional period representing the decimal
dot present in the input.

\iniciocodigo
@<Lexer: Rule 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

4) If the next character is a double quote, the next token will be a
string. Its content will be all other chacarters until the next double
quote that should be in the same line. If we have a double quote
opening a string, but the same line do not have another double quote
to close the string, this is an error.

\iniciocodigo
@<Lexer: Rule 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


5) If the next character is a parenthesis, semicolon or a comma, the
next token will be symbolic and composed by that single character.

\iniciocodigo
@<Lexer: Rule 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Otherwise, the next token will be symbolic and will be composed by
the longest sequence of 12 families of characteres:

\iniciocodigo
@<Lexer: Rule 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer is read according with subrules 6-a to 6-l
  @<Lexer: Rule A@>
  @<Lexer: Rule B@>
  @<Lexer: Rule C@>
  @<Lexer: Rule D@>
  @<Lexer: Rule E@>
  @<Lexer: Rule F@>
  @<Lexer: Rule G@>
  @<Lexer: Rule H@>
  @<Lexer: Rule I@>
  @<Lexer: Rule J@>
  @<Lexer: Rule K@>
  @<Lexer: Rule L@>
  // Depending on buffer content, generates next token
  @<Lexer: New Reserved Symbolic Token@>
  @<Lexer: New Generic Symbolic Token@>
}
@
\fimcodigo

a) The first family of letters are the uppercase and lowercase
alphabetic letters, digits and underline. A digit cannot be the first
character in the sequence, otherwise it would be considered part of a
numeric token.

\iniciocodigo
@<Lexer: Rule A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) The second family is composed by the symbols for greater, equal and
lesser, colon and a pipe..

\iniciocodigo
@<Lexer: Rule B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acute and grave accents.

\iniciocodigo
@<Lexer: Rule C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Plus and minus.

\iniciocodigo
@<Lexer: Rule D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Slash, backslash and multiplication symbol.

\iniciocodigo
@<Lexer: Rule E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Opening brackets

\iniciocodigo
@<Lexer: Rule F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Hash sign, ampersand, at sign and dollar sign.

\iniciocodigo
@<Lexer: Rule G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Circumflex accent and tilde.

\iniciocodigo
@<Lexer: Rule H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Opening brackets.

\iniciocodigo
@<Lexer: Rule I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Closing brackets.

\iniciocodigo
@<Lexer: Rule J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Opening and closing braces.

\iniciocodigo
@<Lexer: Rule K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Lexer: Rule L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo


After reading the characters for our new symbolic token, we check if
we have a reserved symbolic token: a token representing a language
keyword. We can check this using function \monoespaco{strcmp}
comparing the buffer with some keywords. We will store a list of
keywords here:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static char* list_of_keywords[] = {
@<List of Keywords@>
  NULL};
@
\fimcodigo

Therefore, to know if we are dealing with a token that represents a
reserved keyword, we check if it is in this NULL terminated list. If
so, we create a token whose type is chosen according with the position
in this list:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // Token types for keywords begin in 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(dealloc, first_token);
      return NULL;
    }
    @<Change Type in Token Creation for Special Cases@>
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(first_token == NULL)
      first_token = last_token = new_token;
    else{
      ((struct generic_token *) last_token) -> next = new_token;
      last_token = new_token;
    }
    continue;
  }
}
@
\fimcodigo

To use function \monoespaco{strcmp} we need the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <string.h>
@
\fimcodigo


If we do not have a reserved symbolic token, and if we have something
in our buffer, then we generate a new generic symbolic token:

\iniciocodigo
@<Lexer: New Generic Symbolic Token@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Set Pointer to Internal Variable@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

\secao{4. METAFONT Programs}

When we evaluate a METAFONT program, we need two additional
structures. The first one, which we will call \monoespaco{struct
metafont} will contain all the final information extracted from the
typographical font and that will be needed to render each glyph. The
second structure, which we will call \monoespaco{struct context}
represents the current state in our parser and represents information
that we need to know to interpret correctly the token list. This
second structure can be discarded after we read all the tokens from
our font.

The first thing that our parser needs to know is that a METAFONT
program is a list (possibly empty) of statements ended by a symbolic
token \monoespaco{end} or \monoespaco{dump}:

\alinhaverbatim
<Program> -> <List of Statements> end | <List of Statements> dump
\alinhanormal

for us, there will be no difference between these two kind of programs
and symbols \monoespaco{end} and \monoespaco{dump} will be
equivalent. In the original METAFONT, one of them ends programs that
define typographical fonts and the other ends the description of a
base file (something like a basic standard library).

We will define then a new kind of symbolic token to represent this
end-of-file marking:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>=
#define TYPE_END             8 // The symbolic token 'end'
#define TYPE_DUMP            9 // The symbolic token 'dump'
@
\fimcodigo

And let's add both the keywords \monoespaco{end} and \monoespaco{dump}
in ourt list of keywords:

\iniciocodigo
@<List of Keywords@>=
"end", "dump",
@
\fimcodigo

But to simplify, we will not use \monoespaco{TYPE\_DUMP},
only \monoespaco{TYPE\_END} to make the code simpler in the parser:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>=
if(token_type == TYPE_DUMP)
  token_type = TYPE_END;
@
\fimcodigo


The first parser function to be defined is the one that recognizes an
entire program. It basically checks if the program is ended correctly
and if not, generates an error. If the program is ended correctly, it
passes for the next parser function that evaluates list of statements,
marking the beginning and end of such list:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  struct generic_token *previous = NULL;
  while(end != NULL && end -> type != TYPE_END){
    previous = end;
    end = (struct generic_token *) (end -> next);
  }
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file,
                    (previous == NULL)?(1):(previous -> line));
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, previous);
}
@
\fimcodigo

The context struct still will not be entirely defined. We will show
its content while each attribute becames necessary:

\iniciocodigo
@<Data Structures (metafont.h)@>=
struct context{
  @<Attributes (struct context)@>
};
@
\fimcodigo


And as seen above, one of the contents in \monoespaco{struct metafont}
is the file name from where the font was read. We also will store the
functions that will be use to allocate and disallocate the structure
and its elements:

\iniciocodigo
@<Data Structures (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Attributes (struct metafont)@>
};
@
\fimcodigo

Both data structures will have a function that initializes them and
also finalizes them:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct context *cx);
@
\fimcodigo

The structure \monoespaco{metafont} needs to store more informations,
as it could be allocated both using permanent or temporary memory
allocations. Meanwhile, the context always will be temporary and will
be allocated with temporary functions.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Initialization (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Initialization (struct context)@>
  return cx;
}
@
\fimcodigo

And this is the definition for the functions that frees the memory
occupied by these structures:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalization (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct context *cx){
  if(temporary_free != NULL){
    @<Finalization (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo


\secao{5. List of Statements}

A list of potentially empty statements delimited by a semicolon:

\alinhaverbatim
<List of Statements> -> <Empty> | <Statement> ; <List of Statements>
\alinhanormal

The function that will evaluate and interpret a list of statements is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

This function will iterate over each declaration and execute for all
them, in the order thay appear, the function that evaluates individual
statements. For this, the function will find all semicolons and use
them to detect where each statement begins and where they end:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
        if(!ret)
          return false;
      begin = end -> next;
    }
  }
  return ret;
}
@
\fimcodigo

The function above iterates over each statement, ignoring empty
statements. For each non-empty statement, it assures that the
pointers \monoespaco{begin} and \monoespaco{end} delimit the
individual statement. During the iteration we always ensure that we do
not go outside the region delimited by \monoespaco{begin\_token\_list}
and \monoespaco{end\_token\_list}.

\secao{6. Compound Statements}

An individual statement in the language can be composed by many other
statements. The syntax for this is:

\alinhaverbatim
<Statement> -> <Empty> | <Compound> | <Declaration> | <Assignment> |
               <Definition> | <Command>
<Compound> -> begingroup <List of Statements> <Non-Title> endgroup
\alinhanormal

We already know what is a list of statements and already have a
function to eval them. The non-title declaration, for now, will be
treated as any other statement, because we still do not support title
statements (they are isolated strings). Therefore, a compund statement
is just a list of statements delimited by
tokens \monoespaco{begingroup} and \monoespaco{endgroup}.

Then we need to take into account the existance of these two new kind
of special symbolic tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_BEGINGROUP            10 // O token simbólico 'begingroup'
#define TYPE_ENDGROUP              11 // O token simbólico 'endgroup'
@
\fimcodigo

And we add them to the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"begingroup", "endgroup",
@
\fimcodigo

And now the function that will evaluate individual statements. As
seen, there are 8 different kinds of statements:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Statement: Empty@>
  @<Statement: Compound@>
  @<Statement: Declaration@>
  @<Statement: Assignment@>
  //@<Statement: Definition@>
  //@<Statement: Command@>
  // If we are here, we could not identify the statement:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

In the case of an empty statement, probably we will not need to deal
with them. The function \monoespaco{eval\_list\_of\_statements}
silently ignore them before calling this function. But just in case an
empty statement appear by different means, we will explicitly accept
them with the code below:

\iniciocodigo
@<Statement: Empty@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Now let's deal with the compound statement. The first thing to recall
is that it will be important for the language to know in which nesting
level we are to know the scope of each declared variable. Because of
this, our context will store the current nesting
level. Each \monoespaco{begingroup} should increase by 1 the nesting
level and each \monoespaco{endgroup} should decrease by 1. We declare
the nesting level below:

\iniciocodigo
@<Attributes (struct context)@>=
  int nesting_level;
@
\fimcodigo

This should be initialized as zero:

\iniciocodigo
@<Initialization (struct context)@>=
  cx -> nesting_level = 0;
@
\fimcodigo


The second thing to recall is that if we are in a compound statement,
this means that the end of the declaration pointer could be wrong.
For example, supose that the
function \monoespaco{eval\_list\_of\_statements} evaluated the
following tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;]
\alinhanormal

The function correctly would consider the beginning of the first
statement the token \monoespaco{begingroup}. But wrongly would
consider the token \monoespaco{T2} as the end of this statement.
Because it works in a naive logic, always considering the semicolons
as the delimiters for statements, not considering that statements
could contain semicolons. The end of the first statement should be the
token \monoespaco{endgroup} instead.

Instead of increasing the complexity of
function \monoespaco{eval\_list\_of\_statements} making it aware of
compound statements, we will make the
function \monoespaco{eval\_statements} correct the pointers, making
the pointers to delimit correctly the statement. Only after correcting
the pointers, we can pass the list of statements from the compouns
statement to be evaluated:

\iniciocodigo
@<Statement: Compound@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  struct generic_token *t = begin_token_list, *previous = NULL;
  int nesting_level = 0;
  while(t != NULL){
    if(t -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(t -> type == TYPE_ENDGROUP){
      nesting_level --;
      if(nesting_level == 0)
        break;
    }
    previous = t;
    t = (struct generic_token *) (t -> next);
  }
  *end_token_list = t; // Now the statement is correctly delimited
  if(*end_token_list == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed 'begingroup'.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(previous == begin_token_list) // Empty compound statement
    return true;
  else{
    bool ret;
    cx -> nesting_level ++;
    ret = eval_list_of_statements(mf, cx, ((struct generic_token *)
                                         begin_token_list) -> next,
                                  previous);
    cx -> nesting_level --;
    return ret;
  }
}
@
\fimcodigo


\secao{7. Variable Declarations}

The syntax to declare variables is:

\alinhaverbatim
<Declaration> -> <Type> <List of Declarations>
<Type> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<List of Declarations> -> <Tag> | <Tag> , <List of Declarations>
\alinhanormal

A ``tag'' is basically a symbolic token without a predefined meaning
in the language. For example, ``\monoespaco{tag}'' is a tag, but
``\monoespaco{begingroup}'' is not.

To interpret a declaration, we will introduce the following special
tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_T_BOOLEAN               12 // Symbolic token 'boolean'
#define TYPE_T_PATH                  13 // Symbolic token 'path'
#define TYPE_T_PEN                   14 // Symbolic token 'pen'
#define TYPE_T_PICTURE               15 // Symbolic token 'picture'
#define TYPE_T_TRANSFORM             16 // Symbolic token 'transform'
#define TYPE_T_PAIR                  17 // Symbolic token 'pair'
#define TYPE_T_NUMERIC               18 // Symbolic token 'numeric'
@
\fimcodigo

And then we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


When a variable is declared, we need to do two things:

1) If the variable do not exist in the current nesting level, we
should allocate a new structure to store its content. If it already
exist in the current nesting level, an error is returned. A default
value depending of its type if stored in the variable. But it should
not be used before being initialized.

2) We iterate over the following tokens in the list of tokens until
the end of the list or until the current nesting level ends. When we
find a symbolic token with the variable name, we update its pointer to
the newly allocated variable.


As each variable type has its own information and content, the
specifics about how the variable is created can be different. What all
variables have in common is the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
// Generic variable
struct variable{
  int type;
  int nesting_level;
  void *next;
};
@
\fimcodigo

All variables first store their type, then their nesting level, and
finally, a ponter for the next variable. Depending on the variable
type, more information could be stored after the pointer for the next
variable.

If we are dealing with a global variable, we could want to preserve
and store its name, just in case if later the user would want to
change the variable content indentifying it by the name. In this case,
we would want to use the following structure to store the name with
the variable:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

And the metafont structure will have pointers for these global
variables, with names and without:

\iniciocodigo
@<Attributes (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

These pointers are initialized with NULL:

\iniciocodigo
@<Initialization (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

To disallocate a list of global variables, we just iterate over the
linked list that they create. Some variables, which are more complex,
could need additional operations before removing them, but we will
deal with them later:

\iniciocodigo
@<Finalization (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Global Variable 'v'@>
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

And to disallocate a list with preserved names, we act in a similar
way:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) named -> var;
    next = (struct named_variable *) (named -> next);
    mf -> free(named -> name);
    @<Finalize Global Variable 'v'@>
    mf -> free(v);
    mf -> free(named);
    named = next;
  }
}
@
\fimcodigo

In the case of variables that are not global, they will be stored in
contexts, not in the metafont struct. After all, their duration always
will be temporary:

\iniciocodigo
@<Attributes (struct context)@>=
  void *variables;
@
\fimcodigo

The list of variables is initialized as empty:

\iniciocodigo
@<Initialization (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

And we finalize it exactly as the list of global variables:

\iniciocodigo
@<Finalization (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Local Variable 'v'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

And now let's interpret the variable declaration:

\iniciocodigo
@<Statement: Declaration@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // All kinds of declarations
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insert Declared Variable@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

Inserting a new variable follows the logic below:

\iniciocodigo
@<Insert Declared Variable@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

The function that inserts a new global variable without its name is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

It will allocate a new variable and store it in the local pointed
by \monoespaco{target}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Initializing New Variable@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Inserting a named variable is done with the following function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

The function works in a similar way, first allocating the structure
with the variable nam and then placing the variable there:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));

  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL)
    mf -> named_variables = named;
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

Anf finally, the function that search in a list of tokens for symbolic
tokens with the same name that the allocated new variable and updating
each one to make them point to the newly allocated variable position:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

The function will walk in the linked list starting in the token next
to the declared variable. And t will stop only when there is no more
tokens or when the variable do not exist anymore because we are not
more in its nesting level (it happens when we find
the \monoespaco{endgroup} which ends the current nesting level):

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Numeric Variables}

A numeric variable will be stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparing numeric variables with generic variables, the difference is
that we have an additional floating point variable in the structure
called \monoespaco{value}. It will store the numeric value. When we
create a numeric variable, we initialize it with NaN, which represents
an unknown value:

\iniciocodigo
@<Initializing New Variable@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

Using the macro \monoespaco{NAN} requires the mathematical header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

In the case of numeric variables, nothing additional is needed when we
deallocate them, as they have no additional structure besides a single
floating-point number.

However, besides the variables declared by the users, our version of
the Metafont language will have some additional internal
variables. They always will be present and do not need to be
declared. We will have exactly three of
them: \monoespaco{pt}, \monoespaco{cm} and \monoespaco{mm}. Basically
they will store how many pixels correspond to 1pt, 1cm and 1mm
respectively.

Such internal numeric variables will be declared in the metafont
struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

During the initialization we will allocate space for the three
variables and fill their values:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   pt;
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   28.3465 * pt; // 1cm = 28.3465pt
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   2.83465 * pt; // 1mm = 2.83465pt
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;

  }
}
@
\fimcodigo

We also will create the following macros to access each one of these
variables more easily:

\iniciocodigo
@<Local Macros (metafont.c)@>=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

To finalize the metafont structure, we need to deallocate these
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

When our lexer creates a new symbolic token which is not a reserved
word, it should check if this token have the same name than an
internal variable. If so, we can then set correctly the pointer to the
variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\subsecao{7.2. Pair Variables}

A pair variable will store point coordinates. They will be stored in
the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct pair_variable{
  int type; // Must be 'TYPE_T_PAIR'
  int nesting_level;
  void *next;
  float x, y;
};
@
\fimcodigo

The difference is that they have space for two floating point values
instead of one. Initially we will represent the first of them with NaN
to represent a non-initialized pair:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Path Variables}

A path variable store a sequence of points and control
points. Together they compose a sequence of Cubic Beziér Curves.

A Cubic Beziér Curve is defined by two extremity points ($z_1$ and
$z_4$) and two control points ($z_2'$ and $z_3'$). The two extremity
curves are always part of the curve. To obtain the other curve points
given the four points $(z_1, z_2', z_3', z_4)$, we use the following
procedure:

1) Get three intermediate points: $z_{12}'$ is the point halfway the
points $z_1$ and $z_2'$, $z_{23}'$ is the point halfway between $z_2'$
and $z_3'$ and $z_{34}$ is the point halfway between $z_3'$ and $z_4$.

2) Get two intermediate points: $z_{123}'$ is the point halfway
between $z_{12}'$ and $z_{23}'$ while $z_{234}'$ is the point halfway
between $z_{23}'$ and $z_{34}'$.

3) Get the new curve point $z_{1234}$ located halfway between
$z_{123}'$ and $z_{234}'$.

4) Generate the remaining curve points repeating this procedure
recursively over the points $(z_1, z_{12}', z_{123}', z_{1234})$ and
over $(z_{1234}, z_{234}', z_{34}', z_4)$.

It is also possible to define such curves using a formula. Given the
extremity points and the control points, a Cubic Beziér Curve is
defined by the following formula if we vary $t$ between 0 and 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

The data structure that will represent a sequence of Cubic Beziér
Curves is:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct path_points{
  float x, y; // Extremity point
  float u_x, u_y, v_x, v_y;   // Control Points
  void *subpath;
};
struct path_variable{
  int type; // Must be 'TYPE_T_PATH'
  int nesting_level;
  void *next;
  bool cyclic;
  int length;
  struct path_points *points;
};
@
\fimcodigo

Basically its points will be stored in the
pointer \monoespaco{points}, an array of structs whose number of
elements is equal \monoespaco{length}. Each structure will represent a
point $(x, y)$ or a subpath (if \monoespaco{subpath} is not null, and
in this case we ignore $x$ and $y$). The control points defined
by \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
and \monoespaco{v\_y} are the control points between the current point
or subpath and the next one if it exists. If we have a cyclic path,
the control points in the last point or subpath show how it is
connected to the first point in the path. If we are not in a cyclic
path, then the control points of the last point is ignored.

We will represent a non-initialized oath variable setting its length
as -1:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
}
@
\fimcodigo

When we remove a global variable, if it is a path variable and if it
is initialized, then we also need to remove the allocated list of
points:

\iniciocodigo
@<Finalize Global Variable 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && mf -> free != NULL)
    path_recursive_free(mf -> free, path, false);
}
@
\fimcodigo

If the variable is not global we do the same, but using a different
disallocation function:

\iniciocodigo
@<Finalize Local Variable 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL)
    path_recursive_free(temporary_free, path, false);
}
@
\fimcodigo

As a path can contain subpaths and each subpath also can contain more
subpaths, we will use a recursive function to disallocate their
memory. Given a disallocation function and a pointer to a path
variable, we disalloc all its subpaths, and then we disalloc the path
variable. The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].subpath != NULL)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath, true);
    }
    free_func(path -> points);
    if(free_first_pointer)
      free_func(path);
  }
}
@
\fimcodigo

\secao{8. Assignments}

Assignments are how we initialize variables, how we modify their
values and how we store the result of expressions.

The syntax for an assignment is:

\alinhaverbatim
<Assignment> -> <Variable> = <Right Side> |
                <Variable> := <Right Side> |
<Right Side> -> <Expression> | <Assignment>
\alinhanormal

This means that we can chain assignments, for example, in the code
below, all variables, if numeric, will store the value 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

If in the beginning of a statement we find a variable, then certainly
we are dealing with an assignment.

We will begin teaching our lexer that both tokens ``\monoespaco{=}''
and ``\monoespaco{:=}'' are equivalent, represent the same thing and
have an special meaning:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_ASSIGNMENT            19 // Symbolic token '='
#define TYPE_ASSIGNMENT2           20 // Symbolic token ':='
@
\fimcodigo

Both types are added to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"=", ":=",
@
\fimcodigo

But to simplify the code, we will transform the second type in the
first and consider only the first kind of assignment:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>+=
else if(token_type == TYPE_ASSIGNMENT2)
  token_type = TYPE_ASSIGNMENT;
@
\fimcodigo


Now that we have this new kind of token, the code to evaluate
assignments is described below. What it does is walk over the tokens
in the assignment detecting all variables that should pass by the
assignment. While it does it, it checks if all them are declared, if
all them have the same type, if we are assigning to something that is
not a variable, if we forget the assignment symbol, or if we are
missing an expression after the assignment. If one of these things are
detected, an error is generated.

The part that we still will not show is how we evaluate the expression
after the last assignment symbol and how in the end we update the
value for each variable to be equal what was evaluated. How we do
these things change depending on the variable types, each type have
its own expressions and its own way of storing the value in the
variables. These details will be shown in the next subsections.

\iniciocodigo
@<Statement: Assignment@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  struct generic_token *begin_expression;
  int type = 0; // Type for the variables being assigned
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment.\n", mf -> file,
              var -> line);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Assignment for Numeric Variables@>
  @<Assignment for Pair Variables@>
  @<Assignment for Path Variables@>
  return true;
}
@
\fimcodigo

\subsecao{8.1. Numeric Assignments and Expressions}

How do we assign numeric variables given the code above? We use the
following code:

\iniciocodigo
@<Assignment for Numeric Variables@>=
if(type == TYPE_T_NUMERIC){
  int i;
  bool ret;
  struct numeric_variable result;
  ret = eval_numeric_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                               &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_numeric_variable((struct numeric_variable *) var -> var,
                            &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The function that makes the assignment is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source);
@
\fimcodigo

And its simple implementation is given below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source){
  target -> value = source -> value;
}
@
\fimcodigo

Now we will write how to interpret numeric expressions.

\subsubsecao{8.1.1. Sum and Subtraction: Normal and Pythagorean}

The rules for numeric expressions begins as:

\alinhaverbatim
<Numeric Expression> -> <Numeric Tertiary>
<Numeric Tertiary> -> <Numeric Secundary> |
                      <Numeric Tertiary> <T-Op> <Numeric Secundary>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

The symbols \monoespaco{+} and \monoespaco{-} represent the usual
addition and subtraction. The symbol \monoespaco{++} should not be
confused with C language increment and means the pythagorean sum:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

This can be easily computed in C using the
function \monoespaco{hypot} from the standard math library.

The symbol \monoespaco{+-+} is the ``pythagorean subtraction'' defined
below:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

We will compute the pythagorean subtraction using the last definition,
as the multiplication of two square roots. This is the computation
that minimizes errors involving overflows and underflows.

The four operators above are the ones with smaller precedence. These
operations will be done only after all other mathematical operations.

Now we will improve our lexer making it identify and create the new
tokens for these operators. We also will create new token types for
``['' and ``]'', as we will need to identify these tokens in our
parser:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_SUM                   21 // Symbolic token '+'
#define TYPE_SUBTRACT              22 // Symbolic token '-'
#define TYPE_PYTHAGOREAN_SUM       23 // Symbolic token '++'
#define TYPE_PYTHAGOREAN_SUBTRACT  24 // Symbolic token '+-+'
#define TYPE_OPEN_BRACKETS         25 // Symbolic token '['
#define TYPE_CLOSE_BRACKETS        26 // Symbolic token ']'
#define TYPE_OPEN_BRACES           27 // Symbolic token '{'
#define TYPE_CLOSE_BRACES          28 // Symbolic token '}'
@
\fimcodigo

And we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo

Now let's evaluate numeric expressions, which means evaluating
tertiary numeric expressions. The function is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

The tertiary numeric expressions is where we solve additions and
subtractions. By the syntax rules, what we need to do is walk over the
tokens in the expression until find the last tertiary operator that is
not delimited by parenthesis, brackets or braces.

To help with this, the following macros will store, check and count
the nesting level for parenthesis, braces and brackets:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define DECLARE_NESTING_CONTROL() int nesting_parenthesis = 0, \
                                      nesting_brackets = 0, \
                                      nesting_braces = 0;
#define COUNT_NESTING(p) if(p -> type == TYPE_OPEN_PARENTHESIS)           \
                               nesting_parenthesis ++;                    \
                             else if(p -> type == TYPE_CLOSE_PARENTHESIS) \
                               nesting_parenthesis --;                    \
                             else if(p -> type == TYPE_OPEN_BRACKETS)     \
                               nesting_brackets ++;                       \
                             else if(p -> type == TYPE_CLOSE_BRACKETS)    \
                               nesting_brackets --;                       \
                             else if(p -> type == TYPE_OPEN_BRACES)       \
                               nesting_braces ++;                         \
                             else if(p -> type == TYPE_CLOSE_BRACES)      \
                               nesting_braces --;
#define IS_NOT_NESTED() (nesting_parenthesis == 0 && nesting_brackets == 0 && \
                         nesting_braces == 0)
@
\fimcodigo


Everything in the left side should be recursively evaluated as another
tertiary expression. Everything in the right side should be
interpreted as a secundary numeric expression. Finally, if we did not
find any tertiary operator, the entire expression is evaluated as a
secundary numeric expression.

However, there are some exceptions, cases in which the
symbols \monoespaco{+} and \monoespaco{-} should not be treated as a
sum or subtraction. This happens if they are in the beginning of the
numeric expression, or if before them there is a comma, an opening
bracket, a multiplication or division symbol, another tertiary
operator, or one of the following tokens that we will define later:
\monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}.

If we have a previous token (\monoespaco{prev}) and the current one
(\monoespaco{cur}), we can check if it represents a valid sum or
subtraction with the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo
\iniciocodigo
@<Operador Secundário de Pares: Escala-X@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

The following code interprets tertiary numeric expressions and
identify correctly the tertiary operators with the help of the macro:


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secundary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_PYTHAGOREAN_SUM ||
                          p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
                          IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secundary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_numeric_secundary(mf, cx, begin_secundary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM)
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT)
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM)
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Negative square root "
                " in pythagorean subtraction.\n", mf -> file,
                last_sum -> line);
#endif
        return false;
      }
    }
    return true;
  }
  else
    return eval_numeric_secundary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.2. Multiplication and Division}

The rules to deal with secundary numeric expressions are:

\alinhaverbatim
<Numeric Secundary> -> <Numeric Primary> |
                       <Numeric Secundary> <S-Op> <Numeric Primary>
<S-Op> -> * | /
\alinhanormal

The operators \monoespaco{*} and \monoespaco{/} are respectively the
multiplication and division.

Let's add these operators as reserved tokens and define their types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_MULTIPLICATION        29 // Symbolic token '*'
#define TYPE_DIVISION              30 // Symbolic token '/'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"*", "/",
@
\fimcodigo

The function that will evaluate numeric secundary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

And its definition is very similar with the function that evaluates
tertiary expressions, except that this function computes
multiplication and division.

However, there is an additional rule that we should be aware: the
token ``/'' will be considered division only if it is not delimited by
two numeric tokens. If so, then it represents a fraction and it should
be computed with a higher precedence than what we deal here. However,
if the token before the previous one already was considered part of a
fraction, then in this case we have a division despide being
surrounded by numeric tokens. This way the code \monoespaco{1/3/1/3}
is interpreted as a division between two fractions $(1/3)/(1/3)$:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_secundary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
                          p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_token_list &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ // Valid multiplication or division
         last_mul = p;
         end_secundary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secundary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secundary(mf, cx, begin_expression, end_secundary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end_token_list, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION)
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){
      if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.\n",
                mf -> file, last_mul -> line);
#endif
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else
    return eval_numeric_primary(mf, cx, begin_expression,
                                end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.3. Modulus,
  Trigonometric Functions,  Exponentials, Floor and
  Random Uniform Values}

The rules for primary numeric expressions are:

\alinhaverbatim
<Numeric Primary> -> <Numeric Atom> |
                     length <Numeric Primary> | (...) |
                     <Numeric Operator> <Numeric Primary>
<Numeric Operator> -> sqrt | sind | cosd | mlog | mexp | floor |
                       uniformdeviate |
                       <Scalar Multiplication Operator>
<Scalar Multiplication Operator> -> + | - |
                       <Primary Numeric Token Before Variable>
<Primary Numeric Token> -> <Numeric Token> / <Numeric Token> |
                           <Numeric Token>
\alinhanormal

The operator \monoespaco{length}, when appearing before a numeric
primery means that we want its modulus. If it appears before another
kind of primary expression, it could mean different things.

The new modulus operator should be added to the list of reserved
words. We will add also the other new operators from the list of
numeric operators. The brackets are already in this list:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_LENGTH         31 // Symbolic token 'length'
#define TYPE_SQRT           32 // Symbolic token 'sqrt'
#define TYPE_SIND           33 // Symbolic token 'sind'
#define TYPE_COSD           34 // Symbolic token 'cosd'
#define TYPE_LOG            35 // Symbolic token 'log'
#define TYPE_EXP            36 // Symbolic token 'exp'
#define TYPE_FLOOR          37 // Symbolic token 'floor'
#define TYPE_UNIFORMDEVIATE 38 // Symbolic token 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

The function that evaluates a primary numeric expression is this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result);
@
\fimcodigo


We can decide which syntax rule should be applied while evaluating the
primary numeric expression using seven different interpretation rules:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result){
  @<Numeric Primary: Rule 1@>
  @<Numeric Primary: Rule 2@>
  @<Numeric Primary: Rule 3@>
  @<Numeric Primary: Additional Operators@>
  @<Numeric Primary: Rule 4@>
  return true;
}
@

The rules are:

1) If the expression is composed by a single token, or if it begins
with ``('' and ends with ``)'', or if it is composed by three tokens,
a numeric, a division and another numeric, then the entire expression
is a numeric atom:

\iniciocodigo
@<Numeric Primary: Rule 1@>=
if(begin_expression == end_expression ||
   (begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
    end_expression -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin_expression -> type == TYPE_NUMERIC &&
     begin_expression -> next != end_expression &&
     ((struct generic_token *) begin_expression -> next) -> type ==
       TYPE_DIVISION &&
     ((struct generic_token *) begin_expression -> next) -> next ==
       end_expression &&
     end_expression -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin_expression, end_expression,
                          result);
}
@
\fimcodigo

2) If we find operator \monoespaco{length}, then we check if the
expression after it is numeric. If so, we compute its modulus. If the
expression have another type, we will define later how the operator
will proceed. We assume that we have a function that discovers the
type of a primary expression.

\iniciocodigo
@<Numeric Primary: Rule 2@>=
else if(begin_expression -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx,
                                             (struct generic_token *)
                                             begin_expression -> next,
                                             end_expression);
  if(expr_type == TYPE_T_NUMERIC){
    bool ret;
    struct numeric_variable num;
    ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                               begin_expression -> next,
                               end_expression, &num);
    if(!ret)
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Evaluate 'length'@>
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "primary expression after 'length'.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;
  }
}
@
\fimcodigo

But how can we identify if we are facing a numeric priumary expression
or an expression of different kind? Well, reading its tokens. We still
cannot define a function that does this completely, as we still did
not define how are functions of different types. But for now we will
present the more simplist definition that if the expression is
composed by a single token, if numeric, the expression is numeric, and
if it is a variable, the expression have the same type than the
variable. This captures the simplest case:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(begin_expr -> type == TYPE_SYMBOLIC){
      struct symbolic_token *p = (struct symbolic_token *) begin_expr;
      if(p -> var == NULL)
        return 0; // Unknown
      else{
        struct variable *v = (struct variable *) (p -> var);
        return v -> type;
      }
    }
  }
  else{
    //@<Discover Primary Expression Type@>
  }
  return TYPE_T_NUMERIC;
  //return 0; // Unknown
}
@
\fimcodigo

3) If we find some of the numeric operators, we have a numeric
operator followed by a numeric primary expression.

The first numeric operator is the square root:

\iniciocodigo
@<Numeric Primary: Rule 3@>=
else if(begin_expression -> type == TYPE_SQRT){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value < 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Square root "
            "of negative number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;
}
@
\fimcodigo

Next we have the operator \monoespaco{sind}, which interprets the next
number in degrees (because of this it has the letter ``d'' in the end)
and computes the sine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SIND){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = sinf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the cosine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_COSD){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the logarithm in $e$ basis:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_LOG){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value <= 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Computing logarithm of "
            "non-positive number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = logf(num.value);
  return true;
}
@
\fimcodigo

And the exponential which means $exp x = e^x$:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_EXP){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = expf(num.value);
  return true;
}
@
\fimcodigo

The floor of a given value:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_FLOOR){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = floorf(num.value);
  return true;
}
@
\fimcodigo

About the operator \monoespaco{uniformdeviate}, it generates a number
uniform and random between 0 and the value passed as operand. We can
compute this generating a number between 0 and 1 and then multiply
this value with the operand.

Generating a floating point number between 0 and 1 following a
distribution near to uniform can be done generating a random 64-bit
number and then multiplying it with $2^{-64}$. Not all possible
floating-point numbers could be represented generating them this
way. Numbers smaller than $2^{-64}$ would be ignored and the rounding
would make some numbers near 1 more probable, but we also would have
less density in the range near 1. However, despithe these drawbacks,
the result would be sufficiently precise for our purposes:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_UNIFORMDEVIATE){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;
  }
  return true;
}
@
\fimcodigo

If the next operator is the symbol \monoespaco{+}, this means a
multiplication by 1. This operation can be ignored:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUM){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  return true;
}
@
\fimcodigo

But if the operator is a symbol \monoespaco{-}, hen this means a
multiplication by -1:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUBTRACT){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  result -> value *= -1;
  return true;
}
@
\fimcodigo

4) In the remaining cases, we have a scalar multiplicationwhere the
scalar is a primary numeric token that is not followed
by \monoespaco{+}, \monoespaco{-} or another numeric token. To deal
with this, we needto identify the beginning and end of the primary
numeric token. BY the rules it is a single numeric token, or three
tokens (two numeric ones separated by a \monoespaco{/}). After
separating the parts, the first part is multiplied by the second (a
numeric primary expression):

\iniciocodigo
@<Numeric Primary: Rule 4@>=
else{
  bool ret;
  float token_value;
  struct generic_token *after_token;
  if(begin_expression -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  token_value = ((struct numeric_token *) begin_expression) -> value;
  after_token = (struct generic_token *) (begin_expression -> next);
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    after_token = (struct generic_token *) (after_token -> next);
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = (struct generic_token *) (after_token -> next);
  }
  ret = eval_numeric_primary(mf, cx, after_token, end_expression, result);
  if(!ret)
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Isolated Numbers and Random Normal Values}

The final rules for numeric expressions are:

\alinhaverbatim
<Numeric Atom> -> <Numeric Variable> |
                  <Primary Numeric Token> |
                  ( <Numeric Expression> ) |
                  normaldeviate
\alinhanormal

The only new token in this part is \monoespaco{normaldeviate}:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_NORMALDEVIATE  39 // O token simbólico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"normaldeviate",
@
\fimcodigo

This operator creates a new random number taken from a n ormal
distribution with mean 0 and standard deviation 1.

The function that evaluates numeric atoms is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result);
@
\fimcodigo

We will decide which rule to apply while evaluating the numeric atom
first checking if we have a single token or not, and then applying
different rules based on this:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result){
  if(begin_expression == end_expression){
    @<Numeric Atom: Rule 1@>
    @<Numeric Atom: Rule 2@>
    @<Numeric Atom: Rule 3@>
  }
  else{
    @<Numeric Atom: Rule 4@>
    @<Numeric Atom: Rule 5@>
  }
  return true;
}
@

1) If we have a single token and it is a numeric token, we just return
its value:

\iniciocodigo
@<Numeric Atom: Rule 1@>=
if(begin_expression -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin_expression) -> value;
  return true;
}
@
\fimcodigo

2) If we have a single token and it is a variable, we return its
content. But we first need to check if the variable was declared, if
it is numeric and if it was initialized:

\iniciocodigo
@<Numeric Atom: Rule 2@>=
if(begin_expression -> type == TYPE_SYMBOLIC){
  struct numeric_variable *var;
  var = ((struct symbolic_token *) begin_expression) -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric variable "
            "'%s' in numeric expression.\n", mf -> file,
            begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(isnan(var -> value)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

3) Finally, if we have a single token and it is
a \monoespaco{normaldeviate}, then we need to generate a random number
taken from a normal distribution. Given that we already have a
function to generate random bits, we can simulate a normal
distribution following these steps:

a) First we generate two random numbers between -1 and 1. We will call
them $u$ and $v$. e can generate them getting 64 random bits,
multiplying the first 63 by $2^{-63}$ and using the remaining bit to
choose the signal. The result is sufficiently close to uniform.

b) If $u^2+v^2\geq 1$, the numbers form a point outside a circle with
radius 1. In this case, the result should be discarded and we try to
generate numbers again. We also discard the result if both numbers are
zero, as in this case our method do not work.

c) After this, we can produce two numbers following a normal
distribution computing:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

One of the values will be returned. The other can be stored to be
returned next time we need a random normal value. We store it in the
Metafont struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Initially the structure will have no value stored. We will store
values there only after using the procedure descrbed above:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

So, when we need to generate a normal rando value, we always check
first if we already have a pre-generated value, and if not, we
generate two values:

\iniciocodigo
@<Numeric Atom: Rule 3@>=
if(begin_expression -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    random_bits = random_func();
    do{
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Now the cases where we have more than one token. If the first token
in ``('' and the last one is ``)'', we compute the inner expression as
a numeric expression, and then return the result discarding the
parenthesis:

\iniciocodigo
@<Numeric Atom: Rule 4@>=
if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
   end_expression -> type == TYPE_CLOSE_PARENTHESIS){
   bool ret;
   struct generic_token *p = begin_expression;
   while(p -> next != end_expression)
     p = (struct generic_token *) p -> next;
   if(p == begin_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.",
            mf -> file, begin_expression -> line);
#endif
     return false;
   }
   ret = eval_numeric_expression(mf, cx, (struct generic_token *)
                                         begin_expression -> next, p,
                                         result);
   if(!ret)
     return false;
   return true;
}
@
\fimcodigo

5) Finally, the case when the numeric atom is a fraction composed by a
numeric token, \monoespaco{/} and another numeric token. The result is
obtained dividing both tokens:

\iniciocodigo
@<Numeric Atom: Rule 5@>=
if(begin_expression -> type == TYPE_NUMERIC &&
   end_expression -> type == TYPE_NUMERIC &&
   ((struct generic_token * ) begin_expression -> next) -> type ==
   TYPE_DIVISION){
  result -> value = ((struct numeric_token *) begin_expression) -> value /
           ((struct numeric_token *) end_expression) -> value;
  return true;
}
@
\fimcodigo

\subsecao{8.2. Pair Assignments and Expressions}

To make the assignment to pair variables, we use the code below:

\iniciocodigo
@<Assignment for Pair Variables@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pair_variable((struct pair_variable *) var -> var, &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The declaration for the assignment function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source){
  target -> x = source -> x;
  target -> y = source -> y;
}
@
\fimcodigo

Now let's see how to evaluate  pair expressions.

\subsubsecao{8.2.1. Sum and Subtraction}

The grammar rules for pair tertiary expressions begin with sum and
subtraction:

\alinhaverbatim
<Pair Expression> -> <Pair Tertiary>
<Pair Tertiary> -> <Pair Secundary> | (...) |
                   <Pair Tertiary> <PT-Op> <Pair Secundary>
<PT-Op> -> + | -
\alinhanormal

Sum and subtraction is evaluated exactly as expected from vector sum
and subtraction.

The function that evaluates pair expressions is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result);
@
\fimcodigo

The method to evaluate tertiary pair expressions are not different
from what we already defined with numeric expressions. We just have
fewer tertiary operators here.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secundary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct pair_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secundary = (struct generic_token *) (last_sum -> next);
    eval_pair_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_pair_secundary(mf, cx, begin_secundary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM){
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else
    return eval_pair_secundary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.2.2. Transformers and Scalar Multiplication and Division}

The grammar for secundary pair expressions is:

\alinhaverbatim
<Pair Secundary> -> <Pair Primary> |
                    <Pair Secundary><Mul or Div><Numeric Primary> |
                    <Numeric Secundary> * <Pair Primary> |
                    <Pair Secundary><Transformer>
<Mul or Div> -> * | /
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary>
\alinhanormal

Let's add the seven new keywords representing transformers:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_ROTATED  40 // Symbolic token 'rotated'
#define TYPE_SCALED   41 // Symbolic token 'scaled'
#define TYPE_SHIFTED  42 // Symbolic token 'shifted'
#define TYPE_SLANTED  43 // Symbolic token 'slanted'
#define TYPE_XSCALED  44 // Symbolic token 'xscaled'
#define TYPE_YSCALED  45 // Symbolic token 'yscaled'
#define TYPE_ZSCALED  46 // Symbolic token 'zscaled'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo


The function that evaluates secundary pair expressions is declared
below:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_secundary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct pair_variable *result);
@
\fimcodigo

Evaluating a secundary expression here is very similar to what we did
for numeric expressions. We also walk over the token list searching
for the rightmost secundary operator, ignoring anything nested inside
parenthesis and brackets. We follow the same rules to check when we
have a division and when the symbol \monoespaco{/} is just a fraction
separator. The difference is that here we have a total of nine
secundary operators including the transformers. Because of the big
quantity, we will show each of them separately instead of all them in
the code block below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct pair_variable *result){
  struct generic_token *end_secundary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ //  Divisão ou operadores válidos
         last_mul = p;
         end_secundary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secundary != NULL){
    bool ret;
    begin_primary = (struct generic_token *) (last_mul -> next);
    @<Secundary Pair Operator: Multiplication@>
    @<Secundary Pair Operator: Division@>
    @<Secundary Pair Operator: Rotation@>
    @<Secundary Pair Operator: Scaling@>
    @<Secundary Pair Operator: Shifting@>
    @<Secundary Pair Operator: Slanting@>
    @<Secundary Pair Operator: X-Scaling@>
    @<Secundary Pair Operator: Y-Scaling@>
    @<Secundary Pair Operator: Z-Scaling@>
  }
  else
    return eval_pair_primary(mf, cx, begin_expression,
                             end_expression, result);
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

The first operator is the multiplication. Notice that we can have two
different multiplications: a pair multiplicated by a numeric or a
numeric multiplicated by a pair. To identify which of the two should
be applied, we must check the primary expression to the right of the
operator. It is a primary expression and we have a function that
identifies the type of a primary expression:

\iniciocodigo
@<Secundary Pair Operator: Multiplication@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end_expression) ==
     TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    if(!eval_numeric_secundary(mf, cx, begin_expression, end_secundary,
                               &a))
      return false;
    if(!eval_pair_primary(mf, cx, begin_primary, end_expression, &b))
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary,
                              &a);
    if(!ret)
      return false;
    ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }
}
@
\fimcodigo

If we have a division, then this always will be a pair divided by a
numeric. We should generate an error in case of division by zero:

\iniciocodigo
@<Secundary Pair Operator: Division@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.",
            mf -> file, last_mul -> line);
#endif
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

If we have a rotation, we rotate our pair counter-clockwise using the
origin as the axis. We interpret angles in degrees, not in radians:

\iniciocodigo
@<Secundary Pair Operator: Rotation@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  theta = 0.0174533 * b.value;
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

A scaling is the same thing than a multiplication:

\iniciocodigo
@<Secundary Pair Operator: Scaling@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

A shifting is equal a sum, but this operator have a higher precedence:

\iniciocodigo
@<Secundary Pair Operator: Shifting@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

The slanting operator shifts a point more to the right depending on
how above the axis $x$ it is and more to the left depending on how
below the axis $x$ it is:

\iniciocodigo
@<Secundary Pair Operator: Slanting@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

A x-scaling multiplies a numeric scalar to the first value in the
pair:

\iniciocodigo
@<Secundary Pair Operator: X-Scaling@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Likewise a y-scaling multiplies a numeric scalar to the second value
in the pair:

\iniciocodigo
@<Secundary Pair Operator: Y-Scaling@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Finally, a z-scaling interprets two pairs as complex numbers and
multiply them:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Secundary Pair Operator: Z-Scaling@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Pair Intermediary Values, Literals and Variables}

The final grammar rules for pair expressions are:

\alinhaverbatim
<Pair Primary> -> <Pair Variable> |
                  ( <Numeric Expression> , <Numeric Expression> ) |
                  ( <Pair Expression> ) |
                  <Numeric Atom> [ <Pair Expression, <Pair Expression>] |
                  (...) |
                  <Scalar Multiplication Operator><Pair Primary>
\alinhanormal

The novel operator is the constructionn $a[b, c]$, where $b$ and $c$
are pairs. It represents intermediary values between $b$ end $c$. It
is evaluated as $a(b+c)$. This means that $.5[a,b]$ is half the path
between $b$ and $c$.

The other rules are analogous to what we already described in the
grammar for numeric expressions.

The function that will evaluate pair primary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result);
@
\fimcodigo

Each one of the five grammar rules will be tested separately to
discover which one we should apply when we find a primary expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result){
  if(begin_expression == end_expression){
    @<Pair Primary: Rule 1@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Pair Primary: Rule 2@>
    @<Pair Primary: Rule 3@>
  }
  @<Pair Primary: Rule 4@>
  @<Pair Primary: Rule 5@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

The first rule will be applied when we have a single token in the
expression. The only case when it happens is when we are evaluating a
pair variable:

\iniciocodigo
@<Pair Primary: Rule 1@>=
if(begin_expression == end_expression){
  struct symbolic_token *tok = (struct symbolic_token *) begin_expression;
  struct pair_variable *var;
  if(tok -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable token "
            "in pair expression.",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
  var = (struct pair_variable *) tok -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            tok -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_PAIR){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-pair variable "
            "'%s' in pair expression.\n", mf -> file,
            begin_expression -> line, tok -> value);
#endif
    return false;
  }
  result -> x = var -> x;
  result -> y = var -> y;
  return true;
}
@
\fimcodigo

If the expression is delimited by parenthesis, we could be facing a
literal representation of a pair in the form $(a, b)$, or we could be
dealing with a pair expression inside parenthesis. We can
differentiate the two cases checking the presence of a comma inside
the parenthesis, but not inside any other internal parenthesis or
bracket.

\iniciocodigo
@<Pair Primary: Rule 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  begin_a = (struct generic_token *) begin_expression -> next;
  end_a = begin_a;
  DECLARE_NESTING_CONTROL();
  bool literal = true;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    bool ret;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    ret = eval_numeric_expression(mf, cx, begin_a, end_a, &a);
    if(!ret)
      return false;
    ret = eval_numeric_expression(mf, cx, begin_b, end_b, &b);
    if(!ret)
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

In the code above we identify if we are dealing with a literal
checking for a comma and we set in the boolean
variable \monoespaco{literal} if we found it. If this variable is not
true, immediately after the last \monoespaco{if} above, we run the
following \monoespaco{else} as the next rule:

\iniciocodigo
@<Pair Primary: Rule 3@>=
else{
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
}
@
\fimcodigo

If the last token is a \monoespaco{]}, then we have a construction of
type $a[b,c]$. Our task is separate the three parts $a$, $b$ and $c$, evaluate them and return $a(b+c)$:

\iniciocodigo
@<Pair Primary: Rule 4@>=
if(end_expression -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  DECLARE_NESTING_CONTROL();
  begin_a = begin_expression;
  end_a = begin_a;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type ==
        TYPE_OPEN_BRACKETS)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_b = (struct generic_token *) end_a -> next;
  begin_b = (struct generic_token *) begin_b -> next;
  if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_b = begin_b;
  while(end_b != end_expression){
    COUNT_NESTING(end_b);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_b -> next) -> type == TYPE_COMMA)
      break;
    if(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_c = (struct generic_token *) end_b -> next;
  begin_c = (struct generic_token *) begin_c -> next;
  if(begin_c == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_c = begin_c;
  while(end_c -> next != end_expression)
    end_c = (struct generic_token *) end_c -> next;
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c))
    return false;
  result -> x = (b.x + c.x) * a.value;
  result -> y = (b.y + c.y) * a.value;
  return true;
}
@
\fimcodigo

The last rule is when we have a scalar multiplication operator. The
operator can be \monoespaco{+}, \monoespaco{-}, a single numeric token
or a fraction:

\iniciocodigo
@<Pair Primary: Rule 5@>=
else{
  bool ret;
  if(begin_expression -> type == TYPE_SUM)
    return eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
  else if(begin_expression -> type == TYPE_SUBTRACT){
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin_expression -> type == TYPE_NUMERIC){
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin_expression) -> value;
    tok = (struct generic_token *) begin_expression -> next;
    if(tok -> type == TYPE_DIVISION){
      tok = (struct generic_token *) begin_expression -> next;
      if(tok == end_expression || tok -> next == end_expression ||
         tok -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "expression.\n ", mf -> file, begin_expression -> line);
#endif
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = (struct generic_token *) tok -> next;
    }
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pairs in Numeric Expressions}

Numeric subexpressions can appear inside pair expressions. For
example, in $a[b,c]$, $a$ is a numeric atom. Likewise, pair
subexpressions can appear inside numeric expressions. We did not
define this in the section about numeric expressions because we still
had not defined how to evaluate pair expressions. There are four
numeric primary operators involving pairs:

\alinhaverbatim
<Numeric Primary> -> length <Pair Primary> | xpart <Pair Primary> |
                       ypart <Pair Primary> | angle <Pair Primary>
\alinhanormal

This require defining the following three new token types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_XPART  47 // Symbolic token 'xpart'
#define TYPE_YPART  48 // Symbolic token 'ypart'
#define TYPE_ANGLE  49 // Symbolic token 'angle'
@
\fimcodigo

They correspond to the following keywords:

\iniciocodigo
@<List of Keywords@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

The first case, which did not need a new token, othe
operator \monoespaco{length} was already being used to get the modulus
of a given number and we had written that it could be used on other
types, not only in numerics. In the case of pairs, this operators
returns the euclidean norm:

\iniciocodigo
@<Evaluate 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) hypot(p.x * p.x, p.y * p.y);
  return true;
}
@
\fimcodigo

The operator \monoespaco{xpart} returns the first value in a pair:

\iniciocodigo
@<Numeric Primary: Additional Operators@>=
else if(begin_expression -> type == TYPE_XPART){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = p.x;
  return true;
}
@
\fimcodigo

While the operator \monoespaco{ypart} returns the second value in a
pair:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_YPART){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = p.y;
  return true;
}
@
\fimcodigo

Finally, the last operator, \monoespaco{angle}, measure the angle of a
pair. Which means the angle between the segment that connects the
origin to the pair coordintate and the segment that connects the
origin to $(1,0)$. An error will be generated if you try to measure
the angle of $(0,0)$:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Measuring the angle "
            "of (0,0).\n ", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = (float) asin(p.y / (hypot(p.x * p.x, p.y * p.y)));
  result -> value *= 57.2958; // Radianos para graus
  return true;
}
@
\fimcodigo

\subsecao{8.3. Path Assignments and Expressions}

To assign a path to a variable with the right type, we use the
following code:

\iniciocodigo
@<Assignment for Path Variables@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  if(!eval_path_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_path_variable(mf, (struct path_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &result, false);
}
@
\fimcodigo

The declaration for the assignment function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source){
  int i;
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> length != -1 && disalloc != NULL)
    path_recursive_free(disalloc, target, false);
  target -> cyclic = source -> cyclic;
  target -> length = source -> length;
  target -> points = (struct path_points *)
                       alloc(sizeof(struct path_points) *
                       target -> length);
  for(i = 0; i < target -> length; i ++){ // Copiar pontos
    memcpy(&(target -> points[i]), &(source -> points[i]),
           sizeof(struct path_points));
    if(source -> points[i].subpath != NULL)
      recursive_copy_points(alloc, (struct path_variable **)
                                   &(target -> points[i].subpath),
                            source -> points[i].subpath);
  }
}
@
\fimcodigo

Copying a path recursively means allocating space for the new path and
copying the data. While copying the points, we should also check if
there are other subpaths that should be copyied recursively. To do
this, we use the following auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source){
  int i;
  *target = (struct path_variable *) alloc(sizeof(struct path_variable));
  (*target) -> cyclic = source -> cyclic;
  (*target) -> length = source -> length;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> length);
  for(i = 0; i < (*target) -> length; i ++){
    memcpy(&((*target) -> points[i]), &(source -> points[i]),
           sizeof(struct path_points));
    if(source -> points[i].subpath != NULL)
      recursive_copy_points(alloc, (struct path_variable **)
                                   &((*target) -> points[i].subpath),
                            source -> points[i].subpath);
  }
}
@
\fimcodigo

Now we can examine the path expressions.

\subsubsecao{8.3.1. Joining Paths}

The grammar for path expressions begin with:

\alinhaverbatim
<Path Expression> -> <Pair Expression> | <Path Tertiary> |
                     <Path Subexpression><Direction Specifier> |
                     <Path Subexpression><Path Join> cycle
<Path Join> -> <Direction Specifier><Basic Join><Direction Specifier>
<Basic Join> -> & | .. | .. <Tension> .. | .. <Controls> ..
<Tension> -> tension <Tension Amount> |
             tension <Tension Amount> and <Tension Amount>
<Tension Amount> -> <Numeric Primary> | atleast <Numeric Primary>
<Controls> -> controls <Pair Primary> |
              controls <Pair Primary> and <Pair Primary>
<Direction Specifier> -> Empty |
                         { <Pair Expression } |
                         { <Numeric Expression> , <Numeric Expression> }
<Path Subexpression> -> <Path Expression> |
                        <Path Subexpression><Path Join><Path Tertiary>
\alinhanormal

This requires the register of these new types of tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_CYCLE          50 // Symbolic token 'cycle'
#define TYPE_AMPERSAND      51 // Symbolic token '&'
#define TYPE_JOIN           52 // Symbolic token '..'
#define TYPE_TENSION        53 // Symbolic token 'tension'
#define TYPE_AND            54 // Symbolic token 'and'
#define TYPE_ATLEAST        55 // Symbolic token 'atleast'
#define TYPE_CONTROLS       56 // Symbolic token 'controls'
#define TYPE_CURL           57 // Symbolic token 'curl' (still not supported)
@
\fimcodigo

And for each one we register a new correspondent keyword:

\iniciocodigo
@<List of Keywords@>+=
"cycle", "&", "..", "tension", "and", "atleast", "controls", "curl",
@
\fimcodigo

The first thing that we will define is how to count the number of
joins in a path expression. For this we will use the following
function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end);
@
\fimcodigo

The function works counting the number of ``\&'' and also counting the
``..'' that appear alone or that appear for the second time in a join
that specifies tension or control points:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end){
int count = 0;
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin;
  while(p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_AMPERSAND)
        count ++;
      else if(p -> type == TYPE_JOIN){
        struct generic_token *next = (struct generic_token *) p -> next;
        if(p == end || (next -> type !=  TYPE_TENSION &&
                        next -> type != TYPE_CONTROLS))
          count ++;
      }
    }
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }
  return count;
}
@
\fimcodigo

Now we can begin the expression evaluation.

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result);
@
\fimcodigo

Knowing the number of joins is the first step to discover the size of
our new variable and how should we allocate space for it. The number
of points is always the number of joins plus one:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result){
  int expected_length;
  int number_of_joins = count_path_joins(begin_expression, end_expression);
  expected_length = number_of_joins + 1;
  @<Path Expression: When There is No Joins@>
  @<Path Expression: Allocating Path Variable@>
  @<Path Expression: Iterating over Joins@>
  return false;
}
@
\fimcodigo

And what if the number of joins is zero? In this case we could have a
pair expression or a path tertiary expression. Anyway, we could have
in the end a direction specifier, which should be ignored in the case
of a single point or element without a join. We check if we have a
direction specifier checking if the last token is ``$\}$''. In this case,
we change the position of the end of expression for the last token
before the direction specifier:

\iniciocodigo
@<Path Expression: When There is No Joins@>=
if(number_of_joins == 0){
  if(end_expression -> type == TYPE_CLOSE_BRACES){
    struct generic_token *p = begin_expression;
    DECLARE_NESTING_CONTROL();
    while(p != end_expression){
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() &&
         ((struct generic_token *) p -> next) -> type == TYPE_OPEN_BRACES)
        break;
      p = (struct generic_token *) p -> next;
    }
    end_expression = p;
  }
  return eval_path_tertiary(mf, cx, begin_expression, end_expression,
                           result);
}
@
\fimcodigo

If there are one or more joins, then we need to allocate the new
points in our path variable. The number of allocated points is given
by variable \monoespaco{expected\_length}:

\iniciocodigo
@<Path Expression: Allocating Path Variable@>=
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points) *
                     expected_length);
if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
          begin_expression -> line);
#endif
    return false;
}
result -> length = 0; // Initialization
result -> points[0].x = NAN;
@
\fimcodigo

Now we will evaluate the joins. We need to iterate over all the tokens
finding the joins in the format:

$$
z_1{d} j {e}\_2
$$

Therefore, we need variables to store the begin and end of each part
while we perform the iteration. And then we create a loop where we
will iterate over each join in the format above:

\iniciocodigo
@<Path Expression: Iterating over Joins@>=
{
  struct generic_token *begin_z1, *end_z1 = NULL, *begin_z2, *end_z2;
  struct generic_token *begin_d = NULL, *end_d = NULL, *begin_e, *end_e;
  struct generic_token * begin_j, *end_j;
  struct path_points *z1_point = NULL, *z2_point = NULL;
  @<Path Expression: Additional Variables Declaration@>
  begin_z1 = begin_expression;
  while(begin_z1 != end_expression || result -> length < expected_length){
    @<Path Expression: Delimit Join Tokens@>
    @<Path Expression: Interpret Join Extremities@>
    @<Path Expression: Interpret Direction Specifiers@>
    @<Path Expression: Interpret the Join@>
    @<Path Expression: Determine Curve Shape@>
    @<Path Expression: End of Each Iteration@>
    begin_z1 = begin_z2;
    end_z1 = end_z2;
  }
}
@
\fimcodigo

We need to delimit the first element $z_1$ only in the first
iteration, when we are still in the beginning of the expression. In
the other iterations the element is already delimited in the beginning
as seen in the code above. To correctly delimit the token, we just
walk over the token list until we find the last token before ``$\{$'',
``\&'' or ``..'' assuming that we are not inside parenthesis or
brackets.

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>=
if(begin_z1 == begin_expression){
  DECLARE_NESTING_CONTROL();
  int next_type;
  end_z1 = begin_z1;
  while(end_z1 != end_expression){
    COUNT_NESTING(end_z1);
    next_type = ((struct generic_token *) end_z1 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND))
      break;
    end_z1 = (struct generic_token *) end_z1 -> next;
  }
}
@
\fimcodigo

Now we will delimit the first direction specifier. First we check if
we are in the end of an expression. If so, we interrupt the loop and
exit, as there are no more specifiers and we finished to read and
obtain the path. Otherwise, we read the next token to check if we have
a ``$\{$''. If not, there is no first direction specifier.  If so, then
we delimit it until finding the closing ``$\}$'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_z1 == end_expression)
  return true;
begin_d = (struct generic_token *) end_z1 -> next;
if(begin_d -> type != TYPE_OPEN_BRACES){
  begin_d = NULL;
  end_d = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_d = begin_d;
  while(end_d != end_expression){
    COUNT_NESTING(end_d);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) (end_d -> next)) -> type == TYPE_CLOSE_BRACES)
      break;
    end_d = (struct generic_token *) end_d -> next;
  }
  if(end_d != end_expression)
    end_d = (struct generic_token *) end_d -> next;
  if(begin_d == end_d){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_d -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Now we will delimit the join. If the join is ``\&'', then it is a
single token. If the join begins with ``..'', then it could be a
single token if the next token is not ``\monoespaco{controls}'' or
``\monoespaco{tension}''. But if the next token is these specifiers,
then the join is delimited by the first ``..'' and the second ``..'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_d == NULL)
  begin_j = (struct generic_token *) end_z1 -> next;
else{
  if(end_d == end_expression)
    return true;
  begin_j = (struct generic_token *) end_d -> next;
}
end_j = begin_j;
if(begin_j -> type == TYPE_JOIN){
  struct generic_token *next_token;
  next_token = (struct generic_token *) begin_j -> next;
  if(next_token -> type == TYPE_CONTROLS || next_token -> type == TYPE_TENSION){
    DECLARE_NESTING_CONTROL();
    end_j = next_token;
    while(end_j != end_expression){
      COUNT_NESTING(end_j);
      if(IS_NOT_NESTED() && end_j -> type != TYPE_JOIN)
        break;
      end_j = (struct generic_token *) end_j -> next;
    }
  }
}
else if(begin_j -> type != TYPE_AMPERSAND){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, begin_f -> line);
#endif
  return false;
}
@
\fimcodigo

The next direction delimiter may exist or not, depending if the next
token is ``$\{$'':

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
if(end_j == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, end_f -> line);
#endif
  return false;
}
begin_e = (struct generic_token *) end_j -> next;
if(begin_e -> type != TYPE_OPEN_BRACES){
  begin_e = NULL;
  end_e = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_e = begin_e;
  while(end_e  != end_expression){
    COUNT_NESTING(end_e);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) (end_e -> next)) ->  type == TYPE_CLOSE_BRACES)
      break;
    end_e = (struct generic_token *) end_e -> next;
  }
  if(end_e != end_expression)
    end_e = (struct generic_token *) end_e -> next;
  if(begin_e == end_e){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_e -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Finally, the last join element is the next point or subpath joining
the previous one. This is always a tertiary path expression. This last
element will have its end delimited by an ampersand, opening braces or
by a join token:

\iniciocodigo
@<Path Expression: Delimit Join Tokens@>+=
{
  DECLARE_NESTING_CONTROL();
  int next_type;
  if(end_e == NULL)
    begin_z2 = (struct generic_token *) end_j -> next;
  else{
    if(end_e == end_expression)
      return true;
    begin_z2 = (struct generic_token *) end_e -> next;
  }
  end_z2 = begin_z2;
  while(end_z2 != end_expression){
    COUNT_NESTING(end_z2);
    next_type = ((struct generic_token *) end_z2 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND))
      break;
    end_z2 = (struct generic_token *) end_z2 -> next;
  }
}
@
\fimcodigo

Once we delimited each part of the join, now we need to interpret the
parts. First we will care about the extremity curve points. For this,
first we get the result of $z_1$, a path tertiary expression, and copy
it to our result. We need to do this only when we are in the beginning
of an expression, in the other cases we already interpreted this point
or subpath in the previous iteration:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>=
if(begin_z1 == begin_expression){
  bool ret;
  struct path_variable z1;
  ret = eval_path_tertiary(mf, cx, begin_z1, end_z1, &z1);
  if(!ret)
    return false;
  if(z1.length == 1 && z1.points[0].subpath == 0){
    result -> points[0].subpath = NULL;
    result -> points[0].x = z1.points[0].x;
    result -> points[0].y = z1.points[0].y;
  }
  else
    recursive_copy_points(temporary_alloc, (struct path_variable **)
                                           &(result -> points[0].subpath), &z1);
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z1, false);
}
@
\fimcodigo

And we need to do the same with $z_2$, the other extremity. But in
this case, we need to recall that the next point may be
a \monoespaco{cycle} token. If so, we copy the first point. Otherwise,
we interpret the value like we did for $z_1$:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  struct path_points *p = result -> points;
  while(p[0].subpath != NULL)
    p = ((struct path_variable *) p[0].subpath) -> points;
  result -> points[result -> length].subpath = NULL;
  result -> points[result -> length].x = p[0].x;
  result -> points[result -> length].y = p[0].y;
}
else{
  bool ret;
  struct path_variable z2;
  ret = eval_path_tertiary(mf, cx, begin_z2, end_z2, &z2);
  if(!ret)
    return false;
  if(z2.length == 1 && z2.points[0].subpath == 0){
    result -> points[result -> length].subpath = NULL;
    result -> points[result -> length].x = z2.points[0].x;
    result -> points[result -> length].y = z2.points[0].y;
  }
  else
    recursive_copy_points(temporary_alloc,
                         (struct path_variable **)
                         &(result -> points[result -> length].subpath), &z2);
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z2, false);
}
@
\fimcodigo

After running the code above, our result variable that stores the
expression result already has the extremity points from this join. But
we still do not have the control points. But before compute them, we
will set the pointers \monoespaco{z1\_point}
and \monoespaco{z2\_point} to point to the current extremity points of
the current join. We read this information from the
variable \monoespaco{result} that we are filling:

\iniciocodigo
@<Path Expression: Interpret Join Extremities@>+=
z1_point = &(result -> points[result -> length - 2]);
while(z1_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z1_point -> subpath;
  z1_point = &(p -> points[p -> length - 1]);
}
z2_point = &(result -> points[result -> length - 1]);
while(z2_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z2_point -> subpath;
  z2_point = &(p -> points[0]);
}
@
\fimcodigo

Now we need to interpret both direction specifiers. They can be empty
(which is equivalent to have direction $(0, 0)$) or they can be a pair
specifying a direction vector.

We will store them in the variables \monoespaco{(w0\_x,
w0\_y)} and \monoespaco{(w1\_x, w1\_y)}.  We also
will store the previous direction specifier from last iteration and
also we will reserve space to store the next direction specifier if we
need to peek it ahead of time. This could be necessary to take in
consideration a broader picture when deciding the curve shape:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>=
float w0_x = NAN, w0_y = NAN, w1_x = NAN, w1_y = NAN;
float prev_w_x = NAN, prev_w_y = NAN;
float next_w_x = NAN, next_w_y = NAN;
@
\fimcodigo

During this iteration where we are delimiting and interpreting the
join operator and its points, we need to reinitialize such values. The
current specifiers are set as null, except that if the previous
iteration stored a next specifier, this specifier is our first one and
we do not need to read it again. After this, the next value is
erased. And finally, after this, we read the second direction
specifier from the tokens:

\iniciocodigo
@<Path Expression: Interpret Direction Specifiers@>=
w0_x = w0_y = w1_x = w1_y = NAN;
if(!isnan(next_w_x)){
  w0_x = next_w_x;
  w0_y = next_w_y;
}
else if(!eval_direction_specifier(mf, cx, begin_d, end_d, &w0_x, &w0_y))
  return false;
next_w_x = next_w_y = NAN;
if(!eval_direction_specifier(mf, cx, begin_e, end_e, &w1_x, &w1_y))
  return false;
@
\fimcodigo

The function that evaluates direction specifiers is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y);
@
\fimcodigo

And the function works checking for 4 different cases: when there is
no direction specifier, when it is a curl specification, when it is a
direction specified by two numbers and when it is a direction
specified by a pair:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y){
  @<Direction Specifier: Case 1@>
  @<Direction Specifier: Case 2@>
  @<Direction Specifier: Case 3@>
  return false;
}
@
\fimcodigo

When a specifier does not exist, we store nothing and return letting
the values as indefinide:

\iniciocodigo
@<Direction Specifier: Case 1@>=
if(begin == NULL || end == NULL){
  return true;
}
@
\fimcodigo

Now we will check if we have the case ``$\{ a , b\}$'' where $a$ and
$b$ are numbers. To check for this case, we will try to delimit $a$
and $b$ searching for the comma. We will interpret this case only if
the comma is found:

\iniciocodigo
@<Direction Specifier: Case 2@>=
DECLARE_NESTING_CONTROL();
struct generic_token *begin_a, *end_a, *begin_b = NULL, *end_b;
begin_a = (struct generic_token *) begin -> next;
end_a = begin_a;
while(end_a -> next != end){
  COUNT_NESTING(end_a);
  if(IS_NOT_NESTED() && end_a -> type == TYPE_COMMA){
    begin_b = (struct generic_token *) end_a -> next;
    break;
  }
  end_a = (struct generic_token *) end_a -> next;
}
if(begin_b != NULL){
  struct numeric_variable a, b;
  end_b = begin_b;
  while(end_b -> next != end)
    end_b = (struct generic_token *) end_b -> next;
  if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(a.value != 0.0 || b.value != 0.0){
    *w_x = a.value;
    *w_y = b.value;
  }
  return true;
}
@
\fimcodigo

And finally, the last case, where we have an element $\{a\}$, where
$a$ is a pair expression. To deal with this case, recall that in the
previous case we already delimited $a$. If a comma was not found, we
did not delimited $b$, but still delimited $a$. Therefore, we can
interpret the tokens as a pair expression:

\iniciocodigo
@<Direction Specifier: Case 3@>=
else{ // if in the previous case there was no comma
  struct pair_variable a;
  if(!eval_pair_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(a.x != 0.0 || a.y != 0.0){
    *w_x = a.x;
    *w_y = a.y;
  }
  return true;
}
@
\fimcodigo

Now finally we will interpret the join itself. As the direction
specifier can be represented in two ways, as a direction vector or as
a curl, the join can be represented by two numbers representing the
tension or two pairs $u$ and $v$ representing directly the control
points. We will declare then variables that will hold these values:

\iniciocodigo
@<Path Expression: Interpret the Join@>=
float tension0 = NAN, tension1 = NAN, u_x = NAN, u_y = NAN, v_x = NAN,
      v_y = NAN;
bool atleast0 = false, atleast1 = false; // If our tension is just an inferior limit
@
\fimcodigo

First we will deal with the simplest cases. If our join is a
concatenation, characterized by the ``\&'' token, we are concatenating
tow points or (more probably) two sub-paths. In this case we should
check is the two joining points occupy the same place (which means
having a distance lesser than 0.00002). If not, we should raise an
error. If so, we create control points halfway between the two joining
points.

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
  double dif_x = z1_point -> x - z2_point -> x;
  double dif_y = z1_point -> y - z2_point -> y;
  if(hypot(dif_x * dif_x, dif_y * dif_y) > 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Concatenating discontinuous paths.\n",
            mf -> file, begin_f -> line);
#endif
    return false;
  }
  v_x = u_x = (z1_point -> x + z2_point -> x) / 2.0;
  v_y = u_y = (z1_point -> y + z2_point -> y) / 2.0;
}
@
\fimcodigo

If our join is composed just by the token ``..'', then it will be
defined as having a tension of exactly 1 and 1:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_JOIN){
  tension0 = 1.0;
  tension1 = 1.0;
  atleast0 = false;
  atleast1 = false;
}
@
\fimcodigo

The join could be specifying directly the control points in the form
``.. controls $c_0$ ..'' or ``.. controls $c_0$ and $c_1$ .. '', where
$c_0$ and $c_1$ are pair expressions. In this case we try to delimit
the values of $c_0$ and $c_1$ (if it exists) and use them directly as
control points. If $c_1$ does not exist, then we use as the second
control point a point equal $c_0$:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_c0, *end_c0, *begin_c1 = NULL, *end_c1 = NULL;
  struct pair_variable c0, c1;
  begin_c0 = (struct generic_token *) begin_j -> next;
  begin_c0 = (struct generic_token *) begin_c0 -> next;
  if(begin_c0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  end_c0 = begin_c0;
  while(end_c0 -> next != end_j){
    COUNT_NESTING(end_c0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_c0 -> next) -> type == TYPE_AND)
      break;
    end_c0 = (struct generic_token *) end_c0 -> next;
  }
  if(end_c0 -> next != end_j){
    begin_c1 = end_c0 -> next;
    begin_c1 = (struct generic_token *) begin_c1 -> next;
    if(begin_c1 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    end_c1 = begin_c1;
    while(end_c1 -> next != end_j)
      end_c1 = (struct generic_token *) end_c1 -> next;
  }
  if(!eval_pair_primary(mf, cx, begin_c0, end_c0, &c0))
    return false;
  u_x = c0.x;
  u_y = c0.y;
  if(begin_c1 != NULL){
    if(!eval_pair_primary(mf, cx, begin_c1, end_c1, &c1))
      return false;
     v_x = c1.x;
     v_y = c1.y;
  }
  else{
    v_x = c0.x;
    v_y = c0.y;
  }
}
@
\fimcodigo

The last join type have the format ``.. tension $t_0$ ..'' or
``.. tension $t_0$ and $t_1$ .. '' where $t_0$ and $t_1$ are primary
numeric expressions which could or not be preceded by the token
``\monoespaco{atleast}''. If just $t_0$ is defined but not $t_1$, we
assume that $t_1$ have the same value than $t_0$. We can then
interpret this join with the code below:


\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_TENSION){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_t0, *end_t0, *begin_t1 = NULL, *end_t1 = NULL;
  struct numeric_variable t0, t1;
  begin_t0 = (struct generic_token *) begin_j -> next;
  begin_t0 = (struct generic_token *) begin_t0 -> next;
  if(begin_t0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  if(begin_t0 == end_j ||
     (begin_t0 -> type == TYPE_ATLEAST && begin_t0 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  else
    atleast0 = false;
  end_t0 = begin_t0;
  while(end_t0 -> next != end_j){
    COUNT_NESTING(end_t0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_t0 -> next) -> type == TYPE_AND)
      break;
    end_t0 = (struct generic_token *) end_t0 -> next;
  }
  if(end_t0 -> next != end_j){
    begin_t1 = end_t0 -> next;
    begin_t1 = (struct generic_token *) begin_t1 -> next;
    if(begin_t1 == end_j ||
       (begin_t1 -> type == TYPE_ATLEAST && begin_t1 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    if(begin_t1 -> type == TYPE_ATLEAST){
      atleast1 = true;
      begin_t1 = (struct generic_token *) begin_t1 -> next;
    }
    else
      atleast1 = false;
    end_t1 = begin_t1;
    while(end_t1 -> next != end_j)
      end_t1 = (struct generic_token *) end_t1 -> next;
  }
  if(!eval_numeric_primary(mf, cx, begin_t0, end_t0, &t0))
    return false;
  tension0 = t0.value;
  if(begin_t1 != NULL){
    if(!eval_numeric_primary(mf, cx, begin_t1, end_t1, &t1))
      return false;
    tension1 = t1.value;
  }
  else{
    tension1 = t0.value;
  }
}
@
\fimcodigo

With this we already dealt with all the different join types. If we
could not interpret the join in any of the cases above, then we should
raise an error:

\iniciocodigo
@<Path Expression: Interpret the Join@>+=
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr,
          "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
          mf -> file, begin_j -> line);
#endif
  return false;
}
@
\fimcodigo

After interpreting the join, either we have a pair of control points,
in which case we do not need to do anything more to determine the
curve shape, or we havetwo numbers representing the curve tension. In
this case, it will be important to take into consideration the
direction specifiers to choose the final curve shape.

However, the direction specifiers could be empty. In this case, there
are several rules that we should follow to choose the default direction.

%The first rule is that in the beginning and end of a non-cyclic path,
%we always will have an implicit ``\monoespaco{$\{$curl 1$\}$}''.
%The same happens before and after a concatenation. Therefore:

%$$
%z_0 .. z_1 .. z_2 = \{\monoespaco{curl}\ 1\}z_0 .. z_1 .. z_2\{\monoespaco{curl}\ 1\}
%$$

%And also:

%$$
%.. z_n \& z_{n+1} .. = .. z_n\{\monoespaco{curl}\ 1\} \& \{\monoespaco{curl}\ 1\}z_{n+1} ..
%$$

%This means that in the first iteration, if we are not in a cyclic
%path, we need to consider that the previous direction specifier
%is \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>=
%if(begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE)
%  prev_curl = 1.0;
%
%\fimcodigo

%If we are in a concatenation, if ee have no direction specifier, then
%we consider them as \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>+=
%if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
%  if(isnan(curl0) && isnan(w0_x))
%    curl0 = 1.0;
%  if(isnan(curl1) && isnan(w1_x))
%    curl1 = 1.0;
%}
%
%\fimcodigo

%And finally, if we are not in a cyclic path and we do not have a
%direction specifier after the second current point, we must check if
%we are in the last path join. We check this looking at the tokens and
%looking if there are a next join after the second current point and
%before the end of the expression. If this is the last join, we
%consider the last delimiter as \monoespaco{curl 1}:

%\iniciocodigo
%<Path Expression: Determine Curve Shape>+=
%if(end_z1 == end_expression)
%  next_curl = 1.0;
%else if(end_expression -> type != TYPE_CYCLE &&
%        ((struct generic_token *) (end_z1 -> next)) -> type !=
%        TYPE_OPEN_BRACES){
%  bool last_join = true;
%  struct generic_token *p = (struct generic_token *) end_z1 -> next;
%  DECLARE_NESTING_CONTROL();
%  while(p != end_expression){
%    COUNT_NESTING(p);
%    if(IS_NOT_NESTED() &&
%       (p -> type == TYPE_AMPERSAND || p -> type == TYPE_JOIN)){
%      last_join = false;
%      break;
%    }
%    p = (struct generic_token *) p -> next;
%  }
%  if(last_join)
%    next_curl = 1.0;
%}
%
%\fimcodigo

%These rules by themselves do not do anything. The beginning and end
%points in a non-cyclic path are discontinuous, we do not need control
%points after them. Likewise, in a concatenation we have equal points
%joining. We do not need anything between them. However, these previous
%rules became relevant when combined with the next rules.

If there is a direction specifier after a point, but not before, we
copy the direction specifier. We do the same when there is a direction
specifier before, but not after it. Therefore:

$$
.. z_0 .. z_1\{d\} ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

And also:

$$
.. z_0 .. \{d\}z_1 ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

The cyclic nature of a path must be taken into consideration.

For the case where we want to copy the direction specifier in the left
side to the right side of a point, we need to preserve this value
between iterations. By our rules, it is important to preserve the
value only when we read it explicitly between braces. Then, when we
are in the end of each iteration, we preserve the specifier in these
cases, otherwise we erase it:

\iniciocodigo
@<Path Expression: End of Each Iteration@>=
if((begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE) ||
   (begin_j == end_j && begin_j -> type == TYPE_AMPERSAND) ||
   (begin_e != NULL && end_e != NULL)){
  prev_w_x = w1_x;
  prev_w_y = w1_y;
}
else{
  prev_w_x = NAN;
  prev_w_y = NAN;
}
@
\fimcodigo

Now to apply the rule where we copy the specifier from the left of a
point to its right, we use the code:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(w0_x) && isnan(w0_y)){
  w0_x = prev_w_x;
  w0_y = prev_w_y;
}
@
\fimcodigo

Now we copy the direction specifier from the right to the left. We do
this only if we already do not have a defined specifier and if the
specifier to the right is given explicitly between braces:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(w1_x) && isnan(w1_y)               ){
  if(end_z2 -> next != NULL && end_z2 != end_expression &&
     ((struct generic_token *) (end_z2 -> next)) -> type ==
     TYPE_OPEN_BRACES){
    struct generic_token *next0, *next1;
    DECLARE_NESTING_CONTROL();
    next0 = (struct generic_token *) end_z2 -> next;
    next1 = next0;
    while(next1 != end_expression){
      COUNT_NESTING(next1);
      if(IS_NOT_NESTED() && next1 -> type == TYPE_CLOSE_BRACES)
        break;
      next1 = (struct generic_token *) next1 -> next;
    }
    if(next0 -> type == TYPE_OPEN_BRACES && next1 -> type == TYPE_CLOSE_BRACES){
      if(!eval_direction_specifier(mf, cx, begin_e, end_e, &next_w_x,
                                   &next_w_y))
        return false;
      w1_x = next_w_x;
      w1_y = next_w_y;
    }
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
              mf -> file, begin_j -> line);
#endif
      return false;
    }
  }
}
@
\fimcodigo

But we also need to deal with the cyclic case. By the grammar rules,
there will be no direction specifier before the first point. But a
direction specifier can be placed before the token \monoespaco{cycle}
if it exists. And in this case, this specifier could be copied to the
right side of the first point. Likewise, the direction specifier can
be copied from the right side of the first point to the place before
the \monoespaco{cycle} token if we do not have an explicit specifier
there.

First the simplest case: there is an explicit direction specifier
after the first point in the beginning of a cyclic path. In this case,
we need to store it to use when choosing the last control points in
the curve. To store it, we will need the following new variables:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float first_w_x = NAN, first_w_y = NAN;
@
\fimcodigo

And then, in the first iteration over the joins, if we are in a cyclic
path and if exists an explicit specifier, we store it:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d != NULL && end_d != NULL){
  first_w_x = w0_x;
  first_w_y = w0_y;
}
@
\fimcodigo

After, when we arrive at the last iteration of a cyclic path, we will
take into account the stored value:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  if(!isnan(first_w_x) && isnan(w1_x)){
    w1_x = first_w_x;
    w1_y = first_w_y;
  }
}
@
\fimcodigo

To make copies in the opposite direction, when we are in the first
iteration, we need to look at the last join. First we walk over the
expression until the end (until finding \monoespaco{cycle}) always
storing the last direction specifier and the last join. If the
token \monoespaco{cycle} appear after the last specifier, then we need
to check its value and copy it.

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d == NULL && isnan(w0_x)){
  struct generic_token *begin_last_spec = NULL, *end_last_spec = NULL,
                       *last_join = NULL, *p;
  DECLARE_NESTING_CONTROL();
  p = end_z2;
  while(p != end_expression){
    if(IS_NOT_NESTED() && p -> type == TYPE_OPEN_BRACES)
      begin_last_spec = p;
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_CLOSE_BRACES)
        end_last_spec = p;
      else if(p -> type == TYPE_JOIN || p -> type == TYPE_AMPERSAND)
        last_join = p;
      else if(p -> type == TYPE_CYCLE)
        break;
    }
    p = (struct generic_token *) p -> next;
  }
  if(end_last_spec != NULL && end_last_spec -> next == p &&
     p -> type == TYPE_CYCLE){
    if(!eval_direction_specifier(mf, cx, begin_last_spec, end_last_spec,
                                 &w0_x, &w0_y))
      return false;
  }
  @<Code After Peeking the Last Join in Cyclic Path@>
}
@
\fimcodigo

The next rule applies when we have a join like:

\alinhaverbatim
.. z .. controls  u  and  v ..  = .. z{u-z} .. controls  u  and  v ..
\alinhanormal

And also:

\alinhaverbatim
.. controls u and v .. z =  .. controls u and v .. z{z-v} ..
\alinhanormal

But only if the result of subtracting the pairs $u-z$ and $z-v$ is
different than zero. If equal zero, we will raise an erros as we still
do not support this.

First the easiest case: the explicit control points appear before the
current join. In this case we already read these control points in the
previous iteration. We just need variables to store this control point:


\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float previous_point_x = NAN, previous_point_y = NAN;
@
\fimcodigo

If we have some value stored in these variables and if we do not have
an explicit direction specifier, then we generate our specifier with
the described rules. Just observe that we consider as equals points
whose distance is lesser or equal than 0.00002.

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_d == NULL && end_d == NULL && !isnan(previous_point_x) &&
   !isnan(previous_point_y) && isnan(w0_x)){
  w0_x = z1_point -> x - previous_point_x;
  w0_y = z1_point -> y - previous_point_y;
  if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

After possibly using the previous direction specifier, we do not need
it anymore and we can update the variables with current values for the
case that we need them in the next iteration:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  previous_point_x = v_x;
  previous_point_y = v_y;
}
else{
  previous_point_x = NAN;
  previous_point_y = NAN;
}
@
\fimcodigo

About the second direction specifier, if we still do not have a value,
we should check the next join and see if we find explicit control
points. If we find it, we read the first of these points, interpret it
and use its value like described in the rules above:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_e == NULL && end_e == NULL &&  isnan(w1_x) &&
   end_z1 != end_expression){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_point, *end_point;
  begin_point = (struct generic_token *) end_z1 -> next;
  while(begin_point != end_expression){
    COUNT_NESTING(begin_point);
    if(IS_NOT_NESTED() && (begin_point -> type == TYPE_JOIN ||
                          begin_point -> type == TYPE_AMPERSAND))
      break;
    begin_point = (struct generic_token *) begin_point -> next;
  }
  if(begin_point != end_expression && begin_point -> type != TYPE_AMPERSAND){
    begin_point = (struct generic_token *) begin_point -> next;
    if(begin_point != end_expression && begin_point -> type == TYPE_CONTROLS){
      begin_point = (struct generic_token *) begin_point -> next;
      end_point = begin_point;
      while(end_point != end_expression){
        struct generic_token *next = (struct generic_token *) end_point -> next;
        COUNT_NESTING(end_point);
        if(IS_NOT_NESTED() && next != NULL &&
           (next -> type == TYPE_AND || next -> type == TYPE_JOIN))
          break;
        end_point = (struct generic_token *) end_point -> next;
      }
      if(end_point != end_expression){
        struct pair_variable var;
        if(!eval_pair_primary(mf, cx, begin_point, end_point, &var))
          return false;
        w1_x = var.x - z2_point -> x;
        w1_y = var.y - z2_point -> y;
        if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                          "direction specifier.\n",  mf -> file,
                          begin_j -> line);
#endif
          return false;
        }
      }
    }
  }
}
@
\fimcodigo

Now let's deal with the cyclic case. If we are in the first iteration,
our path is cyclic and we have explicit control points, then we need
additional variables to store que explicit control point:

\iniciocodigo
@<Path Expression: Additional Variables Declaration@>+=
float first_point_x = NAN, first_point_y = NAN;
@
\fimcodigo

And we initialize the variable if necessary in the first iteration:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  first_point_x = u_x;
  first_point_y = u_y;
}
@
\fimcodigo

After, when we need to choose the shape of the join in the cyclic
extremity, we take into account the existance of this variable:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE && begin_d == NULL &&
   end_d == NULL && isnan(w1_x) && !isnan(first_point_x) && isnan(w1_x)){
  w1_x = first_point_x - z2_point -> x;
  w1_y = first_point_y - z2_point -> y;
  if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

And now the opposite direction. If we are in the first iteration in a
cyclic path, we peek the last join and check if we have explicit
control points to apply this rule. But in the previous rule we already
wrote code to peek between other things the last join. Therefore, we
can just append additional logic to the previous rule, after getting
the last join:


\iniciocodigo
@<Code After Peeking the Last Join in Cyclic Path@>=
if(last_join != NULL && last_join -> type == TYPE_JOIN){
  struct generic_token *p = (struct generic_token *) last_join -> next;
  if(p -> type == TYPE_CONTROLS){
    struct generic_token *p_end;
    p = (struct generic_token *) p -> next;
    p_end = p;
    while(p_end != end_expression){
      struct generic_token *next = (struct generic_token *) p_end -> next;
      COUNT_NESTING(p_end);
      if(IS_NOT_NESTED() && (next -> type == TYPE_JOIN ||
                             next -> type == TYPE_AND))
        break;
      p_end = next;
    }
    if(p_end != end_expression){
      struct pair_variable var;
      if(!eval_pair_primary(mf, cx, p, p_end, &var))
        return false;
      w0_x = z1_point -> x - var.x;
      w0_y = z1_point -> y - var.y;
      if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                        "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
        return false;
      }
    }
  }
}
@
\fimcodigo

After applying the rules, we expect to have either defined control
points or direction specifiers well-defined. If we have neither, we
raise an error and exit:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  if(isnan(w0_x) || isnan(w0_y) || isnan(w1_x) || isnan(w1_y)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

If no error happened, we either already have our control points or we
need to discover the control points having a path segment as below:

$$
z_n\{w_n\}..\ {\hskip2mm \monoespaco{tension}\hskip2mm } \alpha {\hskip2mm \monoespaco{and}\hskip2mm } \beta .. \{w_{n+1}\}z_{n+1}
$$

To compute the control points given these informations, we regard the
points as complex numbers and compute:

$$
\theta = arg(w_n/(z_{n+1}-z_n))
$$

$$
\phi = arg((z_{n+1}-z_n)/w_{n+1})
$$

Next we compute the control points $u$ and $v$ with:


$$
u = z_{n} + e^{i\theta}(z_{n+1}-z_n)f(\theta, \phi)/\alpha
$$

$$
v = z_{n+1} - e^{-i\phi}(z_{n+1}-z_n)f(\phi, \theta)/\beta
$$

Except when the keyword ``atleast'' is used. In this case, if
necessary, we increase the value of $\alpha$ or $\beta$ in a way that
the control points lies inside the triangle defined by the two
extremity points and the angles given by each direction specifier. If
the triangle is invalid, we keep the original tension values.

The function $f$ used above is defined as:

$$
f(\theta, \phi) = {{2+\sqrt{2}(\sin\theta-{{1}\over{16}}\sin\phi)(\sin\phi-{{1}\over{16}}\sin\theta)(\cos\theta-\cos\phi)}\over{3(1+{1\over 2}(\sqrt 5 - 1)\cos\theta+{1\over 2}(3-\sqrt 5)\cos\phi)}}
$$

First we will define it as an auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
double compute_f(double theta, double phi);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
double compute_f(double theta, double phi){
  double n = 2 + sqrt(2) * (sin(theta) - 0.0625 * sin(phi)) *
             (sin(phi) - 0.0625 * sin(theta)) * (cos(theta) - cos(phi));
  double d = 3 * (1 + 0.5 * (sqrt(5) - 1) * cos(theta) + 0.5 * (3 - sqrt(5)) *
                  cos(phi));
  return n/d;
}
@
\fimcodigo

Now we can compute the control points if we already do not know
them. As we should regard the points as complex numbers, we will need
the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <complex.h>
@
\fimcodigo

And with the help of the C99 functions to deal with complex numbers,
we compute the formula for the control points:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  double complex u, v;
  double complex z0 = z1_point -> x + z1_point -> y * I;
  double complex z1 = z2_point -> x + z2_point -> y * I;
  double theta = carg(z0 / (z1 - z0));
  double phi = carg((z1 - z0)/z1);
  u = z0 + (cexp(theta * I) * (z1 - z0) * compute_f(theta, phi)) / tension0;
  v = z1 - (cexp(-phi * I) * (z1 - z0) * compute_f(phi, theta)) / tension1;
  u_x = creal(u);
  u_y = cimag(u);
  v_x = creal(v);
  v_y = cimag(v);
  @<Adjust tension in case of 'atleast'@>
}
@
\fimcodigo

The first thing to compute is if we have a valid triangle. For this,
we first should check the internal angles. Given three pairs of
coordinates, where the first one is the vertex where we want to get
the angle, we can compute the angle there using the following
auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y){
  double v0_x, v0_y, v1_x, v1_y;
  v0_x = c0_x - v_x;
  v0_y = c0_y - v_y;
  v1_x = c1_x - v_x;
  v1_y = c1_y - v_y;
  if(fabs(v0_x) <= 0.00002 &&  fabs(v0_y) <= 0.00002)
    return INFINITY;
  if(fabs(v1_x) <= 0.00002 &&  fabs(v1_y) <= 0.00002)
    return INFINITY;
  return acos((v0_x * v1_x + v0_y * v1_y) /
                (hypot(v0_x * v0_x, v0_y * v0_y) *
                 hypot(v1_x * v1_x, v1_y * v1_y)));
}
@
\fimcodigo

Knowing how to measure the angles, we can check if the triangle is
valid. And with this we can write the function that checks if the
control points are inside the triangle. And if not, we correct its
coordinate. First we measure all the internal angles, then we get the
coordinates of the third vertex usinf the Law of Sines (the two other
vertices are known). The function is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y){
  double internal_angle0, internal_angle1, internal_angle2;
  double triangle_angle;
  double p2_x, p2_y;
  internal_angle0 = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + d0_x, p0_y + d0_y);
  internal_angle1 = get_angle(p1_x, p1_y, p0_x, p0_y, p1_x + d1_x, p1_y + d1_y);
  internal_angle2 = M_PI - internal_angle0 - internal_angle1;
  if(internal_angle0 + internal_angle1 >= M_PI - 0.00002)
    return; // Not a valid triangle
  { // Discover the third vertex coordinate:
    // First compute the triangle side that goes from p0 to the unknown vertex
    double known_side = hypot((p1_x - p0_x) * (p1_x - p0_x),
                              (p1_y - p0_y) * (p1_y - p0_y));
    double triangle_side = known_side * sin(internal_angle0) /
                           sin(internal_angle2);
    // Knowing the triangle side and the angle, we compute the coordinates:
    triangle_angle = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + 1.0, p0_y);
    p2_x = p0_x + triangle_side * cos(triangle_angle + internal_angle0);
    p2_y = p0_y + triangle_side * sin(triangle_angle + internal_angle0);
  }
  {
    @<Check if the point is inside the triangle@>
    @<If Not, Adjust the Tension@>
  }
}
@
\fimcodigo

How do we check that a point is inside a triangle? There are several
ways, what we will use is a technique that computes the signed area of
three triangles composed by the point and two of the vertex points
from the triangle, whose vertices we will pass always in the same
clockwise or counter-clockwise order. The signed area of a triangle is
its area, but the result is positive or negative, depending if we
passed the vertices in clockwise or counter-clockwise order. If all
the signed areas are positive, or if all them are negative, then the
point is inside the triangle. If not, the point is outside:

\iniciocodigo
@<Check if the point is inside the triangle@>=
bool s1, s2, s3; // O sinal das áreas
s1 = ((*control_x - p1_x) * (p0_y - p1_y) -
      (p0_x - p1_x) * (*control_y - p1_y)) < 0;
s2 = ((*control_x - p2_x) * (p1_y - p2_y) -
      (p1_x - p2_x) * (*control_y - p2_y)) < 0;
s3 = ((*control_x - p0_x) * (p2_y - p0_y) -
      (p2_x - p0_x) * (*control_y - p0_y)) < 0;
if(s1 == s2 && s2 == s3)
  return;
@
\fimcodigo

An advantage of the above method is that the signed area that have a
different sign than others represents the side which is near the
target point. Therefore, if we did not exit the function, we can check
the closest side, get its line equation and compute the nearest point
in the line. If the point is in the triangle side, this is the new
point or our control point. Otherwise, we choose the nearest vertex to
the point.

\iniciocodigo
@<If Not, Adjust the Tension@>=
{
  double x0, y0, x1, y1;
  if(s1 != s2 && s1 != s3){
    x0 = p0_x; y0 = p0_y;
    x1 = p1_x; y1 = p1_y;
  }
  else if(s2 != s1 && s2 != s3){
    x0 = p1_x; y0 = p1_y;
    x1 = p2_x; y1 = p2_y;
  }
  else{
    x0 = p2_x; y0 = p2_y;
    x1 = p0_x; y1 = p0_y;
  }
  if(x1 < x0){ // x1 must be >= x0 (assuming this the logic becames simpler)
    double tmp;
    tmp = x1; x1 = x0; x0 = tmp;
    tmp = y1; y1 = y0; y0 = tmp;
  }
  if(x0 == x1){ // Vertical line (do not use line equation, or we divide by zero)
    *control_x = x0;
    if(*control_y > y0 && *control_y > y1){
      if(y0 > y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
    else if(*control_y < y0 && *control_y < y1){
      if(y0 < y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
  }
  else if(y0 == y1) // Horizontal line
    *control_y = y0;
  else{ // Use line equation
    // m0 x + b0 = y is the line that contains the triangle side
    double m0 = (y1 - y0) / (x1 - x0);
    double b0 = y1 - m0 * x1;
    // m1 x + b1 = y is the perpendicular line that crosses the point
    double m1 = - m0;
    double b1 = *control_y - m1 * *control_x;
    *control_x = (b1 - b0) / (m0 - m1);
    *control_y = m0 * *control_x + b0;
  }
  if(*control_x > x1){
    *control_x = x1;
    *control_y = y1;
  }
  else if(*control_x < x0){
    *control_x = x0;
    *control_y = y0;
  }
}
@
\fimcodigo

This ends our function to adjust control points if we are adealing
with the ``\monoespaco{atleast}'' keyword. Now we can just use this
function if we are dealing with this case:

\iniciocodigo
@<Adjust tension in case of 'atleast'@>=
if(atleast0)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &u_x, &u_y);
if(atleast1)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &v_x, &v_y);
@
\fimcodigo

And with this we get the control points and we can update its value in
the path variable that we are building:

\iniciocodigo
@<Path Expression: Determine Curve Shape@>+=
result -> points[result -> length].u_x = u_x;
result -> points[result -> length].u_y = u_y;
result -> points[result -> length].v_x = v_x;
result -> points[result -> length].v_y = v_y;
@
\fimcodigo

This finalizes how a curve should be built given its points and
subpaths. Now we will see how we read the points and subpaths.

\subsubsecao{8.3.2. Tertiary Path Expressions}

The grammar for tertiary path expressions is:

\alinhaverbatim
<Path Tertiary> -> <Pair Tertiary> | <Path Secundary>
\alinhanormal

And it is only this. Therefore, to interpret a tertiary path
expression, we should walk over the expression and check if we find a
tertiary pair expression. If so, we should interpret the entire
expression like a pair expression. Otherwise, we interpret as a
secundary path expression. If we interpret the expression like a pair,
we should convert the result from a pair to a path with a single
point.

Anyway, after interpreting the expression and obtain a path as result,
we return the result.

The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  struct generic_token *p, *prev = NULL;
  bool this_expression_is_pair = false;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      this_expression_is_pair = true;
      break;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(this_expression_is_pair){
    struct pair_variable pair;
    if(!eval_pair_expression(mf, cx, begin_expression, end_expression,
                            &pair));
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> x = pair.x;
    result -> points -> y = pair.y;
    return true;
  }
  else
    return eval_path_secundary(mf, cx, begin_expression, end_expression,
                               result);
}
@
\fimcodigo

\subsubsecao{8.3.3. Secundary Path Expressions: Transformers}

The grammar for secundary path expressions is:

\alinhaverbatim
<Path Secundary> -> <Pair Secundary> | <Path Primary> |
                    <Path Secundary><Transformer>
\alinhanormal

The transformers are the same that were presented for pair
expressions. The first thing that we should test in theses expressions
is if we have a transformer at the end of the expression. If so, then
we should apply the last rule in the grammar above. If not, we should
check if we have a secundary pair operator (multiplication or
division). If so, we apply the second rule, treating the path
secundary expression as a pair secundary. Otherwise we apply the first
rule and interpret the expression as a primery path expression.

Applying a transformer to rotate, scale and others means applying the
transformation in each extremity point and each control point in the
path.

The declaration for the function that evaluates path secundary
expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_secundary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

And the implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_secundary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  bool have_transform = false, have_pair_operator = false;
  struct generic_token *p, *last_fraction = NULL, *transform_op = NULL,
                       *before_transform = NULL, *prev = NULL,
                       *prev_prev = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else if(p -> type == TYPE_DIVISION || p -> type == TYPE_MULTIPLICATION)
         have_pair_operator = true;
       else{
         have_transform = true;
         transform_op = p;
         before_transform = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(have_transform){
    if(transform_op -> next == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_path_secundary(mf, cx, begin_expression, before_transform, result))
      return false;
    @<Path Transform: Rotate@>
    @<Path Transform: Scale@>
    @<Path Transform: Shift@>
    @<Path Transform: Slant@>
    @<Path Transform: X-Scale@>
    @<Path Transform: Y-Scale@>
    @<Path Transform: Z-Scale@>
  }
  else if(have_pair_operator){
    struct pair_variable pair;
    if(!eval_pair_secundary(mf, cx, begin_expression, end_expression, &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> x = pair.x;
    result -> points -> y = pair.y;
    return true;    
  }
  else
    return eval_path_primary(mf, cx, begin_expression, end_expression,
                             result);
}
@
\fimcodigo

In the code above, when we check if we have a transformer in the
expression, we always store the last transformer in the
variable \monoespaco{transform\_op} and the last token before the
transformer in the variable \monoespaco{before\_transform}. This allow
us to divide the expression in its parts and interpret the code to
obtain the path to be transformed, as is shown above.

If we have a rotation, to interpret the totation transformer after we
got the path to be rotated in the \monoespaco{result} variable, we can
use the code below:

\iniciocodigo
@<Path Transform: Rotate@>=
if(transform_op -> type == TYPE_ROTATED){
  struct numeric_variable a;
  double theta, sin_theta, cos_theta;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  theta = 0.0174533 * a.value; // Converting degrees to radians
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  path_rotate(result, sin_theta, cos_theta);
  return true;
}
@
\fimcodigo

The code above assumes that we have a recursive function that applies
the rotation once we pass it the sine and cosine of the rotation
angle. We will use the function below for this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_rotate((struct path_variable *) (p -> points[i].subpath),
                  sin_theta, cos_theta);
    else{
      double x = p -> points[i].x, y = p -> points[i].y;
      p -> points[i].x = x * cos_theta - y * sin_theta;
      p -> points[i].y = x * sin_theta + y * cos_theta;
      x = p -> points[i].u_x;
      y = p -> points[i].u_y;
      p -> points[i].u_x = x * cos_theta - y * sin_theta;
      p -> points[i].u_y = x * sin_theta + y * cos_theta;
      x = p -> points[i].v_x;
      y = p -> points[i].v_y;
      p -> points[i].v_x = x * cos_theta - y * sin_theta;
      p -> points[i].v_y = x * sin_theta + y * cos_theta;
    }
  }
}
@
\fimcodigo

Now we will interpret the scaling operator. It shoult interpret a
numeric value and then multiply all points in the path by such value:

\iniciocodigo
@<Path Transform: Scale@>=
if(transform_op -> type == TYPE_SCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_xyscale(result, a.value, a.value);  
  return true;
}
@
\fimcodigo

The recursive function that applies this for every point in the path
is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y);
@
\fimcodigo

Notice that by the function signature we can pass different values to
stretch the path horizontally and vertically. This transformer
stretches the path always in the same proportion, but other
transformers will also use this function to stretch not preserving
proportions. Its implementation is:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_xyscale((struct path_variable *) (p -> points[i].subpath), x,
                   y);
    else{
      p -> points[i].x *= x;
      p -> points[i].y *= y;
      p -> points[i].u_x *= x;
      p -> points[i].u_y *= y;
      p -> points[i].v_x *= x;
      p -> points[i].v_y *= y;
    }
  }
}
@
\fimcodigo

The next transformer translate, or shift a given path. We first read a
pair and this pair sets how the path should be shifted in the $x$ and
$y$ axis:

\iniciocodigo
@<Path Transform: Shift@>=
if(transform_op -> type == TYPE_SHIFTED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_shift(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

And the recursive function that performs the shifting:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_shift((struct path_variable *) (p -> points[i].subpath), x, y);
    else{
      p -> points[i].x += x;
      p -> points[i].y += y;
      p -> points[i].u_x += x;
      p -> points[i].u_y += y;
      p -> points[i].v_x += x;
      p -> points[i].v_y += y;
    }
  }
}
@
\fimcodigo

Now to the slanting transformer. This transformer shifts to the right
the points based on how above the origin they are in tha $y$ axis and
shifts to the left based on how below the origin they are in the $y$
axis:

\iniciocodigo
@<Path Transform: Slant@>=
if(transform_op -> type == TYPE_SLANTED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_slant(result, a.value);  
  return true;
}
@
\fimcodigo

And the function that slants recursively:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_slant(struct path_variable *p, float s);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_slant(struct path_variable *p, float s){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_slant((struct path_variable *) (p -> points[i].subpath), s);
    else{
      p -> points[i].x += s * p -> points[i].y;
      p -> points[i].u_x += s * p -> points[i].u_y;
      p -> points[i].v_x += s * p -> points[i].v_y;
    }
  }
}
@
\fimcodigo


The next transformer change the horizontal size of the path while
preserving the vertical size. We need to read a numeric value and it
determines how much the path should be horizontally stretched:

\iniciocodigo
@<Path Transform: X-Scale@>=
else if(transform_op -> type == TYPE_XSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, a.value, 1.0);  
  return true;
}
@
\fimcodigo

Here we are using a recursive function already defined. We do not need
to redefine it again. And we also can stretch the path vertically:

\iniciocodigo
@<Path Transform: Y-Scale@>=
else if(transform_op -> type == TYPE_YSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, 1.0, a.value);  
  return true;
}
@
\fimcodigo

The last transformer is the Z-scale which reads a pair, interprets it
as a complex number, interpret all points in the path as complex
numbers and multiply them:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

We interpret and make the transformation below, remembering that this
is the last transformation and that an error should be raised if we
need to apply a transformation and this is not the correct:


\iniciocodigo
@<Path Transform: Z-Scale@>=
else if(transform_op -> type == TYPE_ZSCALED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_zscale(result, a.x, a.y);  
  return true;
}
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer\n",
          mf -> file, transform_op -> line);
#endif
  return false;
}
@
\fimcodigo

And the recursive function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_zscale((struct path_variable *) (p -> points[i].subpath),
                  x, y);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = x0 * x - y0 * y;
      p -> points[i].y = x0 * y + y0 * x;
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = x0 * x - y0 * y;
      p -> points[i].u_y = x0 * y + y0 * x;
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = x0 * x - y0 * y;
      p -> points[i].v_x = x0 * y + y0 * x;
    }
  }
}
@
\fimcodigo

\subsubsecao{8.3.4. Primary Path Expressions}

The grammar for primary path expressions is:

\alinhaverbatim
<Path Primary> -> <Pair Primary> | <Path Variable> |
                  ( <Path Expression> ) |
                  reverse <Path Primary> |
                  subpath <Pair Expression> of <Pair Primary>
\alinhanormal

This means that we need to register the new
tokens \monoespaco{reverse}, \monoespaco{subpath} and \monoespaco{of}:


\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_REVERSE        58 // O token simbólico 'reverse'
#define TYPE_SUBPATH        59 // O token simbólico 'subpath'
#define TYPE_OF             60 // O token simbólico 'of'
@
\fimcodigo

And for each one of them, we add its string to the list of reserved
words:

\iniciocodigo
@<List of Keywords@>+=
"reverse", "subpath", "of",
@
\fimcodigo

What the grammar rules say is that in the end of each path
expression,we will find a path variable, a parenthesis, some of these
new path operators or, in all other cases, a pair primary. Therefore,
we should first test these first cases and if we are not in one of
them, we are with a primary pair.

The function that will interpret primary path expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result){
  if(begin_expression -> type == TYPE_REVERSE){
    @<Primary Path: Reverse@>
  }
  else if(begin_expression -> type == TYPE_SUBPATH){
    @<Primary Path: Subpath@>
  }
  else if(begin_expression == end_expression &&
          begin_expression -> type == TYPE_SYMBOLIC){
    //@<Primary Path: Variable@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    //@<Primary Path: Parenthesis@>
  }
  else{
    //@<Primary Path: Primary Pair@>
  }
  return false;
}
@
\fimcodigo

The first case: we must compute the reverse of a path. For this, we
need to reverse the order for all exptremity points and for each one
of them, we need also to swap the two control points. We need to do
the reversion recursively inside the subpaths. The code for detecting
the path to be reversed and apply the reversion is:

\iniciocodigo
@<Primary Path: Reverse@>=
if(begin_expression -> next == NULL ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                      result))
  return false;
reverse_path(result);
return true;
@
\fimcodigo

We need now to define the function that makes the reversion. The
function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void reverse_path(struct path_variable *path);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void reverse_path(struct path_variable *path){
  struct path_points tmp;
  int i, iter = (path -> length) / 2;
  for(i = 0; i < iter; i ++){
    memcpy(&tmp, &(path -> points[i]), sizeof(struct path_points));
    memcpy(&(path -> points[i]),
           &(path -> points[path -> length - i - 1]),
           sizeof(struct path_points));
    memcpy(&(path -> points[path -> length - i - 1]), &tmp,
           sizeof(struct path_points));
    tmp.u_x = path -> points[i].u_x;
    tmp.u_y = path -> points[i].u_y;
    path -> points[i].u_x = path -> points[i].v_x;
    path -> points[i].u_y = path -> points[i].v_y;
    path -> points[i].v_x = tmp.u_x;
    path -> points[i].v_y = tmp.u_y;
    tmp.u_x = path -> points[path -> length - i - 1].u_x;
    tmp.u_y = path -> points[path -> length - i - 1].u_y;
    path -> points[path -> length - i - 1].u_x =
                              path -> points[path -> length - i - 1].v_x;
    path -> points[path -> length - i - 1].u_y =
                              path -> points[path -> length - i - 1].v_y;
    path -> points[path -> length - i - 1].v_x = tmp.u_x;
    path -> points[path -> length - i - 1].v_y = tmp.u_y;
    if(path -> points[i].subpath != NULL)
      reverse_path((struct path_variable *) path -> points[i].subpath);
    if(path -> points[path -> length - i - 1].subpath != NULL)
      reverse_path((struct path_variable *)
                   path -> points[path -> length - i - 1].subpath);
  }
}
@
\iniciocodigo

The next step is compute the subpath. In the original METAFONT, we
could pass non-integer point positions. For example, we could select a
subpath between the conrol points 0.5 and 1.8. With such positions,
METAFONT would generate new intermediary control points betwwen the
first and the second and between the second and third as
indicated. New extemity and control points would be generated. 'But as
this is a little messy computation, here we will support only subpaths
between integer positions.

\iniciocodigo
@<Primary Path: Subpath@>=
DECLARE_NESTING_CONTROL();
struct pair_variable a;
struct path_variable b;
struct generic_token *of, *end_pair_expr = begin_expression -> next;
struct generic_token *begin_subexpr;
if(begin_expression -> next == NULL ||
   end_pair_expr -> type == TYPE_OF ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
of = (struct generic_token *) (end_pair_expr -> next);
while((!IS_NOT_NESTED() || of -> type != TYPE_OF) && of != NULL &&
      of != end_expression){
  COUNT_NESTING(end_pair_expr);
  end_pair_expr = of;
  of = (struct generic_token *) (of -> next);
}
if(of == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_expression(mf, cx, (struct generic_token *) begin_expression -> next,
                         end_pair_expr, &a))
  return false;
begin_subexpr = of -> next;
if(!eval_path_primary(mf, cx, begin_subexpr, end_expression, &b))
  return false;
{
  int final_path_size;
  if(a.x < 0)
    a.x = 0;
  if(a.y < 0)
    a.y = 0;
  if(a.x >= result -> length)
    a.x = result -> length - 1;
  if(a.y >= result -> length)
    a.y = result -> length - 1;
  final_path_size = a.y - a.x;
  if(final_path_size < 0)
    final_path_size *= -1;
  final_path_size ++;
  result -> length = final_path_size;
  result -> points = (struct path_points *)
                       temporary_alloc(final_path_size *
                                       sizeof(struct path_points));
  if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  recursive_copy_subpath(result -> points, &b, (a.x <= a.y)?(a.x):(a.y),
                         final_path_size);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  if(a.x > a.y)
    reverse_path(result);
  return true;
}
@
\fimcodigo

We need now to present the function that will recursively copy a path
to another path. The origin path can have recursive subpaths while the
destiny path is flat, have no recursive subpaths and already had its
memory allocated. The destiny address is a pointer to path points
inside a path variable. The origin address is a pointer to some poath
variable. The function will get as arguent an offset that defines how
many points in the beginning will be ignored. And also a size argument
to represent the number of points to be copied. The function always
return how many points were read (even if they were not opied because
we have a positive offset):

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int recursive_copy_subpath(struct path_points *dst, struct path_variable *src,
                           int offset, int size);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int recursive_copy_subpath(struct path_points *dst, struct path_variable *src,
                           int offset, int size){
  int i, read_data = 0;
  for(i = 0; i < src -> length; i ++){
    if(size <= 0)
      break;
    if(src -> points[i].subpath == NULL){
      if(offset <= 0){
        dst -> subpath = NULL;
        dst -> x = src -> points[i].x;
        dst -> y = src -> points[i].y;
        dst -> u_x = src -> points[i].u_x;
        dst -> u_y = src -> points[i].u_y;
        dst -> v_x = src -> points[i].v_x;
        dst -> v_y = src -> points[i].v_y;
        size --;
        dst ++;
      }
      else
        offset --;
      read_data ++;
    }
    else{
      int recursive_read = recursive_copy_subpath(dst, (struct path_variable *)
                                                       src -> points[i].subpath,
                                                  offset, size);
      if(offset > recursive_read){
        offset -= recursive_read;
        read_data += recursive_read;
      }
      else{
        read_data += recursive_read;
        dst += (read_data - offset);
        size -= (read_data - offset);
        offset = 0;
      }
    }
  }
  return read_data;
}
@
\fimcodigo



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim
