\font\sixteen=cmbx12
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx12
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\def\matrix#1#2#3#4#5#6#7#8#9{\left[{{#1 \atop #4}\atop
      {\scriptstyle #7}}{{#2 \atop #5}\atop {\scriptstyle #8}}{{#3\atop
      #6}\atop{\scriptstyle #9}}\right]}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\twelvebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{WEAVEFONT: Linguagem de Desrição de Fontes Tipográficas}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of  WEAVEFONT, a language
 created to represent typographical fonts, vector illustrations and
 animations. The language is strongly based on METAFONT, a description
 language created by Donald Knuth in 1984 [KNUTH, 1989]. The syntax is
 very similar for both languages, but WEAVEFONT was created to run and
 produce images in real time using OpenGL. Therefore, changes were
 made to make the language faster for this goal. Contrary to METAFONT,
 WEAVEFONT do not support macros and is an imperative
 language. Several useful features from METAFONT that were implemented
 with macros, in WEAVEFONT are a direct part of the language.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém uma implementação de WEAVEFONT, uma linguagem criada
 para representar fontes tipográficas, ilustrações vetoriais e
 animações. A linguagem é fortemente baseada em METAFONT, uma
 linguagem de descrição criada por Donald Knuth em 1977 [KNUTH,
 1989]. A sintaxe é muito similar para ambas as linguagens.  mas
 WEAVEFONT foi criada para executar e produzir imagens em tempo real
 usando OpenGL. Por isso, mudanças foram feitas para tornar a
 linguagem mais rápida para tal propósito. Ao contrário de METAFONT,
 WEAVEFONT não suporta macros e é uma linguagem imperativa. Várias
 funcionalidades úteis que em METAFONT foram criadas usando macros, em
 WEAVEFONT são diretamente parte da linguagem.}

\secao{Índice}

\def\indice#1{\leaders\hbox{.}\hfill #1}

1. Introdução \indice{3}

1.1. Programação Literária \indice{5}

2. Código Auxiliar Geral \indice{6}

2.1. Código de Álgebra Linear \indice{6}

2.1.1. Resolvendo Sistemas de Equações Lineares \indice{9}

2.2. Mutexes e Seções Críticas \indice{11}

3. Inicialização e Finalização \indice{12}

4. Analisador Léxico \indice{12}

4.1. Tipos de Tokens \indice{12}

4.2. A Análise Léxica \indice{16}

5. Programas WEAVEFONT \indice{24}

5.1. Executando Programas \indice{24}

5.2. Lidando com Erros \indice{27}

5.3. Separando Lista de Instruções em Instruções Individuais \indice{30}

6. Uma Instrução Composta: O Bloco Composto \indice{31}

6.1. Suportando Instruções Compostas \indice{31}

6.2. A Instrução \monoespaco{begingroup}$\ldots$\monoespaco{endgroup}\indice{36}

7. Declaração de Variáveis \indice{37}

7.1. Variáveis Numéricas \indice{43}

7.2. Variáveis de Pares \indice{45}

7.3. Variáveis de Transformação \indice{45}

7.4. Variáveis de Caminhos \indice{47}

7.4.1. Removendo Recursão de Variáveis de Caminho \indice{50}

7.4.2. Tensão e Especificadores de Direção \indice{51}

7.4.3. Deduzindo Especificadores de Direção \indice{56}

7.4.4. Normalização de Caminhos \indice{64}

7.5. Variáveis de Caneta \indice{66}

7.6. Variáveis de Imagens \indice{XX}

7.7. Variáveis Booleanas \indice{XX}

8. Atribuições \indice{XX}

8.1. Atribuições e Expressões Numéricas \indice{XX}

8.1.1. Soma e Subtração: Normal e Pitagórica \indice{XX}

8.1.2. Multiplicação e Divisão \indice{XX}

8.1.3. Módulo, Seno, Cosseno, Exponenciais, Piso e Aleatórios Uniformes \indice{XX}

8.1.4. Números Isolados e Valores Aleatórios Normais \indice{XX}

8.2. Atribuições e Expressões de Pares \indice{XX}

8.2.1. Soma e Subtração \indice{XX}

8.2.2. Transformações, Multiplicação e Divisão Escalar \indice{XX}

8.2.3. Valores Intermediários de Pares, Literais e Variáveis \indice{XX}

8.2.4. Pares em Expressões Numéricas \indice{XX}

8.3. Atribuições e Expressões de Transformação \indice{XX}

8.3.1. Transformações sobre Transformadores \indice{XX}

8.3.2 Expressões Primárias de Transformação: Literais e Variáveis \indice{XX}

8.3.3. Transformações em Expressões Numéricas \indice{XX}

8.3.4. Transformações em Expressões de Pares \indice{XX}

8.4. Atribuições e Expressões de Caminhos \indice{XX}

8.4.1. Junção de Caminhos \indice{XX}

8.4.2. Expressões Terciárias de Caminhos \indice{XX}

8.4.3. Expressões Secundárias de Caminhos: Transformadores \indice{XX}

8.4.4. Expressões Primárias: Variáveis, Reversos e Subcaminhos \indice{XX}

8.4.5. Caminhos em Expressões Numéricas \indice{XX}

8.4.6. Caminhos em Expressões de Pares \indice{XX}

8.5. Atribuições e Expressões de Caneta \indice{XX}

8.5.1. Expressão Terciária de Caneta \indice{XX}

8.5.2. Transformadores de Caneta \indice{XX}

8.5.3. Expressões Primárias: Caneta Nula, Circular,
Arbitrária e Variáveis \indice{XX}

8.5.4. Canetas em Expressões de Caminho \indice{XX}

8.6. Atribuições e Expressões de Imagens \indice{XX}

8.6.1. Expressões Terciárias de Imagem: Soma e Subtração \indice{XX}

8.6.2. Expressões Secundárias de Imagem: Transformadores \indice{XX}

8.6.3. Expressões Primárias: Inversores, Identidade e
Imagens Vazias \indice{XX}

8.6.4. Imagens em Expressões Numéricas \indice{XX}

8.7. Atribuições e Expressões Booleanas \indice{XX}

8.7.1. Comparações \indice{XX}

8.7.2. A Operação OR \indice{XX}

8.7.3. A Operação AND \indice{XX}

8.7.4. Expressões Primárias Booleanas: Literais e Predicados Simples \indice{XX}

8.8. Identificando Tipos de Expressões \indice{XX}

9. Declaração Composta: Declaração Condicional \indice{XX}

10. O Comando \monoespaco{pickup} \indice{XX}

10.1. Pontos de Extremidade de Caneta \indice{XX}

10.2. Triangulação \indice{XX}

10.3. Interpretando o Comando \monoespaco{pickup} \indice{XX}

10.4. Os Operadores \monoespaco{bot}, \monoespaco{top}, \monoespaco{lft},
\monoespaco{rt} \indice{XX}

11. O Comando \monoespaco{draw} e \monoespaco{erase} \indice{XX}

11.1. Preparando o Framebuffer \indice{XX}

11.2. Shaders de Desenho \indice{XX}

11.3. Desenhando Caminhos \indice{XX}

12. Declaração Composta: Declaração de Caractere \indice{XX}

12.1 Unicode e UTF-8 \indice{XX}

13. Funções de API para Usar as Fontes \indice{XX}

Referências \indice{XX}

\secao{1. Introdução}

A primeira linguagem de descrição para fontes tipográficas foi a
METAFONT. Ela foi criada em 1984 por Donald Knuth e difere de outros
formatos de fontes tipográficas por permitir a criação de fontes à
partir da modificação de parâmetros definidos na descrição básica da
fonte. Desta forma, o projetista de uma fonte não deve criar uma
simples fonte tipográfica, mas uma meta-fonte, a qual pode por sua vez
gerar muitas outras fontes tipográficas diferentes mediante a simples
modificação dos parâmetros.  Aqui também chamaremos de meta-fonte as
fontes que definiremos, as quais não devem ser confundidas com a
linguagem METAFONT.

A especificação original da linguagem METAFONT pode ser encontrada em
[KNUTH, 1989].  Baseada nesta linguagem, definiremos aqui a linguagem
WEAVEFONT, a qual tem objetivos similares. A diferença é que a
linguagem a ser definida aqui deverá ser usada em tempo real para
produzir imagens à partir da descrição vetorial.

O arquivo de código-fonte que está sendo definido neste artigo pode
tanto ser usado sozinho para usar somente a linguagem WEAVEFONT, ou
pode estar integrado ao subsistema do Motor de Jogos Weaver, do qual
esta linguagem é um sub-projeto. Se estivermos usando este projeto
dentro do motor de jogos, isso significa que temos definida a
macro \monoespaco{WEAVER\_ENGINE}. Neste caso, devemos definir a
seguinte função:

\iniciocodigo
@<Declaração de Função (metafont.h)@>=
#if defined(WEAVER_ENGINE)
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
                        void (*permanent_free)(void *),
                        void *(*temporary_alloc)(size_t),
                        void (*temporary_free)(void *),
                        void (*before_loading_interface)(void),
                        void (*after_loading_interface)(void),
                        char *source_filename,
                        struct user_interface *target);
#endif
@
\fimcodigo

Esta função serve para ler um arquivo (\monoespaco{source\_filename})
e gerar com ele uma nova interface de usuário a ser usada pelo motor
de jogos. No caso, o arquivo com código WEAVEFONT será interpretado
como uma imagem vetorial ou uma animação vetorial.

E nós precisamos também inserir o cabeçalho Weaver de interface de usuário:

\iniciocodigo
@<Inclui Cabeçalhos Gerais (metafont.h)@>=
#if defined(WEAVER_ENGINE)
#include "interface.h"
#endif
@
\fimcodigo

Tanto se estivermos executando este código de dentro do Motor Weaver
ou de fora dele, uma operação que será necessária será ler uma fonte
tipográfica, uma meta-fonte. Depois de lê-la, nós retornamos um
ponteiro para uma estrutura com todas as informações relevantes sobre
ela. Esta estrutura pode então ser usada para renderizar caracteres
que estiverem definidos ali. Depois de renderizar o que queremos,
precisaremos de uma segunda função para desalocar a estrutura. Em
suma, iremos definir também as seguintes funções para criar e destruir
uma nova meta-fonte que serão sempre exportadas:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
struct metafont *_Wnew_metafont(char *filename);
void _Wdestroy_metafont(struct metafont *mf);
@
\fimcodigo

Podemos em um mesmo projeto criar e manter muitas meta-fontes para
renderizar caracteres ou imagens delas. Mas antes de começar a criar a
primeira delas, será importante chamar a seguinte função de
inicialização que especifica algumas das funções que devem ser usadas,
e além disso nos informa quantos pontos por polegada tem a nossa tela
(DPI):

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
bool _Winit_weavefont(void *(*temporary_alloc)(size_t),
                     void (*temporary_free)(void *),
                     void *(*permanent_alloc)(size_t),
                     void (*permanent_free)(void *),
                     uint64_t (*rand)(void), int dpi);
@
\fimcodigo

As funções passadas como argumento para tal inicializador são
respectivamente uma para fazer alocações temporárias de memória, outra
para desalocar o que foi alocado com ela (pode ser NULL), outra para
fazer alocações mais permanentes, outra para desalocar o que foi
alocado com ela (pode ser NULL também), uma para gerar 64 bits
aleatórios e por fim a medida de DPI. A função retorna verdadeiro se a
inicialização foi bem-sucedida.

Após terminar o uso de nossas funções, deve-se chamar a função abaixo
que finaliza e desaloca qualquer coisa que tenha sido gerada pela
função de inicialização:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
void _Wfinish_weavefont(void);
@
\fimcodigo

Caso algum erro tenha ocorrido durante a execução de um código
WEAVEFONT que define uma meta-fonte, então o usuário poderá usar a
seguinte função para imprimir na tela uma mensagem descrevendo o erro
encontrado:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
void _Wprint_metafont_error(struct metafont *);
@
\fimcodigo


\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{metafont.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
#include <stdlib.h>  // Define 'atof', 'abs'
#if defined(__linux__) || defined(BSD) || defined(__EMSCRIPTEN__)
#include <GLES3/gl3.h> // Nossa linguagem renderiza com OpenGL
#endif
#if !defined(_WIN32)
#include <sys/param.h> // Necessário no BSD, mas causa problema no Windows
#endif
@<Inclui Cabeçalhos Gerais (metafont.h)@>
@<Declarações Gerais (metafont.h)@>
@<Estrutura de Dados (metafont.h)@>
@<Declaração de Função (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (metafont.h)'', o mesmo nome apresentado no
trecho de código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{metafont.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Cabeçalhos Locais (metafont.c)@>
@<Macros Locais (metafont.c)@>
@<Estrutura de Dados Locais (metafont.c)@>
@<Variáveis Locais (metafont.c)@>
@<Declaração de Função Local (metafont.c)@>
@<Funções Auxiliares Locais (metafont.c)@>
@<Definição de Funções da API (metafont.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{2. Código Auxiliar Geral}

O código apresentado nesta seção tem como característica ser usado em
diferentes partes de nossa linguagem e também ser independente de
estruturas de dados específicas deste projeto. Por causa disso, vamos
defini-lo como uma introdução, antes do código mais específico.

\subsecao{2.1. Código de Álgebra Linear}

Iremos usar com uma frequência muito grande matrizes $3\times 3$, que
serão usadas tipicamente para representar transformações lineares em
um espaço vetorial de 3 dimensões. Tais matrizes serão simplesmente um
array de 9 elementos, representando os elementos da matriz.

Os valores da matriz estarão dispostos da seguinte forma, de acordo
como os armazenamos no array M:

$$
\matrix{M[0]}{M[1]}{M[2]}{M[3]}{M[4]}{M[5]}{M[6]}{M[7]}{M[8]}
$$

Sendo assim, podemos inicializar uma matriz identidade com:

\iniciocodigo
@<Macros Locais (metafont.c)@>=
#define INITIALIZE_IDENTITY_MATRIX(I) {\
  int _i;\
  for(_i = 0; _i < 9; _i++)\
    I[_i] = ((_i%4)?(0.0):(1.0));\
}   
@
\fimcodigo

Apesar de nossas matrizes lidarem com espaço vetorial de 3 dimensões,
na prática todos os valores que usaremos estarão contidos no plano
$\{(x, y, 1)\}$. tal que $x$ e $y$ são números reais. O motivo de
trabalharmos no espaço de 3 dimensões é poder representar a translação
(ou deslocamento) de pontos como transformações lineares, algo que só
se torna possível no espaço 2D se o tratarmos como inscrito dentro de
um espaço vetorial 3D.

Dado um vetor de 3 dimensões $(x, y, 1)$, podemos transformá-lo em um
novo vetor $(x', y', 1)$ aplicando a transformação linear representada
por uma matriz abaixo:

$$\left[x\; y\; 1\right]
\matrix{M[0]}{M[1]}{0}{M[3]}{M[4]}{0}{M[6]}{M[7]}{1}
=\left[x'\;\; y'\;\; 1\right]
$$

As novas coordenadas $(x', y')$ do novo vetor podem ser calculadas com
ajuda das macros abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define LINEAR_TRANSFORM_X(x, y, M) (x * M[0] + y * M[3] + M[6])
#define LINEAR_TRANSFORM_Y(x, y, M) (x * M[1] + y * M[4] + M[7])
@
\fimcodigo

A multiplicação de matrizes tem a propriedade de associatividade
abaixo:

$$
\left((x, y, 1)\cdot A\right) \cdot B = (x, y, 1)\cdot \left(A \cdot B\right)
$$

Isso quer dizer que podemos acumular várias transformações em uma só
matriz. Aplicar a transformaçao $AB$ sobre um vetor é o mesmo que
aplicar primeiro a transformação $A$ e depois a transformação $B$. O
código abaixo acumula duas transformações lineares, calculando $AB$ e
armazenando o resultado em $A$. Note que o código sempre assume que a
última coluna de toda matriz é $(0, 0, 1)^{T}$:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define MATRIX_MULTIPLICATION(A, B) {\
  float _a0 = A[0], _a1 = A[1], _a3 = A[3], _a4 = A[4], _a6 = A[6],\
        _a7 = A[7];\
  A[0] = _a0 * B[0] + _a1 * B[3];\
  A[1] = _a0 * B[1] + _a1 * B[4];\
  A[3] = _a3 * B[0] + _a4 * B[3];\
  A[4] = _a3 * B[1] + _a4 * B[4];\
  A[6] = _a6 * B[0] + _a7 * B[3] + B[6];\
  A[7] = _a6 * B[1] + _a7 * B[4] + B[7];\
}
@
\fimcodigo

Existem algumas transformações lineares que são muito mais comuns do
que outras. Para realizá-las mais facilmente vamos criar macros
especiais para elas. Por exemplo, rotacionar um vetor $(x, y, 1)$ em
relação ao ponto $(0, 0, 1)$ um ângulo $\theta$ é feito multiplicando
pela matriz:

$$\left[x\; y\; 1\right]
\matrix{cos(\theta)}{sin(\theta)}{0}{-\sin(\theta)}{cos(\theta)}{0}{0}{0}{1}
=\left[x\cdot cos(\theta) - y\cdot sin(\theta)\;\; x\cdot sin(\theta)
+ y\cdot cos(\theta)\;\; 1\right]
$$

Acumular a transformação acima sobre uma matriz é feito com a macro
seguinte:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_ROTATE(M, theta) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  double _cos_theta, _sin_theta;\
  _sin_theta = sin(theta);\
  _cos_theta = cos(theta);\
  M[0] = _m0 * _cos_theta - _m1 * _sin_theta;\
  M[1] = _m0 * _sin_theta + _m1 * _cos_theta;\
  M[3] = _m3 * _cos_theta - _m4 * _sin_theta;\
  M[4] = _m3 * _sin_theta + _m4 * _cos_theta;\
  M[6] = _m6 * _cos_theta - _m7 * _sin_theta;\
  M[7] = _m6 * _sin_theta + _m7 * _cos_theta;\
}
@
\fimcodigo

Outra transformação relevante é ampliar ou reduzir vetores, os
esticando ou comprimindo. Para fazer isso no eixo $x$, multiplicamos
pela seguinte matriz:

$$\left[x\; y\; 1\right]
\matrix{s}{0}{0}{0}{1}{0}{0}{0}{1}
=\left[sx\;\; y\;\; 1\right]
$$

O que é feito pela macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE_X(M, s) {\
  M[0] = M[0] * s;\
  M[3] = M[3] * s;\
  M[6] = M[6] * s;\
}
@
\fimcodigo

Fazer isso no eixo $y$ envolve a multiplicação:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{s}{0}{0}{0}{1}
=\left[x\;\; sy\;\; 1\right]
$$

E pra isso usamos a macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE_Y(M, s) {\
  M[1] = M[1] * s;\
  M[4] = M[4] * s;\
  M[7] = M[7] * s;\
}
@
\fimcodigo

E fazer isso nos dois eixos é feito simplesmente combinando ambas as
operações:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE(M, s) {\
  TRANSFORM_SCALE_X(M, s);\
  TRANSFORM_SCALE_Y(M, s);\
}
@
\fimcodigo

Uma translação, ou deslocamento é a única operação que exige que
usemos três dimensões ao invés de duas. Deslocar um vetor uma
distância $a$ na horizontal e uma distância $b$ na vertical é feito
pela transformação:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{1}{0}{a}{b}{1}
=\left[x+a\;\; y+b\;\; 1\right]
$$

E essa multiplicação de matrizes é feita usando a seguinte macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SHIFT(M, a, b) {\
  M[6] = M[6] + a;\
  M[7] = M[7] + b;\
}
@
\fimcodigo

Inclinar com intensidade $s$ é uma operação feita pela multiplicação:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{s}{1}{0}{0}{0}{1}
=\left[x+sy\;\; y\;\; 1\right]
$$

Que realizamos sobre outras matrizes com a macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SLANT(M, s) {\
  M[0] = M[0] + s * M[1];\
  M[3] = M[3] + s * M[4];\
  M[6] = M[6] + s * M[7];\
}
@
\fimcodigo

A última transformação especial que iremos tratar aqui é a mudança de
escala no plano complexo. Isso significa multiplicar os pontos por um
par $(s, t)$, interpretado como um número complexo. Isso obtém ao
mesmo tempo tanto rotação como mudança de escala. É feito pela
multiplicação de matriz:

$$\left[x\; y\; 1\right]
\matrix{s}{t}{0}{-t}{s}{0}{0}{0}{1}
=\left[sx-ty\;\; tx+sy\;\; 1\right]
$$

Realizar esta multiplicação por outra matriz é feito com essa macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE_Z(M, s, t) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  M[0] = _m0 * s - _m1 * t;\
  M[1] = _m0 * t + _m1 * s;\
  M[3] = _m3 * s - _m4 * t;\
  M[4] = _m3 * t + _m4 * s;\
  M[6] = _m6 * s - _m7 * t;\
  M[7] = _m6 * t + _m7 * s;\
}
@
\fimcodigo

\subsubsecao{2.1.1. Resolvendo Sistemas de Equações Lineares}

Resolver sistemas de equações lineares é o problema central da álgebra
linear. São equações em que as incógnitas estão sempre sendo
multiplicadas por constantes numéricas e somadas (sem haver duas
incógnitas multiplicadas entre si). Por exemplo:

$$
x+2y+3z = 6
$$
$$
2x+5y+2z=4
$$
$$
6x-3y+z=2
$$

Podemos representar o sistema de equações acima na forma matricial,
associando a primeira coluna a $x$, a segunda a $y$ e a terceira a $z$:

$$
\matrix{1}{2}{3}{2}{5}{2}{6}{-3}{1}x=\left[{{6 \atop 4}\atop
      {\scriptstyle 2}}\right]
$$

Resolver o sistema é encontrar uma solução válida para $x$. No caso:
      $X=\left[{{0 \atop 0}\atop {\scriptstyle 2}}\right]$

Uma função capaz de resolver este sistema pode ser a abaixo, que
recebe um número de dimensões $n$, um vetor já alocado com os $n^2$
elementos de uma matriz, um vetor já alocado com $n$ elementos do lado
direito da equação, e um próximo vetor com $n$ valores da solução, que
serão preenchidos pela função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>=
void solve_linear_system(int n, double *m, double *b, double *x);
@
\fimcodigo

Antes de mostrar como resolver o sistema, é útil definir algumas novas
macros para nos ajudar. Vamos assumir que toda matriz, independente do
tamanho está alocada em um único vetor contínuo que concatena cada uma
de suas linhas. Será muito comum que tenhamos que trocar a ordem das
linhas de uma matriz para resolver o sistema de equações. Trocar
linhas da matriz $M$, que representa o lado esquerdo de um sistema de
equações, também significa trocar as mesmas linhas de $b$, a matriz
representando o lado direito do sistema de equações.

A macro abaixo mostra o que acontece quando, em um sistema de $n$
linhas, trocamos na matriz $M$ e em $b$ as linhas $i$ e $j$:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define EXCHANGE_ROWS(n, M, b, i, j) {\
  if(i != j){\
   int _k;\
   double _tmp;\
   _tmp = b[i];\
   b[i] = b[j];\
   b[j] = _tmp;\
   for(_k = 0; _k < n; _k++){\
       _tmp = m[i*n+_k];\
       m[i*n+_k] = m[j*n+_k];\
       m[j*n+_k] = _tmp;}}}
@
\fimcodigo

Note que trocar as linhas não muda o resultado de um sistema de
equações. Por exemplo, as três equações abaixo tem a mesma solução
($x=0$, $y=0$, $z=2$) do sistema de equações do começo da Subseção
2.1.1:

$$
6x-3y+z=2
$$
$$
x+2y+3z = 6
$$
$$
2x+5y+2z=4
$$


Outra operação relevante é, dado um sistema com $n$ linhas, com a
matriz $M$ e a matriz $b$, devemos combinar as linhas $i$ e $j$,
subtraindo da linha $i$ o conteúdo da linha $j$ multiplicado por $q$:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define SUB_MUL_LINES(n, m, b, i, j, q) {\
  int _k;\
  b[i] -= (q * b[j]);\
  for(_k = 0; _k < n; _k++){\
      m[i*n+_k] -= (q * m[j*n+_k]);}}
@
\fimcodigo

Realizar esta operação tampouco muda o resultado do sistema de
equações. Por exemplo, no sistema logo acima, podemos subtrair a
segunda linha pela primeira multiplicada por $1/6$ e a terceira pela
primeira multiplicada por $1/3$. O resultado seria:

$$
6x-3y+z=2
$$
$$
5/2y+17/6z = 17/3
$$
$$
6y+5/3z=10/3
$$

Embora o resultado não tenha mudado, conseguimos simplificar o sistema,
deixando as duas últimas equações com apenas duas incógnitas. Com mais
uma operação, é possível deixar a última equação com apenas uma
incógnita e à partir daí a solução se torna trivial.

O que queremos então é realizar as operações das duas macros acima
sucessivas vezes até obter uma matriz triangular com todos os
elementos abaixo da diagonal principal nulos. Depois, obter a solução
se torna fácil: na última linha só há e podemos calcular diretamente o
resultado. Sabendo o valor da última incógnita, resta apenas uma
incógnita desconhecida na penúltima linha. E assim continuamos até
chegar à primeira linha e não restar mais incógnitas desconhecidas.

Para construir a matriz triangular, temos uma iteração onde
percorremos uma linha de cada vez. Na iteração $i$, nosso objetivo é
tornar nulo todos os elementos da coluna $i$ que estejam abaixo da
linha $i$. Para isso, escolhemos a linha atual ou abaixo dela que tem
o maior valor absoluto na coluna $i$ e trocamos a posição dela com a
linha atual. Isso não é estritamente necessário, mas escolher o maior
valor possível minimiza os erros da operação. E então à partir disso
escolhemos valores adequados para transformar a matriz e resolvê-la:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void solve_linear_system(int n, double *m, double *b, double *x){
  int i, j;
  for(i = 0; i < n; i ++){ // Para cada linha
    // Acha maior pivô possível na coluna atual e troca de posição com ele:
    int max_line = i;
    double max = abs(m[i * n + i]);
    for(j = i + 1; j < n; j ++){
      if(abs(m[j*n+i]) > max){
        max = abs(m[j*n+i]);
        max_line = j;
      }
    }
    EXCHANGE_ROWS(n, m, b, i, max_line);
    // Torna zero as colunas do pivô nas linhas abaixo:
    for(j = i + 1; j < n; j ++){
      double multiplier = m[j * n + i]/m[i * n + i];
      SUB_MUL_LINES(n, m, b, j, i, multiplier);
    }
  }
  // Gerando a solução à partir da matriz triangular:
  for(i = n - 1; i >= 0; i --){
    x[i] = 0;
    for(j = n - 1; j > i; j --)
      x[i] += x[j] * m[i*n + j];
    x[i] = (b[i] - x[i]) / m[i*n + i];
  }
}
@
\fimcodigo

Note que não preservamos o estado das matrizes passadas como argumento
para a função. E que não fazemos qualquer checagem de erro. É
responsabilidade de quem chamar esta função alocar vetores de tamanho
correto e só passar sistemas que tenham uma solução (ou uma divisão
por zero irá ocorrer e matar o programa).

Note that we do not preserve the state of the matrices passed as an
argument for the function. And we don't do any error checking. AND
responsibility of whoever calls this function to allocate vectors of
size correct and only pass systems that have a solution (or a division
by zero will occur and kill the program).

\subsecao{2.2. Mutexes e Seções Críticas}

Um mutex é uma estrutura de dados abstrata usada para controlar acesso
de múltiplos processos a um recurso em comum. Eles serão tratados de
forma diferente dependendo do sistema operacional e ambiente. Devido à
seu caráter não-portável, teremos que usar diferentes técnicas
dependendo de onde o código será compilado.

No Linux e BSD, o Mutex é definido pela biblioteca
\monoespaco{pthread} e segue a nomenclatura típica dela. No Web Assembly,
o Emscripten possui uma implementação com API compatível, mas ela só
irá funcionar se a página web que servir a aplicação passar os
cabeçalhos certos, por isso só iremos suportar threads nele se o
usuário pedir definindo uma
macro \monoespaco{W\_ALWAYS\_USE\_THREADS}. No Windows há uma
diferença entre um mutex, que pode ser compartilhado entre diferentes
programas e uma ``seção crítica'', que só pode ser compartilhada entre
threads de um mesmo programa. No nosso caso, devemos usar seções
críticas que nos dão uma performance melhor.

\iniciocodigo
@<Declarar um Mutex@>=
#if defined(_WIN32)
CRITICAL_SECTION mutex;
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
pthread_mutex_t mutex;
#endif
@
\fimcodigo

Isso significa que no Linux e BSD nós precisamos inserir o cabeçalho
da biblioteca \monoespaco{pthread}. No Windows, basta o cabeçalho
padrão do windows que já colocamos em \monoespaco{metafont.h}.

\iniciocodigo
@<Inclui Cabeçalhos Gerais (metafont.h)@>=
#if defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#include <pthread.h>
#endif
@
\fimcodigo

No nosso código vamos precisar inicializar cada Mutex que
declararmos. Para isso, usaremos a seguinte macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>=
#if defined(_WIN32)
#define MUTEX_INIT(mutex) InitializeCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_INIT(mutex) pthread_mutex_init(&mutex, NULL);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_INIT(mutex)
#endif
@
\fimcodigo

Para finalizar um Mutex quando não precisarmos mais, usamos a seguinte
macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#if defined(_WIN32)
#define MUTEX_DESTROY(mutex) DeleteCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_DESTROY(mutex) pthread_mutex_destroy(&mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_DESTROY(mutex)
#endif
@
\fimcodigo

Tendo um Mutex, há duas operações que podemos fazer com ele. A
primeira é requerer o uso do Mutex. Neste momento, se algum outro
processo está usando ele, iremos esperar até que o Mutex esteja livre
novamente:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#if defined(_WIN32)
#define MUTEX_WAIT(mutex) EnterCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_WAIT(mutex) pthread_mutex_lock(&mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_WAIT(mutex)
#endif
@
\fimcodigo

E finalmente, depois de deixarmos de usar o recurso guardado pelo
Mutex, podemos liberar ele com o código abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>=
#if defined(_WIN32)
#define MUTEX_SIGNAL(mutex) LeaveCriticalSection(mutex);
#elif defined(__linux__) || defined(BSD) || defined(W_ALWAYS_USE_THREADS)
#define MUTEX_SIGNAL(mutex) pthread_mutex_unlock(&mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_SIGNAL(mutex)
#endif
@
\fimcodigo


\secao{3. Inicialização e Finalização}

Primeiro vamos definir a função de inicialização. O que ela fará será
armazenar em uma série de variáveis estáticas ques erão usadas pelas
outras funções, além de nos informar a medida de densidade de pixels
da tela em DPI. As variáveis que armazenarão tais informações são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int dpi;
@
\fimcodigo

E a função de inicialização consiste em preencher tais variáveis:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>=
bool _Winit_weavefont(void *(*t_alloc)(size_t),
                     void (*t_free)(void *),
                     void *(*p_alloc)(size_t),
                     void (*p_free)(void *),
                     uint64_t (*random)(void), int pixel_density){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  dpi = pixel_density;
  @<Inicialização WEAVEFONT@>
  return true;
}
@
\fimcodigo

A função de finalização também existe e à medida que adicionarmos mais
coisas à inicialização, poderemos precisar adicionar código
correspondente à finalização:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>+=
void _Wfinish_weavefont(void){
  @<Finalização WEAVEFONT@>
}
@
\fimcodigo

Coisas como variáveis globais e informações que uma meta-fonte precisa
à longo prazo serão sempre alocadas com a alocação permanente. Coisas
como variáveis locais dentro de uma definição de como renderizar um
caractere serão alocadas pela alocação temporária. Se o gerenciador de
memória distinguir entre estes dois tipos de alocação (como ocorre no
Motor Weaver), estas serão duas funções diferentes. Na maioria dos
casos, será a mesma função, possivelmente um \monoespaco{malloc}. Caso
em que ambas as funções de desalocação também serão
um \monoespaco{free}. Já no Motor Weaver, não há funções de
desalocação: a alocação permanente é desalocada quando o laço de jogo
atual (``game loop'') termina e a temporária é desalocada a cada frame.

Como esperamos que estas funções sejam chamadas apenas uma vez por
programa, não precisamos usar mutex nelas.

\secao{4. Analisador Léxico}

\subsecao{4.1. Tipos de Tokens}

A primeira coisa a criar para uma linguagem é seu analisador
léxico. Ele irá ler o código-fonte da linguagem presente em um arquivo
e irágerar uma lista de ``tokens'', sendo cada token a unidade mais
básica da linguagem, basicamente uma palavra.

WEAVEFONT reconhece três tipos de tokens: numéricos, strings e
simbólicos. Na prática nós iremos dividir os tokens simbólicos em
diferentes tipos de subtokens para podermos armazená-los e lê-los de
maneira mais eficiente. Aqui é onde definimos os três tipos
principais e onde vamos mais adiante armazenar todos os subtipos:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>=
enum { // Tipos de Tokens
  TYPE_NUMERIC = 1, TYPE_STRING, TYPE_SYMBOLIC,
  // Os 3 primeiros tipos básicos (numérico, string e simbólico) estão acima.
  // Os outros serão colocados logo abaixo:
  @<WEAVEFONT: Definição de Token Simbólico@>
  // E um último tipo que não deve ser usado, exceto para indicar erro:
  TYPE_INVALID_TOKEN
};
@
\fimcodigo

Um token numérico será representado internamente como um número em
ponto flutuante. Nisso iremos diferir do METAFONT que usava uma
representação própria de números em ponto fixo. Esta escolha nos
permitirá realizar operações sobre números mais rapidamente, graças ao
suporte de hardware.  Essa é a aparência de um token numérico:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct numeric_token{
  int type;   // Deve ser igual a 'TYPE_NUMERIC'
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

E isso é como representaremos tokens de strings:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct string_token{
  int type;   // Deve ser igual a 'TYPE_STRING'
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[4];
  // Ponteiro para o glifo que a string representa (tratado na Seção XXX)
  struct _glyph *glyph;
};
@
\fimcodigo

Nós iremos armazenar apenas os primeiros 4 bytes de cada string que
encontrarmos, mesmo que no código-fonte a string seja maior. Isso será
feito porque ao contrário do METAFONT original, a única utilidade para
strings aqui será indicar qual caractere Unicode deve estar associado
a cada glifo definido. Para isso nós precisamos de apenas 4 bytes.

Já no caso de tokens simbólicos, precisamos armazenar todo o seu
conteúdo para podermos saber qual token temos, e vamos alocar
dinamicamente de acordo com o tamanho do símbolo:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct symbolic_token{
  int type;   // Deve ser igual a 'TYPE_SYMBOLIC'
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  void *var;
  char *value;
};
@
\fimcodigo

Também colocamos neste token o ponteiro \monoespaco{var}, já que ele
pode corresponder a uma variável, e por isso pode precisar apontar
para a região da memória com o conteúdo da variável.

Mas isso pode consumir mais espaço na memória do que é
necessário. Alguns símbolos são muito comuns e são definidos por
padrão na própria linguagem e podem usar menos espaço que isso. Por
exemplo, parênteses e vírgulas. Podemos representar eles com a
seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct generic_token{
  int type;   // Um sub-tipo de token simbólico.
  struct generic_token *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

Precisamos apenas definir para eles um subtipo de token que indique o quê
eles são:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>=
TYPE_OPEN_PARENTHESIS,  // '('
TYPE_CLOSE_PARENTHESIS, // ')'
TYPE_COMMA,             // ','
TYPE_SEMICOLON,         // ';'
@
\fimcodigo

Podemos definir posteriormente muitos outros tipos de tokens
simbólicos reservados. Note que pelas regras da enumeração em C que
usamos, qualquer token cujo tipo é um número igual ou maior que 3 é
simbólico.

Todo token possui um ponteiro para um próximo token. Isso ocorre
porque eles geralmente formarão uma lista encadeada de tokens.

Tokens são gerados pela função de alocação permanente. Precisamos
mantê-los na memória, já que podemos ter que interpretá-los muitas
vezes, cada vez que formos renderizar um novo caractere. Justamente
por isso, não queremos armazenar neles mais do que é necessário. Por
exemplo, o número de linha em que eles estão é útil para indicar onde
um erro foi localizado no código-fonte. Esta é uma variável que
certamente será usada por um projetista de fontes ou por quem está
criando código WEAVEFONT. Mas para a maioria dos usuários, depurar
erros não será algo que eles farão. Por causa disso, só armazenamos
tal informação se estivermos em modo de depuração. E pelo mesmo motivo
não nos preocupamos em armazenar strings muito grandes.

Para desalocar a memória ocupada por uma lista de tokens e apagá-los,
pode-se usar a seguinte função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void free_token_list(void *token_list){
  if(permanent_free != NULL && token_list != NULL){
    struct generic_token *p, *p_next;
    p = token_list;
    while(p != NULL){
      p_next = p -> next;
      if(p -> type == TYPE_SYMBOLIC)
        permanent_free(((struct symbolic_token *) p) -> value);
      permanent_free(p);
      p = p_next;
    }
  }
}
@
\fimcodigo

\subsecao{4.2. A Análise Léxica}

Agora a função que fará a análise léxica. Ela receberá como argumento
a estrutura da meta-fonte (cujos detalhes ainda vamos definir) e uma
string com caminho para arquivo com código-fonte METAFONT. Ela
produzirá uma lsita de tokens e armazenará no ponteiro indicado por
seus dois últimos argumentos o primeiro e o último token lido.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void lexer(struct metafont *mf, char *path, struct generic_token **first_token,
           struct generic_token **last_token){
  FILE *fp;
  char c;
  int line = 1;
  *first_token = NULL;
  *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Análise Léxica: Regra 1@>
    @<Análise Léxica: Regra 2@>
    @<Análise Léxica: Regra 3@>
    @<Análise Léxica: Regra 4@>
    @<Análise Léxica: Regra 5@>
    @<Análise Léxica: Regra 6@>
    // Nenhuma regra aplicada: erro. Definiremos erros na Subseção 5.2.
    RAISE_ERROR_INVALID_CHAR(mf, NULL, line, c);
    free_token_list(first_token);
    *first_token = NULL;
    *last_token = NULL;
    return;
  }
  fclose(fp);
}
@
\fimcodigo 

Como usamos o tipo \monoespaco{FILE}, precisamos inserir o
cabeçalho de entrada e saída padrão para podermos abrir e ler
arquivos:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

As regras para ler os tokens consiste em ler cada linha do código
fonte aplicando as seguintes regras para cada novo caractere lido:

1) Se o próximo caractere é um espaço, tabulação ou um ponto que não é
sucedido por um dígito decimal ou um novo ponto, ignore-o e siga em
frente.

\iniciocodigo
@<Análise Léxica: Regra 1@>=
if(c == ' ' || c == '\t' ||
   (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

Como estamos usando a função \monoespaco{isdigit}, devemos inserir o
seguinte cabeçalho que a declara:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo

2) Se o próximo caractere é o símbolo de porcentagem, ignore-o e
ignore todos os outros caracteres seguintes na linha. Este símbolo
marca o começo de comentários na linguagem.

\iniciocodigo
@<Análise Léxica: Regra 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) Se o próximo caractere é um dígito decimal ou um ponto seguido por
um dígito decimal, então o próximo token será numérico. E é formado
pela maior sequência possível de ser lida envolvendo dígitos decimais
e opcionalmente um único ponto representando o ponto decimal.

\iniciocodigo
@<Análise Léxica: Regra 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token =
    (struct numeric_token *) permanent_alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL, line); // Vamos definir erros na Seção 5.2.
    return;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo


4) Se o próximo caractere é uma aspa dupla, então o próximo token deve
ser uma string e será composto pela sequência de caracteres até a
próxima aspa dupla não-precedida por uma contrabarra, que deve estar
na mesma linha. Se existir uma aspa dupla iniciando uma string, mas
não existir outra para finalizar a string na mesma linha, um erro será
gerado. Ao encontrar uma primeira contrabarra, ela é ignorada, mas o
caractere a seguir é considerado sempre. Esta regra permite que
representemos aspas duplas dentro de string (na
forma \monoespaco{"\\""}) e uma contrabara dentro de string (na forma
\monoespaco{"\\\\"}).

\iniciocodigo
@<Análise Léxica: Regra 4@>=
if(c == 34){ // 34: ASCII para aspas duplas
  struct string_token *new_token =
    (struct string_token *) permanent_alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL, line);
    return;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0, prev;
  do{
    prev = c;
    c = fgetc(fp);
    if(i < 5 && (c !='\\' || prev == '\\')){
      new_token -> value[i] = c;
      i ++;
    }
  } while((c != 34 || prev == '\\') && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    RAISE_ERROR_UNCLOSED_STRING(mf, NULL, line, new_token -> value);
    if(permanent_free != NULL)
      permanent_free(new_token);
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    return;
  }
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo

5) Se o próximo caractere for um parêntese, ponto-e-vírgula ou uma
vírgula, então o próximo token será um token simbólico formado por
este único caractere.

\iniciocodigo
@<Análise Léxica: Regra 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) permanent_alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL, line);
    return;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo

6) Caso contrário, o próximo token será simbólico e formado pela
sequência mais longa possível formada somente por caracteres que
pertencem a uma dentre 12 famílias:

\iniciocodigo
@<Análise Léxica: Regra 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer é lido de acordo com as subregras 6-a a 6-l
  @<Análise Léxica: Regra A@>
  @<Análise Léxica: Regra B@>
  @<Análise Léxica: Regra C@>
  @<Análise Léxica: Regra D@>
  @<Análise Léxica: Regra E@>
  @<Análise Léxica: Regra F@>
  @<Análise Léxica: Regra G@>
  @<Análise Léxica: Regra H@>
  @<Análise Léxica: Regra I@>
  @<Análise Léxica: Regra J@>
  @<Análise Léxica: Regra K@>
  @<Análise Léxica: Regra L@>
  // De acordo com conteúdo do buffer, gera o próximo token
  @<Análise Léxica: Gera Token Simbólico Reservado@>
  @<Análise Léxica: Gera Token Simbólico Genérico@>
}
@
\fimcodigo


a) A primeira família de letras são as letras de A a Z maiúsculas e
minúsculas além do ``underline'' e dígitos. Um dígito não pode ser o
primeiro caractere da sequência, ou ele seria interpretado como um
token numérico.

\iniciocodigo
@<Análise Léxica: Regra A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) A segunda família são os símbolos de maior, menor, igual, dois
pontos e a barra vertical.

\iniciocodigo
@<Análise Léxica: Regra B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acento agudo e grave.

\iniciocodigo
@<Análise Léxica: Regra C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Mais e menos.

\iniciocodigo
@<Análise Léxica: Regra D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Barra, barra invertida e símbolo de multiplicação.

\iniciocodigo
@<Análise Léxica: Regra E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Ponto de interrogação e exclamação.

\iniciocodigo
@<Análise Léxica: Regra F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Cerquilha, ``e'' comercial, arroba e cifrão.

\iniciocodigo
@<Análise Léxica: Regra G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Acento circunflexo e til.

\iniciocodigo
@<Análise Léxica: Regra H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Abrir colchetes.

\iniciocodigo
@<Análise Léxica: Regra I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Fechar colchetes.

\iniciocodigo
@<Análise Léxica: Regra J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Abrir e fechar chaves.

\iniciocodigo
@<Análise Léxica: Regra K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Análise Léxica: Regra L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

Depois de ler todos os caracteres do próximo token, primeiro vemos se
estamos diante de um token simbólico reservado. Estes são tokens
simbólicos com o que seriam palavras-chave da linguagem. Podemos
identificá-los porque iremos armazenar uma lista de palavras-chave
reservadas da linguagem aqui:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static char* list_of_keywords[] = {
@<Lista de Palavras Reservadas@>
  NULL};
@
\fimcodigo

Sendo assim, sabemos que temos um token que corresponde a uma
palavra-chave reservada se ele estiver presente nesta lista terminada
em NULL. Se for o caso, geramos um token especial com um tipo
dependendo de sua posição na lista:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Reservado@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // O tipo de tokens reservados começa no 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) permanent_alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(*first_token);
      *first_token = *last_token = NULL;
      RAISE_ERROR_NO_MEMORY(mf, NULL, line);
      return;
    }
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(*first_token == NULL)
      *first_token = *last_token = (struct generic_token *) new_token;
    else{
      (*last_token) -> next = (struct generic_token *) new_token;
      *last_token = (struct generic_token *) new_token;
    }
    continue;
  }
}
@
\fimcodigo

Para usar a função \monoespaco{strcmp}, precisamos do seguinte
cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <string.h>
@
\fimcodigo

Se não for um token simbólico reservado, e se existir algo copiado
para o nosso buffer, então geramos um novo token simbólico
genérico. Este token será então uma variável:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Genérico@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) permanent_alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(*first_token);
    *first_token = *last_token = NULL;
    RAISE_ERROR_NO_MEMORY(mf, NULL, line);
    return;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  // Se tiver o nome de variável interna, podemos ajustar já seu ponteiro
  // para  o local em que seu conteúdo está:
  @<Preenche Ponteiro para Variável Interna@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) permanent_alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(*first_token == NULL)
    *first_token = *last_token = (struct generic_token *) new_token;
  else{
    (*last_token) -> next = (struct generic_token *) new_token;
    *last_token = (struct generic_token *) new_token;
  }
  continue;
}
@
\fimcodigo

\secao{5. Programas WEAVEFONT}

\subsecao{5.1. Executando Programas}

Quando avaliamos um programa WEAVEFONT, vamos precisar de duas
extruturas adicionais. A primeira delas, a qual chamaremos
de \monoespaco{struct metafont} irá conter as informações finais da
meta-fonte tipográfica que foi lida e que terá tudo que for necessário
para que tal fonte possa ser usada para renderizar cada um dos glifos
da fonte. A segunda estrutura, a qual chamaremos de \monoespaco{struct
context} representa o estado atual do analisador sintático e
representa informações que devemos saber para poder continuar
interpretando corretamente uma lista de tokens. Essa segunda estrutura
pode ser descartada depois de terminarmos de ler os tokens de nossa
fonte.

Em suma, para cada arquivo com código-fonte WEAVEFONT, iremos gerar um
único \monoespaco{struct metafont} com informações da fonte. Mas cada
vez que formos executar código deste arquivo (quando lemos ele pela
primeira vez, e depois uma vez para cada caractere a ser renderizado),
criaremos un novo \monoespaco{struct context}, que será descartado
após a execução.

A primeira coisa que nosso analisador sintático precisa saber é que
todo programa WEAVEFONT é uma sequência de instruções:

\alinhaverbatim
<Programa> -> <Lista de Instruções>
\alinhanormal

Na linguagem METAFONT era necessário indicar o fim de um programa com
a instrução \monoespaco{end}. Mas para a linguagem WEAVEFONT isso não
é necessário, pois ela assume que todo o código-fonte está contido em
um único arquivo. Portanto, o fim do arquivo é o fim do código

A primeira função de análise sintática que definiremos é a que
reconhece um programa inteiro. Ela recebe uma lista de tokens a ser
executada, representada pelo primeiro e último elemento. Se a lista
for nula, apenas retornamos: não fazer nada é a execução correta de um
programa vazio. Se existir, passa para a próxima função que irá
separar essa lista em instruções individuais e irá executar cada uma
delas. Por fim, retornamos se a execução foi bem-sucedida ou não.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_program(struct metafont *mf, struct context *cx,
                  struct generic_token *first_token,
                  struct generic_token *last_token){
  if(first_token == NULL)
    return true;
  if(!eval_list_of_statements(mf, cx, first_token, last_token))
    return false;
  // Código adicional a ser definido futuramente:
  @<Após Execução de Programa@>
  return true;
}
@
\fimcodigo

A estrutura de contexto ainda não será definida inteiramente. Iremos
mostrar o conteúdo dela à medida que for necessário. Por hora, a única
variável que mostraremos será a styring que armazena qual caractere
UTF-8 está sendo renderizado no momento, ou que armazena a string
vazia se não houver nenhum:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>=
struct context{
  char current_character[5];
  @<Atributos (struct context)@>
};
@
\fimcodigo

Já a estrutura da meta-fonte, por hora vamos indicar três variáveis
dentro dela. A primeira é um mutex, como descrito na Subseção 2.2.
Depois temos uma string com o nome do arquivo de onde o código da
fonte foi lida. A última indica se a fonte já terminou de carregar ou
se ainda está em carregamento. Uma fonte em carregamento está
executando código WEAVEFONT, mas ainda não terminou de processar todo
o arquivo até o final pela primeira vez. Ela ainda não sabe quais
caracteres ela pode ou não renderizar. Já se ela não está em modo de
carregamento,ela já terminou de processar o arquivo com o código e
está pronta para renderizar imagens.

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>+=
struct metafont{
  @<Declarar um Mutex@>
  char *file;
  bool loading;
  @<Atributos (struct metafont)@>
};
@
\fimcodigo

Ambas as estruturas de dados terão uma função que as inicializa e as
finaliza (a função que finaliza a estrutura
metafont, \monoespaco{\_Wdestroy\_metafont}, já foi declarada na Seção
1, quando listávamos o cabeçalho das funções que seriam exportadas
para o usuário):

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct metafont *init_metafont(char *filename);
struct context *init_context(struct metafont *mf);
void destroy_context(struct metafont *mf, struct context *cx);
@
\fimcodigo

A estrutura \monoespaco{metafont} precisa armazenar mais informações,
e também pode tanto ser alocada com a função permanente ou temporária
de alocação. Já o contexto sempre será temporário, e por isso sempre
será alocado e desalocado com as funções temporárias de memória.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct metafont *init_metafont(char *filename){
  struct metafont *mf;
  mf = (struct metafont *) permanent_alloc(sizeof(struct metafont));
  if(mf == NULL)
    return NULL;
  MUTEX_INIT(mf -> mutex);
  // Copiando o nome do arquivo com o código
  size_t filename_size = strlen(filename) + 1;
  mf -> file = (char *) permanent_alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  // Iniciamos no modo de carregamento
  mf -> loading = true;
  // Mais código a ser definido futuramente:
  @<Inicialização (struct metafont)@>
  return mf;
}
struct context *init_context(struct metafont *mf){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  if(cx == NULL){
    RAISE_ERROR_NO_MEMORY(mf, NULL, 0); // Vamos definir erros na Seção 5.2.
    return NULL;
  }
  cx -> current_character[0] = '\0';
  // A ser definido futuramente:
  @<Inicialização (struct context)@>
  return cx;
}
@
\fimcodigo

Já a definição das funções que finalizam e desalocam as estruturas:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>+=
void _Wdestroy_metafont(struct metafont *mf){
  if(permanent_free != NULL){
    permanent_free(mf -> file);
    // A ser definido no futuro:
    @<Finalização (struct metafont)@>
    MUTEX_DESTROY(mf -> mutex);
    permanent_free(mf);
  }
}
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void destroy_context(struct metafont *mf, struct context *cx){
  if(temporary_free != NULL){
    // A ser definido no futuro:
    @<Finalização (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo

Conforme foi comentado, a variável booleana \monoespaco{loading}
dentro da \monoespaco{struct metafont} deve ser mudada para falso
depois que o programa inteiro é avaliado e executado pela primeira
vez. Nesta mesma Subseção mostramos o código que é executado para ler
o programa pela primeira vez (função \monoespaco{eval\_program}). Só
precisamos então adicionar depois dele código para atualizar esta
variável:

\iniciocodigo
@<Após Execução de Programa@>=
mf -> loading = false;
@
\fimcodigo

\subsecao{5.2. Lidando com Erros}

Quando erros existirem em um código-fonte WEAVEFONT, nenhuma imagem ou
meta-fonte tipográfica pode ser gerada. Entretanto, o programador deve
ter alguma forma de descobrir o quê deu errado para que o problema
possa ser ajustado. Por causa disso, vamos adicionar à estrutura de
cada meta-fonte variáveis que, em caso de erro, conterão um
diagnóstico do quê aconteceu de errado:

\iniciocodigo
@<Atributos (struct metafont)@>=
  int errno, errno_line; // Código de erro, linnha em que teve erro
  char errno_character[5]; // Caractere sendo renderizado durante erro
  char *errno_str; // Informações adicionais na forma de string
  int errno_int; // INformações adicionais na forma de inteiro
@
\fimcodigo

A ideia é que caso nenhum erro aconteça, todas as variáveis acima
serão igual a zero ou nulo. Então, quando inicializamos uma
meta-fonte, precisamos inicializar estas variáveis com tais valores
que indicam ausência de erro:

\iniciocodigo
@<Inicialização (struct metafont)@>=
mf -> errno = mf -> errno_line = 0;
mf -> errno_character[0] = '\0';
mf -> errno_str = NULL;
mf -> errno_int = 0;
@
\fimcodigo

A ideia é que tão logo o primeiro erro seja encontrado, o valor
de \monoespaco{errno} deve mudar para algo que indique a natureza do
erro encontrado. Caso estejamos contando o número de linhas no código
(ou seja, quando a macro \monoespaco{W\_DEBUG\_METAFONT} estiver
definida), então a linha onde o erro ocorreu deve ser armazenada
em \monoespaco{errno\_line}. E se mais informação precisam ser
indicadas para que o erro possa ser descrito com mais precisão, então
usaremos o ponteiro logo abaixo e o faremos apontar para uma string
relevante. Ou armazenaresmo algum número que explique o erro
em \monoespaco{errno\_int}.

Somente o primeiro erro encontrado em cada meta-fonte deve ser
armazenado. Se houverem mais, eles devem ser ignorados. Todas as
funções que executam código WEAVEFONT devem retornar um valor
booleano. Caso nenhum erro tenha ocorrido, retrona-se verdadeiro. Já
em caso de erros, retorna-se falso.

Os diferentes tipos de erros serão armazenados aqui:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
enum { // Tipos de Erros
  ERROR_NO_ERROR = 0,
  // Os diferentes tipos que serão definidos:
  @<Tipos de Erros@>
  // E um último que esperamos nunca usar: indica erro desconhecido
  ERROR_UNKNOWN
};
@
\fimcodigo

Dado o código que definimos até agora, somente três tipos de erro
podem ocorrer. Podemos ficar sem memória quando estamos alocando um
token, um contexto ou qualquer outra estrutura auxiliar da qual
precisamos. Ou podemos ter encontrado um símbolo completamente
não-suportado em nosso analisador léxico. Ou ainda podemos ter
começado uma string e não terminado.

Não vamos nos preocupar com erros como quando um usuário passa um
arquivo de código-fonte que não existe para inicializar uma
meta-fonte. Neste caso, a fonte não será inicializada e não haverá
código algum. Os tipos de erro que nos interessa aqui são erros
léxicos e de sintaxe encontrados na linguagem.

Pode ser difícil para um usuário ter que lembrar todos os tipos de
erros para analisar corretamente esta informação. Por causa disso, uma
função será exportada para imprimir na tela uma mensagem
diagnosticando o erro encontrado:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>+=
void _Wprint_metafont_error(struct metafont *mf){
  char *line_number;
  // Primeiro tentamos gerar uma string com o número de linha onde teve erro.
  // Assim é como podemos calcular o tamanho desta string:
  int str_size = 128;
  //(int)(((int)ceil(log10((double) (mf -> errno_line)))+1));
  //          printf("AQUIII %d\n", (int) log10((double) (mf -> errno_line)));
  line_number = (char *) temporary_alloc(str_size);
  // Mas se não temos um número de linha, só deixamos a string vazia:
  if(mf -> errno_line == 0)
    line_number[0] = '\0';
  else
    sprintf(line_number, "%d: ", mf -> errno_line);
  switch(mf -> errno){
  case ERROR_NO_ERROR:
    fprintf(stderr, "%s:%s No errors.", mf -> file, line_number);
    break;
  @<Imprime Mensagem de Erro@>
  default:
    fprintf(stderr, "%s:%s Unknown error.", mf -> file, line_number);
  }
  if(mf -> errno_character[0] != '\0'){
    fprintf(stderr, " (while rendering '%s')\n", mf -> errno_character);
  }
  else
    fprintf(stderr, "\n");
  if(temporary_free != NULL)
    temporary_free(line_number);
}
@
\fimcodigo

Para adicionar novos tipos de erro, basta começarmos definindo os seus
tipos, o que acabará dando um código numérico para ele. Por exemplo,
para os casos de erro por não termos memória, por encontrarmos um caractere
inválido no analisador léxico e por termos começado e não terminado
uma string, podemos adicionar os 3 tipos abaixo:

\iniciocodigo
@<Tipos de Erros@>=
ERROR_NO_MEMORY, ERROR_INVALID_CHAR, ERROR_UNCLOSED_STRING,
@
\fimcodigo

Todo código de gerar erro tem algumas coisas em comum: eles recebem
uma estrutura com a meta-fonte que gerou o erro, opcionalmente pode
ter uma estrutura de contexto e tem um valor numérico que é zero ou o
número da linha onde teve o erro e todos os erros tem seu tipo
identificado por um código numérico. A seguinte macro genérica é o
código que todo erro produzido executa no momento que é gerado:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_GENERIC_ERROR(mf, cx, line, error_code) {\
  struct context *_cx = cx;\
  if(!mf -> errno){\
    mf -> errno = error_code;\
    mf -> errno_line = line;\
    if(cx != NULL && _cx -> current_character[0] != '\0')\
      memcpy(mf -> errno_character, _cx -> current_character, 5);}}
@
\fimcodigo

A única coisa mais específica é que cada tipo de erro diferente pode
querer armazenar diferentes tipos de informações adicionais nas
variáveis \monoespaco{errno\_str} e \monoespaco{errno\_int}. E há
erros que não armazenam nada nelas.

O erro de memória insuficiente é um dos casos em que nada mais é
armazenado:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_NO_MEMORY(mf, cx, line) {\
  RAISE_GENERIC_ERROR(mf, cx, line, ERROR_NO_MEMORY);}
@
\fimcodigo

No caso de termos um caractere não suportado, este erro armazena o
caractere em questão como um inteiro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_INVALID_CHAR(mf, cx, line, char) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_INVALID_CHAR);\
    mf -> errno_int = char;}}
@
\fimcodigo

E finalmente, quando estamos com uma string não-finalizada, nós
armazenamos a string em questão:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNCLOSED_STRING(mf, cx, line, str) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNCLOSED_STRING);\
    mf -> errno_str = (char *) permanent_alloc(strlen(str)+1);\
    memcpy(mf -> errno_str, str, sizeof(str)+1);}}
@
\fimcodigo

Para imprimir uma mensagem de diagnóstico para os três erros
definidos, usamos:

\iniciocodigo
@<Imprime Mensagem de Erro@>=
case ERROR_NO_MEMORY:
  fprintf(stderr, "%s:%s Not enough memory for allocation.", mf -> file,
          line_number);
  break;
case ERROR_INVALID_CHAR:
  fprintf(stderr, "%s:%s Unsupported character in source code: '%x'.",
          mf -> file, line_number, (unsigned) mf -> errno_int);
  break;
case ERROR_UNCLOSED_STRING:
  fprintf(stderr, "%s:%s Unclosed string \"%s\".", mf -> file,
          line_number, mf -> errno_str);
  break;
@
\fimcodigo

Note que no caso do erro em que a string não é finalizada, nós
copiamos o conteúdo da string para \monoespaco{errno\_str} após alocar
espaço para isso. O que significa que quando formos finalizar o
nosso \monoespaco{struct metafont}, precisaremos checar se existe algo
alocado lá e desalocar:

\iniciocodigo
@<Finalização (struct metafont)@>=
if(mf -> errno_str != NULL && permanent_free != NULL)
  permanent_free(mf -> errno_str);
@
\fimcodigo

O maior problema das macros que definimos é que elas esperam receber
um valor com o número de linha em que o erro ocorreu, ou zero se isso
não puder ser obtido. Para obter o valor quando ele existe,
tipicamente checamos o token onde o erro foi encontrado. Mas essa
informação é perdida e o local em que isso é armazenado sequer existe,
a menos que a macro \monoespaco{W\_DEBUG\_METAFONT} esteja
definida. Isso significa que toda vez que formos gerar qualquer erro,
teremos que checar se essa macro está definida para saber que valor
passar, o que seria um pouco chato.

Para evitar isso, vamos definir a macro abaixo para valores obcionais
que existemm somente se estamos em modo de depuração. Se não
estivermos, a macro sempre produz zero, e se estivermos, ela produz o
valor que passarmos. Como isso será uma macro, podemos até passar
variáveis que não existem fora do modo de depuração, que isso não
gerará um erro, já que neste caso tais variáveis são removidas:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#if defined(W_DEBUG_METAFONT)
#define OPTIONAL(x) x
#else
#define OPTIONAL(x) 0
#endif
@
\fimcodigo


\subsecao{5.3. Separando Lista de Instruções em Instruções Individuais}

Uma lista de instruções é uma sequência vazia, ou uma sequência de
instruções vazias, simples e compostas que podem se alternar em
qualquer ordem:

\alinhaverbatim
<Lista de Instruções> -> <Vazio> |
                         <vazio> ; <Lista de Instruções> |
                         <Instrução Simples> ; <Lista de Instruções> |
                         <Instrução Composta> <Lista de Instruções>
\alinhanormal

Uma instrução simples e vazia sempre deve ser terminada por um
ponto-e-vírgula. Já instruções compostas não precisam de
ponto-e-vírgula como delimitador, pois todas elas possuem um conjunto
de tokens de abertura no começo e um outro conjunto de tokens de
fechamento que as delimita. Elas podem ser instruções bastante longas
e podem conter dentro delas outras listas de instruções. Por exemplo,
um \monoespaco{if} e todo o código que é executado condicionalmente
dentro de seu corpo faz parte de uma mesma instrução composta.

Para realizar a análise sintática correta de nossos programas, nós
devemos ser capazes de identificar cada uma das instruções
individuais, mesmo quando não é tão simples encontrar como elas são
delimitadas. Contudo, por enquanto, nesta Subseção nós iremos escrever
código adotando uma heurística mais simples provisória: vamos assumir
que todas as instruções são delimitadas ou por um ponto-e-vírgula ou
pelo final da lista de tokens.

A função que fará isso é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_list,
                            struct generic_token *end_list);
@
\fimcodigo

O objetivo desta função é separar cada uma das instruções individuais
e passar cada uma delas para uma próxima função que avalia uma única
expressão. Para isso, ela assumirá que pode separar instruções
meramente separando elas pelo ponto-e-vírgula. O seu código é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_list,
                            struct generic_token *end_list){
  struct generic_token *begin, *end = NULL;
  begin = begin_list;
  @<Antes de Avaliar Código@>
  while(begin != NULL){
    // Este laço pula instruções vazias e posiciona 'begin' no começo da
    // próxima instrução não-vazia:
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_list)
        begin = begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    // Este laço acha o próximo token antes de um ';'e posiciona 'end' nele:
    if(end != NULL){
      while(end != end_list && end -> next -> type != TYPE_SEMICOLON)
        end = end -> next;
    }
    // Se encontramos algo, avaliamos uma instrução individual:
    if(begin != NULL){
      if(!eval_statement(mf, cx, begin, &end))
        return false;
      // E após avaliar a instrução, posiciona 'begin' no ';'
      if(end != end_list)
        begin = end -> next;
      else
        begin = NULL;
    }
  }
  @<Depois de Avaliar Código@>
  return true;
}
@
\fimcodigo

A função acima basicamente percorre uma lista de tokens até o final.
A invariante do laço \monoespaco{while} mais externo é que quando
iniciamos ele, o ponteiro \monoespaco{begin} está sempre ou em um
ponto-e-vírgula ou no começo da próxima instrução a ser executada. No
primeiro caso, vamos avançando a posição desse ponteiro ignorando os
pontos-e-vírgulas: elas são instruções vazias e portanto podem ser
ignoradas. Depois que \monoespaco{begin} estiver no começo de
instrução não-vazia, posicionamos então \monoespaco{end} no próximo
token que preceder um ponto-e-vírgula. Assim, os dois tokens delimitam
perfeitamente a instrução individual a ser executada, a qual passamos
para a função \monoespaco{eval\_statement}. Depois que esta função
avalia a instrução, se não ocorreu erro, fazemos com
que \monoespaco{begin} seja posicionado após o \monoespaco{end}, que
precede um ponto-e-vírgula. Sendo assim, na próxima iteração
o \monoespaco{begin} estará em um ponto-e-vírgula e o invariante do
laço é mantido.

Ou ao menos, a função acima pode funcionar perfeitamente na ilusão de
que é isso que ocorre. Isso porque o valor de \monoespaco{end} é
passado por referência, não por valor para a
função \monoespaco{eval\_statement}. Isso quer dizer que o valor dele
pode mudar. E isso de fato pode acontecer: quando uma instrução
composta é executada, o ponteiro pode ser movido para um valor
anterior ou posterior, dependendo de qual for a instrução e de como
ela é executada. De qualquer forma, toda vez que o ponteiro for movido
será para o token que precede a próxima instrução a ser
executada. Desta forma, a
função \monoespaco{eval\_list\_of\_statements} fica bastante simples,
com a ilusão de simplicidade mantida pelo trabalho da
função \monoespaco{eval\_statement}, que iremos definir nas próximas
Seções.

\secao{6. Uma Instrução Composta: O Bloco Composto}

\subsecao{6.1. Suportando Instruções Compostas}

Vimos na Seção anterior que existem instruções compostas que podem ser
formadas por muitas outras instruções. As regras gramaticais para elas é:

\alinhaverbatim
<Instrução Composta> -> <Bloco Composto> |
                        <Bloco Condicional> |
                        <Declaração de Caractere>
<Bloco Composto> -> begingroup <Lista de Instruções> endgroup
<Bloco Condicional> -> if <Expressão Booleana> :
                         <Lista de Instruções>
                         <Alternativas>
                       fi
<Definição de Caractere> -> beginchar <Descrição de Caractere>
                              <Lista de Instruções>
                            endchar
\alinhanormal

Pelas regras acima, as instruções compostas são três: podem ser
blocos (começam com \monoespaco{begingroup} e terminam
com \monoespaco{endgroup}), condicionais (começam com \monoespaco{if}
e terminam com \monoespaco{fi}) ou definição de caractere (começam
com \monoespaco{beginchar} e terminam com \monoespaco{endchar}).

Como podem haver listas de instruções dentro de cada instrução
composta, então várias instruções compostas podem também estar
aninhadas, uma dentro da outra. Mas cada instrução composta deve ser
iniciada e finalizada na ordem correta. Se o último começo de
instrução composta que lemos foi um \monoespaco{begingroup}, mas
pouco depois encontramos um \monoespaco{fi} ou
um \monoespaco{endchar}, o programa não está correto.

Para ler corretamente instruções compostas, devemos sevar em conta os
tokens que as delimitam, definidos abaixo:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_BEGINGROUP,            // O token simbólico 'begingroup'
TYPE_ENDGROUP,              // O token simbólico 'endgroup'
TYPE_IF,                    // O token simbólico 'if'
TYPE_FI,                    // O token simbólico 'fi'
TYPE_BEGINCHAR,             // O token simbólico 'beginchar'
TYPE_ENDCHAR,               // O token simbólico 'endchar'
@
\fimcodigo

E adicionamos eles à nossa lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"begingroup", "endgroup", "if", "fi", "beginchar", "endchar",
@
\fimcodigo

E agora a função que irá avaliar uma instrução individual.

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *,
                    struct generic_token *begin, struct generic_token **end);
@
\fimcodigo

A função recebe o começo e o fim da lista de tokens que forma uma
instrução individual. Para instruções simples, ambos os ponteiros
estão corretos. Para instruções compostas, que não são delimitadas por
ponto-e-vírgula como vimos na seção anterior, o ponteiro de começo
está correto, mas o de final não. Cabe então à
função \monoespaco{eval\_statement} corrigir esse ponteiro final
nestes casos.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_statement(struct metafont *mf, struct context *cx,
                    struct generic_token *begin, struct generic_token **end){
  @<Instrução: Composta@>
  @<Instrução: Declaração de Variável@>
  @<Instrução: Atribuição@>
  @<Instrução: Comando@>
  // Se estamos aqui, não identificamos o tipo de instrução:
  RAISE_ERROR_UNKNOWN_STATEMENT(mf, cx, OPTIONAL(begin -> line));
  return false;
}
@
\fimcodigo

A função acima irá testar se está diante de uma instrução composta ou
simples. Pode ser que nenhuma das opções seja identificada. Neste
caso, devemos gerar um erro de instrução não reconhecida. Primeiro
adicionamos este novo tipo de erro:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNKNOWN_STATEMENT,
@
\fimcodigo

E colocamos informação sobre ele nas variáveis de erro.

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNKNOWN_STATEMENT(mf, cx, line) {\
  RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNKNOWN_STATEMENT);}
@
\fimcodigo

E geramos uma mensagem impressa caso o usuário pergunte o quê deu
errado:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNKNOWN_STATEMENT:
  fprintf(stderr, "%s:%s Unknown statement. Perhaps you misspelled some "
          "operator, forgot an assignment or placed a ';' in the wrong "
          "place.", mf -> file, line_number);
  break;
@
\fimcodigo

Agora vamos às instruções composta. A primeira coisa a lembrarmos é que
será importante para a linguagem saber em qual nível de aninhamento
estamos para saber o escopo de eventuais variáveis declaradas. Por
causa disso, o contexto de nossa análise deve memorizar o nível de
aninhamento atual. Cada início de instrução composta
(\monoespaco{begingroup}, \monoespaco{if}, \monoespaco{beginchar})
aumenta esse nível em 1 e cada fim de instrução composta
(\monoespaco{endgroup}, \monoespaco{fi}, \monoespaco{endchar}) diminui
o nível em 1. Também devemos saber qual o token que criou o último
nível de aninhamento caso estejamos aninhados em uma instrução
composta e devemos armazenar uma cópia do token esperado que o
finalizará em uma pilha. Desta forma, saberemos se uma instrução
composta está sendo finalizada pelo token correspondente. Declaramos o
nível de aninhamento atual e a pilha de tokens esperados de
finalização:

\iniciocodigo
@<Atributos (struct context)@>=
  int nesting_level;
  struct generic_token *end_token_stack;
@
\fimcodigo

O nível de aninhamento deve ser inicializada como zero e a pilha de
tokens de finalização deve ser vazia inicialmente:

\iniciocodigo
@<Inicialização (struct context)@>=
  cx -> nesting_level = 0;
  cx -> end_token_stack = NULL;
@
\fimcodigo

Para facilitar a escrita de código que lida com estes níveis de
aninhamento, vamos criar duas funções auxiliares. Ambas recebem
um \monoespaco{struct context} com o contexto de execução atual e um
token. A primeira deve aumentar em 1 o nível de aninhamento dado um
token que começa uma instrução composta e a segunda deve diminuir
dado um token que finaliza um nível de aninhamento. A primeira deve
retornar erro se receber um token incorreto que não inicia uma
instrução composta e a segunda também vai gerar erro se o token
passado não for o correto que finaliza o nível de aninhamento atual:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok);
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok);
@
\fimcodigo

A implementação da primeira função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok){
  struct generic_token *end_token;
  end_token = (struct generic_token *)
                    temporary_alloc(sizeof(struct generic_token));
  if(end_token == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(tok -> line));
    return false;
  }
  // Somente 3 tipos de tokens serão passados para esta função:
  switch(tok -> type){
  case TYPE_BEGINGROUP:
    end_token -> type = TYPE_ENDGROUP;
    break;
  case TYPE_IF:
    end_token -> type = TYPE_FI;
    break;
  case TYPE_BEGINCHAR:
    end_token -> type = TYPE_ENDCHAR;
    break;
  default:
    return false;
  }
#if defined(W_DEBUG_METAFONT)
  end_token -> line = tok -> line;
#endif
  cx -> nesting_level ++;
  end_token -> next = cx -> end_token_stack;
  cx -> end_token_stack = end_token;
  return true;
}
@
\fimcodigo

E a implementação da segunda função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok){
  struct generic_token *end_tok = cx -> end_token_stack;
  if(end_tok == NULL){
    RAISE_ERROR_UNEXPECTED_TOKEN(mf, cx, OPTIONAL(tok -> line), tok -> type);
    return false;
  }
  else if(end_tok-> type != tok -> type){
    RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(tok -> line),
                               end_tok -> type, tok -> type);
    return false;
  }
  cx -> nesting_level --;
  cx -> end_token_stack = end_tok -> next;
  if(temporary_free != NULL)
    temporary_free(end_tok);
  return true;
}
@
\fimcodigo

Dois erros diferentes podem ser detectados acima. Podemos ter o
fechamento de uma instrução composta quando nenhuma instrução composta
foi aberta ou achamos o fechamento de uma instrução, sendo que a
última instrução que foi aberta era outra. Vamos adicionar então estes
dois tipos à lista:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNEXPECTED_TOKEN, ERROR_EXPECTED_FOUND,
@
\fimcodigo

No primeiro caso, nós armazenamos o token inesperado na forma de um
inteiro na variável de erro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNEXPECTED_TOKEN(mf, cx, line, tok) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNEXPECTED_TOKEN);\
    mf -> errno_int = tok;}}
@
\fimcodigo

O segundo tipo de erro é quando esperávamos encontrar um tipo de token
simbólico, mas ao invés disso encontramos outro. Devemos então
armazenar nas variáveis de erro qual o tipo de token que esperávamos e
qual o tipo que achamos no lugar disso. O esperado terá seu tipo
representado como string e o encontrado será armazenado como um
inteiro com seu tipo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_EXPECTED_FOUND(mf, cx, line, expected, found) {\
  if(!mf -> errno){\
    mf -> errno_int = found;\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_EXPECTED_FOUND);\
    if(found >= 8){\
      size_t _s = strlen(list_of_keywords[found - 8]);\
      mf -> errno_str = (char *) permanent_alloc(_s+1);\
      memcpy(mf -> errno_str, list_of_keywords[expected - 8], _s+1);\
    } else{\
      size_t _s = strlen(token_names_not_in_list_of_keywords[found]);\
      mf -> errno_str = (char *) permanent_alloc(_s+1);\
      memcpy(mf -> errno_str, \
             token_names_not_in_list_of_keywords[expected], _s+1);}}}
@
\fimcodigo

Na macro acima nós geramos a string correta para o tipo de token
esperado porque cada tipo de token possui um código numérico
sequencial (todos estão em um \monoespaco{enum} definido da Subseção
4.1) e o nome da maioria dos tokens também está em uma lista de
strings sequencial com o nome de todas as palavras-chave (definida na
Subseção 4.2). Converter do tipo para o nome, para a maioria deles é
apenas uma questão de subtrair o código numérico do tipo para obter o
índice em que o nome dele está na lista de nomes. Entretanto, isso não
funciona para tokens cujo valor numérico é menor que 8, já que eles
não são tratados como palavras-chave. Para representar o nome destes
outros tokens possíveis, lemos os seus nomes desta outra lista:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static char *token_names_not_in_list_of_keywords[] = {
  "nil", "<Numeric>", "<String>", "<Variable Name>", "(", ")", ",", ";"};
@
\fimcodigo

Já para imprimirmos uma mensagem de erro, fazemos o mesmo tipo de
transformação, mas desta vez para converter para string o tipo de
token que armazenamos como inteiro em \monoespaco{errno\_int}:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNEXPECTED_TOKEN:
  fprintf(stderr, "%s:%s We found '%s' token in a context where such "
          "token makes no sense.", mf -> file, line_number,
          ((mf -> errno_int < 8)?
          (token_names_not_in_list_of_keywords[mf -> errno_int]):
          (list_of_keywords[mf -> errno_int - 8])));
  break;
case ERROR_EXPECTED_FOUND:
  fprintf(stderr, "%s:%s Expected '%s' token. Found '%s' token.",
          mf -> file, line_number, mf -> errno_str,
          ((mf -> errno_int < 8)?
          (token_names_not_in_list_of_keywords[mf -> errno_int]):
          (list_of_keywords[mf -> errno_int - 8])));
  break;
@
\fimcodigo

Note que se um erro ocorrer ao interpretar código quando estamos no
meio de uma função composta, nós podemos interromper a execução antes
de executarmos o \monoespaco{end\_nesting\_level}. Por causa disso, ao
finalizar um contexto, devemos remover e finalizar qualquer token
existente na pilha de tokens de finalização esperados:

\iniciocodigo
@<Finalização (struct context)@>=
if(temporary_free != NULL){
  while(cx -> end_token_stack != NULL){
    struct generic_token *end_tok = cx -> end_token_stack;
    cx -> end_token_stack = end_tok -> next;
    temporary_free(end_tok);
  }  
}
@
\fimcodigo

\subsecao{6.2. A Instrução \monoespaco{begingroup}$\ldots$\monoespaco{endgroup}}

Como exatamente uma instrução composta é avaliada? Primeiro lembre-se
que a função \monoespaco{eval\_list\_of\_statements} separa o código
em partes usando o ponto-e-vírgula como delimitador. Em seguida, ele
passa cada parte para a função \monoespaco{eval\_statement}. Conforme
comentado, esse comportamento é um pouco ingênuo, pois instruções
compostas são instruções que podem possuir outras instruções e
ponto-e-vírgula dentro delas. Considere a seguinte lista
de tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][T5];
\alinhanormal

Nessa sequência, os três primeiros tokens seriam passados para serem
avaliados. depois, seria o \monoespaco{[T3][T4]}. E por fim,
o \monoespaco{[endgroup]}. Mas vamos fazer as coisas um pouco
diferentes. Quando recebermos um \monoespaco{[begingroup][T5]},
devemos avaliar só ele iniciando um novo aninhamento. Os dois outros
tokens recebidos serão devolvidos, para serem avaliados logo em
seguida. Fazemos isso mudando a posição do ponteiro que marca o fim da
instrução atual, conforme discutido na Subseção 5.3.

Quando recebermos o \monoespaco{endgroup}, faremos o mesmo:
interpretaremos só ele, marcando o fim da ĩnstrução composta e
devolvemos o token que vem a seguir para ser interpretado depois.

O código para tratar então qualquer declaração que comece
com \monoespaco{begingroup } é:

\iniciocodigo
@<Instrução: Composta@>=
if(begin -> type == TYPE_BEGINGROUP){
  begin_nesting_level(mf, cx, begin);
  // Para que o começo da próxima instrução benha depois de 'begingroup':
  *end = begin;
  return true;
}
@
\fimcodigo

Da mesma forma, se recebermos uma função que começa
com \monoespaco{endgroup}, nós tratamos só este priemiro token
encerrando o aninhamento do bloco:

\iniciocodigo
@<Instrução: Composta@>+=
else if(begin -> type == TYPE_ENDGROUP){
  if(!end_nesting_level(mf, cx, begin))
    return false;
  *end = begin;
  return true;
}
@
\fimcodigo

E se nós finalizarmos um programa sem finalizar uma instrução
composta? Neste caso, temos um novo tipo de erro:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNFINISHED_STATEMENT,
@
\fimcodigo

Quando este erro ocorrer, devemos armazenar como um inteiro o tipo de
instrução que não foi finalizada:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNFINISHED_STATEMENT(mf, cx, line, statement) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNFINISHED_STATEMENT);\
    mf -> errno_int = statement;}}
@
\fimcodigo

E a mensagem de erro que avisa o que aconteceu:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNFINISHED_STATEMENT:
  fprintf(stderr, "%s:%s Unfinished statement '%s'.",
          mf -> file, line_number, list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

Após executar qualquer código WEAVEFONT, o seguinte teste é realizado
para ver se estamos diante deste tipo de erro:

\iniciocodigo
@<Após Execução de Programa@>=
if(cx -> nesting_level > 0){
  RAISE_ERROR_UNFINISHED_STATEMENT(mf, cx,
                                  OPTIONAL(cx -> end_token_stack -> line),
                                  cx -> end_token_stack -> type);
  return false;
}
@
\fimcodigo

\secao{7. Declaração de Variáveis}

A declaração de variáveis é a primeira das instruções simples que
veremos. A sintaxe para declarar variáveis é:

\alinhaverbatim
<Instrução Simples> -> <Declaração de Variável> | ...
<Declaração de Variável> -> <Tipo> <Lista de Declaração>
<Tipo> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<Lista de Declaração> -> <Tag> | <Tag> , <Lista de Declaração>
\alinhanormal

Uma ``tag'' é basicamente um token simbólico sem um significado
pré-definido na linguagem. Por exemplo, ``\monoespaco{tag}'' é uma tag,
mas ``\monoespaco{begingroup}'' não é.

Para interpretar a declaração de variáveis, vamos então introduzir no
nosso analisador léxico os seguintes tokens especiais:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_T_BOOLEAN,               // O token simbólico 'boolean'
TYPE_T_PATH,                  // O token simbólico 'path'
TYPE_T_PEN,                   // O token simbólico 'pen'
TYPE_T_PICTURE,               // O token simbólico 'picture'
TYPE_T_TRANSFORM,             // O token simbólico 'transform'
TYPE_T_PAIR,                  // O token simbólico 'pair'
TYPE_T_NUMERIC,               // O token simbólico 'numeric'
@
\fimcodigo

E adicionamos todos à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo

Quando uma variável é declarada, devemos fazer duas coisas:

1) Se a variável não existir no nível de aninhamento atual, devemos
alocar uma estrutura da memória para armazenar seu conteúdo. Se ela já
existir, um erro é gerado. A variável é inicialmente preenchida com um
valor padrão que depende de seu tipo. Ela não poderá ser usada antes
de ser inicializada.

2) Devemos percorrer a lista de tokens e procurar por ocorrências
desta variável mais adiante no mesmo nível de aninhamento, ou em
aninhamento inferior. E devemos atualizar o ponteiro destes tokens
para que apontem para a região de memória recém-alocada para esta
variável.

Como cada variável possui diferentes informações e conteúdo,
dependendo de seu tipo, o modo pelo qual cada uma delas é criada pode
diferir. O que todas as variáveis tem em comum é a seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
// Variável genérica
struct variable{
  int type;
  struct variable *next;
};
@
\fimcodigo

Todas armazenam primeiro o seu tipo e depois um ponteiro para a
próxima. Dependendo do tipo da variável haverá mais informações
após o ponteiro.

Se estivermos diante de uma variável global, podemos querer preservar
e armazenar o nome da variável para o caso de querermos depois
modificar o seu valor dado o seu nome. Então vamos usar a seguinte
estrutura que armazena o nome e a variável:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct named_variable{
  char *name;
  struct named_variable *next;
  struct variable *var;
};
@
\fimcodigo

E a estrutura de dados da meta-fonte possui ponteiros para as
variáveis globais com nome armazenado e também para as outras
variáveis armazenadas nela:

\iniciocodigo
@<Atributos (struct metafont)@>=
  struct named_variable *named_variables;
  struct variable *variables;
@
\fimcodigo

Tais ponteiros para variáveis são inicializados como NULL:

\iniciocodigo
@<Inicialização (struct metafont)@>=
mf -> named_variables = NULL;
mf -> variables = NULL;
@
\fimcodigo

Para desalocar a lista de variáveis armazenadas na meta-fonte, basta
percorrer a lista encadeada delas. Algumas variáveis mais complexas
precisarão de operações adicionais para serem removidas, mas
trataremos delas posteriormente. Aqui desalocamos as variáveis cujos
nomes nós não armazenamos nem preservamos:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(permanent_free != NULL){
  struct variable *v = (struct variable *) (mf -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável 'v' em 'struct metafont'@>
    permanent_free(v);
    v = next;
  }
}
@
\fimcodigo

Já desalocar a lista de variáveis globais com nomes preservados é
praaticamente a mesma coisa, só precisamos desalocar também a
estrutura onde guardamos o nome delas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(permanent_free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) (named -> var);
    next = (struct named_variable *) (named -> next);
    permanent_free(named -> name);
    @<Finaliza Variável 'v' em 'struct metafont'@>
    permanent_free(v);
    permanent_free(named);
    named = next;
  }
}
@
\fimcodigo

No caso das variáveis que forem declaradas dentro da especificação de
um caractere a ser renderizado, elas serão armazenadas no contexto,
não na estrutura da fonte. Afinal, a duração delas será sempre
temporária:

\iniciocodigo
@<Atributos (struct context)@>=
  struct variable *variables;
@
\fimcodigo

A lista de variáveis é inicializada como vazia:

\iniciocodigo
@<Inicialização (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

E finalizamos ela assim como finalizamos a lista de variáveis globais:

\iniciocodigo
@<Finalização (struct context)@>+=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável 'v' em 'struct context'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

Agora vamos à interpretação da declaração de variável. Toda vez que
uma instrução começa com um tipo de variável, significa que estamos
diante de uma declaração de variável. Só temos então que obter o tipo
e o nome de cada variável, que estará separada por vírgulas quando há
mais de uma sendo declarada. E para cada nome encontrado, criaremos a
variável:

\iniciocodigo
@<Instrução: Declaração de Variável@>=
else if(begin -> type >= TYPE_T_BOOLEAN && begin -> type <= TYPE_T_NUMERIC){
  int type = begin -> type;
  struct symbolic_token *variable = (struct symbolic_token *) (begin -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(variable -> line),
                                 TYPE_SYMBOLIC, variable -> type);
      return false;
    }
    @<Insere Variável Declarada@>
    if(variable != (struct symbolic_token *) *end)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(variable -> line),
                                 TYPE_COMMA, variable -> type);
      return false;
    }
    if(variable == (struct symbolic_token *) *end){ // Erro: Terminou com ','
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL((*end) -> line),
                                TYPE_SEMICOLON, TYPE_COMMA);
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

Criar e inserir uma variável no fragmento de código acima significa:

\iniciocodigo
@<Insere Variável Declarada@>=
{
  void *variable_pointer;
  if(mf -> loading){ // Variável deve ser guardada em 'struct metafont'
    if(cx -> nesting_level != 0 || variable -> value[0] == '_')
      variable_pointer = insert_variable(mf, type, variable,
                                         &(mf -> variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else{ // Variável guardada em 'struct context'
    variable_pointer = insert_variable(mf, type, variable, &(cx -> variables));
  }
  if(variable_pointer == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(variable -> line));
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

A função que insere uma nova variável sem o nome é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_variable(struct metafont *mf,
                                 int type,
                                 struct symbolic_token *variable,
                                 struct variable **target);
@
\fimcodigo

Ela aloca uma nova variável e a coloca no local indicado
por \monoespaco{target}, que será a lista
encadeada \monoespaco{variables} dentro da estrutura da meta-fonte ou
do contexto. No primeiro caso, a variável deve ser alocada pela função
de alocação permanente, e no segundo, pela alocação temporária. Por
isso passamos como argumento a função de alocação que deve ser usada:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_variable(struct metafont *mf,
                                 int type,
                                 struct symbolic_token *variable,
                                 struct variable **target){
  struct variable *var;
  size_t var_sizes[] = {
    sizeof(struct boolean_variable), sizeof(struct path_variable),
    sizeof(struct pen_variable), sizeof(struct picture_variable),
    sizeof(struct transform_variable), sizeof(struct pair_variable),
    sizeof(struct numeric_variable)
  };
  size_t var_size = var_sizes[type-TYPE_T_BOOLEAN];
  if(mf -> loading)
    var = (struct variable *) permanent_alloc(var_size);
  else
    var = (struct variable *) temporary_alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    @<Inicialização de Nova Variável@>
  }  
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL){
      p = (struct variable *) p -> next;
    }
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Já inserir uma variável nova com o nome é feito com a seguinte função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

Ela funciona de maneira similar, apenas alocando a estrutura do nome e
colocando a nova variável ali. Como só preservamos o nome de variáveis
globais, então certamente usaremos a alocação permanente para elas:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              permanent_alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) permanent_alloc(name_size);
  if(named -> name == NULL){
    if(permanent_free != NULL)
      permanent_free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(mf, type, var, &(named -> var));
  if(new_var == NULL){
    if(permanent_free != NULL){
      permanent_free(named -> name);
      permanent_free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL){
    mf -> named_variables = named;
  }  
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

E finalmente, a função que percorre uma lista de tokens procurando por
tokens simbólicos com o mesmo nome da variável alocada e fazendo o
ponteiro deles apontar para onde a variável está:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

A função percorre todos os tokens que vem depois do token com o nome
da nova variável e só para quando percorre a lista inteira ou quando
sai do nível de aninhamento atual para um onde a variável não existe
mais (quando acha um \monoespaco{endgroup}, \monoespaco{fi}
ou \monoespaco{endchar} encerrando o nível de aninhamento da variável):

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = (struct symbolic_token *) var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP || p -> type == TYPE_IF ||
       p -> type == TYPE_BEGINCHAR)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP || p -> type == TYPE_FI ||
            p -> type == TYPE_ENDCHAR)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Variáveis Numéricas}

Uma variável numérica será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  void *next;
  float value;
};
@
\fimcodigo

Comparando uma variável numérica com uma variável genérica, a
diferença é a variável de ponto-flutuante \monoespaco{value} que
armazena o valor numérico. Durante a criação da variável, o valor é
inicializado como NaN, que para nós representa uma variável com valor
desconhecido:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

O uso da macro \monoespaco{NAN} requer que usemos o cabeçalho
matemático:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

No caso das variáveis numéricas, nada a mais é necessário durante a
finalização, já que não há nada muito complexo além de um número em
ponto flutuante nelas.

Entretanto, além de variáveis declaradas pelo usuário, teremos também
algumas variáveis internas numéricas próprias. Elas sempre estarão
presentes e não precisam ser declaradas. Temos seis delas que são
numéricas: \monoespaco{pt}, \monoespaco{cm}, \monoespaco{mm}, \monoespaco{w},
\monoespaco{h} e \monoespaco{d}. Basicamente as três primeiras
irão armazenar quantos pixels correspondem a 1pt, 1cm e 1mm
respectivamente. As próximas três irão armazenar a largura, altura e
profundidade de um novo glifo caso estejamos renderizando algum no
momento. Nos demais casos, elas conterão zero.

Tais variáveis numéricas internas serão armazenadas na estrutura
da meta-fonte:

\iniciocodigo
@<Atributos (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

Na inicialização alocamos espaço para as três variáveis e as preenchemos:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_numeric_variables =
             permanent_alloc(6 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   ((double) dpi) / 72.0; // 1in = 72 pt
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   ((double) dpi) / 2.54; // 1in = 2.54cm
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   ((double) dpi) / 25.4; // 1in = 25.4mm
{
  int i;
  for(i = 0; i < 6; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;
  }
}
@
\fimcodigo

Criamos as seguintes macros para acessar cada uma destas variáveis
mais facilmente:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
#define INTERNAL_NUMERIC_W  3
#define INTERNAL_NUMERIC_H  4
#define INTERNAL_NUMERIC_D  5
@
\fimcodigo

Para finalizar a estrutura metafont, devemos desalocar tais variáveis
internas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(permanent_free != NULL)
  permanent_free(mf -> internal_numeric_variables);
@
\fimcodigo

Quando o nosso analisador léxico gera um novo token simbólico que não
é uma palavra reservada, ele já deve checar se este token tem o nome
de uma variável interna. Se tiver, o ponteiro para ela já é preenchido
corretamente:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
else if(!strcmp(buffer, "w")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_W]);
}
else if(!strcmp(buffer, "h")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_H]);
}
else if(!strcmp(buffer, "d")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_D]);
}
@
\fimcodigo

\subsecao{7.2. Variáveis de Pares}

Uma variável de par serve para armazenar coordenadas de um ponto. Ela
será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct pair_variable{
  int type; // Deve ser 'TYPE_T_PAIR'
  void *next;
  float x, y;
};
@
\fimcodigo

A diferença é que elas possuem espaço para dois valores em ponto
flutuante ao invés de um. Inicialmente vamos representar o primeiro
deles como NaN, para representar uma variável não-inicializada:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Variáveis de Transformação}

Se um variável de par é uma tupla de dois valores numéricos, uma
variável de transformação é uma tupla com seis valores
diferentes. Sejam os valores $(a, b, c, d, e, f)$, o que eles
representam é uma transformação linear na qual o par $(x, y)$ é
transformado em $(x', y')$ da seguinte forma:

$$\left[x\; y\;
      1\right]\matrix{c}{e}{0}{d}{f}{0}{a}{b}{1}=\left[x'\;\; y'\;\;
      1\right]
$$

Ou: $(x', y') = (a+cx+dy, b+ex+fy)$.

A ordem em que os elementos são representados pode parecer estranha,
mas é feito assim por compatibilidade com a linguagem METAFONT
original criada por Knuth.

Uma variável de transformação então simplesmente deve armazenar uma
transformação linear na forma de uma matriz:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct transform_variable{
  int type; // Deve ser 'TYPE_T_TRANSFORM'
  void *next;
  float value[9];
};
@
\fimcodigo

Uma transformação com valores não-inicializados possui seu primeiro
valor marcado como NAN:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_TRANSFORM)
  ((struct transform_variable *) var) -> value[0] = NAN;
@
\fimcodigo

Existe uma variável de transformação interna que sempre estará
presente sem precisar ser declarada. É a
variável \monoespaco{identity}, que representa a ausência de uma
transformação. É uma transformação que não irá mudar o ponto. Ela é
representada pela tupla $(0, 0, 1, 0, 0, 1)$ e sua transformação na
forma matricial é representada pela multiplicação por uma matriz
identidade.

As variáveis internas de transformação serão armazenadas na estrutura
Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct transform_variable *internal_transform_variables;
@
\fimcodigo

Na inicialização o espaço para armazenar as variáveis internas será
alocado e as variáveis internas são inicializadas:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_transform_variables =
  (struct transform_variable *)
    permanent_alloc(sizeof(struct transform_variable));
if(mf -> internal_transform_variables == NULL){
  if(permanent_free != NULL)
    permanent_free(mf);
  return NULL; //ERRO: Sem memória suficiente
}
// A transformação 'identity':
mf -> internal_transform_variables[0].type = TYPE_T_TRANSFORM;
INITIALIZE_IDENTITY_MATRIX(mf -> internal_transform_variables[0].value);
@
\fimcodigo

Na finalização isso deve ser desalocado:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(permanent_free != NULL)
  permanent_free(mf -> internal_transform_variables);
@
\fimcodigo

A variável \monoespaco{identity} deve ser registrada como tendo a
primeira posição:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_TRANSFORM_IDENTITY 0
@
\fimcodigo

E durante a leitura do código-fonte, podemos já ajustar corretamente
todas as referências para esta variável colocando o valor correto de
seu endereço nos tokens lidos:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>+=
else if(!strcmp(buffer, "identity"))
  new_token -> var =
          &(mf -> internal_transform_variables[INTERNAL_TRANSFORM_IDENTITY]);
@
\fimcodigo

\subsecao{7.4. Variáveis de Caminhos}

Variáveis de caminho são os tipos de variável mais complexas em
WEAVEFONT. Estas variáveis armazenam uma sequência de curvas onde a
próxima curva começa onde a última termina. Cada curva pode estar
representada de mais de uma forma diferente. Mas cada uma delas é uma
Curva de Beziér cúbica. O caminho pode ser cíclico, quando a última
curva da sequência termina no mesmo ponto em que o primeiro
começa. Para armazenar o conteúdo de um caminho, precisamos alocar
estruturas adicionais. Basicamente uma variável de caminho tem um
array de ``pontos'', com cada ponto sendo um ponto da curva com
informações adicionais relacionadas à ele, ou então sendo um ponteiro
para um subcaminho com vários outros pontos. Alguns destes pontos
podem estar ainda com informações incompletas que precisam ser
preenchidas. A variável que armazena isso é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct path_variable{
  int type; // Must be 'TYPE_T_PATH'
  void *next;
  bool permanent; // Which allocation was used: permanent or temporary
  bool cyclic;
  int length, number_of_points, number_of_missing_directions;
  struct path_points *points; // Array com 'length' elementos.
};
@
\fimcodigo

O número de pontos de uma variável de caminho é sempre maior ou igual
ao de sua variável \monoespaco{length}, já que cada posição do array
de \monoespaco{length} elementos contém ouumúnico ponto, ou um
subcaminho de 1 ou mais pontos.

De fato, cada ponto do array pode estar na verdade em quatro diferentes
formatos:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define UNINITIALIZED_FORMAT 0 // Não deve ser usado, exceto como inicialização
#define PROVISIONAL_FORMAT   1 // Informações sobre o ponto sendo coletadas
#define SUBPATH_FORMAT       2 // Ponteiro para muitos pontos de um subcaminho
#define FINAL_FORMAT         3 // Formato final, pronto pra ser usado
@
\fimcodigo

Vamos descrever agora como é o formato final que almejamos para cada
uma de nossas curvas.

Uma Curva de Beziér cúbica é definida por dois pontos de extremidade
($z_1$ e $z_4$) e dois pontos de controle ($z_2'$ e $z_3'$). Os dois
pontos de extremidade fazem parte da curva. Para obter todos os outros
pontos que fazem parte da curva à partir de quatro pontos $(z_1, z_2',
z_3', z_4)$, usa-se o seguinte procedimento:

1) Obtenha o ponto intermediário $z_{12}'$, que fica na metade do
caminho entre $z_1$ e $z_2'$, o ponto intermediário $z_{23}'$, que
fica no meio do caminho entre $z_2'$ e $z_3'$ e o ponto intermediário
$z_{34}'$, que fica no meio do caminho entre $z_3'$ e $z_4$.

2) Obtenha agora os dois pontos intermediários novos: $z_{123}'$, que
fica no meio do caminho entre $z_{12}'$ e $z_{23}'$ e o ponto
$z_{234}'$ que fica entre os pontos $z_{23}'$ e $z_{34}'$.

3) O novo ponto que faz parte da curva gerado é o ponto $z_{1234}$,
que fica no meio do caminho entre $z_{123}'$ e $z_{234}'$.

4) Gere os outros pontos da curva aplicando este procedimento
recursivamente sobre $(z_1, z_{12}', z_{123}', z_{1234})$ e sobre
$(z_{1234}, z_{234}', z_{34}', z_4)$.

É possível também obter uma fórmula para tais curvas. Dado dois pontos
de extremidade e dois de controle, todos os pontos intermediários
podem ser obtidos usando a fórmula abaixo, variando $t$ entre 0 e 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

A estrutura de dados que armazena a sequência de Curvas de Beziér nos
diferentes formatos é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct path_points{
  int format; // Qual o formato do ponto
  union{
    // Formato final: armazena ponto de extremidade e pontos de controle
    struct{
      float x, y; // Ponto de extremidade
      float u_x, u_y, v_x, v_y;   // Pontos de controle que o sucedem
    } point;
    // Formato de subcaminho: aponta para subcaminho
    struct path_variable *subpath;
    // Formato provisório: outras informações que não são pontos de controle
    struct{
      float x, y; // Ponto de extremidade
      float dir1_x, dir1_y, dir2_x, dir2_y; // Especificadores de direção
      float tension1, tension2;
      bool atleast1, atleast2;
    } prov;
  };
};
@
\fimcodigo

Basicamente seus pontos estarão apontados pelo
ponteiro \monoespaco{points}, um vetor de estrutura que terá um número
de elementos igual a \monoespaco{length}. Cada estrutura representará
um ponto $(x, y)$ ou então terá um ponteiro para outra variável de
caminho que contém um subcaminho (sempre que \monoespaco{subpath} não
for nulo, e nesta caso ignoraremos $x$ e $y$). Essa outra variável de
caminho pode conter recursivamente muitos pontos. Para armazenar a
quantidade total de pontos que o caminho contém recursivamente,
usamos \monoespaco{total\_length}. Enquanto a
variável \monoespaco{length} armazena apenas o tamanho do
array \monoespaco{points}.

Os pontos de controle definidos
por \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
e \monoespaco{v\_y} são os pontos de controle entre o ponto ou
subcaminho atual e o próximo, se houver. Caso seja um caminho cíclico,
os pontos de controle do último ponto ou subcaminho determinam como
ele será ligado ao primeiro ponto. Se não for cíclico, os pontos de
controle do último ponto são ignorados.

O modo como representaremos uma variável de caminho não-inicializada é
mantendo seu tamanho (\monoespaco{length}) como sendo igual a -1:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
  ((struct path_variable *) var) -> permanent = mf -> loading;
}
@
\fimcodigo

Quando vamos remover uma variável na estrutura da meta-fonte, se ela
for do tipo caminho e estiver inicializada, precisamos remover a lista
de pontos alocada com a função de desalocação permanente:

\iniciocodigo
@<Finaliza Variável 'v' em 'struct metafont'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;  
  if(path -> length != -1 && permanent_free != NULL)
    path_recursive_free(permanent_free, path, false);
}
@
\fimcodigo

Se a variável estiver na estrutura de contexto, fazemos o mesmo, mas
usando uma função de desalocação para variáveis temporárias:


\iniciocodigo
@<Finaliza Variável 'v' em 'struct context'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL)
    path_recursive_free(temporary_free, path, false);
}
@
\fimcodigo

Como um caminho pode conter subcaminhos e cada um deles também pode
ter seus próprios subcaminhos, em tais casos usamos uma função
recursiva para desalocar memória. Dada a função de desalocação e um
ponteiro para uma variável de caminho, nós desalocamos todos os seus
subcaminhos e depois a desalocamos. A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer);
@
\fimcodigo

E sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].format == SUBPATH_FORMAT)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath, true);
    }
    free_func(path -> points);
    if(free_first_pointer)
      free_func(path);
  }
}
@
\fimcodigo

\subsubsecao{7.4.1. Removendo Recursão de Variáveis de Caminho}

As variáveis de caminho são as mais complexas da linguagem WEAVEFONT,
e podem estar representadas de diferentes formas. Entretanto, muitas
destas formas são provisórias e apresentam características
indesejáveis. Por exemplo, embora um caminho possa armazenar seus
subcaminhos de maneira recursiva por meio de vários ponteiros, muitas
vezes isso é indesejável, pois nos impede de acessar rapidamente cada
um dos seus pontos.

Depois de avaliar um caminho, antes de armazenar ele como variável, é
interessante transformá-lo para o formato em que seja mais fácil
manipulá-lo. O caminho inicialmente vem no formato que foi mais fácil
montá-lo, dado a expressão de caminho que o gerou. Devemos então
aproveitar que o caminho será armazenado para convertê-lo de um
formato para outro.

A primeira destas conversões é remover a recursão dos caminhos. Isso
fará com que sua \monoespaco{length} e \monoespaco{total\_length}
fiquem com o mesmo tamanho, eliminando possibilidade de
confusões. Além disso, nenhum de seus pontos irá apontar para qualquer
subcaminho: cada um deles será efetivamente um ponto.

Para isso, vamos definir uma função que fará uma cópia de um
caminho. Mas ao fazer tal cópia, toda a recursão da origem será
eliminada no destino. A função que fará isso tem seu cabeçalho
mostrado abaixo, seguido do cabeçalho da função de cópia recursiva
auxiliar que ela chamará:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool recursive_copy_points(struct metafont *mf, struct context *cx,
                           void *(*alloc)(size_t),
                           struct path_variable **target,
                           struct path_variable *source,
                           bool alloc_target); // Precisa alocar destino?
void recursive_aux_copy(struct path_points **dst,
                        struct path_variable *origin, int *missing_directions);
@
\fimcodigo

A função usa a função de alocação indicada, que pode ser a permanente
ou temporária. Em seguida, preenche as variáveis relevantes no destino
e começa a copiar recursivamente. Este também é o momento em que
aproveitamos a iteração para checar se há informações pendentes que
precisam ser preenchidas no caminho. Mais especificamente a
variável \monoespaco{number\_of\_missing\_directions}:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool recursive_copy_points(struct metafont *mf, struct context *cx,
                          void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target){
  struct path_points *p;
  if(alloc_target){
    *target = (struct path_variable *) alloc(sizeof(struct path_variable));
    if(*target == NULL){
      RAISE_ERROR_NO_MEMORY(mf, cx, 0);
      return false;
    }
  }
  (*target) -> cyclic = source -> cyclic;
  (*target) -> permanent = (alloc == permanent_alloc);
  (*target) -> length = source -> number_of_points;
  (*target) -> number_of_points = source -> number_of_points;
  (*target) -> number_of_missing_directions = 0;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> number_of_points);
  if((*target) -> points == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, 0);
    return false;
  }
  p = (*target) -> points;
  recursive_aux_copy(&p, source, &((*target) -> number_of_missing_directions));
  return true;
}
@
\fimcodigo

Já a função recursiva que efetivamente copia os pontos:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin,
                        int *missing_directions){
  int index = 0;
  while(index <= origin -> length - 1){
    if(origin -> points[index].format != SUBPATH_FORMAT &&
       !isnan(origin -> points[index].point.x)){
      memcpy(*dst, &(origin -> points[index]),  sizeof(struct path_points));
      (*dst) ++;
      if(origin -> points[index].format == PROVISIONAL_FORMAT){
        // Aproveitamos para remover especificadores de direção inválidos:
        if(origin -> points[index].prov.dir1_x == 0.0 &&
           origin -> points[index].prov.dir1_y == 0.0){
          origin -> points[index].prov.dir1_x = NAN;
          origin -> points[index].prov.dir1_y = NAN;
        }
        if(origin -> points[index].prov.dir2_x == 0.0 &&
           origin -> points[index].prov.dir2_y == 0.0){
          origin -> points[index].prov.dir2_x = NAN;
          origin -> points[index].prov.dir2_y = NAN;
        }
        if(isnan(origin -> points[index].prov.dir1_x))
          (*missing_directions) ++;
        if(isnan(origin -> points[index].prov.dir2_x))
          (*missing_directions) ++;
      }
    }
    else if(origin -> points[index].format == SUBPATH_FORMAT)
      recursive_aux_copy(dst, (struct path_variable *)
                              (origin -> points[index].subpath),
                         missing_directions);
    index  ++;
  }
  return;
}
@
\fimcodigo

\subsubsecao{7.4.2. Tensão e Especificadores de Direção}

Vimos que um ponto que faz parte de um caminho pode estar em um
formato provisório, além de seu formato final e do seu formato de
ponteiro para subcaminhos. Quando isso ocorre, ele possui uma
quantidade bem grande de variávels. Em especial, ele possui dois
valores numéricos representando sua tensão e possui dois pares
representando os dois próximos especificadores de direção.

O primeiro especificador de direção deve ser considerado como um vetor
contendo o ângulo de virada da trajetória da curva no primeiro ponto
de extremidade e o segundo é o mesmo para o próximo ponto de
extremidade. O ângulo de virada pode ser visto como o ângulo das
``rodas'' de um veículo naquele ponto, caso o veículo estivesse
fazendo a trajetória da curva. Podemos representar tais informações no
código abaixo representando o trecho de um caminho:

\alinhaverbatim
{w0} z1 {w1} .. tension t1 and t2 {w2} z2 {w3} 
\alinhanormal

Note que se $w_0\neq w_1$ ou $w2 \neq w_2$, então haverá uma quebra na
curva no respectivo ponto de extremidade, haverá uma ``ponta'', um
ponto não-derivável.

Já a tensão deve representar o quão ``solta'' ou ``presa'' está uma
curva. Uma curva com tensão maior terá um perímetro menor e tenderá a
se aproximar de uma reta à medida que a tensão aumenta.

Tendo tais informações, como converter o ponto da curva do formato
provisório para o formato final? Usando como exemplo o segmento de
curva acima, isso é feito com ajuda das fórmulas abaixo:

$$
\theta = arg(w_1/(z_2-z_1))\,\,\,\phi = arg((z_2-z_1)/w_2)
$$

Não é o vetor de direção em si, mas o ângulo computado acima de tais
vetores que é efetivamente usado para computar os pontos de controle
do formato final de um ponto. A diferença entre o primeiero formato
provisório e o segundo é que o segundo já calculou esses ângulos
$\theta$ e $\phi$ e armazenou os resultados, descartando os vetores de
direção.

Para calcular a função $arg$ acima, vamos precisar do cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <complex.h>
@
\fimcodigo

Os pontos de controle $u$ e $v$ são obtidos então pelas fórmulas:

$$
u = z_{n} + e^{i\theta}(z_{n+1}-z_n)f(\theta, \phi)/\alpha
$$

$$
v = z_{n+1} - e^{-i\phi}(z_{n+1}-z_n)f(\phi, \theta)/\beta
$$

Com a função $f$ definida como:

$$
f(\theta, \phi) = {{2+\sqrt{2}(\sin\theta-{{1}\over{16}}\sin\phi)(\sin\phi-{{1}\over{16}}\sin\theta)(\cos\theta-\cos\phi)}\over{3(1+{1\over 2}(\sqrt 5 - 1)\cos\theta+{1\over 2}(3-\sqrt 5)\cos\phi)}}
$$

Podemos então declarar a função que faz a conversão e também a função
que computa $f$ abaixo:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void convert_to_final(struct path_variable *p);
double compute_f(double theta, double phi);
@
\fimcodigo

A função $f$:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double compute_f(double theta, double phi){
  double n = 2 + sqrt(2) * (sin(theta) - 0.0625 * sin(phi)) *
             (sin(phi) - 0.0625 * sin(theta)) * (cos(theta) - cos(phi));
  double d = 3 * (1 + 0.5 * (sqrt(5) - 1) * cos(theta) + 0.5 * (3 - sqrt(5)) *
                  cos(phi));
  return n/d;
}
@
\fimcodigo

Se assumirmos que um caminho já passou pela normalização que removeu
sua recursão, podemos facilmente transformar todos os seus pontos de
formato provisório para o final usando a função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void convert_to_final(struct path_variable *p){
  int i;
  for(i = 0; i < p -> length - 1; i ++){
    if(p -> points[i].format == PROVISIONAL_FORMAT){
      bool atleast0 = p -> points[i].prov.atleast1;
      bool atleast1 = p -> points[i].prov.atleast2;
      double complex u, v;
      struct path_points *p0 = &(p -> points[i]), *p1 = &(p -> points[i+1]);
      double w0_x = p0 -> prov.dir1_x, w0_y = p0 -> prov.dir1_y;
      double w1_x = p0 -> prov.dir2_x, w1_y = p0 -> prov.dir2_y;
      double complex z0 = p0 -> prov.x + p0 -> prov.y * I;
      double complex z1 = p1 -> prov.x + p1 -> prov.y * I;
      double theta = carg((w0_x + w0_y * I) / (z1 - z0));
      double phi = carg((z1 - z0)/(w1_x + w1_y * I));
      u = z0 + (cexp(theta * I) * (z1 - z0) * compute_f(theta, phi)) /
        p -> points[i].prov.tension1;
      v = z1 - (cexp(-phi * I) * (z1 - z0) * compute_f(phi, theta)) /
        p -> points[i].prov.tension2;
      p -> points[i].format = FINAL_FORMAT;
      p -> points[i].point.u_x = creal(u);
      p -> points[i].point.u_y = cimag(u);
      p -> points[i].point.v_x = creal(v);
      p -> points[i].point.v_y = cimag(v);
      @<Ajuste de Tensão@>
    }
  }
  if(p -> cyclic)
    memcpy(&(p -> points[p -> length - 1]), &(p -> points[0]),
           sizeof(struct path_points));
}
@
\fimcodigo

Uma última complicação que resta na conversão é ajustar a tensão. Se a
variável booleana \monoespaco{atleast0} estiver como verdadeira, isso
significa que a primeira tensão que tínhamos era um valor mínimo. Mas
devemos aumentá-la se necessário, para o menor valor tal que o
primeiro ponto de controle fique dentro de um triângulo delimitado
pelos pontos de extremidade e do ponto em que as retas direcionadas
pelos especificadores de direção se cruzam:

\iniciocodigo
@<Ajuste de Tensão@>=
if(atleast0)
  correct_tension(p0 -> point.x, p0 -> point.y,
                  p1 -> point.x, p1 -> point.y,
                  w0_x, w0_y, w1_x, w1_y,
                  &(p -> points[i].point.u_x), &(p -> points[i].point.u_y));
if(atleast1)
  correct_tension(p0 -> point.x, p0 -> point.y,
                  p1 -> point.x, p1 -> point.y,
                  w0_x, w0_y, w1_x, w1_y,
                  &(p -> points[i].point.v_x), &(p -> points[i].point.v_y));
@
\fimcodigo

A declaração da função que corrige a tensão e que usamos acima:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y);
@
\fimcodigo

E a implementação da função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y){
  double internal_angle0, internal_angle1, internal_angle2;
  double triangle_angle;
  double p2_x, p2_y;
  internal_angle0 = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + d0_x, p0_y + d0_y);
  internal_angle1 = get_angle(p1_x, p1_y, p0_x, p0_y, p1_x + d1_x, p1_y + d1_y);
  internal_angle2 = M_PI - internal_angle0 - internal_angle1;
  if(internal_angle0 + internal_angle1 >= M_PI - 0.00002 ||
     internal_angle0 == 0.0 || internal_angle1 == 0.0 ||
     internal_angle2 == 0.0)
    return; // // Não é um triângulo válido
  { // Descobre o terceiro vértice da coordenada
    // Primeiro compute lado do triângulo que vai de p0 ao vértice conhecido
    double known_side = hypot(p1_x - p0_x, p1_y - p0_y);
    double triangle_side = known_side * sin(internal_angle0) /
                           sin(internal_angle2);
    // Conhecendo o lado e o ângulo, computamos as coordenadas
    triangle_angle = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + 1.0, p0_y);
    p2_x = p1_x + triangle_side * cos(triangle_angle + internal_angle1);
    p2_y = p1_y + triangle_side * sin(triangle_angle + internal_angle1);
  }
  {
    @<Checa se Ponto Está Dentro do Triângulo@>
    @<Se Não Estiver, Ajusta Tensão para Ficar@>
  }
}
@
\fimcodigo

A função que obtém o ângulo entre dois vetores:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y){
  double v0_x, v0_y, v1_x, v1_y;
  v0_x = c0_x - v_x;
  v0_y = c0_y - v_y;
  v1_x = c1_x - v_x;
  v1_y = c1_y - v_y;
  if(fabs(v0_x) <= 0.00002 &&  fabs(v0_y) <= 0.00002)
    return INFINITY;
  if(fabs(v1_x) <= 0.00002 &&  fabs(v1_y) <= 0.00002)
    return INFINITY;
  
  return acos((v0_x * v1_x + v0_y * v1_y) /
                (hypot(v0_x, v0_y) * hypot(v1_x, v1_y)));
}
@
\fimcodigo


Como checar se um ponto está dentro de um triângulo? Há várias formas,
a que usaremos consiste em medir a área com sinal dos três novos
triângulos formados pelo ponto e dois vértices do triângulo. A ``área
com sinal'' é a área do triângulo, só que ela tem valor positivo ou
negativo dependendo se passamos os vértices no sentido horário ou
anti-horário. Em seguida, apenas verificamos se todas as áreas tem o
mesmo sinal (positivo ou negativo). Se tiver, então o ponto certamente
está fora. Caso contrário, o ponto está dentro do triângulo:

\iniciocodigo
@<Checa se Ponto Está Dentro do Triângulo@>=
bool s1, s2, s3; // O sinal das áreas
s1 = ((*control_x - p1_x) * (p0_y - p1_y) -
      (p0_x - p1_x) * (*control_y - p1_y)) < 0;
s2 = ((*control_x - p2_x) * (p1_y - p2_y) -
      (p1_x - p2_x) * (*control_y - p2_y)) < 0;
s3 = ((*control_x - p0_x) * (p2_y - p0_y) -
      (p2_x - p0_x) * (*control_y - p0_y)) < 0;
if(s1 == s2 && s2 == s3)
  return;
@
\fimcodigo

Uma vantagem deste método é que dependendo de qual área com sinal tem
um sinal diferente das outras, isso determina qual dos lados do
triângulo é mais próximo do ponto. Então, se ainda estivermos na
função, checamos qual é o lado mais próximo, obtemos sua equação de
reta e calculamos o ponto mais próximo na reta. Se o ponto estiver no
lado do triângulo, este é o novo ponto do ponto de controle. Se não, o
ponto de controle se torna a extremidade do triângulo mais próxima do
ponto.

\iniciocodigo
@<Se Não Estiver, Ajusta Tensão para Ficar@>=
{
  double x0, y0, x1, y1;
  if(s1 != s2 && s1 != s3){
    x0 = p0_x; y0 = p0_y;
    x1 = p1_x; y1 = p1_y;
  }
  else if(s2 != s1 && s2 != s3){
    x0 = p1_x; y0 = p1_y;
    x1 = p2_x; y1 = p2_y;
  }
  else{
    x0 = p2_x; y0 = p2_y;
    x1 = p0_x; y1 = p0_y;
  }
  if(x1 < x0){ // x1 deve ser maior ou igual a x0
    double tmp;
    tmp = x1 ; x1 = x0; x0 = tmp;
    tmp = y1; y1 = y0; y0 = tmp;
  }
  if(x0 == x1){ // Reta vertical (equação da reta daria divisão por zero)
    *control_x = x0;
    if(*control_y > y0 && *control_y > y1){
      if(y0 > y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
    else if(*control_y < y0 && *control_y < y1){
      if(y0 < y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
  }
  else if(y0 == y1) // Reta horizontal
    *control_y = y0;
  else{ // Usar equação da reta
    // m0 x + b0 = y é a reta que contém o lado do triângulo
    double m0 = (y1 - y0) / (x1 - x0);
    double b0 = y1 - m0 * x1;
    // m1 x + b1 = y é a perpendicular ao lado do triângulo e passa pelo ponto
    double m1 = - m0;
    double b1 = *control_y - m1 * *control_x;
    *control_x = (b1 - b0) / (m0 - m1);
    *control_y = m0 * *control_x + b0;
  }
  if(*control_x > x1){
    *control_x = x1;
    *control_y = y1;
  }
  else if(*control_x < x0){
    *control_x = x0;
    *control_y = y0;
  }
}
@
\fimcodigo

\subsubsecao{7.4.3. Deduzindo Especificadores de Direção}

Quando interpretamos um caminho de uma expressão ou trecho de código,
e após remover a recursão dele, ele sempre virá com seus pontos ou no
formato final, ou no formato provisório. Caso esteja no primeiro
formato provisório, ele sempre virá com as variáveis de tensão
e \monoespaco{atleast} corretamente preenchidas. Entretanto, ele pode
vir sem um dos especificadores de direção ou mesmo sem ambos. Por isso
cada variável de caminho armazena
em \monoespaco{number\_of\_missing\_directions} quantos
especificadores de direção faltam.

Podem haver dois casos: podemos ter especificadores de direção em que
o primeiro valor é NaN (Not-a-NUmber) e o segundo é um número, ou
ambos podem ser NaN. Se ambos não tiverem valor numérico, o
especificador de direção está ausente e é desconhecido. Se só o
segundo for um número, então ele representa a ``enrolamento''
(``curl'') da curva. Quanto maior o valor, mais os pontos de
extremidade agem ``enrolando'' a curva, como se ela fôsse uma corda
sendo enrolada em uma roldana. Uma parte maior da curva vai se
aproximando de uma reta, com a mudança brusca de direção sendo
reduzida a uma área menor. De qualquer forma, ambos os casos são
tratados como faltando um especificador, só a regra de como calcular
eles muda.

Para preencher os especificadores faltantes de um caminho, devemos
dividir ele em diferentes segmentos. Cada caminho com pontos faltantes
possui um ou mais segmentos em que existe um especificador de direção
ou ``curl'' apenas na região de extremidade do segmento:

$z_0\{w_0\}\,..\, $tension$\, a_0\, $and$\, b_0\, ..\, z_1\, ..\,
<etc.>\, z_{n-1}\, ..\, $tension$\, a_{n-1}\, $and$\,
b_{n-1} \{w_n\}z_{n}$

Este é o código da função que preenche os especificadores
faltantes. Note que o que ela faz é primeiro checar se temos um caso
em que praticamente todos os especificadores estão faltando. Neste
caso, o nosso segmento é o caminho todo. Caso contrário, ela itera
sobre cada segmento até que não hajam mais especificadores faltando:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool find_missing_directions(struct metafont *mf, struct context *cx,
                             struct path_variable *p);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool find_missing_directions(struct metafont *mf, struct context *cx,
                             struct path_variable *p){
  if(p -> number_of_missing_directions == 0 || p -> length < 2)
    return true;
  if(p -> cyclic && p -> number_of_missing_directions >= (2 * p -> length))
    return fill_cyclic_missing_directions(mf, cx, p, 0, p -> length - 1);
  if(!(p -> cyclic) && p -> number_of_missing_directions <= (2 * p -> length - 2))
    return fill_missing_directions(mf, cx, p, 0, p -> length - 2);
  else{
    int begin_segment = 0, end_segment = 0;
    while(p -> number_of_missing_directions > 0){
      while(p -> points[begin_segment].format != PROVISIONAL_FORMAT ||
            isnan(p -> points[begin_segment].prov.dir1_y) ||
            !isnan(p -> points[begin_segment].prov.dir1_x))
        begin_segment = (begin_segment + 1) % p -> length;
      end_segment = begin_segment;
      while(isnan(p -> points[end_segment].prov.dir2_x))
        end_segment = (end_segment + 1) % p -> length;
      if(!fill_missing_directions(mf, cx, p, begin_segment, end_segment))
        return false;
    }
    return true;
  }
}
@
\fimcodigo

Os valores desconhecidos são obtidos resolvendo sistemas de equações
lineares. Cada ponto que fica nas extremidades finais de um segmento
constribuirá com 1 incógnita e uma equação para o sistema. Todos os
outros pontos contribuirão com 3 incógnitas e 3 equações. Se o
segmento é um caminho cíclico inteiro, então não há pontos nas
extremidades e cada ponto contribui com 3 incógnitas e 3
equações. Isso significa que em caminhos não-cíclicos de $n$ pontos,
há $3(n-2)+2$ incógnitas, enquanto em caminhos cíclicos de $n$ pontos
teremos $3n$ incógnitas.

As incógnitas acrestentadas serão $\theta_0$ para o primeiro ponto de
segmento não-cíclico, $\phi_{n-1}$ para o último ponto de segmento
não-cíclico, e para os demais pontos de índice $i$, temos as
incógnitas $\theta_i$, $\psi_i$ e $\phi_i$. A ordem de cada incógnita
no sistema de equações é:
$(\theta_0, \theta_1, \psi_1, \phi_1, \ldots, \theta_{n-2}, \psi_{n-2}, \phi_{n-2}, \phi_{n-1})$
quando temos mais de dois pontos. Quando temos apenas dois pontos, a
ordem é simplesmente $(\theta_0, \phi_1)$.

Quando estivermos preenchendo os valores de uma nova equação do
sistema de equações em uma matriz $M$, que representa o lado esquerdo
de um sistema de equações linear, as incógnitas que cada equação pode
representar serão o $\theta$ atual e anterior, o $\psi$ atual, o
$\phi$ atual e o próximo. Nenhuma outra incógnita será
referenciada. Desta forma, cada linha da matriz $M$ terá no máximo
cinco elementos não-nulos.

Mas qual a posição destes cinco elementos na matriz $M$? Vamos declarar
cinco variáveis para manter o controle de tais índices:

\iniciocodigo
@<Declaração de Variáveis de Incógnitas (Não-Cíclico)@>=
int previous_theta, current_theta, current_psi, current_phi, next_phi,
    number_of_equations;
previous_theta = -1;
current_theta = 0;
current_psi = current_phi = -1;
if(begin == end)
  next_phi = 1;
else
  next_phi = 3;
number_of_equations = 0;
@
\fimcodigo

Os valores inicializados acima já funcionam no caso não-cíclico quando
estamos no primeiro ponto e queremos inserir a primeira
equação. Lembre-se que a posição das incógnitas em cada coluna de $M$
é dada pela ordem:
$(\theta_0, \theta_1, \psi_, \phi_1, \ldots)$. Então quando estamos no
ponto 0, não existe $\theta$ anterior e nem $\psi$ ou $\phi$
atuais. Já a posição do atual $\theta_0$ e $\phi_1$ (que é o próximo
$\phi$) estão corretas.

Já no caso cíclico, em todos os pontos, sempre teremos definidos os
valores de $\theta$, $\psi$ e $\phi$. Portanto, inicicalizamos da
seguinte forma:

\iniciocodigo
@<Declaração de Variáveis de Incógnitas (Cíclico)@>=
int previous_theta, current_theta, current_psi, current_phi, next_phi,
    number_of_equations;
previous_theta = size - 3;
current_theta = 0;
current_psi = 1;
current_phi = 2;
next_phi = 5;
number_of_equations = 0;
@
\fimcodigo


Se o nosso sistema de equações tem ``\monoespaco{size}'' elementos,
então o seguinte trecho de código abaixo muda a posição destes valores
para a próxima equação, mas sem mudar o ponto atual. Isso ocorre
quando não estamos nem na primeira e nem na última equação, quando um
mesmo ponto pode incluir até três equações. Neste caso as incógnitas
referenciadas são as mesmas, só precisamos passar para a próxima linha
da matriz $M$.

\iniciocodigo
@<Próxima Equação, Mesmo Ponto@>=
{
  previous_theta += size;
  current_theta += size;
  current_psi += size;
  current_phi += size;
  next_phi += size;
  number_of_equations ++;
}
@
\fimcodigo

Já quando passamos de um ponto pra outro, não só queremos passar para
a próxima equação, mas também precisamos atualizar as incógnitas que
não serão mais as mesmas:

\iniciocodigo
@<Próxima Equação, Próximo Ponto@>=
{
  previous_theta = current_theta + size;
  current_phi = next_phi + size;
  current_theta += (size + 3);
  current_psi += (size + 3);
  next_phi = number_of_equations * size + ((next_phi + 3) % size) + size;
  number_of_equations ++;
}
@
\fimcodigo

Note que não precisamos tratar como caso especial quando passamos do
primeiro ponto e equação para o próximo ponto. Em tais casos, o
$\psi_0$, que não existe, está já inicializado como tendo índice
-1. Pular para a próxima variável (de $\psi_{n}$ para $\psi_{n+1}$)
funcionasempre incrementando em 3 a posição. Então, ao passar para
fora do primeiro ponto, o valor já fica ajustado corretamente como o
índice 2, que realmente é a posição de $\psi_1$ no vetor de incógnitas
$x$.

Levando em conta o que foi apresentado sobre o sistema de equações a
ser resolvido em cada caso, no caso de segmento não-cíclico, a função
que preenche as direções faltantes é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool fill_missing_directions(struct metafont *mf, struct context *cx,
                             struct path_variable *p, int begin, int end);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool fill_missing_directions(struct metafont *mf, struct context *cx,
                             struct path_variable *p, int begin, int end){
  double *M, *x, *b;
  struct path_points *p0 = NULL, *p1 = &(p -> points[(begin) % p -> length]),
                     *p2 = &(p -> points[(begin+1) % p -> length]);
  double complex z0 = NAN, z1 = p1 -> prov.x + p1 -> prov.y * I,
                 z2 = p2 -> prov.x + p2 -> prov.y * I;
  int i = 1, size;
  @<Declaração de Variáveis de Incógnitas (Não-Cíclico)@>
  @<Checa caso degenerado@>
  int number_of_points = (end-begin+2);
  if(number_of_points < 0)
    number_of_points *= -1;
  size = 3 * ((number_of_points) - 2) + 2; // Tamanho do sistema de equações
  // Alocação do sistema:
  M = (double *) temporary_alloc(size * size * sizeof(double));
  x = (double *) temporary_alloc(size * sizeof(double));
  b = (double *) temporary_alloc(size * sizeof(double));
  if(M == NULL || x == NULL || b == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, 0);
    if(M != NULL && temporary_free != NULL) temporary_free(M);
    if(x != NULL && temporary_free != NULL) temporary_free(x);
    if(b != NULL && temporary_free != NULL) temporary_free(b);
    return false;
  }
  memset(M, 0, size * size * sizeof(double));
  // Iterando sobre cada ponto adicionando sistema de equações:
  @<Equação: Ponto Inicial@>
  if(begin != end){
    for(i = 1; (begin + i - 1) % p -> length != end ; i ++){
      p0 = p1; p1 = p2;
      p2 = &(p -> points[(begin+i+1) % p -> length]);
      z0 = z1; z1 = z2;
      z2 = p2 -> prov.x + p2 -> prov.y * I;
      @<Equação: Caso Geral@>
    }
  }
  @<Equação: Último Ponto@>
  if(!(p -> cyclic) && p -> length == 3){
    printf("M: %f %f %f %f %f\n", M[0], M[1], M[2], M[3], M[4]);
    printf(" : %f %f %f %f %f\n", M[5], M[6], M[7], M[8], M[9]);
    printf(" : %f %f %f %f %f\n", M[10], M[11], M[12], M[13], M[14]);
    printf(" : %f %f %f %f %f\n", M[15], M[16], M[17], M[18], M[19]);
    printf(" : %f %f %f %f %f\n", M[20], M[21], M[22], M[23], M[24]);
    printf("b: %f %f %f %f %f\n", b[0], b[1], b[2], b[3], b[4]);
  }
  solve_linear_system(size, M, b, x);
  @<Preenche especificador: primeiro ponto@>
  {
    int theta;
    for(theta = 1, i = 1; i < number_of_points - 1; i ++, theta += 3){
      // Acha direção em p->points[i] usando valor de x[theta]
      @<Preenche especificador: ponto interno@>
    }
  }
  @<Preenche especificador: último ponto@>
  if(temporary_free != NULL){
    temporary_free(M);
    temporary_free(x);
    temporary_free(b);
  }
  return true;
}
@
\fimcodigo

Já a função que preenche as direções faltantes no caso do caminho
cíclico inteiro não ter direções é bastante similar. Ela apenas deve
levar em conta que todos os pontos do caminho tem direções a serem
descobertas e também irá usar uma fórmula diferente para calcular o
tamanho do sistema de equações lineares, já que haverão três
incógnitas por ponto:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool fill_cyclic_missing_directions(struct metafont *mf, struct context *cx,
                                    struct path_variable *p, int begin,
                                    int end);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool fill_cyclic_missing_directions(struct metafont *mf, struct context *cx,
                                    struct path_variable *p, int begin,
                                    int end){
  double *M, *x, *b;
  struct path_points *p0 = NULL,
                     *p1 = &(p -> points[end]),
                     *p2 = &(p -> points[begin]);
  double complex z0 = p0 -> prov.x + p0 -> prov.y * I,
                 z1 = p1 -> prov.x + p1 -> prov.y * I,
                 z2 = p2 -> prov.x + p2 -> prov.y * I;
  int i, size = 3 * (p -> length); // Tamanho do sistema de equações
  @<Declaração de Variáveis de Incógnitas (Cíclico)@>
  // Alocação do sistema:
  M = (double *) temporary_alloc(size * size * sizeof(double));
  x = (double *) temporary_alloc(size * sizeof(double));
  b = (double *) temporary_alloc(size * sizeof(double));
  if(M == NULL || x == NULL || b == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, 0);
    if(M != NULL && temporary_free != NULL) temporary_free(M);
    if(x != NULL && temporary_free != NULL) temporary_free(x);
    if(b != NULL && temporary_free != NULL) temporary_free(b);
    return false;
  }
  memset(M, 0, size * size * sizeof(double));
  // Iterando sobre cada ponto adicionando sistema de equações:
  for(i = 0; i < p -> length; i ++){
    p0 = p1; p1 = p2;
    p2 = &(p -> points[(begin+i+1) % p -> length]);
    z0 = z1; z1 = z2;
    z2 = p2 -> prov.x + p2 -> prov.y * I;
    @<Equação: Caso Geral@>
  }
  solve_linear_system(size, M, b, x);
  {
    int theta;
    for(theta = 0, i = 0; i < p -> length; i ++, theta += 3){
      // Acha direção em p->points[i] usando valor de x[theta]
      @<Preenche especificador: ponto interno@>
    }
  }
  if(temporary_free != NULL){
    temporary_free(M);
    temporary_free(x);
    temporary_free(b);
  }
  return true;
}
@
\fimcodigo

Vamos ver agora quais são as equações que devemos inserir em cada
caso. Vamos ao primeiro ponto de um segmento não-cíclico. Pelas regras
de como expressões de caminho são interpretadas, temos que esse
primeiro ponto de segmento, que podemos chamar de $z_0$ e que é
sucedido por $z_1$ (aqui tratamos ambos como números complexos), ou já
tem um especificador de direção conhecido (o qual chamamos de $w_0$)
ou então ele possui um valor de ``curl'' associado a ele, o qual
chamamos de $\gamma$.

Se ele já tem um especificador de direção, o valor de $\theta_0$ dele
já é conhecido e dado pela equação:

$$
\theta_0 = arg(w_0/(z_1-z_0))
$$

Se ao invés disso ele tiver apenas um valor de $\gamma$, então
descobriremos depois $\theta_0$ com ajuda da seguinte equação que
adicionamos ao sistema:

$$
k_0\theta_0+k_1\phi_1=0
$$

Com as constantes $k_0$ e $k_1$ dependendo das tensões $t_1$ e
$t_2$ do ponto inicial:

$$
k_0=t_1^2(t_2^{-1}-3)-\gamma t_2^2t_1^{-1}
$$
$$
k_1=t_1^2t_2^{-1}-\gamma t_2^2(t_1^{-1}-3)
$$

O código para adicionar equação em ambos os casos segue abaixo:

\iniciocodigo
@<Equação: Ponto Inicial@>=
if(!isnan(p1 -> prov.dir1_x)){ // w0 conhecido
  double w1_x = p1 -> prov.dir1_x, w1_y = p1 -> prov.dir1_y;
  M[0] = 1.0; // Theta_0 é a primeira incógnita
  b[0] = carg((w1_x + w1_y * I) / (z2 - z1));
}
else{ // gamma conhecido
  double gamma = p1 -> prov.dir1_y;
  double t1 = p1 -> prov.tension1;
  double t2 = p1 -> prov.tension2;
  int phi1;
  if(begin == end)
    phi1 = 1;
  else
    phi1 = 3;
  M[0] = t1*t1*(1/t2 - 3.0) - gamma * t2 * t2 * (1/t1);
  M[phi1] = t1*t1*(1/t2) - gamma * t2 * t2 * (1/t1 - 3.0);
  b[0] = 0.0;
}
{
  previous_theta = size;
  current_theta = size + 1;
  current_psi = size + 2;
  current_phi = size + 3;
  if(number_of_points > 3)
    next_phi = size + 6;
  else
    next_phi = size + 4;
  number_of_equations ++;
}
@
\fimcodigo

No caso do ponto final, nós também teremos ou um especificador de
direção $w_n$ conhecido ou teremos um valor de ``curl'' conhecido com
o valor $\gamma_n$.

Se a direção $w_n$ for conhecida, nós já sabemos o falor de $\phi_n$
pela fórmula:

$$
\phi_n = arg((z_n - z_{n-1})/w_n)
$$

Já se tivermos apenas um valor de $\gamma_n$ conhecido, então o valor
de $\phi_n$ será descoberto depois com ajuda da equação:

$$
k_0\theta_{n-1}+k_1\phi_{n}=0
$$

Usando as constantes abaixo, que dependem da tensão $t_1$ e $t_2$
presente no ponto anterior:

$$
k_0=t_2^2t_1^{-1}-\gamma t_1^2(t_2^{-1}-3)
$$
$$
k_1=t_2^2(t_1^{-1}-3)-\gamma t_1^2t_2^{-1}
$$

O código para adicionar equação em ambos os casos segue abaixo.

\iniciocodigo
@<Equação: Último Ponto@>=
p1 = &(p -> points[(end) % p -> length]);
p2 = &(p -> points[(end+1) % p -> length]);
z1 = p1 -> prov.x + p1 -> prov.y * I;
z2 = p2 -> prov.x + p2 -> prov.y * I;
if(!isnan(p1 -> prov.dir2_x)){ // w_n conhecido
  double w1_x = p1 -> prov.dir2_x, w1_y = p1 -> prov.dir2_y;
  M[size * size - 1] = 1.0;
  b[size - 1] = carg((z2 - z1)/(w1_x + w1_y * I));
}
else{ // gamma conhecido
  double gamma = p1 -> prov.dir2_y;
  double t1 = p1 -> prov.tension1;
  double t2 = p1 -> prov.tension2;
  int last_theta;
  if(begin == end)
    last_theta = 2;
  else
    last_theta = size * size - 4;
  M[last_theta] = t2*t2*(1/t1) - gamma * t1 * t1 * (1/t2 - 3.0);
  M[size * size - 1] = t2*t2*(1/t1 - 3.0) - gamma * t1 * t1 * (1/t2);
  b[size - 1] = 0.0;
}
@
\fimcodigo

Por fim, vamos às três equações que são geradas para os pontos
interiores, que são todos os pontos de um segmento cíclico ou todos os
pontos de um segmento não-cíclico que não são o primeiro nem o último.

Dado o ponto $z_n$ precedido por $z_{n-1}$ e sucedido por $z_{n+1}$,
temos:

$$
\psi_n = arg((z_{n+1}-z_n)/(z_n-z_{n-1}))
$$
$$
\theta_n + \psi_n + \phi_n = 0
$$
$$
k_0\theta_{k-1} + k_1\theta_k + k_2\phi_n + k_3\phi_{n+1} = 0
$$

Assumindo o trecho de segmento:

$$
z_0\; ..\; tension\; t_0\; and\; t_1\; ..\; z_1\; ..\; tension\; t_2\; and\; t_3
\; .. z_2
$$

As constantes $k_0$, $k_1$, $k_2$ e $k_3$ para o ponto $z_1$ são dadas por:

$$
k_0 = t_1^2\|z_1-z_0\|^{-1}t_0^{-1}
$$
$$
k_1 = - t_2^2\|z_2-z_1\|^{-1}(t_3^{-1}-3)
$$
$$
k_2 = t_1^2\|z_1-z_0\|^{-1}(t_0^{-1} - 3)
$$
$$
k_3 = - t_2^2\|z_2-z_1\|^{-1}(t_3^{-1})
$$

O código que armazena as três equações segue abaixo:

\iniciocodigo
@<Equação: Caso Geral@>=
M[current_psi] = 1.0;
b[number_of_equations] = carg((z2 - z1)/(z1 - z0));
if(b[number_of_equations] == -M_PI)
  b[number_of_equations] *= -1.0;
@<Próxima Equação, Mesmo Ponto@>
M[current_theta] = M[current_psi] = M[current_phi] = 1.0;
b[number_of_equations] = 0.0;
@<Próxima Equação, Mesmo Ponto@>
{
  double t0 = p0 -> prov.tension1, t1 = p0 -> prov.tension2,
         t2 = p1 -> prov.tension1, t3 = p1 -> prov.tension2;
  M[previous_theta] = t1 * t1 * (1.0/cabs(z1 - z0)) * (1.0/t0);
  M[current_theta] = - t2 * t2 * (1.0/cabs(z2 - z1)) * (1.0/t3 - 3.0);
  M[current_phi] = t1 * t1 * (1.0/cabs(z1 - z0)) * (1.0/t0 - 3.0);
  M[next_phi] = - t2 * t2 * (1.0/cabs(z2 - z1)) * (1.0/t3);
  b[number_of_equations] = 0.0;
  @<Próxima Equação, Próximo Ponto@>
}
@
\fimcodigo

Mas o quê exatamente estas equações representam e de onde elas vieram?
Basicamente usamos as mesmas regras e equações que a linguagem
METAFONT usa para gerar suas curvas. Isso nos dá compatibilidade com a
linguagem. O método usado e as equações foram desenvolvidas por John
Hobby e publicadas em [HOBBY, 1986]. O que as regras
significam é que o caminho tem o seu formato invariante diante de
translação, rotação e mudança de escala. Além disso, a fórmula foi
desenvolvida para que qualquer mudança em um ponto local tenha
influência cada vez menor nos pontos seguintes (o impacto de mudanças
cai exponencialmente) e para minimizar pontas e mudanças bruscas de
direção na curva.

A equação que determina o formato da curva sempre tem solução desde
que todas as tensões sejam maiores que $3/4$ e os valores do
``enrolamento'' sejam sempre positivos ou nulos. Estas restrições de
valores serão reforçadas na interpretação de expressões de caminho. Se
encontrarmos um valor fora destes limites, iremos gerar um erro.

Existe, contudo, um último caso degenerado que podemos encontrar, em
que a equação pode não ter solução. Ele ocorre quando tempos um
segmento de apenas dois pontos e ambos possuem um ``enrolamento'' ao
invés de um especificador de direção. Há dois casos possíveis neste
cenário: eles geram um sistema de equações sem solução ou eles geram
um sistema onde a solução é uma linha reta. Por causa disso, vamos
assumir que sempre temos uma linha reta em tais casos:

\iniciocodigo
@<Checa caso degenerado@>=
if(begin == end && isnan(p1 -> prov.dir1_x) && isnan(p1 -> prov.dir2_x)){
  p1 -> format = FINAL_FORMAT;
  p1 -> point.u_x = p1 -> point.x + (1.0/3) * (p2 -> point.x - p1 -> point.x);
  p1 -> point.v_x = p1 -> point.x + (2.0/3) * (p2 -> point.x - p1 -> point.x);
  p1 -> point.u_y = p1 -> point.y + (1.0/3) * (p2 -> point.y - p1 -> point.y);
  p1 -> point.v_y = p1 -> point.y + (2.0/3) * (p2 -> point.y - p1 -> point.y);
  p -> number_of_missing_directions -= 2;
  return true;
}
@
\fimcodigo

Agora vamos começar a preencher os valores desconhecidos dos
especificadores de direção, assumindo que já resolvemos o sistema de
equações linear. No caso do primeiro ponto de um segmento não-cíclico,
as equações nos revelaram o valor $\theta_0$ associado a ele. Se ele
já tinha um especificador de direção, não precisamos fazer nada. Se
ele não tinha, o especificador $w_0$ é definido como:

$$
\theta_0 = arg(w_0/(z_1-z_0))
$$

E este é o código que coloca o primeiro especificador de direção se
precisar:

\iniciocodigo
@<Preenche especificador: primeiro ponto@>=
if(isnan(p -> points[begin].prov.dir1_x)){
  double complex dir;
  z0 = p -> points[begin].prov.x + p -> points[begin].prov.y * I;
  z1 = p -> points[(begin+1) % p -> length].prov.x +
       p -> points[(begin+1) % p -> length].prov.y * I;
  dir = cos(x[0]) + sin(x[0]) * I;
  dir *= (z1 - z0);
  p -> points[begin].prov.dir1_x = creal(dir);
  p -> points[begin].prov.dir1_y = cimag(dir);
  p -> number_of_missing_directions --;
}
@
\fimcodigo

Já no caso do último ponto, resolver o sistema de equações nos revelou
$\phi_{n}$. Se ele já possuía um especificador de direção, não é
necessário fazer nada. Caso contrário, podemos deduzir seu
especificador $w_n$ com a fórmula:

$$
\phi_n = arg((z_n-z_{n-1})/w_n)
$$

O código que faz isso, se necessário, segue abaixo:

\iniciocodigo
@<Preenche especificador: último ponto@>=
if(isnan(p -> points[end].prov.dir2_x)){
  double complex dir;
  z1 = p -> points[end].prov.x + p -> points[end].prov.y * I;
  z2 = p -> points[(end+1) % p -> length].prov.x +
       p -> points[(end+1) % p -> length].prov.y * I;
  dir = cos(x[size - 1]) + sin(x[size - 1]) * I;
  dir /= (z2 - z1);
  dir = 1.0 / dir;
  p -> points[end].prov.dir2_x = creal(dir);
  p -> points[end].prov.dir2_y = cimag(dir);
  p -> number_of_missing_directions --;
}
@
\fimcodigo

Já para todos os demais pontos de índice $k$, nós temos tanto um
$\theta_k$ como um $\phi_k$ e podemos usar tanto uma como a outra
fórmula que o mesmo resultado é obtido. Mas a iteração que percorre os
pontos para preencher os resultados itera sobre cada um dos valores
existentes ajustando um índice \monoespaco{i} correspondendo ao número
do ponto que estamos visitando e um índice \monoespaco{theta} com o
valor do índice no vetor solução $x$ que possui o $\theta$ associado
ao ponto atual. Por causa disso, escolhemos usar a fórmula de
$\theta_k$:

$$
\theta_k = arg(w_k/(z_{k+1}-z_k))
$$

Para os pontos internos, cada ponto possui na verdade dois
especificadores de direção: um do lado direito (armazenado nele mesmo)
e outro do lado esquerdo (armazenado no ponto anterior). Preenchemos
ambos os valores com o código abaixo:

\iniciocodigo
@<Preenche especificador: ponto interno@>=
{
  double complex dir;
  z0 = p -> points[begin + i].prov.x + p -> points[begin + i].prov.y * I;
  z1 = p -> points[(begin + i + 1) % p -> length].prov.x +
       p -> points[(begin + i + 1) % p -> length].prov.y * I;
  dir = cos(x[theta]) + sin(x[theta]) * I;
  dir *= (z1 - z0);
  p -> points[i].prov.dir1_x = creal(dir);
  p -> points[i].prov.dir1_y = cimag(dir);
  p -> number_of_missing_directions --;
  if(begin + i - 1 >= 0){
    p -> points[begin + i - 1].prov.dir2_x = creal(dir);
    p -> points[begin + i - 1].prov.dir2_y = cimag(dir);
    p -> number_of_missing_directions --;
  }
  else if(p -> cyclic){
    p -> points[end].prov.dir2_x = creal(dir);
    p -> points[end].prov.dir2_y = cimag(dir);
    p -> number_of_missing_directions --;
  }
}
@
\fimcodigo

\subsubsecao{7.4.4. Normalização de Caminhos}

Agora que definimos uma função que remove a recursão de caminhos
(\monoespaco{recursive\_copy\_points}, vista na Subseção 7.4.1), outra
para garantir que todos os pontos terão especificadores de direção
(\monoespaco{find\_missing\_directions}, vista na Subseção 7.4.3) e
uma outra que converte todos os pontos de um caminho do formato
provisório para o final (\monoespaco{convert\_to\_final}, visto na
Subseção 7.4.2), é hora de combinar todas estas funções de modo a
normalizar um caminho, deixando ele em seu formato final: o formato no
qual ele já pode ser renderizado.

Fazer isso envolve chamar cada uma destas funções na ordem
certa. Entretanto, existe uma última complicação que devemos tratar
para caminhos cíclicos.

Poderíamos representar um caminho cíclico de duas formas: assumindo
que é um caminho onde o primeiro e último ponto sempre são iguais ou
assumindo que há uma ligação adicional entre o último e o primeiro
ponto. No primeiro caso, o caminho cíclico abaixo armazenaria os
pontos $(0, 0)$, $(0, 3)$, $(4, 0)$ e $(0, 0)$ totalizando quatro
pontos, sendo que o último é igual ao primeiro. No segundo caso,
armazenaríamos apenas os três pontos e presumiríamos que o último
ponto está ligado ao primeiro, já que o caminho estaria marcado como
cíclico.

\alinhaverbatim
(0, 0) .. (0, 3) .. (4, 0) .. cycle;
\alinhanormal

Aparentemente, representar apenas três pontos é mais elegante: não
desperdiçamos memória com um ponto adicional e como visto no código da
subseção anterior, podemos iterar sobre caminhos cíclicos, começando à
partir de qualquer ponto que códigos como o abaixo passariam
exatamente uma vez por cada ponto:

\alinhaverbatim
for(i = 0; i < path -> length; i ++)
  struct path_point *p = &(path -> points[(begin + i) % path -> length]);
\alinhanormal

Observe como no código acima, não importa qual o valor
de \monoespaco{begin}, nós visitamos cada ponto uma só vez. Mas apenas
se trabalharmos com o pressuposto de que não estamos repetindo o
primeiro ponto uma vez adicional no fim do caminho cíclico. No código
da Subseção 7.4.3, usamos um laço deste tipo para percorrer um
segmento de caminho, e o código funciona mesmo quando o final do
segmento de caminho cíclico está armazenado antes do começo.

Entretanto, há dois casos em que há vantagem em armazenar
explicitamente uma cópia do primeiro ponto no fim de um caminho
cíclico. Primeiro, que e fizermos isso, a função que desenha o caminho
usando uma caneta não precisa tratar de maneira diferente caminhos
cíclicos e não-cíclicos. Nos dois casos, ela vai desenhando passando
por cada ponto até chegar ao último. Segundo, e mais importante,
considere o código abaixo que concatena dois caminhos:

\alinhaverbatim
p = ((-3, -3) -- (0, 0)) & ((0, 0) .. (0, 3) .. (4, 0) .. cycle);
\alinhanormal

A concatenação destrói a natureza cíclica do caminho. Se nós não
armazenamos explicitamente um ponto $(0, 0)$ no fim do segundo caminho
concatenado, como o resultado da operação deixa de ser cíclico,
teremos que inserir um ponto $(0, 0)$ adicional no fim do caminho
resultante. Para isso, potencialmente podemos ter que realocar o vetor
em que os pontos são armazenados no segundo caminho.

Para evitar aumentar a complexidade do código de concatenação e de
desenho, optaremos então por representar explicitamente uma cópia do
primeiro ponto no fim de um caminho cíclico. Mas para os casos em que
é melhor não ter esta cópia, podemos então realizar as operações:

1) Decremente a variável \monoespaco{length} do caminho.

2) Realize as operações assumindo que uma cópia do primeiro ponto não
é colocada no fim.

3) Incremente novamente a variável \monoespaco{length} e copie para a
última posição o primeiro ponto.

Desta forma, o código da Subseção anterior funcionará e conseguimos
ficar com quase o melhor dos dois mundos. Apenas tendo que fazer a
conversão acima em algumas partes. Por exemplo, dada a função que
normaliza um caminho deixando-o em seu formato final:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool normalize_path(struct metafont *mf, struct context *cx,
                    struct path_variable *path);
@
\fimcodigo

Ela pode ser implementada da seguinte forma:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool normalize_path(struct metafont *mf, struct context *cx,
                    struct path_variable *path){
  struct path_variable *new;
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(path -> permanent){
    alloc = permanent_alloc;
    disalloc = permanent_free;
  }
  else{
    alloc = temporary_alloc;
    disalloc = temporary_free;
  }
  if(!recursive_copy_points(mf, cx, alloc, &new, path, true))
    return false;
  if(disalloc != NULL)
    disalloc(path -> points);
  // Path se torna idêntico ao que era, mas sem recursão:
  memcpy(path, new, sizeof(struct path_variable));
  disalloc(new);
  if(path -> number_of_missing_directions > 0){
    if(path -> cyclic){
      if(isnan(path -> points[path -> length - 1].prov.dir1_x))
        path -> number_of_missing_directions --;
      if(isnan(path -> points[path -> length - 1].prov.dir2_x))
        path -> number_of_missing_directions --;
      path -> length --;
    }
    if(!find_missing_directions(mf, cx, path))
      return false;
    if(path -> cyclic){
      path -> length ++;
      memcpy(&(path -> points[path -> length - 1]), &(path -> points[0]),
             sizeof(struct path_points));
    }
  }
  convert_to_final(path);
  return true;
}
@
\fimcodigo


\subsecao{7.5. Variáveis de Caneta}

Uma variável de caneta armazena a estrutura utilizada para desenhar
formas no METAFONT. As canetas especificam o diâmetro e formato das
linhas e pontos a serem desenhados. Elas são armazenadas na seguinte
estrutura:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
struct pen_variable;
@
\fimcodigo

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct pen_variable{
  int type; // Deve ser 'TYPE_T_PEN'
  void *next;
  bool permanent; // Alocação da variável é permanente ou temporária?
  struct path_variable *format; // O formato como caminho cíclico
  int flags;
  struct pen_variable *referenced; // Não-nulo só em 'currentpen'
  float gl_matrix[9]; // Matriz de transformação OpenGL
  // As variáveis abaixo serão manipuladas só na Seção 10.
  GLuint gl_vbo; // Os vértices OpenGL após triangulação
  GLsizei indices; // Número de vértices presentes acima
  // Esta armazena o quão detalhada é a triangulação, necessária para
  // saber se devemos triangular novamente ou não em alguns casos:
  float triang_resolution; 
};
@
\fimcodigo

Aqui vamos dar uma breve explicação do que são cada uma destas
variáveis e por que elas são necessárias:

As variáveis \monoespaco{type}, \monoespaco{nesting\_level}
e \monoespaco{next} são comuns a todos os tipos de variáveis e não
apresentam novidade. Servem para que saibamos qual tipo de dado está
sendo armazenado na variável, qual o seu escopo e qual a próxima
variável caso ela esteja em uma lista encadeada.

A variável \monoespaco{format} especifica o formato de nossa caneta
como um caminho cíclico. No METAFONT original, era necessário que além
de cíclico, o caminho seja convexo. Para nós, será necessário apenas
que o caminho seja cíclico e simples. O que significa que o perímetro
do caminho não pode ter ter intersecções e cruzar consigo mesmo. Caso
isso não seja respeitado, o resultado será indefinido e não iremos
garantir que as canetas gerem o resultado esperado.

Não importa o quão complexo seja o formato da caneta, para que ele
possa ser desenhado na tela via OpenGL, ele deve ser convertido para
um conjunto de triângulos em um processo chamado de
triangulação. Detalhes sobre como triangular, ou mesmo se precisamos
triangular serão definidos pela variável \monoespaco{flags}. As flags
possíveis são:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define FLAG_CONVEX   1
#define FLAG_STRAIGHT 2
#define FLAG_CIRCULAR 4
#define FLAG_SQUARE   8
#define FLAG_NULL    16
@
\fimcodigo


A flag \monoespaco{FLAG\_CONVEX} armazena se estamos diante de um
formato convexo. Se esse for o caso, fazer a triangulação será um
processo muito simples. Poderemos usar um algoritmo muito mais simples
e rápido que fará tudo em O(n) quando precisarmos.

A flag \monoespaco{FLAG\_STRAIGHT} armazena se o formato de nossa caneta
é formado apenas por linhas retas, sem curvas. Se isso for verdade,
então quer dizer que uma vez que ele seja triangulado, nunca mais
precisaremos fazer isso novamente, mesmo que a caneta depois seja
ampliada ou reduzida. Se ela é formada só por linhas retas, os
triângulos são capazes de represerntar seu formato com perfeição, não
estamos usando nenhum tipo de aproximação. Por isso, não precisamos
gerar a triangulação novamente para poder mostrar mais detalhes
quando, por exempolo, a caneta se torna maior.

A flag \monoespaco{FLAG\_CIRCULAR} armazena se nós sabemos que a caneta
tem um formato circular. Neste caso, seremos capazes de fazer a
triangulação sem olhar para os pontos da variável de caminho
representando o formato.

A flag \monoespaco{FLAG\_SQUARE} armazena se a caneta é uma caneta
quadrada. Neste caso também não precisamos dos pontos da variável de
caminho e podemos usar uma triangulação já feita antes sem precisar
triangular novamente.

A flag \monoespaco{FLAG\_NULL} armazena se esta é uma caneta
nula. Neste caso ela nunca precisa ser triangulada, pois ela
representa um único ponto sem largura nem altura.

A variável \monoespaco{referenced} só poderá ter um valor não-nulo
quando estivermos nos referindo à caneta 'currentpen'. Neste caso, a
'currentpen' atuará como um ponteiro para outra caneta
definida. Devemos considerar então que 'currentpen' tem o formato e
triangulação da caneta apontada, mas a sua matriz de transformação
(descrita abaixo) na verdade deverá ser considerada como a matriz da
caneta apontada multiplicada pela matriz de \monoespaco{currentpen}.

A variável \monoespaco{gl\_matrix} armazena a matriz de transformação
OpenGL. Como as canetas possuem um formato bem-definido e não serão
depois subdivididos ou concatenados como podem ser os subcaminhos,
então podemos representar eventuais transformações lineares nela por
meio dessa matriz ao invés de ter que computar novos valores para seus
pontos.

As demais variáveis serão usadas mais na Seção
10. A \monoespaco{gl\_vbo} referenciará os vértices da caneta após ela
ser triangulada para poder ser desenhada. Se a caneta não foi
triangulada, seu valor será zero. Tais vértices, se existirem, estarão
armazenados na memória da placa de vídeo. Por
fim, \monoespaco{triang\_resolution} será uma medida interna do quão
detalhada é a triangulação. Ela ajudará a determinar se precisamos
criar uma triangulação mais detalhada, ou se a que temos já é a
suficiente.

Uma variável de caneta declarada, mas ainda não inicializada terá seu
formato igual ao ponteiro nulo, será não-circular e como ela ainda não
foi triangulada, terá seu ID de vértices OpenGL igual a zero.

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PEN){
  ((struct pen_variable *) var) -> format = NULL;
  ((struct pen_variable *) var) -> gl_vbo = 0;
  ((struct pen_variable *) var) -> indices = 0;
  ((struct pen_variable *) var) -> flags = false;
  ((struct pen_variable *) var) -> referenced = NULL;
  ((struct pen_variable *) var) -> permanent = mf -> loading;
}
@
\fimcodigo

O que significa que ao remover uma variável global e ela for de
caminho, devemos fazer a desalocação do formato e jogar fora os
vértices:

\iniciocodigo
@<Finaliza Variável 'v' em 'struct metafont'@>=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && permanent_free != NULL)
    path_recursive_free(permanent_free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
}
@
\fimcodigo

Se a variável for local ao invés de global, nós fazemos o mesmo usando
uma função diferente de desalocação.

\iniciocodigo
@<Finaliza Variável 'v' em 'struct context'@>+=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && temporary_free != NULL)
    path_recursive_free(temporary_free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
  @<Finalizando Caneta Local 'pen'@>
}
@
\fimcodigo

Além das variáveis de caneta definidas pelo usuário, iremos suportar a
existência de duas outras variáveis interna de caneta. Uma delas será
chamada de \monoespaco{currentpen} e irá representar a caneta atual
com a qual iremos escrever e desenhar. A outra será uma caneta de
formato perfeitamente quadrado que estará já inicializada à disposição
do usuário e que deixamos já alocada para fins de melhor performance.

Tais variáveis serão armazenadas na estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct pen_variable *internal_pen_variables;
@
\fimcodigo

Na inicialização iremos alocar espaço para ambas e inicializaremos
elas. A variável \monoespaco{currentpen} por padrão começará sendo uma
caneta vazia e a \monoespaco{pensquare} será um quadrado de lado
1.

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_pen_variables = (struct pen_variable *)
                                 permanent_alloc(2 * sizeof(struct pen_variable));
if(mf -> internal_pen_variables == NULL){
  if(permanent_free != NULL)
    permanent_free(mf);
  return NULL;
}
mf -> internal_pen_variables[0].format = NULL; // A caneta 'currentpen'
mf -> internal_pen_variables[0].type = TYPE_T_PEN;
mf -> internal_pen_variables[0].flags = FLAG_NULL;
mf -> internal_pen_variables[0].referenced = NULL;
mf -> internal_pen_variables[0].gl_vbo = 0;
mf -> internal_pen_variables[0].indices = 0;
mf -> internal_pen_variables[0].permanent = true;
mf -> internal_pen_variables[1].format = NULL; // A caneta 'pensquare'
mf -> internal_pen_variables[1].type = TYPE_T_PEN;
mf -> internal_pen_variables[1].flags = FLAG_CONVEX | FLAG_STRAIGHT |
                                        FLAG_SQUARE;
mf -> internal_pen_variables[1].referenced = NULL;
mf -> internal_pen_variables[1].gl_vbo = 0;
mf -> internal_pen_variables[1].indices = 4;
mf -> internal_pen_variables[1].permanent = true;
{ // Inicializando a matriz de transformação de ambas
  int j;
  for(j = 0; j < 2; j ++)
    INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[j].gl_matrix);
}
@
\fimcodigo

As seguintes macros nos permitirão acessar mais fácil a posição de
cada variável interna:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_PEN_CURRENTPEN 0
#define INTERNAL_PEN_PENSQUARE  1
@
\fimcodigo

Para finalizar a estrutura metafont, devemos desalocar as variáveis
internas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(permanent_free != NULL){
  if(mf -> internal_pen_variables[1].format != NULL){
    permanent_free(mf -> internal_pen_variables[1].format -> points);
    permanent_free(mf -> internal_pen_variables[1].format);
  }
  permanent_free(mf -> internal_pen_variables);
}
@
\fimcodigo

E ao ler um código-fonte, devemos ajustar corretamente os ponteiros
das variáveis que apontam para tais variáveis internas:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
else if(!strcmp(buffer, "currentpen"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]);
else if(!strcmp(buffer, "pensquare"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_PENSQUARE]);
@
\fimcodigo

A caneta '\monoespaco{currentpen}' é especial por ser a única caneta
que pode ao invés de ter um conteúdo próprio, referenciar o conteúdo
de outra caneta como um ponteiro. Mas o que acontece se desalocamos
uma caneta que era uma variável local, mas que era referenciada
pela \monoespaco{currentepen}? Fácil. Neste caso,
a \monoespaco{currentpen} volta a ter seu valor padrão e ser uma
caneta nula:

\iniciocodigo
@<Finalizando Caneta Local 'pen'@>=
if(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced == pen){
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].format = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].type = TYPE_T_PEN;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].flags = FLAG_NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].gl_vbo = 0;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].indices = 0;
}
@
\fimcodigo

\subsecao{7.6. Variáveis de Imagens}

Uma variável de imagem armazena uma imagem renderizada, possivelmente
por meio de pincéis e comandos de desenho do Weaver Metafont. Ao
contrário do METAFONT original, o Weaver Metafont requer que cada
imagem tenha um tamanho bem-definido. Todas elas terão uma altura e
largura. E além disso terão um índice representando uma textura
OpenGL, onde estará a iamgem renderizada:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct picture_variable{
  int type; // Deve ser 'TYPE_T_PICTURE'
  void *next;
  int width, height;
  GLuint texture;
};
@
\fimcodigo

Uma variável de imagem que foi declarada, mas ainda não inicializada
terá altura e largura negativa, e seu índice de textura será zero:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PICTURE){
  ((struct picture_variable *) var) -> width = -1;
  ((struct picture_variable *) var) -> height = -1;
  ((struct picture_variable *) var) -> texture = 0;
}
@
\fimcodigo

Ao remover uma variável alocada permanentemente na estrutura da
meta-fonte, se ela for de imagem, pedir via OpenGL que a textura seja
destruída caso exista:

\iniciocodigo
@<Finaliza Variável 'v' em 'struct metafont'@>=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

Se a variável for local ao invés de global, nós fazemos o mesmo:

\iniciocodigo
@<Finaliza Variável 'v' em 'struct context'@>+=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

Existirá uma variável interna de imagem no Weaver Metafont chamada
de \monoespaco{currentpicture}. No início de todo programa esta
variável estará pré-declarada. Para criar uma lista de variáveis
internas de imagem, a declaramos na estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct picture_variable *internal_picture_variables;
@
\fimcodigo

E na inicialização deixamos a variável \monoespaco{currentpicture}
declarada, mas deixada como não-inicializada:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_picture_variables = (struct picture_variable *)
                                   permanent_alloc(sizeof(struct picture_variable));
if(mf -> internal_picture_variables == NULL){
  if(permanent_free != NULL)
    permanent_free(mf);
  return NULL;
}
// A imagem 'currentpicture':
mf -> internal_picture_variables[0].type = TYPE_T_PICTURE;
mf -> internal_picture_variables[0].width = -1;
mf -> internal_picture_variables[0].height = -1;
mf -> internal_picture_variables[0].texture = 0;
@
\fimcodigo

Para deixar consistente com as outras variáveis internas, criamos esta
macro para nos referir à posição dela:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_PICTURE_CURRENTPICTURE 0
@
\fimcodigo

No momento em que chegar a hora de desalocar as variáveis internas,
devemos eliminar a textura dela também caso ela tenha sido
inicializada:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> internal_picture_variables[0].texture != 0)
  glDeleteTextures(1, &(mf -> internal_picture_variables[0].texture));
if(permanent_free != NULL)
  permanent_free(mf -> internal_picture_variables);
@
\fimcodigo

E à medida que lemos um código fonte, devemos ajustar corretamente as
variáveis chamadas ``\monoespaco{currentpicture}'' para apontar para a
variável interna:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
else if(!strcmp(buffer, "currentpicture"))
  new_token -> var =
          &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE]);
@
\fimcodigo

\subsecao{7.7. Variáveis Booleanas}

A mais simples de todas as variáveis, uma variável booleana armazena
somente verdadeiro ou falso. O formato de sua estrutura é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct boolean_variable{
  int type; // Deve ser 'TYPE_T_BOOLEAN'
  void *next;
  short value;
};
@
\fimcodigo

O valor \monoespaco{value} armazenado pela variável será 0 se for
falso ou 1 se for verdadeiro. No caso de ser uma variável
não-inicializada, armazenaremos -1:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_BOOLEAN)
  ((struct boolean_variable *) var) -> value = -1;
@
\fimcodigo


\secao{8. Atribuições}

Atribuições são como fazemos com que as variáveis sejam inicializadas,
como modificamos seus valores e como armazenamos nelas o resultado de
expressões.

A sintaxe de uma atribuição é:

\alinhaverbatim
<Instrução Simples> -> <Declaração de Variável> | <Atribuição> | ...
<Atribuição> -> <Variável> = <Lado Direito> |
                <Variável> := <Lado Direito>
<Lado Direito> -> <Expressão> | <Atribuição>
\alinhanormal

Isso significa que podemos realizar atribuições encadeadas, por
exemplo, todas as variáveis abaixo, se forem numéricas, passarão a
valer 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

Se no começo de uma declaração nós encontramos uma variável, então
certamente estamos diante de uma atribuição.

No contexto de uma atribuição, os tokens ``\monoespaco{=}'' e
``\monoespaco{:=}'' são equivalentes:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_EQUAL,            // O token simbólico '='
TYPE_ASSIGNMENT,       // O token simbólico ':='
@
\fimcodigo

Ambos os tipos de atribuição vão para a lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"=", ":=",
@
\fimcodigo

Agora que temos este novo tipo de token, o código para avaliar uma
atribuição segue em seguida. O que ele faz é percorrer a atribuição
detectando todas as variáveis que deverão passar pela
atribuição. Enquanto faz isso, o código checa se todas as variáveis
estão declaradas, se todas possuem o mesmo tipo, se tentamos atribuir
para algo que não é uma variável, um símbolo de atribuição está
faltando ou se está faltando uma expressão depois do último símbolo de
atribuição. Em qualquer um destes casos, um erro é gerado.

A parte que ainda não está sendo mostrada no código abaixo, mas será
definida nas próximas subseções é como avaliar a expressão após o
último símbolo de atribuição e como efetivamente fazemos a
atribuição. Isso porque o modo de fazer isso depende do tipo das
variáveis. Dependendo do tipo delas, esperaremos encontrar um tipo
diferente de expressão, e realizar o armazenamento de tais variáveis
também será diferente. Estes detalhes veremos nas próximas subseções.

\iniciocodigo
@<Instrução: Atribuição@>=
else if(begin -> type ==  TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin;
  struct generic_token *begin_expression;
  int type = 0; // Tipo das variáveis na atribuição
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
      RAISE_ERROR_EXPECTED_FOUND(mf, cx, OPTIONAL(var -> line),
                                TYPE_SYMBOLIC, var -> type);
      return false;
    }
    if(var -> var == NULL){
      RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(var -> line),
                                      var -> value);
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
      RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(var -> line),
                                     var -> value, 
                                     ((struct variable *)(var -> var)) -> type,
                                     type);
      return false;
    }
    if(var != (struct symbolic_token *) end)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_EQUAL && var -> type != TYPE_ASSIGNMENT){
      RAISE_ERROR_UNKNOWN_STATEMENT(mf, cx, OPTIONAL(begin -> line));
      return false;
    }
    if(var != (struct symbolic_token *) end)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL && (var -> next -> type == TYPE_EQUAL ||
                          var -> next -> type == TYPE_ASSIGNMENT));
  if(var == NULL){
    RAISE_ERROR_MISSING_EXPRESSION(mf, cx, OPTIONAL(var -> line), type);
    return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Atribuição de Variável Numérica@>
  @<Atribuição de Variável de Par@>
  @<Atribuição de Variável de Transformação@>
  @<Atribuição de Variável de Caminho@>
  @<Atribuição de Variável de Caneta@>
  @<Atribuição de Variável de Imagem@>
  @<Atribuição de Variável Booleana@>
  return true;
}
@
\fimcodigo

O código de atribuição acima será executado sempre que o primeiro
token de uma instrução for um nome de variável. Isso só ocorre em um
programa válido quando estamos prestes a fazer uma atribuição.

O código foca-se primariamente em lidar com erros. O
laço \monoespaco{do...while} acima serve basicamente para verificar se
o lado esquerdo da atribuição está correto. O invariante do laço é que
no começo de cada iteração, temos \monoespaco{var} apontando para um
token que é a próxima variável de uma atribuição encadeada. Podemos
encontrar aqui alguns erros já definidos antes, mas há alguns novos
como:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNDECLARED_VARIABLE, ERROR_WRONG_VARIABLE_TYPE, ERROR_MISSING_EXPRESSION,
@
\fimcodigo

O primeiro erro tratado é um erro já declarado antes e ocorre quando
estamos em uma série de atribuições encadeadas, mas um dos tokens que
deveria ser um nome de variável, não é. Por exemplo:

\alinhaverbatim
numeric a;
a = , = 3; % ERRO: esperava um nome de variável, obteve um ","
\alinhanormal

Neste caso, um erro será gerado na segunda iteração do laço.

O próximo erro que pode ocorrer é encontrarmos uma variável que não
foi declarada na atribuição. Isso pode ocorrer com variáveis de
qualquer posição no encadeamento. No exemplo acima, o erro seria
gerado se a variável \monoespaco{a} não tivesse sido declarada. Este é
um novo tipo de erro e vamos definir a macro que gera ele:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, line, name) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNDECLARED_VARIABLE);\
    mf -> errno_str = (char *) permanent_alloc(strlen(name)+1);\
    memcpy(mf -> errno_str, name, strlen(name)+1);}}
@
\fimcodigo

Como armazenamos o nome da variável não declarada que encontremos,
iremos usar esta informação para avisar o usuário que ela não está
declarada, caso ele pergunte o quê deu errado:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNDECLARED_VARIABLE:
  fprintf(stderr, "%s:%s Variable '%s' was not declared.", mf -> file,
          line_number, mf -> errno_str);
  break;
@
\fimcodigo

O próximo erro detectado também é novo e pode ocorrer em código do
tipo:

\alinhaverbatim
numeric a;
picture b;
a = b = 3; % ERRO: Variáveis de tipos diferentes na mesma atribuição
\alinhanormal

Para este tipo de erro, devemos informar ao usuário o nome da variável
com tipo diferente do esperado, o tipo dela e qual o tipo que
esperávamos no lugar disso. São três informações diferentes. Mas as
duas primeiras podem ser representadas juntas. A macro abaixo gera a
representação na forma de string de um token de nome de variável
declarado. No exemplo acima, a representação do token \monoespaco{b}
seria ``\monoespaco{<b:picture>}''. A macro que nos ajuda a montar tal
representação é:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define VARIABLE_TO_STRING(name, type, str) {\
  size_t _s = strlen(name) + 13;\
  str = (char *) permanent_alloc(_s);\
  str[0] = '\0';\
  strcat(str, "<");\
  strcat(str, name);\
  strcat(str, ":");\
  strcat(str, list_of_keywords[type - 8]);\
  strcat(str, ">");}
@
\fimcodigo

Com ajuda desta macro, podemos representar melhor informações sobre o
erro, usando uma string para indicar tanto o nome como tipo da
variável incorreta encontrada. O tipo esperado podemos armazenar como
um inteiro ao gerar o erro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, line, name, type, expected) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_WRONG_VARIABLE_TYPE);\
    VARIABLE_TO_STRING(name, type, mf -> errno_str);\
    mf -> errno_int = expected;}}
@
\fimcodigo

E aqui avisamos ao usuário o quê deu errado:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_WRONG_VARIABLE_TYPE:
  fprintf(stderr, "%s:%s Found '%s', but a variable of type '%s' was expected.",
          mf -> file, line_number, mf -> errno_str,
          list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

O próximo erro ocorre somente quando estamos na primeira iteração. O
primeiro token é um nome de variável, mas o próximo não é
um \monoespaco{=} nem um \monoespaco{:=}. Neste caso pode ter ocorrido
que o usuário esqueceu de colocar a atribuição. Ou pode ser que ele
tentou digitar algum outro comando, mas errou o nome durante a
digitação. Neste caso é difícil produzir uma mensagem de erro útil, já
que a causa pode ser duas coisas bem diferentes. Por isso apenas
geramos um erro de instrução desconhecida.

E finalmente, o último erro detectado no código acima, que só é
percebido depois que o laço se encerrar, acontece quando temos uma
atribuição incompleta como em:

\alinhaverbatim
numeric a;
a=;
\alinhanormal

Neste caso, o usuário esqueceu de colocar uma expressão. E devemos
armazenar o tipo de expressão esperada para avisar o usuário:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_MISSING_EXPRESSION(mf, cx, line, type) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_MISSING_EXPRESSION);\
    mf -> errno_int = type;}}
@
\fimcodigo

E aqui imprimimos a mensagem com o dignóstico do erro:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_MISSING_EXPRESSION:
  fprintf(stderr, "%s:%s Missing %s expression.",
          mf -> file, line_number, list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

\subsecao{8.1. Atribuições e Expressões Numéricas}

Como então realizar a atribuição de variáveis numéricas após checarmos
que não há erros no lado esquerdo a instrução de atribuição? Usamos o
código abaixo:

\iniciocodigo
@<Atribuição de Variável Numérica@>=
if(type == TYPE_T_NUMERIC){
  int i;
  struct numeric_variable result;
  // Obtém o valor da expressão do lado direito da atribuição:
  if(!eval_numeric_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    // A atribuição em si:
    ((struct numeric_variable *) (var -> var)) -> value = result.value;
    // Obtendo a próxima variável a atribuir:
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Agora passemos para definir como interpretar expressões numéricas.

\subsubsecao{8.1.1. Soma e Subtração: Normal e Pitagórica}

As regras iniciais de expressões numéricas seguem abaixo:

\alinhaverbatim
<Expressão Numérica> -> <Terciário Numérico>
<Terciário Numérico> -> <Secundário Numérico> |
                        <Terciário Numérico> <T-Op> <Secundário Numérico>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

Os símbolos de \monoespaco{+} e \monoespaco{-} corespondem à adição e
subtração. O símbolo \monoespaco{++} corresponde à soma pitagórica:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

Isso pode ser facilmente calculado em C usando a função da biblioteca
padrão matemática \monoespaco{hypot}.

Já o símbolo \monoespaco{+-+} corresponde à ``subtração pitagórica''
definida abaixo:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

Na subtração pitagórica, nós vamos usar a última definição envolvendo
a multiplicação de duas raízes quadradas em nossa implementação, pois
é a forma de cálculo que minimiza erros e presença de overflows e
underflows.

Os quatro operadores acima serão aqueles com a menor precedência. Tais
operações de soma e subtração serão feitas apenas depois que todas as
outras operações forem feitas.

Vamos definir os tokens de tais operadores:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_SUM,                   // O token simbólico '+'
TYPE_SUBTRACT,              // O token simbólico '-'
TYPE_PYTHAGOREAN_SUM,       // O token simbólico '++'
TYPE_PYTHAGOREAN_SUBTRACT,  // O token simbólico '+-+'
@
\fimcodigo

Entretanto, identificar corretamente os operadores de uma expressão
terciária envolve levar em conta delimitadores como ``['', ``]'',
``$\{$'' e ``$\}$'', além dos parênteses que já foram definidos quando
introduzimos o analisador léxico. Por isso, adicionaeremos também
tokens para os delimitadores que ainda não foram definidos:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_OPEN_BRACKETS,         // O token simbólico '['
TYPE_CLOSE_BRACKETS,        // O token simbólico ']'
TYPE_OPEN_BRACES,           // O token simbólico '{'
TYPE_CLOSE_BRACES,          // O token simbólico '}'
@
\fimcodigo

E adicionamos todos na lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo

Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

As expressões numéricas começam nas expressões terciárias numéricas
onde aparecem essas somas e subtrações. Pelas regras de sintaxe, o que
temos que fazer é percorrer toda a expressão até chegar ao último
símbolo de soma ou subtração que não estiver delimitado por
parênteses, colchetes ou chaves.

Para ajudar com isso, as seguintes macros vão declarar variáveis para
armazenar o aninhamento de delimitadores como parênteses e chaves, vão
checar se o aninhamento está aumentando ou diminuindo e verificar se
estamos dentro de um aninhamento ou não:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define DECLARE_NESTING_CONTROL() int nesting_parenthesis = 0, \
                                      nesting_brackets = 0, \
                                      nesting_braces = 0;
#define COUNT_NESTING(p) \
  {if(p -> type == TYPE_OPEN_PARENTHESIS){         \
    nesting_parenthesis ++;                       \
  } else if(p -> type == TYPE_CLOSE_PARENTHESIS){ \
    nesting_parenthesis --;                       \
  } else if(p -> type == TYPE_OPEN_BRACKETS){     \
    nesting_brackets ++;                          \
  } else if(p -> type == TYPE_CLOSE_BRACKETS){    \
    nesting_brackets --;                          \
  } else if(p -> type == TYPE_OPEN_BRACES){       \
    nesting_braces ++;                            \
  } else if(p -> type == TYPE_CLOSE_BRACES){      \
    nesting_braces --;\
  }}
#define IS_NOT_NESTED() (nesting_parenthesis == 0 && nesting_brackets == 0 && \
                         nesting_braces == 0)
#define RESET_NESTING_COUNT() nesting_parenthesis = 0; \
                              nesting_brackets = 0; \
                              nesting_braces = 0;
@
\fimcodigo

Depois de percorrermos uma expressão, podemos querer gerar um erro
caso tenhamos aberto um parênteses, um colchetes ou chaves que não foi
fechado ou se fechamos um que não foi aberto. Para isso, a seguinte
macro pode ser usada:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, line) {\
  if(nesting_parenthesis > 0){\
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, '(');\
    return false;\
  } else if(nesting_parenthesis < 0){\
    RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, ')');\
    return false;\
  } else if(nesting_brackets > 0){\
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, '[');\
    return false;\
  } else if(nesting_brackets < 0){\
    RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, ']');\
    return false;\
  } else if(nesting_braces > 0){\
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, '{');\
    return false;\
  } else if(nesting_braces < 0){\
    RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, '}');\
    return false;}}
@
\fimcodigo

Essa checagem requer que definamos dois novos tipos de erro:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNCLOSED_DELIMITER, ERROR_UNOPENED_DELIMITER,
@
\fimcodigo

Ao gerar este erro, o delimitador que não foi fechado ou que não foi
aberto será armazenado como um inteiro contendo o caractere:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, line, delimiter) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNCLOSED_DELIMITER);\
    mf -> errno_int = delimiter;}}
#define RAISE_ERROR_UNOPENED_DELIMITER(mf, cx, line, delimiter) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNOPENED_DELIMITER);\
    mf -> errno_int = delimiter;}}
@
\fimcodigo

Esta é a mensagem de diagnóstico deste erro:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNCLOSED_DELIMITER:
  fprintf(stderr, "%s:%s Delimiter '%c' was not closed.",
          mf -> file, line_number, mf -> errno_int);
  break;
case ERROR_UNOPENED_DELIMITER:
  fprintf(stderr, "%s:%s Delimiter '%c' was not previously opened.",
          mf -> file, line_number, mf -> errno_int);
  break;
@
\fimcodigo

Isso não detecta todos os erros possíveis envolvendo
delimitadores. Por exemplo, podemos ter um ``\monoespaco{($\{$)$\}$}''
que está errado, mas que não seria detectado. Tais tipos de erro serão
detectados futuramente. No momento só estamos nos preocupando com
delimitadores porque temos que identificar quando um operador está
fora dele para ser considerado um operador de expressão terciária. E
somente erros que nos impeçam de identificar isso corretamente serão
tratados.

Em uma expressão terciária, tudo que estiver do lado esquerdo do
operador terciário mais à direita deve ser avaliado recursivamente
como outra expressão terciária numérica. Já o que estiver à direita
será interpretado como uma expressão secundária numérica. Por fim, se
nenhum símbolo de soma e subtração for encontrada, a expressão inteira
será avaliada como uma expressão secundária numérica.

Contudo, existem exceções, casos nos quais não devemos considerar os
tokens \monoespaco{+} e \monoespaco{-} como soma e subtração. Por
exemplo:

\alinhaverbatim
a = +1;
\alinhanormal

Neste caso, o token de \monoespaco{+} é só um operador unário que não
muda o sinal do elemento que o sucede. Se fôsse um \monoespaco{-}, ele
inverteria o sinal do elemento a seguir. Não está ocorrendo soma ou
subtração alguma.

Este caso ocorre quando o \monoespaco{+} ou \monoespaco{-} estiverem
ben no começo da expressão numérica, ou então caso sejam precedidos
por vírgula, abrir de colchetes, símbolo de multiplicação, divisão,
outro operador terciário ou então um dos tokens seguintes que veremos
mais
adiante: \monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}, \monoespaco{of}, \monoespaco{point},
\monoespaco{precontrol} ou \monoespaco{postcontrol}.

Se nós temos um token anterior (\monoespaco{prev}) e um atual
(\monoespaco{cur}), podemos checar se ele representa uma adição ou
subtração válida com a macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_OF &&                    \
          prev -> type != TYPE_POINT &&                 \
          prev -> type != TYPE_PRECONTROL &&            \
          prev -> type != TYPE_POSTCONTROL &&           \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo

O código abaixo usa tais macros e interpreta as expressões numéricas
terciárias e trata a execução de operadores terciários,
identificando-os corretamente com ajuda da macro:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin,
                             struct generic_token *end,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  p = begin;
  do{ // Encontra último operador terciário: '+', '-', '++' ou '+-+'
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_PYTHAGOREAN_SUM ||
                          p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
                          IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_tertiary != NULL){ // Se nós temos operador terciário:
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin, end_tertiary, &a);
    eval_numeric_secondary(mf, cx, begin_secondary, end, &b);
    if(last_sum -> type == TYPE_SUM) // Avalia '+':
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT) // Avalia '-':
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM) // Avalia '++':
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){ // Avalia '+-+':
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
        RAISE_ERROR_NEGATIVE_SQUARE_ROOT(mf, cx, OPTIONAL(last_sum -> line),
                                         a.value - b.value);
        return false;
      }
    }
    return true;
  }
  else // Sem operador terciário:
    return eval_numeric_secondary(mf, cx, begin, end, result);
}
@
\fimcodigo

Note que pode ocorrer um erro acima ao tentarmos avaliar a subtração
pitagórica de dois números. Podemos obter a raíz quadrada de um número
negativo. Neste caso temos o seguinte novo tipo de erro:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_NEGATIVE_SQUARE_ROOT,
@
\fimcodigo

Quando isso ocorre, armazenamos o número negativo cuja raíz quadrada
tentamos obter na forma de uma string:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_NEGATIVE_SQUARE_ROOT(mf, cx, line, number) {\
  if(!mf -> errno){\
    mf -> errno_str = (char *) permanent_alloc(64);\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_NEGATIVE_SQUARE_ROOT);\
    snprintf(mf -> errno_str, 63, "%g", number);\
    mf -> errno_str[63] = '\0';}}
@
\fimcodigo

E esta é a mensagem impressa para o usuário:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_NEGATIVE_SQUARE_ROOT:
  fprintf(stderr, "%s:%s Tried to compute square root of negative value '%s'.",
          mf -> file, line_number, mf -> errno_str);
  break;
@
\fimcodigo

\subsubsecao{8.1.2. Multiplicação e Divisão}

As regras para lidar com expressões secundárias são:

\alinhaverbatim
<Secundário Numérico> -> <Primário Numérico> |
                         <Secundário Numérico> <S-Op> <Primário Numérico>
<S-Op> -> * | /
\alinhanormal

Os operadores \monoespaco{*} e \monoespaco{/} são respectivamente a
multiplicação e divisão.

Vamos adicionar estes operadores à lista de palavras-chave reservadas
e definir seus tipos:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_MULTIPLICATION,        // O token simbólico '*'
TYPE_DIVISION,              // O token simbólico '/'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"*", "/",
@
\fimcodigo

A função que irá avaliar expressões secundárias é:

Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin,
                            struct generic_token *end,
                            struct numeric_variable *result);
@
\fimcodigo

E a sua definição é muito semelhante à da função que avalia expressões
terciárias, exceto que ela lida com o cálculo de multiplicação e
divisão.

Entretanto, deve-se levar em conta que o token de divisão só deve ser
tratado neste estágio se aquilo que estiver antes e depois dele não
forem dois tokens numéricos. See forem, estamos diante de uma fração e
elas serão tratadas com um nível de precedência ainda maior. Por outro
lado, se já consideramos o token retrasado como uma fração, então
neste caso sim, o símbolo será de divisão, mesmo que esteja cercado de
tokens numéricos. Assim o código \monoespaco{1/3/1/3} é interpretado
como a divisão de duas frações $(1/3)/(1/3)$:


\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin,
                             struct generic_token *end,
                             struct numeric_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin;
  do{ // Acha último operador secundário '*' ou '/'
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
                          p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end &&  p -> next -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ // Multiplicação ou divisão válida
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_secondary != NULL){ // Se nós temos operador secundário:
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secondary(mf, cx, begin, end_secondary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION) // Avalia '*':
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){ // Avalia '/':
      if(b.value == 0.0){
        RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(last_mul -> line));
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else // Nenhum operador secundário:
    return eval_numeric_primary(mf, cx, begin, end, result);
}
@
\fimcodigo

No código acima, fazemos novamente uma checagem por erros de uso de
delimitadores, mesmo que uma checagem já tenha sido feita ao avaliar a
expressão terciária. Isso é necessário porque, por exemplo, o seguinte
código incorreto não produziria nenhum erro durante a avaliação de
expressão terciária que foi definida na Subseção anterior, mas
encontraria o erro de uso incorreto na avaliação da expressão
secundária acima:

\alinhaverbatim
numeric a;
a=(4*{8)+3}+1;
\alinhanormal

Vamos agora adicionar o novo erro que podemos encontrar de divisão por
zero:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_DIVISION_BY_ZERO,
@
\fimcodigo

Não é necessário adicionar qualquer informação adicional para reportar
este erro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, line) {\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_DIVISION_BY_ZERO);}
@
\fimcodigo

E esta é a mensagem de diagnóstico:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_DIVISION_BY_ZERO:
  fprintf(stderr, "%s:%s Division by zero.", mf -> file, line_number);
  break;
@
\fimcodigo


\subsubsecao{8.1.3. Módulo, Seno, Cosseno, Exponenciais, Piso e Aleatórios Uniformes}

As regras de expressões numéricas primárias são:

\alinhaverbatim
<Primário Numérico> -> <Átomo Numérico> |
                       length <Primário Numérico> | (...) |
                       <Operador Numérico> <Primário Numérico>
<Operador Numérico> -> sqrt | sind | cosd | log | exp | floor |
                       uniformdeviate |
                       <Operador de Multiplicador Escalar>
<Operador de Multiplicador  Escalar> -> + | - |
                       <Token Numérico Primário antes de var>
<Token Numérico Primário> -> <Token Numérico> / <Token Numérico> |
                             <Token Numérico não sucedido por ``/ num''>
\alinhanormal

O operador \monoespaco{length}, quando sucedido por um primário
numérico significa que queremos o módulo do valor. Ele pode ter outros
significados se sucedido por outro tipo de expressão primária.

Os novos operadores que aparecem aqui precisam ser adicionados à lista
de tokens:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_LENGTH,         // O token simbólico 'length'
TYPE_SQRT,           // O token simbólico 'sqrt'
TYPE_SIND,           // O token simbólico 'sind'
TYPE_COSD,           // O token simbólico 'cosd'
TYPE_LOG,            // O token simbólico 'log'
TYPE_EXP,            // O token simbólico 'exp'
TYPE_FLOOR,          // O token simbólico 'floor'
TYPE_UNIFORMDEVIATE, // O token simbólico 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

A função que interpreta uma expressão numéria primária será esta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct numeric_variable *result);
@
\fimcodigo

Podemos decidir qual regra deve ser aplicada na avaliação da expressão
numérica primária por meio de sete regras de interpretação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct numeric_variable *result){
  @<Primário Numérico: Regra 1@>
  @<Primário Numérico: Regra 2@>
  @<Primário Numérico: Regra 3@>
  @<Primário Numérico: Operadores Adicionais@>
  @<Primário Numérico: Regra 4@>
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_NUMERIC);
  return false;
}
@

Se não conseguirmos identificar nenhuma das regras, geramos o erro:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNKNOWN_EXPRESSION,
@
\fimcodigo

Gerar esse erro requer armazenar o tipo de expressão que analizávamos
quando encontramos algo desconhecido:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, line, type) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNKNOWN_EXPRESSION);\
    mf -> errno_int = type;}}
@
\fimcodigo

E a mensagem de diagnóstico é:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNKNOWN_EXPRESSION:
  fprintf(stderr, "%s:%s Unrecognizable %s expression.", mf -> file,
          line_number, list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

As regras que usamos para reconhecer a expressão são:

1) Se a expressão for composta por um único token, se começar com
``('' e terminar com ``)'' ou se for composta por três tokens, um
numérico, um \monoespaco{/} e outro numérico, então toda a expressão é
um átomo numérico:

\iniciocodigo
@<Primário Numérico: Regra 1@>=
if(begin == end || (begin -> type == TYPE_OPEN_PARENTHESIS &&
                    end -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin -> type == TYPE_NUMERIC &&  begin -> next != end &&
     begin -> next -> type == TYPE_DIVISION && begin -> next -> next == end &&
     end -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin, end, result);
}
@
\fimcodigo

2) Se encontramos o operador \monoespaco{length}, apenas checamos se a
expressão depois dele é numérica, e se for, calculamos o seu
módulo. Se for de outro tipo, será definido depois como iremos
calcular. Isso assume que temos uma função que identifica o tipo de
uma expressão.

\iniciocodigo
@<Primário Numérico: Regra 2@>=
else if(begin -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx, begin -> next, end);
  if(expr_type == TYPE_T_NUMERIC){
    struct numeric_variable num;
    if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Avalia 'length'@>
  else{
    RAISE_ERROR_UNKNOWN_EXPRESSION_TYPE(mf, cx, OPTIONAL(begin -> line),
                                        expr_type);
    return false;
  }
}
@
\fimcodigo

Note que identificar se estamos ou não em uma expressão numérica
primária envolve usar a
função \monoespaco{get\_primatry\_expression\_type}. Esta função é
definida na Subseção 8.8. Mas por hora, só é necessário saber que ela
recebe o começo e fim de uma expressão e à partir daí retorna o tipo
da expressão. Se o tipo for numérico, o código acima mostra como
calculamos o módulo. Se a expressão depois de \monoespaco{length} não
for numérica, ela será avaliada por outras regras que definiremos
depois (nas Subseções 8.2.4 e 8.4.5).  E se a expressão não for
reconhecida ou não seja suportada no contexto deste operador, o
seguinte tipo de erro é gerado:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNKNOWN_EXPRESSION_TYPE,
@
\fimcodigo

O tipo de expressão encontrado é armazenado. Dependendo do caso, o
tipo será desconhecido (seu valor será -1) ou será um tipo de
expressão não-suportada.

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNKNOWN_EXPRESSION_TYPE(mf, cx, line, type) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNKNOWN_EXPRESSION_TYPE);\
    mf -> errno_int = type;}}
@
\fimcodigo

Dependendo de qual dos dois casos temos, geramos uma mensagem de erro
diferente:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNKNOWN_EXPRESSION_TYPE:
  if(mf -> errno_int == -1)
    fprintf(stderr, "%s:%s We could not identity the expression type.",
            mf -> file, line_number);
  else
    fprintf(stderr, "%s:%s Found %s expression in a context where such"
                    "expression was not expected.", mf -> file, line_number,
                    list_of_keywords[mf -> errno_int - 8]);
  break;
@
\fimcodigo

3) Se encontrarmos um operador numérico, temos então um operador
numérico seguido de um primário numérico.

O primeiro dos operadores numéricos é o de raíz quadrada:

\iniciocodigo
@<Primário Numérico: Regra 3@>=
else if(begin -> type == TYPE_SQRT){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  if(num.value < 0.0){
    RAISE_ERROR_NEGATIVE_SQUARE_ROOT(mf, cx, OPTIONAL(begin -> line),
                                    num.value);
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;
}
@
\fimcodigo

Em seguida, temos o \monoespaco{sind}, que interpreta o próximo número
em graus (``degrees'', por isso a letra ``d'' no fim) e calcula seu
seno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_SIND){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = sinf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

O cálculo do cosseno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_COSD){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Em seguida calculamos o logaritmo na base $e$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_LOG){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  if(num.value <= 0.0){
    RAISE_ERROR_NEGATIVE_LOGARITHM(mf, cx, OPTIONAL(begin -> line),
                                   num.value);
    return false;
  }
  result -> value = logf(num.value);
  return true;
}
@
\fimcodigo

O novo erro gerado quando tentamos computar o logaritmo de um valor
negativo é:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_NEGATIVE_LOGARITHM,
@
\fimcodigo

Quando o erro é gerado, nós convertemos o número negativo que causou
problemas para uma string:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_NEGATIVE_LOGARITHM(mf, cx, line, number) {\
  if(!mf -> errno){\
    mf -> errno_str = (char *) permanent_alloc(64);\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_NEGATIVE_LOGARITHM);\
    snprintf(mf -> errno_str, 63, "%g", number);\
    mf -> errno_str[63] = '\0';}}
@
\fimcodigo

E avisamos o usuário do problema:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_NEGATIVE_LOGARITHM:
  fprintf(stderr, "%s:%s Tried to compute logarithm of negative value '%s'.",
          mf -> file, line_number, mf -> errno_str);
  break;
@
\fimcodigo

Assim é como calculamos a exponencial correspondente à $exp x = e^x$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_EXP){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  result -> value = expf(num.value);
  return true;
}
@
\fimcodigo

O piso de um valor:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_FLOOR){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  result -> value = floorf(num.value);
  return true;
}
@
\fimcodigo

Com relação ao operador \monoespaco{uniformdeviate}, o que ele faz é
gerar um número uniforme e aleatório entre 0 e o valor passado para o
operador. O modo que usaremos para fazer isso é gerar um número
aleatório em ponto flutuante entre 0 e 1, para em seguida
multiplicá-lo pelo operando.

Gerar um número em ponto flutuante entre 0 e 1 seguindo uma
distribuição próxima à uniforme, basicamente podemos gerar um inteiro
aleatório de 64 bits e multiplicá-lo por $2^{-64}$. Nem todos os valores
em ponto flutuante podem ser gerados desta forma, estaremos ignorando
valores menores que $2^{-64}$ e o arredondamento fará com que alguns
números mais próximos de 1 sejam mais comuns, embora a densidade
destes números mais comuns também seja menor. Entretanto, o resultado
será suficientemente próximo para nossos propósitos:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_UNIFORMDEVIATE){
  struct numeric_variable num;
  if(!eval_numeric_primary(mf, cx, begin -> next, end, &num))
    return false;
  { // Gerando o número aleatório
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;
  }
  return true;
}
@
\fimcodigo

O próximo operador numérico é o símbolo de \monoespaco{+}. Este
símbolo significa uma multiplicação por 1, e pode ser ignorado:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_SUM){
  if(!eval_numeric_primary(mf, cx, begin -> next, end, result))
    return false;
  return true;
}
@
\fimcodigo

Já se tivermos um símbolo de \monoespaco{-}, então isso significa uma
multiplicação por -1:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin -> type == TYPE_SUBTRACT){
  if(!eval_numeric_primary(mf, cx, begin -> next, end, result))
    return false;
  result -> value *= -1;
  return true;
}
@
\fimcodigo


4) Nos demais casos, temos uma multiplicação escalar em que o escalar
é um token numérico primário, que não é sucedido
por \monoespaco{+}, \monoespaco{-} ou por outro token numérico. Para
lidar com isso, teremos que identificar o começo e o fim do token
numérico primário. Pelas regras ele é um único token numérico, ou
então três tokens (dois tokens numéricos separados pelo
token \monoespaco{/} representando uma fração). Depois de realizar a
separação, a primeira parte é multiplicada pela segunda (que é
interpretada como primário numérico):

\iniciocodigo
@<Primário Numérico: Regra 4@>=
else{
  float token_value;
  struct generic_token *after_token;
  if(begin -> type != TYPE_NUMERIC){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_NUMERIC);
    return false;
  }
  token_value = ((struct numeric_token *) begin) -> value;
  after_token = begin -> next;
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                     TYPE_T_NUMERIC);
      return false;
    }
    after_token = after_token -> next;
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = after_token -> next;
  }
  if(!eval_numeric_primary(mf, cx, after_token, end, result))
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Números Isolados e Valores Aleatórios Normais}

As regras finais para as expressões numéricas que iremos tratar são:

\alinhaverbatim
<Átomo Numérico> -> <Variável Numérica> |
                    <Token Numérico Primário> |
                    normaldeviate |
                    ( <Expressão Numérica> )
\alinhanormal

O único token novo a ser tratado é \monoespaco{normaldeviate}:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_NORMALDEVIATE,  // O token simbólico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"normaldeviate",
@
\fimcodigo

Este operador serve para gerar um novo número aleatório com uma
distribuição normal com média 0 e desvio padrão 1.

A função que interpreta átomos numéricos é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct numeric_variable *result);
@
\fimcodigo

Vamos decidir qual regra aplicar para interpretar o átomo primeiro com
base nele ser um único token ou não. E depois, aplicamos diferentes
regras em cada caso:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct numeric_variable *result){
  if(begin == end){
    @<Átomo Numérico: Regra 1@>
    @<Átomo Numérico: Regra 2@>
    @<Átomo Numérico: Regra 3@>
  }
  else{
    @<Átomo Numérico: Regra 4@>
    @<Átomo Numérico: Regra 5@>
  }
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_NUMERIC);
  return false;
}
@

1) Se temos um único token e ele é um token numérico, basta retornar o
seu valor:

\iniciocodigo
@<Átomo Numérico: Regra 1@>=
if(begin -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin) -> value;
  return true;
}
@
\fimcodigo

2) Se temos um único token e ele é uma variável, retornamos o conteúdo
da variável. Mas temos que checar se ela foi declarada, se é numérica
e se foi inicializada:

\iniciocodigo
@<Átomo Numérico: Regra 2@>=
if(begin -> type == TYPE_SYMBOLIC){
  struct symbolic_token *var_token = ((struct symbolic_token *) begin);
  struct numeric_variable *var;
  var = var_token -> var;
  if(var == NULL){
    RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                   var_token -> value);
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
    RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(begin -> line),
                                   var_token -> value, var -> type,
                                   TYPE_T_NUMERIC);
    return false;
  }
  if(isnan(var -> value)){
    RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                      var_token -> value);
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

Se a variável não tiver sido declarada ou for do tipo errado, geramos
os erros cujos tipos já definimos antes. Se a variável não foi
inicializada, aí é um novo tipo de erro que precisamos definir:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_UNINITIALIZED_VARIABLE,
@
\fimcodigo

Quando este erro ocorre, temos que armazenar o nome da variável para
poder informar ao usuário:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, line, name) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_UNINITIALIZED_VARIABLE);\
    mf -> errno_str = (char *) permanent_alloc(strlen(name)+1);\
    memcpy(mf -> errno_str, name, strlen(name)+1);}}
@
\fimcodigo

E esta é a mensagem de erro que geramos:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_UNINITIALIZED_VARIABLE:
  fprintf(stderr, "%s:%s Uninitialized variable '%s'.",
          mf -> file, line_number, mf -> errno_str);
  break;
@
\fimcodigo

3) Por fim, se temos um único token e ele é \monoespaco{normaldeviate},
então temos que gerar um número aleatório de uma distribuição
normal. Dado que temos uma função que gera números aleatórios, podemos
fazer isso procedendo da seguinte forma:

a) Geramos dois números aleatórios e uniformes entre -1 e 1, os quais
chamaremos de $u$ e $v$. Isso pode ser feito obtendo 64 bits,
multiplicando os 63 primeiros por $2^{-63}$ e usando o último bit para
definir o sinal. O resultado é suficientemente próximo de uniforme
para nossos propósitos.

b) Se $u^2+v^2 \geq 1$, isso significa que eles correspondem a pontos
fora de um círculo de raio 1. Neste caso, os descartamos e voltamos ao
passo 1. Também voltamos ao passo um se ambos forem zero, pois neste
caso o método não funcionaria.

c) Isso permite gerar dois valores que terão uma distribuição
uniforme:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

Um dos valores pode ser retornado. O outro pode ser armazenado na
estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Inicialmente a estrutura não tem nenhum valor destes armazenado, vamos
armazenar nela só depois de usarmos o método acima:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

Então, quando precisarmos gerar um valor aleatório de uma distribuição
normal, sempre verificamos se existe um valor pré-obtido, e se não nós
geramos os dois valores:

\iniciocodigo
@<Átomo Numérico: Regra 3@>=
if(begin -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    do{
      random_bits = random_func();
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Agora os casos em que o átomo numérico tem mais de um token. O
primeiro caso é quanto o primeiro token é ``('' e o último é
``)''. Neste caso, a parte interna aos parênteses é interpretada como
uma expressão numérica:

\iniciocodigo
@<Átomo Numérico: Regra 4@>=
if(begin -> type == TYPE_OPEN_PARENTHESIS &&
   end -> type == TYPE_CLOSE_PARENTHESIS){
   struct generic_token *p = begin;
   while(p -> next != end)
     p = p -> next;
   if(p == begin){
     RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '(');
     return false;
   }
   if(!eval_numeric_expression(mf, cx, begin -> next, p, result))
     return false;
   return true;
}
@
\fimcodigo

Se apenas encontramos um parênteses vazio, isso é um erro. O usuário
parece ter simplesmente esquecido de colocar uma expressão dentro
dele. O erro gerado é este novo tipo:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_EMPTY_DELIMITER,
@
\fimcodigo

Ao gerar este erro devemos informar qual o tipo de delimitador vazio
que encontramos. POde ser parênteses, colchetes ou chaves:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_EMPTY_DELIMITER(mf, cx, line, delimiter) {\
  if(!mf -> errno){\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_EMPTY_DELIMITER);\
    mf -> errno_int = delimiter;}}
@
\fimcodigo

A mensagem de erro vai ser personalizada de acordo com qual o
delimitador foi encontrado vazio:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_EMPTY_DELIMITER:
  fprintf(stderr, "%s:%s Unexpected empty delimiter '%c%c'.",
          mf -> file, line_number, mf -> errno_int,
          ((mf -> errno_int == '(')?(')'):
            ((mf -> errno_int == '[')?(']'):('}'))));
  break;
@
\fimcodigo

5) Finalmente, o caso em que o átomo numérico é uma fração composta
por um token numérico, \monoespaco{/} e outro token numérico. O
resultado deve ser obtido dividindo ambos os tokens numéricos:

\iniciocodigo
@<Átomo Numérico: Regra 5@>=
if(begin -> type == TYPE_NUMERIC && end -> type == TYPE_NUMERIC &&
   begin -> next -> type == TYPE_DIVISION){
  if(((struct numeric_token *) end) -> value == 0.0){
    RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(begin -> line));
    return false;
  }
  result -> value = ((struct numeric_token *) begin) -> value /
           ((struct numeric_token *) end) -> value;
  return true;
}
@
\fimcodigo
        
\subsecao{8.2. Atribuições e Expressões de Pares}

Para realizar a atribuição de pares a variáveis do tipo certo, usamos
o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Par@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    struct pair_variable *v = (struct pair_variable *) var -> var;
    v -> x = result.x;
    v -> y = result.y;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Vamos agora à avaliação de expressões de pares.

\subsubsecao{8.2.1. Soma e Subtração}

As regras gramaticais para as expressões de pares começam com:

\alinhaverbatim
<Expressão de Par> -> <Terciário de Par>
<Terciário de Par> -> <Secundário de Par> |
                      <Terciário de Par> <PT-Op> <Secundário de Par>
<PT-Op> -> + | -
\alinhanormal

A soma e subtração é tratada exatamente como se espera de uma soma e
subtração de vetores.

A função que avalia expressões de pares é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct pair_variable *result);
@
\fimcodigo

O método de avaliar as expressões de pares terciárias não é diferente
do que já fizemos com as expressões numéricas. Apenas temos menos
operadores terciários aqui.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct pair_variable a, b;
  p = begin;
  do{ // Encontra último operador terciário de '+' ou '-'
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_tertiary != NULL){
    begin_secondary = last_sum -> next;
    eval_pair_expression(mf, cx, begin, end_tertiary, &a);
    eval_pair_secondary(mf, cx, begin_secondary, end, &b);
    if(last_sum -> type == TYPE_SUM){ // Avalia '+'
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){ // Avalia '-'
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else // Nenhum operador terciário:
    return eval_pair_secondary(mf, cx, begin, end, result);
}
@
\fimcodigo

\subsubsecao{8.2.2. Transformações, Multiplicação e Divisão Escalar}

A gramática para expressões de pares secundárias é:

\alinhaverbatim
<Secundário de Par> -> <Primário de Par> |
                       <Par Secundário><Mul ou Div><Numérico Primário> |
                       <Secundário Numérico> * <Primário de Par> |
                       <Secundário de Par><Transformador>
<Mul ou Div> -> * | /
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> | (...)
\alinhanormal

As regras acima sobre transformadores estão incompletas, pois veremos
ainda na Subseção 8.3.1. que há mais um tipo de transformador a ser
definido.

Por hora, vamos adicionar as sete novas palavras-chave representando
transformadores conhecidos:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_ROTATED,  // O token simbólico 'rotated'
TYPE_SCALED,   // O token simbólico 'scaled'
TYPE_SHIFTED,  // O token simbólico 'shifted'
TYPE_SLANTED,  // O token simbólico 'slanted'
TYPE_XSCALED,  // O token simbólico 'xscaled'
TYPE_YSCALED,  // O token simbólico 'yscaled'
TYPE_ZSCALED,  // O token simbólico 'zscaled'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo

A declaração da função que avaliará expressões secundárias de pares:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin,
                         struct generic_token *end,
                         struct pair_variable *result);
@
\fimcodigo


Interpretar uma expressão secundária aqui é similar ao que fizemos
para as expressões numéricas. Também devemos percorrer a lista de
tokens até achar a operação secundária mais à direita, ignorando
aquilo que está aninhado entre parênteses e colchetes. Deve-se seguir
as mesmas regras para determinar se o \monoespaco{/} é mesmo uma
divisão ou se é uma fração. Mas como aqui temos um total de nove
operadores secundários, incluindo os transformadores. Devido à
quantidade, vamos mostrar separadamente cada um deles ao invés de
colocá-los todos neste bloco de código abaixo:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin,
                             struct generic_token *end,
                             struct pair_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin;
  do{ // Encontra o operador secundário mais à direita
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             // 'transformed' será definido na Subseção 8.3.4.
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end && p -> next -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ //  Divisão ou operadores válidos
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(end_secondary != NULL){
    begin_primary = last_mul -> next;
    @<Operador Secundário de Pares: Multiplicação@>
    @<Operador Secundário de Pares: Divisão@>
    @<Operador Secundário de Pares: Rotação@>
    @<Operador Secundário de Pares: Escala@>
    @<Operador Secundário de Pares: Deslocamento@>
    @<Operador Secundário de Pares: Inclinação@>
    @<Operador Secundário de Pares: X-Escala@>
    @<Operador Secundário de Pares: Y-Escala@>
    @<Operador Secundário de Pares: Z-Escala@>
    @<Operador Secundário de Pares: Outros@>
  }
  else
    return eval_pair_primary(mf, cx, begin, end, result);
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PAIR);
  return false;
}
@
\fimcodigo

O primeiro operador é o de multiplicação. Note que podemos ter dois
tipos de multiplicação: um par por um numérico ou um numérico por um
par. Para identificar qual dos dois tipos se aplica, devemos examinar
o tipo da expressão à direita do operador.

\iniciocodigo
@<Operador Secundário de Pares: Multiplicação@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end) ==  TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    if(!eval_numeric_secondary(mf, cx, begin, end_secondary, &a))
      return false;
    if(!eval_pair_primary(mf, cx, begin_primary, end, &b))
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
      return false;
    if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }
}
@
\fimcodigo

Se temos uma divisão, então sempre será um par dividido por um
numérico. Devemos gerar erro em caso de divisão por zero:

\iniciocodigo
@<Operador Secundário de Pares: Divisão@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  if(b.value == 0.0){
    RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(last_mul -> line));
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

Se temos uma rotação, rotacionamos nosso par no sentido anti-horário
em relação à origem, interpretando o ângulo em graus, não radianos:

\iniciocodigo
@<Operador Secundário de Pares: Rotação@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  theta = 0.0174533 * b.value; // 1 grau = 0,0174533 radianos
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

Se temos uma mudança de escala, isso é sinônimo a uma multiplicação:

\iniciocodigo
@<Operador Secundário de Pares: Escala@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Um deslocamento é igual a uma soma, mas tem uma ordem de precedência
maior:

\iniciocodigo
@<Operador Secundário de Pares: Deslocamento@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_pair_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

O operador de inclinação desloca mais à direita um ponto quanto mais
acima do eixo $x$ ele está e mais à esquerda quanto mais abaixo do
eixo $x$ ele está:

\iniciocodigo
@<Operador Secundário de Pares: Inclinação@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Mudança de escala no eixo $x$ multiplica um escalar apenas pelo
primeiro valor do par:

\iniciocodigo
@<Operador Secundário de Pares: X-Escala@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Assim como no eixo $y$ multiplica o escalar só pelo segundo valor do
par:

\iniciocodigo
@<Operador Secundário de Pares: Y-Escala@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_numeric_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Por fim, a mudança de escala $z$ înterpreta dois pares como números
complexos e os multiplica:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Operador Secundário de Pares: Z-Escala@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_pair_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Valores Intermediários de Pares, Literais e Variáveis}

As regras gramaticais finais para a expressão de pares é:

\alinhaverbatim
<Primário de Par> -> <Variável de Par> |
                     ( <Expressão Numérica> , <Expressão Numérica> ) |
                     ( <Expressão de Par> ) |
                     (...) |
                     <Átomo Numérico>[<Expressão de Par,
                                      <Expressão de Par]  |
                     <Operador de Multiplicação Escalar><Primário de Par>
\alinhanormal

Temos uma parte omitida na regra gramatical acima porque há alguns
operadores primários que vamos definir só nas Subseções 8.4.6 e 10.4.

Uma novidade é a construção do tipo $a[b, c]$ onde $b$ e $c$ são
pares. Ela representa um valor intermediário entre os
pontos. Basicamente é avaliado como $a(b+c)$, de modo que $.5[b,c]$
representa o meio do caminho entre os dois pontos.

As outras regras são análogas às que já vimos na gramática de
expressões numéricas.

A função que avaliará expressões de pares primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct pair_variable *result);
@
\fimcodigo

E cada uma das cinco regras gramaticais acima será testada
separadamente para sabermos qual regra devemos aplicar ao encontrar
uma expressão primária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin,
                       struct generic_token *end,
                       struct pair_variable *result){
  if(begin == end){
    @<Primário de Par: Regra 1@>
  }
  else if(begin -> type == TYPE_OPEN_PARENTHESIS &&
          end -> type == TYPE_CLOSE_PARENTHESIS){
    @<Primário de Par: Regra 2@>
    @<Primário de Par: Regra 3@>
  }
  @<Primário de Par: Outras Regras a Definir Depois@>
  @<Primário de Par: Regra 4@>
  @<Primário de Par: Regra 5@>
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PAIR);
  return false;
}
@

A primeira regra será aplicada quando temos um único token na
expressão. O único caso em que isso ocorre é quando a expressão é uma
variável de par:

\iniciocodigo
@<Primário de Par: Regra 1@>=
struct symbolic_token *tok = (struct symbolic_token *) begin;
struct pair_variable *var;
if(tok -> type != TYPE_SYMBOLIC){
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PAIR);
  return false;
}
var = (struct pair_variable *) tok -> var;
if(var == NULL){
  RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                 tok -> value);
  return false;
}
if(var -> type != TYPE_T_PAIR){
  RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(begin -> line),
                                  tok -> value, var -> type,
                                  TYPE_T_PAIR);
  return false;
}
if(isnan(var -> x)){
  RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                    tok -> value);
  return false;
}
result -> x = var -> x;
result -> y = var -> y;
return true;
@
\fimcodigo

Se a expressão é delimitada por parênteses, nós tanto podemos estar
diante de uma representação literal de um par $(a, b)$ como podemos
estar diante de parênteses com uma expressão de par completa dentro
dele como em $(pair1+(a, b))$. Podemos diferenciar os dois casos pela
vírgula interna no parênteses, a qual está no mesmo escopo que $a$ e
$b$, não deve estar dentro de outros parênteses e colchetes.

\iniciocodigo
@<Primário de Par: Regra 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  if(begin -> next == end){
    RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '(');
    return false;
  }
  begin_a = (struct generic_token *) begin -> next;
  end_a = begin_a;
  DECLARE_NESTING_CONTROL();
  bool literal = true;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(comma -> line),
                                     TYPE_T_PAIR);
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end)
      end_b = (struct generic_token *) end_b -> next;
    if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
      return false;
    if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

No código acima nós identificamos se estamos diante de um literal pela
presença da vírgula e nós identificamos isso marcando na variável
booleana \monoespaco{literal}. Portanto, se esta variável não for
verdadeira, imediatamente após o último \monoespaco{if} acima,
executamos o \monoespaco{else} como a próxima regra:

\iniciocodigo
@<Primário de Par: Regra 3@>=
else
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
@
\fimcodigo

Se o último token for um \monoespaco{]}, então temos uma construção do
tipo $a[B,C]$ onde $a$ é numérico enquanto $B$ e $C$ são pares. Nossa
tarefa é separar essas três partes $a$, $B$ e $C$, interpretá-las e
retornar $B+a(C-B)$:

\iniciocodigo
@<Primário de Par: Regra 4@>=
else if(end -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  DECLARE_NESTING_CONTROL();
  begin_a = begin;
  end_a = begin_a;
  while(end_a != end){ // a: do começo da expressão até antes de '['
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() && end_a -> next -> type == TYPE_OPEN_BRACKETS)
      break;
    end_a = end_a -> next;
  }
  if(end_a == end){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_PAIR);
    return false;
  }
  begin_b = end_a -> next;
  begin_b = begin_b -> next; // b: começa após '['
  end_b = begin_b;
  while(end_b != end){ // b: Termina antes de ','
    COUNT_NESTING(end_b);
    if(IS_NOT_NESTED() && end_b -> next -> type == TYPE_COMMA)
      break;
    end_b = end_b -> next;
  }
  if(end_b == end){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_PAIR);
    return false;
  }
  begin_c = end_b -> next;
  begin_c = begin_c -> next; // c: Começa após ','
  end_c = begin_c;
  while(end_c != end){ // c: termina no penúltimo token
    if(end_c -> next == end)
      break;
    end_c = end_c -> next;
  }
  if(end_c == end){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_PAIR);
    return false;
  }
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a)) // Avalia 'a'
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b)) // Avalia 'b'
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c)) // Avalia 'c'
    return false;
  result -> x = b.x + a.value * (c.x - b.x); // resultado = b +a(c-b)
  result -> y = b.y + a.value * (c.y - b.y);
  return true;
}
@
\fimcodigo

A última regra é quando temos um operador de multiplicação escalar e
um par. O operador pode ser um token
de \monoespaco{+}, \monoespaco{-}, um único token numérico, ou então
uma fração. Temos um exemplo de cada um dos quatro casos abaixo:

\alinhaverbatim
pair a, b, c, d;
a = +(1, 2);
b = -(1, 2);
c = 2a;
d = 1/2b;
\alinhanormal

O código que trata tais expressões é:

\iniciocodigo
@<Primário de Par: Regra 5@>=
else{
  if(begin -> type == TYPE_SUM) // Um '+' unário antes da expressão
    return eval_pair_primary(mf, cx, begin -> next, end, result);
  else if(begin -> type == TYPE_SUBTRACT){ // Um '-' unário
    if(!eval_pair_primary(mf, cx, begin -> next, end, result))
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin -> type == TYPE_NUMERIC){ // Número/fração antes de expressão
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin) -> value;
    tok = begin -> next;
    if(tok -> type == TYPE_DIVISION){ // É uma fração
      tok = begin -> next;
      if(tok == end || tok -> next == end || tok -> type != TYPE_NUMERIC){
        RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                       TYPE_T_PAIR);
        return false;
      }
      if(((struct numeric_token *) tok) -> value == 0.0){
        RAISE_ERROR_DIVISION_BY_ZERO(mf, cx, OPTIONAL(begin -> line));
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = tok -> next;
    }
    if(!eval_pair_primary(mf, cx, begin -> next, end, result))
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pares em Expressões Numéricas}

Subexpressões numéricas podem aparecer dentro de expressões de
pares. Por exemplo, em $a[b,c]$ onde $a$ é um átomo numérico. Da mesma
forma, subexpressões de pares podem aparecer em expressões
numéricas. Mas não definimos os casos quando definimos as expressões
numéricas porque então não tínhamos ainda definido como avaliar
expressões de pares. Existem quatro operadores numéricos primários que
envolvem avaliar pares:

\alinhaverbatim
<Primário Numérico> -> length <Par Primário> | xpart <Par Primário> |
                       ypart <Par Primário> | angle <Par Primário>
\alinhanormal

Isso requer definir os seguintes novos tipos de tokens:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_XPART,  // O token simbólico 'xpart'
TYPE_YPART,  // O token simbólico 'ypart'
TYPE_ANGLE,  // O token simbólico 'angle'
@
\fimcodigo

Correspondentes às seguintes palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

O primeiro caso, que não precisou de um token
novo, \monoespaco{length} já era usado para obter o módulo de números
e havíamos avisado que ele poderia ser usado para outros tipos. No
caso de pares, ele mede a norma euclideana deles:

\iniciocodigo
@<Avalia 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) hypot(p.x, p.y);
  return true;
}
@
\fimcodigo

O operador \monoespaco{xpart} simplesmente retorna o primeiro valor de
um par. Entretanto, devemos ter um cuidado adicional: este operador
pode ser usado em outro contexto como ainda será visto na Sub-subseção
8.3.3. Então devemos primeiro nos certificar que o que vem depois do
operador é um par. Em caso afirmativo, retornamos seu primeiro valor:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin -> type == TYPE_XPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, begin -> next, end);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
      return false;
    result -> value = p.x;
    return true;
  }
  else{
    @<Primário Numérico: X-Part em Não-Par@>
  }
}
@
\fimcodigo

Enquanto o operador \monoespaco{ypart} retorna o segundo valor de um
par. Neste caso também devemos ter o mesmo cuidado de verificar se o
operando que temos depois é mesmo um par ou de algum outro tipo:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin -> type == TYPE_YPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, begin -> next, end);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
      return false;
    result -> value = p.y;
    return true;
  }
  else{
    @<Primário Numérico: Y-Part em Não-Par@>
  }
}
@
\fimcodigo

Por fim, o último operador, \monoespaco{angle} retorna o ângulo de um
par. É o ângulo do segmento que conecta a origem ao par em relação ao
segmento que conecta a origem à $(1,0)$. Um erro deve ser gerado se
tentar medir o ângulo de $(0,0)$:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, begin -> next, end, &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
    RAISE_ERROR_ANGLE_OF_ORIGIN(mf, cx, OPTIONAL(begin -> line));
    return false;
  }
  result -> value = (float) acos(p.x / (hypot(p.x, p.y)));
  result -> value *= 57.2958; // Radianos para graus
  return true;
}
@
\fimcodigo

Medir o ângulo da origem $(0, 0)$ é um erro do tipo:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_ANGLE_OF_ORIGIN,
@
\fimcodigo

Esta é a macro que gera este erro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_ANGLE_OF_ORIGIN(mf, cx, line) {\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_ANGLE_OF_ORIGIN);}
@
\fimcodigo

E a mensagem de erro impressa na tela para informar o usuário:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_ANGLE_OF_ORIGIN:
  fprintf(stderr, "%s:%s Undefined operation 'angle (0, 0)'.",
          mf -> file, line_number);
  break;
@
\fimcodigo

\subsecao{8.3. Atribuições e Expressões de Transformação}

Um dos momentos em que esperamos avaliar uma expressão de
transformação é quando formos fazer uma atribuição para uma variável
de transformação. Neste caso, devemos avaliar a expressão e realizar a
atribuição para todas as variáveis que estiverem do lado esquerdo da
expressão de atribuição:

\iniciocodigo
@<Atribuição de Variável de Transformação@>=
else if(type == TYPE_T_TRANSFORM){
  int i;
  struct transform_variable result;
  if(!eval_transform_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    memcpy(((struct transform_variable *) var -> var) -> value, result.value,
           sizeof(float) * 9);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Vamos agora ver como avaliar as expressões de transformação.

\subsubsecao{8.3.1. Transformações sobre Transformadores}

A regra gramatical para avaliar uma expressão de transformação começam
como:

\alinhaverbatim
<Expressão de Transformação> -> <Terciário de Transformação>
<Terciário de Transformação> -> <Secundário de Transformação>
<Secundário de Transformação> -> <Secundário de Transformação> <Transformador> |
                                 <Primário de Transformação>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário>
                   transformed <Primário de Transformação>
\alinhanormal

Temos aqui um novo tipo de token, representando o último tipo de
transformador que não havíamos definido na subseção anterior sobre
expressões de pares:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_TRANSFORMED,  // O token simbólico 'transformed'
@
\fimcodigo

Ele corresponde à seguinte palavra reservada:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"transformed",
@
\fimcodigo

Com relação às regras gramaticais, elas dizem que não existem no
momento operadores terciários de transformação. De qualquer forma,
vamos definir a função que avalia expressões, e avalia operadores
terciários apenas como uma função que chama o avaliador de operadores
secundários. Tanto para manter a uniformidade das funções que avaliam
expressões como para deixar essa função pronta para ser modificada
caso versões futuras da linguagem venham a trazer operadores
terciários de transformação.

A declaração da função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin,
                               struct generic_token *end,
                               struct transform_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin,
                               struct generic_token *end,
                               struct transform_variable *result){
  return eval_transform_secondary(mf, cx, begin, end, result);
}
@
\fimcodigo

Já a função que avalia expressões secundárias de transformação é esta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end,
                              struct transform_variable *result);
@
\fimcodigo

A função funciona percorrendo a lista de tokens da expressão,
ignorando tokens dentro de parênteses, colchetes e chaves. Toda vez
que encontra o último operador secundário, ele é armazenado em uma
variável. Depois de percorrer todos os tokens, se não achamos um
operador secundário, nós passamos a expressão inteira para o avaliador
de expressões primárias. Se encontramos um, tudo que vem antes dele é
avaliado como expressão secundária e o resultado passa pelo operador,
que será operador transformador.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end,
                              struct transform_variable *result){
  struct generic_token *p, *last_transform = NULL, *last_token = NULL,
                       *end_secondary = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin;
  do{ // Encontra operador de transformação mais à direita:
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() &&
       (p -> type == TYPE_ROTATED || p -> type == TYPE_SCALED ||
        p -> type == TYPE_SHIFTED || p -> type == TYPE_SLANTED ||
        p -> type == TYPE_XSCALED || p -> type == TYPE_YSCALED ||
        p -> type == TYPE_ZSCALED || p -> type == TYPE_TRANSFORMED)){
      last_transform = p;
      end_secondary = last_token;
    }
    last_token = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  } while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(last_transform != NULL){ // Existe um operador secundário:
    if(end_secondary == NULL){ // Mas não tem nada antes dele:
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                     TYPE_T_TRANSFORM);
      return false;
    }
    if(!eval_transform_secondary(mf, cx, begin, end_secondary, result))
      return false;
    @<Aplica Operador Secundário de Transformação@>
  }
  else // Nenhum operador secundário:
    return eval_transform_primary(mf, cx, begin, end, result);
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_TRANSFORM);
  return false;
}
@
\fimcodigo

Vamos agora aplicar os diferentes transformadores sobre as nossas
variáveis e resultados de transformação. O primeiro tipo de
transformador é a rotação, que aplicamos sobre um transformador com o
código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>=
if(last_transform -> type == TYPE_ROTATED){ 
  struct numeric_variable theta;
  double angle_radian;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &theta))
    return false;
  // 1 grau = 0,0174533 radianos
  angle_radian = theta.value * 0.0174533;
  TRANSFORM_ROTATE(result -> value, angle_radian);
  return true;
}
@
\fimcodigo


Já mudar a escala de um transformador, ampliando ele $s$ vezes é feito
pelo código:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE(result -> value, scale.value);
  return true;
}
@
\fimcodigo

A próxima transformação é realizar uma translação, ou deslocamento
$(x, y)$ sobre uma transformação.

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SHIFTED){
  struct pair_variable shift;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end, &shift))
    return false;
  TRANSFORM_SHIFT(result -> value, shift.x, shift.y);
  return true;
}
@
\fimcodigo

Agora vamos tratar o transformador que inclina a nossa transformação
uma quantia $s$.

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SLANTED){
  struct numeric_variable slant;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &slant))
    return false;
  TRANSFORM_SLANT(result -> value, slant.value);
  return true;
}
@
\fimcodigo

A mudança de escala somente no eixo $x$ estica ou comprime a
transformação neste eixo. Isso é obtido pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_XSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE_X(result -> value, scale.value);
  return true;
}
@
\fimcodigo

Podemos também fazer a mudança de escala somente no eixo $y$ usando o
fator de mudança $s$:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_YSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE_Y(result -> value, scale.value);
  return true;
}
@
\fimcodigo

Por fim, há a mudança de escala no plano complexo, que envolve
multiplicar os pontos por um par $(s, t)$, interpretado como um número
complexo. Isso obtém ao mesmo tempo tanto rotação como mudança de
escala. Esse transformador é implementado pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_ZSCALED){
  struct pair_variable scale;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end, &scale))
    return false;
  TRANSFORM_SCALE_Z(result -> value, scale.x, scale.y);
  return true;
}
@
\fimcodigo

Por fim, o último tipo de transformador. Quando temos duas
transformações e as multiplicamos para combiná-las em uma só. Isso é
feito simplesmente multiplicando as matrizes que representam a
transformação:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_TRANSFORMED){
  struct transform_variable b;
  if(!eval_transform_primary(mf, cx, last_transform -> next, end, &b))
    return false;
  MATRIX_MULTIPLICATION(result -> value, b.value);
  return true;
}
@
\fimcodigo

\subsecao{8.3.2 Expressões Primárias de Transformação: Literais e Variáveis}

Continuando a gramática das expressões de transformadores, as próximas
regras são:

\alinhaverbatim
<Primário de Transformação> -> <Variável de Transformação> |
                               ( <Terciário de Transformação> ) |
                               ( <Expressão Numérica> , <Expressão Numérica> ,
                                 <Expressão Numérica> , <Expressão Numérica> ,
                                 <Expressão Numérica> , <Expressão Numérica> )
\alinhanormal

No primeiro caso, temos só um token simbólico com uma variável de
transformação. Nos dois outros casos, o primeiro Token é o abrir de
parênteses. No primeiro, há só uma expressão entre parênteses que
avaliará para um transformador. No segundo, temos seis expressões
numéricas que formarão os valores de nosso transformador.

A função que avaliará as expressões primárias de transformação é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin,
                            struct generic_token *end,
                            struct transform_variable *result);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin,
                            struct generic_token *end,
                            struct transform_variable *result){
  if(begin == end && begin -> type == TYPE_SYMBOLIC){ // É uma variável?
    @<Transformação Primária: Variável@>
  }
  else if(begin != end && begin -> type == TYPE_OPEN_PARENTHESIS &&
          end -> type == TYPE_CLOSE_PARENTHESIS){
    if(begin -> next == end){
      RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '(');
      return false;
    }
    struct generic_token *p = begin -> next;
    DECLARE_NESTING_CONTROL();
    bool has_comma = false;
    do{
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() && p -> type == TYPE_COMMA){
        RESET_NESTING_COUNT();
        has_comma = true;
        break;
      }
      if(p != end)
        p = p -> next;
      else
        p = NULL;
    } while(p != NULL && p != end);
    if(has_comma){
      @<Transformação Primária: Literal@>
    }
    else{
      @<Transformação Primária: Parênteses@>
    }
  }
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                 TYPE_T_TRANSFORM);
  return false;
}
@
\fimcodigo

O código acima identifica se estamos diante de um dos três casos de
expressão primária de transformador: temos uma variável, um literal ou
uma subexpressão delimitada por parênteses. A variável é mais fácil de
identificar, pois é o único caso em que há um único token
simbólico. Tanto o literal como a subexpressão são delimitados por
parênteses. O modo de diferenciar as duas coisas é pela presença de
vírgula, que encontramos no literal, mas não na sub-expressão.

O caso mais simples é quando estamos só lendo uma variável:

\iniciocodigo
@<Transformação Primária: Variável@>=
struct symbolic_token *v = (struct symbolic_token *) begin;
struct transform_variable *content = v -> var;
if(content == NULL){
  RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(v -> line), v -> value);
  return false;
}
if(content -> type != TYPE_T_TRANSFORM){
  RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(v -> line),
                                 v -> value, content -> type,
                                 TYPE_T_TRANSFORM);
  return false;
}
if(isnan(content -> value[0])){
  RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(v -> line), v -> value);
  return false;
}
memcpy(result -> value, content -> value, sizeof(float) * 9);
return true;
@
\fimcodigo

O próximo caso que trataremos é quando temos uma subexpressão entre
parênteses. Devemos apenas avaliar ela após descartar os parênteses
delimitadores:

\iniciocodigo
@<Transformação Primária: Parênteses@>=
struct generic_token *end_expr;
for(end_expr = begin -> next; end_expr -> next != end;
    end_expr = end_expr -> next);
return eval_transform_expression(mf, cx, begin -> next, end_expr, result);
@
\fimcodigo

E finalmente, quando temos um literal de transformação formado por
seis expressões numéricas separadas por vírgulas:

\iniciocodigo
@<Transformação Primária: Literal@>=
int i;
struct generic_token *begin_numeric_expr, *end_numeric_expr;
struct numeric_variable numeric_result;
end_numeric_expr = begin_numeric_expr = begin -> next;
float values[6]; // Cada um dos 6 valores será lido aqui
for(i = 0; i < 6; i ++){
  p = begin_numeric_expr;
  do{
    if(p != end){ // Vamos ignorar o último ')' 
      COUNT_NESTING(p);
    }
    if(IS_NOT_NESTED() && ((i < 5 && p -> type == TYPE_COMMA) ||
                            (i == 5 && p -> type == TYPE_CLOSE_PARENTHESIS))){
      break;
    }
    end_numeric_expr = p;
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(p == NULL){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                   TYPE_T_TRANSFORM);
    return false;
  }
  if(!eval_numeric_expression(mf, cx, begin_numeric_expr, end_numeric_expr,
                              &numeric_result))
    return false;
  values[i] = numeric_result.value;
  begin_numeric_expr = p -> next;
  end_numeric_expr = begin_numeric_expr;
}
// Armazenando na ordem correta dentro da matriz:
result -> value[0] = values[2]; result -> value[1] = values[4];
result -> value[2] = 0.0;
result -> value[3] = values[3]; result -> value[4] = values[5];
result -> value[5] = 0.0;
result -> value[6] = values[0]; result -> value[7] = values[1];
result -> value[8] = 1.0;
return true;
@
\fimcodigo

O código acima tem dois laços. O primeiro tem como invariante de que
no começo de cada uma de suas iterações, \monoespaco{p}
e \monoespaco{begin\_numeric\_expr} apontam para o token marcando o
começo da próxima expressão numérica no literal que ainda não foi
avaliada. O segundo loop tem como tarefa fazer então com
que \monoespaco{end\_numeric\_expr} passe a marcar corretamente o fim
dessa expressão numérica, delimitada pela próxima vírgula ou pelo
fechamento de parênteses final do literal. Depois da execução do loop
mais interno, já temos a expressão delimitada, avaliamos ela e
armazenamos seu valor. Repetimos isso seis vezes para ler o literal de
transformação inteiro.

\subsubsecao{8.3.3. Transformações em Expressões Numéricas}

Transformações podem aparecer dentro de expressões primárias
numéricas. Existem as seguintes regras gramaticais adicionais que as
prevêem:

\alinhaverbatim
<Primário Numérico> -> <Parte de Transformação><Primário de Transformação>
<Parte de Transformação> -> xpart | ypart | xxpart | xypart | yxpart | yypart
\alinhanormal

Os seis operadores acima servem para extrair cada um dos seis valores
numéricos que compõe uma transformação. A ordem em que aparecem acima
é a mesma ordem na qual eles extraem o elemento da transformação.

Como \monoespaco{xpart} e \monoespaco{ypart} já havia aparecido quando
definíamos as expressões de pares, resta definirmos tokens para os
outros quatro operadores que são novos:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_XXPART,  // O token simbólico xxpart'
TYPE_XYPART,  // O token simbólico xypart'
TYPE_YXPART,  // O token simbólico yxpart'
TYPE_YYPART,  // O token simbólico yypart'
@
\fimcodigo

E as palavras reservadas associadas a cada token:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"xxpart", "xypart", "yxpart", "yypart",
@
\fimcodigo

Estes quatro novos operadores são tratados na função que avalia
expressões numéricas primárias:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin -> type >= TYPE_XXPART && begin -> type <= TYPE_YYPART){
  struct transform_variable t;
  if(!eval_transform_primary(mf, cx, begin -> next, end, &t))
    return false;
  if(begin -> type == TYPE_XXPART)
    result -> value = t.value[0];
  else if(begin -> type == TYPE_XYPART)
    result -> value = t.value[3];
  else if(begin -> type == TYPE_YXPART)
    result -> value = t.value[1];
  else if(begin -> type == TYPE_YYPART)
    result -> value = t.value[4];
  return true;
}
@
\fimcodigo

Mas e quanto ao \monoespaco{xpart} e \monoespaco{ypart}? Em princípio,
eles já foram tratados para o caso em que extraimos valores de
pares. Precisamos apenas incrementar a definição já feita na
Subseção 8.2.4. para tratar o caso em que devemos aplicá-la quando
não temos um par. Fazendo isso no caso do \monoespaco{xpart}:

\iniciocodigo
@<Primário Numérico: X-Part em Não-Par@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, begin -> next, end, &t))
  return false;
result -> value = t.value[6];
return true;
@
\fimcodigo

O mesmo deve ser feito no operador \monoespaco{ypart}:

\iniciocodigo
@<Primário Numérico: Y-Part em Não-Par@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, begin -> next, end, &t))
  return false;
result -> value = t.value[7];
return true;
@
\fimcodigo

\subsubsecao{8.3.4. Transformações em Expressões de Pares}

Transformações também aparecem nas regras gramaticais de expressões de
pares. Existe uma expressão secundária que obtém uma expressão
secundária de par do lado esquerdo e um primário de transformação do
lado direito:

\alinhaverbatim
<Secundário de Par> -> <Secundário de Par><Transformador>
<Transformador> -> (...) | transformed <Primário de Transformação>
\alinhanormal

O que este operador faz é aplicar a transformação linear sobre o
par. Vamos implementá-lo com o código adicional abaixo que irá se
somar ao código que implementa transformações sobre pares da
Subsubseção 8.2.2.

\iniciocodigo
@<Operador Secundário de Pares: Outros@>=
else if(last_mul -> type == TYPE_TRANSFORMED){
  struct pair_variable a;
  struct transform_variable b;
  if(!eval_pair_secondary(mf, cx, begin, end_secondary, &a))
    return false;
  if(!eval_transform_primary(mf, cx, begin_primary, end, &b))
    return false;
  result -> x = LINEAR_TRANSFORM_X(a.x, a.y, b.value);
  result -> y = LINEAR_TRANSFORM_Y(a.x, a.y, b.value);
  return true;
}
@
\fimcodigo

\subsecao{8.4. Atribuições e Expressões de Caminhos}

Para realizar a atribuição de caminhos a variáveis do tipo certo,
usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Caminho@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(!eval_path_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin; // 'var' começa na variável atribuída
  for(i = 0; i < number_of_variables; i ++){
    struct path_variable *dst = (struct path_variable *) var -> var;
    if(dst -> permanent){ // Como alocar e desalocar
      alloc = permanent_alloc;
      disalloc = permanent_free;
    }
    else{
      alloc = temporary_alloc;
      disalloc = temporary_free;
    }
    // Se o destino não está vazio, desaloca ele:
    if(dst -> length != -1 && disalloc != NULL)
      path_recursive_free(disalloc, dst, false);
    // Copia a origem para destino
    if(!recursive_copy_points(mf, NULL, alloc, &dst, &result, false))
      return false;
    var = (struct symbolic_token *) (var -> next); // 'var' aponta para '='
    var = (struct symbolic_token *) (var -> next); // 'var' é próxima variável
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &result, false);
}
@
\fimcodigo

Veremos agora na próxima Subseção as regras gramaticais para as
expressões de caminhos:

\subsubsecao{8.4.1. Junção de Caminhos}

A gramática para a expressão de caminhos começa com:

\alinhaverbatim
<Expressão de Caminho> -> <Expressão de Par> | <Terciário de Caminho> |
                          <Sub-expressão de Caminho><Especificador de Direção> |
                          <Sub-expressão de Caminho><Junção de Caminho> cycle
<Junção de Caminho> -> <Especificador de Direção><Junção Básica>
                       <Especificador de Direção>
<Junção Básica> -> & | .. | .. <Tensão> .. | .. <Controles> .. | --
<Tensão> -> tension <Quantidade de Tensão> |
            tension <Quantidade de Tensão> and <Quantidade de Tensão>
<Quantidade de Tensão> -> <Primário Numérico> | atleast <Primário Numérico>
<Controles> -> controls <Par Primário> |
               controls <Par Primário> and <Par Primário>
<Especificação de Direção> -> Vazio |
                              { <Expressão de Par } |
                              { <Expressão Numérica> , <Expressão Numérica> } |
                              { curl <Expressão Numérica> }
<Sub-expressão de Caminho> -> <Expressão de Caminho> |
                              <Sub-expressão de Caminho><Junção de Caminho>
                              <Terciário de Caminho>
\alinhanormal

Tudo isso requer que registremos os seguintes novos tipos de tokens:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_CYCLE,          // O token simbólico 'cycle'
TYPE_AMPERSAND,      // O token simbólico '&'
TYPE_JOIN,           // O token simbólico '..'
TYPE_TENSION,        // O token simbólico 'tension'
TYPE_AND,            // O token simbólico 'and'
TYPE_ATLEAST,        // O token simbólico 'atleast'
TYPE_CONTROLS,       // O token simbólico 'controls'
TYPE_CURL,           // O token simbólico 'curl'
TYPE_STRAIGHT_JOIN,  // O token simbólico '--'
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"cycle", "&", "..", "tension", "and", "atleast", "controls", "curl", "--",
@
\fimcodigo

O que as regras gramaticais revelam é que toda expressão de caminho é
formado pela junção de vários outros sub-caminhos. Se não existir
nenhuma junção, então nosso caminho é um par, que é considerado um
caminho de um único ponto.

Uma das coisas que temos a fazer então é contar quantas junções
existem em uma expressão de caminho. Realizar a contagem pode ser
feito com a seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end);
@
\fimcodigo

A função funciona contando o número de ``\&'', ``--'' e também
contando os ``..'' quando eles aparecem sozinhos ou quando eles
aparecem pela segunda vez dentro de uma junção que especifica pontos
de controle ou tensão. As junções dentro de sub-expressões dentro de
parênteses e delimitadores não são contadas:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end){
  int count = 0;
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin;
  while(p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_AMPERSAND)
        count ++;
      else if(p -> type == TYPE_STRAIGHT_JOIN)
        count ++;
      else if(p -> type == TYPE_JOIN){
        struct generic_token *next = (struct generic_token *) p -> next;
        if(p == end || (next -> type !=  TYPE_TENSION &&
                        next -> type != TYPE_CONTROLS))
          count ++;
      }
    }
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }
  return count;
}
@
\fimcodigo

Contar o número de junções será importante para que saibamos a
quantidade de pontos que devemos alocar inicialmente para um caminho.
De posse de como obter tal informação, podemos começar a tratar as
expressões. A variável que avalia expressão de caminho tem como
cabeçalho:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct path_variable *result);
@
\fimcodigo

O número de pontos de um caminho é inicialmente o número de junções
mais um:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin,
                          struct generic_token *end,
                          struct path_variable *result){
  int expected_length;
  int number_of_joins = count_path_joins(begin, end);
  expected_length = number_of_joins + 1;
  @<Expressão de Caminho: Quando Não Há Junção@>
  @<Expressão de Caminho: Alocar Variável de Caminho@>
  @<Expressão de Caminho: Itera sobre Junções@>
  // Caminhos são retornados normalizados, como visto na Subseção 7.4.4:
  return normalize_path(mf, cx, result); 
}
@
\fimcodigo

E se o número de junções for zero? Neste caso, podemos estar diante de
uma expressão de par como abaixo:

\alinhaverbatim
path p;
p = (2, 3);
\alinhanormal

Ou de uma expressão terciária de caminho onde as junções estão dentro
de parênteses ou outros delimitadores como em:

\alinhaverbatim
path p;
p = ((2, 3)..(1, 2));
\alinhanormal

De qualquer forma, pode haver um ou mais especificador de direção
depois da expressão, o qual precisa ser ignorado. No primeiro caso
porque especificadores de direção não tem efeito algum sobre pontos
isolados. No segundo porque a sub-expressão seria normalizada e já
viria com todos os pontos de controle ao terminarmos de avaliar os
parênteses. Então o especificador de direção novamente não teria
efeito.

Podemos checar se temos especificadores de direção checando se o
último token é um ``$\}$''. Se for o caso, mudamos a posição do fim da
expressão para imediatamente antes do primeiro especificador de
direção, e consideramos somente esta parte como a que deve ser
avaliada. Entretanto, temos que fazer uma validação para garantir que
o especificador adicional está de acordo com a gramática:

\iniciocodigo
@<Expressão de Caminho: Quando Não Há Junção@>=
if(number_of_joins == 0){
  if(end -> type == TYPE_CLOSE_BRACES){
    float dir_x, dir_y;
    struct generic_token *p = begin;
    DECLARE_NESTING_CONTROL();
    while(p != end){
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() &&
         p -> next -> type == TYPE_OPEN_BRACES)
        break;
      p = p -> next;
    }
    RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
    // O especificador é ignorado, mas precisa ser validado:
    if(!eval_direction_specifier(mf, cx, p -> next, end, &dir_x, &dir_y))
      return false;
    end = p;
  }
  result -> permanent = false;
  if(!eval_path_tertiary(mf, cx, begin, end, result))
    return false;
  return normalize_path(mf, cx, result);
}
@
\fimcodigo

Se existir uma ou mais junções, então caberá a nós criar uma nova
variável de caminho alocando as estruturas necessárias para ela. O que
temos a fazer é alocar nela um número de pontos igual à
variável \monoespaco{expected\_length}:

\iniciocodigo
@<Expressão de Caminho: Alocar Variável de Caminho@>=
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points) *
                     expected_length);
if(result -> points == NULL){
  RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(begin -> line));
  return false;
}
result -> length = 0; // Inicialização
result -> permanent = false;
result -> number_of_points = 0;
result -> cyclic = false;
@
\fimcodigo

Agora temos que interpretar todas as junções. Temos que iterar sobre
cada junção presente na expressão, as quais possuem o formato:

$$
z_1{d} j {e}z_2
$$

Então vamos usar variáveis para indicar o começo e o fim de cada parte
à medida que iteramos. Vamos criar um laço onde iremos iterar sobre
cada uma das junções no formato acima para interpretá-las e vamos
marcar o token de começo e de fim de cada parte:

\iniciocodigo
@<Expressão de Caminho: Itera sobre Junções@>=
{
  struct generic_token *begin_z1, *end_z1 = NULL, *begin_z2, *end_z2;
  struct generic_token *begin_d = NULL, *end_d = NULL, *begin_e, *end_e;
  struct generic_token * begin_j, *end_j;
  struct path_points *z0_point = NULL, *z1_point = NULL, *z2_point = NULL;
  struct path_variable *z1_parent;
  begin_z1 = begin;
  end_z1 = begin_z1;
  @<Expressão de Caminho: Prepara Valor Inicial de z1@>
  while(end_z1 != end || result -> length < expected_length){
    @<Expressão de Caminho: Separa Tokens da Junção@>
    @<Expressão de Caminho: Interpreta Extremidades da Junção@>
    @<Expressão de Caminho: Interpreta Direção se Existir@>
    @<Expressão de Caminho: Interpreta Junção@>
    begin_z1 = begin_z2;
    end_z1 = end_z2;
  }
  @<Expressão de Caminho: Após Ler as Junções@>
}
@
\fimcodigo

Para delimitar o primeiro elemento $z_1$, na primeira vez quando ainda
estamos no começo da expressão, basta avançarmos os tokens até
acharmos o primeiro ``{'', ``..'', ``\-\-'' ou ``\&'' fora de qualquer
parênteses ou colchetes. Nas demais vezes, o elemento $z_1$ deve
começar como sendo igual àquilo que era o elemento $z_2$ na iteração
anterior, o que já é garantido pelo código acima.

\iniciocodigo
@<Expressão de Caminho: Prepara Valor Inicial de z1@>=
{
  DECLARE_NESTING_CONTROL();
  int next_type;
  while(end_z1 != end){
    COUNT_NESTING(end_z1);
    next_type = end_z1 -> next -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z1 = (struct generic_token *) end_z1 -> next;
  }
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
}
@
\fimcodigo

Agora vamos delimitar o primeiro especificador de direção. Primeiro
lemos o próximo token para ver se é um ``$\{$''. Se não for, não há o
primeiro especificador de direção. Se for, então delimitamos ele até
acharmos o próximo ``$\}$'':

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>=
begin_d = end_z1 -> next;
if(begin_d -> type != TYPE_OPEN_BRACES){ // Nenhum especificador
  begin_d = NULL;
  end_d = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  if(begin_d == end){
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, OPTIONAL(begin_d -> line), '{');
    return false;
  }
  end_d = begin_d -> next;
  while(end_d != end){
    if(IS_NOT_NESTED() && end_d -> type == TYPE_CLOSE_BRACES)
      break;
    COUNT_NESTING(end_d);
    end_d = end_d -> next;
  }
  if(end_d -> type != TYPE_CLOSE_BRACES){
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, OPTIONAL(begin_d -> line), '{');
    return false;
  }
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin_d -> line));
}
@
\fimcodigo

Agora vamos delimitar a junção. Se ela for um ``\&'' ou um ``--'', ela
corresponde a um único token. Se for um ``..'', devemos checar o
próximo token para identificar se temos um ``\monoespaco{controls}''
ou ``\monoespaco{tension}''. Em caso afirmativo, teremos que delimitar
a junção englobando do primeiro ``..'' até o segundo ``..''. Em caso
negativo, a junção é somente um token ``..''.

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_d == NULL)
  begin_j = end_z1 -> next; // Começa depois de z1
else
  begin_j = end_d -> next; // Ou depois de especificador de direção
end_j = begin_j; // Começamos assumindo que é só um token
if(begin_j == end){ // Mas é preciso ter algo depois dele
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PATH);
  return false;
}
if(begin_j -> type == TYPE_JOIN && // Testando se é mais de um token
   (begin_j -> next -> type == TYPE_CONTROLS ||
    begin_j -> next -> type == TYPE_TENSION)){
  DECLARE_NESTING_CONTROL();
  end_j = end_j -> next;
  while(end_j != end){ // Se for, o final é no próximo '..'
    COUNT_NESTING(end_j);
    if(IS_NOT_NESTED() && end_j -> type == TYPE_JOIN)
      break;
    end_j = end_j -> next;
  }
  if(end_j == end){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                   TYPE_T_PATH);
    return false;
  }
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
}
else if(begin_j -> type != TYPE_JOIN && begin_j -> type != TYPE_AMPERSAND &&
        begin_j -> type != TYPE_STRAIGHT_JOIN){
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                 TYPE_T_PATH);
  return false;
}
@
\fimcodigo

O próximo delimitador de direção pode existir ou não dependendo de
termos um token ``$\{$'' após a junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
begin_e = end_j -> next;
if(begin_e -> type != TYPE_OPEN_BRACES){ // Sem especificador
  begin_e = NULL;
  end_e = NULL;
} else{
  DECLARE_NESTING_CONTROL();
  if(begin_e == end){
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, OPTIONAL(begin_e -> line), '{');
    return false;
  }  
  end_e = begin_e -> next;
  while(end_e != end){
    if(IS_NOT_NESTED() && end_e -> type == TYPE_CLOSE_BRACES)
      break;
    COUNT_NESTING(end_e);
    end_e = end_e -> next;
  }
  if(end_e -> type != TYPE_CLOSE_BRACES){
    RAISE_ERROR_UNCLOSED_DELIMITER(mf, cx, OPTIONAL(begin_e -> line), '{');
    return false;
  }
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin_e -> line));
}
@
\fimcodigo

E por fim, o último elemento da junção é o próximo ponto da junção,
que seria uma expressão de caminho terciária. Este próximo elemento
tem seu fim delimitado pelo fim da expressão, por um token de abrir
chaves, ou pelo começo da próxima junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
{
  DECLARE_NESTING_CONTROL();
  if(end_e == NULL)
    begin_z2 = (struct generic_token *) end_j -> next;
  else
    begin_z2 = (struct generic_token *) end_e -> next;
  end_z2 = begin_z2;
  while(end_z2 != end){
    COUNT_NESTING(end_z2);
    if(IS_NOT_NESTED() &&
       (end_z2 -> next -> type == TYPE_OPEN_BRACES ||
        end_z2 -> next -> type == TYPE_JOIN ||
        end_z2 -> next -> type == TYPE_AMPERSAND ||
        end_z2 -> next -> type == TYPE_STRAIGHT_JOIN))
      break;
    end_z2 = end_z2 -> next;
  }
  if(end_z2 == end)
    COUNT_NESTING(end_z2);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin_z2 -> line));
}
@
\fimcodigo

Uma vez que tenhamos identificado cada parte da junção, temos que
interpretar cada uma delas. Primeiro devemos identificar os pontos das
extremidades da junção e copiá-las para o resultado da expressão. Para
isso primeiro interpretaremos $z_0$, a primeira extremidade de junção
e armazenaremos ela na posição correta do caminho que estamos
interpretando.

\iniciocodigo
@<Expressão de Caminho: Prepara Valor Inicial de z1@>+=
{
  struct path_variable z1;
  if(!eval_path_tertiary(mf, cx, begin_z1, end_z1, &z1))
    return false;
  // Se z1 é um único ponto:
  if(z1.length == 1 && z1.points[0].format != SUBPATH_FORMAT){
    result -> points[0].format = PROVISIONAL_FORMAT;
    result -> points[0].prov.x = z1.points[0].prov.x;
    result -> points[0].prov.y = z1.points[0].prov.y;
    result -> points[0].prov.dir1_x = result -> points[0].prov.dir1_y = NAN;
    result -> points[0].prov.dir2_x = result -> points[0].prov.dir2_y = NAN;
    result -> points[0].prov.tension1 = 1.0;
    result -> points[0].prov.tension2 = 1.0;
    result -> points[0].prov.atleast1 = false;
    result -> points[0].prov.atleast2 = false;
    result -> number_of_points ++;
  } else{ // Se z1 é um subcaminho:
    result -> points[0].format = SUBPATH_FORMAT;
    if(!recursive_copy_points(mf, cx, temporary_alloc,
                              &(result -> points[0].subpath), &z1, true))
      return false;
    result -> number_of_points +=
                               result -> points[0].subpath -> number_of_points;
  }
  result -> cyclic = false;
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z1, false);
}
@
\fimcodigo

No início da iteração quando estamos passando pelos pontos a serem
interpretados, sempre teremos uma variável $z_1$ que é um ponto ou
sub-caminho que começará sendo a primeira parte do caminho sendo unida
às outras com uma junção e que em cada iteração será o próximo
valor. E teremos também uma variável $z_2$ que é a que sucede $z_1$ e
é o valor que na iteração seguinte será assumido pelo $z_1$.

O código abaixo interpreta o $z_2$.  Para este caso, devemos levar em
conta que podemos estar diante de um token \monoespaco{cycle}. Se for
o caso, devemos marcar o caminho interpretado como cíclico e devemos
copiar o ponto inicial para esta posição. Caso contrário, concluímos
que o caminho não é cíclico e interpretamos o ponto $z_2$ de maneira
similar a como interpretamos o primeiro ponto $z_0$:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){ // Lemos 'cycle'
  struct path_points *p = result -> points;
  // O primeiro ponto pode ser interno a sub-caminho:
  while(p[0].format == SUBPATH_FORMAT)
    p = ((struct path_variable *) p[0].subpath) -> points;
  memcpy(&(result -> points[result -> length]), p, sizeof(struct path_points));
  result -> length ++;
  result -> number_of_points ++;
  result -> cyclic = true;
}
else{
  struct path_variable z2;
  if(!eval_path_tertiary(mf, cx, begin_z2, end_z2, &z2))
    return false;
  result -> cyclic = false;
  if(z2.length == 1 && z2.points[0].format != SUBPATH_FORMAT){ // z2 é 1 ponto:
    result -> points[result -> length].format = PROVISIONAL_FORMAT;
    result -> points[result -> length].prov.x = z2.points[0].prov.x;
    result -> points[result -> length].prov.y = z2.points[0].prov.y;
    result -> points[result -> length].prov.dir1_x = NAN;
    result -> points[result -> length].prov.dir1_y = NAN;
    result -> points[result -> length].prov.dir2_x = NAN;
    result -> points[result -> length].prov.dir2_y = NAN;
    result -> points[result -> length].prov.tension1 = 1.0;
    result -> points[result -> length].prov.tension2 = 1.0;
    result -> points[result -> length].prov.atleast1 = false;
    result -> points[result -> length].prov.atleast2 = false;
    result -> number_of_points ++;
  }
  else{ // z2 é um sub-caminho:
    result -> points[result -> length].format = SUBPATH_FORMAT;
    if(!recursive_copy_points(mf, cx, temporary_alloc,
                              &(result -> points[result -> length].subpath),
                              &z2, true))
      return false;
    result -> number_of_points +=
            result -> points[result -> length].subpath -> number_of_points;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z2, false);
}
@
\fimcodigo

Note que uma construção como a abaixo é perfeitamente legal:

\alinhaverbatim
path p;
p = (0, 0) .. (1, 2) .. cycle .. (2, 4) .. cycle .. cycle;
\alinhanormal

Cada ponto que não é um \monoespaco{cycle} faz o interpretador
concluir que não está diante de um caminho cíclico, e
cada \monoespaco{cycle} faz ele chegar à conclusão oposta. Então é
somente o último elemento da junção que determina se o caminho será
tratado como cíclico ou não. Nos demais casos, este token é apenas um
sinônimo para o primeiro ponto.

O código que escrevemos até então, garante que todos os pontos de
extremidade serão corretamente preenchidos. Mas nós não devemos
preencher somente eles, mas também a informação de como eles são
unidos, dados pontos de controle, tensão e especificadores de
direção. Mas para preencher esta informação, precisamos de um ponteiro
que mostre quais são os valores exatos dos pontos de extremidade que
estamos unindo (pontos $z_1$ e $z_2$) além do ponto anterior se houver
(ponto $z_0$). Aparentemente, seria só consultar \monoespaco{result ->
points[result -> length - 2]} e \monoespaco{result -> points[result ->
length - 1]} para obter $z_1$ e $z_2$. Entretanto, estes valores podem
não ser pontos isolados, eles podem ser sub-caminhos. Neste caso, para
achar os verdadeiros pontos de extremidade a serem unidos, temos que
percorrer o sub-caminho:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
// z0 é o ponto anterior, z1 é o atual e z2 é o próximo
z1_point = &(result -> points[result -> length - 2]);
z1_parent = result;
while(z1_point -> format == SUBPATH_FORMAT){
  struct path_variable *p = (struct path_variable *) z1_point -> subpath;
  z1_point = &(p -> points[p -> length - 1]);
  z1_parent = p;
  if(p -> length  != 1 && z1_point -> format != SUBPATH_FORMAT)
    z0_point = &(p -> points[p -> length - 2]);
}
if(z0_point == NULL && result -> length > 2){
  z0_point = &(result -> points[result -> length - 3]);
  while(z0_point -> format == SUBPATH_FORMAT){
    struct path_variable *p = (struct path_variable *) z0_point -> subpath;
    z0_point = &(p -> points[p -> length - 1]);
  }
}
z2_point = &(result -> points[result -> length - 1]);
while(z2_point -> format == SUBPATH_FORMAT){
  struct path_variable *p = (struct path_variable *) z2_point -> subpath;
  z2_point = &(p -> points[0]);
}
@
\fimcodigo

Agora temos que interpretar os dois especificadores de direção. Eles
podem ser vazios (equivalente a ter uma direção $(0, 0)$), podem ser
um par especificando um vetor de direção ou então podem ser um
valor numérico de ``enrolamento'' (\monoespaco{curl}).

A função que lê ambos os especificadores é chamada para isso e
preenche corretamente eles caso estejam sendo explicitamente escritos:

\iniciocodigo
@<Expressão de Caminho: Interpreta Direção se Existir@>=
if(!eval_direction_specifier(mf, cx, begin_d, end_d,
                             &(z1_point -> prov.dir1_x),
                             &(z1_point -> prov.dir1_y)))
  return false;
if(!eval_direction_specifier(mf, cx, begin_e, end_e,
                             &(z1_point -> prov.dir2_x),
                             &(z1_point -> prov.dir2_y)))
  return false;
@
\fimcodigo

A função que avalia os especificadores de direção é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y);
@
\fimcodigo

E ela funciona checando quatro casos diferentes: quando não há
especificador nenhum, quando é um especificador de ``enrolamento''
(``\monoespaco{curl}''), quando é um de direção no formato de dois
números ou quando é um de direção no formato de um par:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y){
  // Detectar erro de especificador vazio:
  if(begin != NULL && begin -> next == end){
    RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '{');
    return false;
  }
  @<Especificador de Direção: Caso 1@>
  @<Especificador de Direção: Caso 2@>
  @<Especificador de Direção: Caso 3@>
  @<Especificador de Direção: Caso 4@>
  return false;
}
@
\fimcodigo

Quando um especificador não existe, não modificamos nem armazenamos
nada, apenas retornamos a função:

\iniciocodigo
@<Especificador de Direção: Caso 1@>=
if(begin == NULL || end == NULL)
  return true;
@
\fimcodigo

Vamos checar agora se temos o caso ``$\{curl \gamma\}$'' onde $\gamma$ é
uma expressão numérica. Neste caso, nós terminamos armazenando
$\gamma$ na coordenada $y$ do especificador de direção e deixamos a
coordenada $x$ como ``Not-a-Number'':

\iniciocodigo
@<Especificador de Direção: Caso 2@>=
if(begin -> next -> type == TYPE_CURL){
  struct numeric_variable gamma;
  struct generic_token *begin_n, *end_n;
  begin_n = begin -> next -> next;
  end_n = begin_n;
  if(end_n == end){
    RAISE_ERROR_MISSING_EXPRESSION(mf, cx, OPTIONAL(end_n -> line),
                                   TYPE_T_NUMERIC);
    return false;
  }
  while(end_n -> next != end)
    end_n = end_n -> next;
  if(!eval_numeric_expression(mf, cx, begin_n, end_n, &gamma))
    return false;
  *w_x = NAN;
  *w_y = gamma.value;
  return true;
}
@
\fimcodigo


Agora devemos checar se temos um caso do tipo ``$\{ a , b\}$'' onde
$a$ e $b$ são números. Para isso, tentaremos delimitar os tokens de
$a$ e $b$ procurando pela vírgula. Mas somente se a vírgula for
encontrada que iremos interpretar isso como o terceiro caso:

\iniciocodigo
@<Especificador de Direção: Caso 3@>=
DECLARE_NESTING_CONTROL();
struct generic_token *begin_a, *end_a, *begin_b = NULL, *end_b;
begin_a = (struct generic_token *) begin -> next;
end_a = begin_a;
while(end_a -> next != end){
  COUNT_NESTING(end_a);
  if(IS_NOT_NESTED() && end_a -> next -> type == TYPE_COMMA){
    begin_b = (struct generic_token *) end_a -> next -> next;
    break;
  }
  end_a = (struct generic_token *) end_a -> next;
}
if(begin_b != NULL){
  struct numeric_variable a, b;
  end_b = begin_b;
  while(end_b -> next != end)
    end_b = (struct generic_token *) end_b -> next;
  if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
    return false;
  *w_x = a.value;
  *w_y = b.value;
  return true;
}
@
\fimcodigo

E o terceiro caso, onde teremos um elemento $\{a\}$, onde $a$ é uma
expressão de par. Para tratar este caso, observe que no caso anterior
nós já delimitamos $a$. Se a vírgula não foi encontrada, de qualquer
forma temos seus tokens delimitados. Então podemos interpretá-los como
uma expressão de par:

\iniciocodigo
@<Especificador de Direção: Caso 4@>=
else{ // Se no caso anterior não achamos a vírgula
  COUNT_NESTING(end_a);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin_a -> line));
  struct pair_variable a;
  if(!eval_pair_expression(mf, cx, begin_a, end_a, &a))
    return false;
  *w_x = a.x;
  *w_y = a.y;
  return true;
}
@
\fimcodigo

Com o código que escrevemos até agora estamos preenchendo todos os
especificadores de direção explícitos que encontramos à medida que
avaliamos a expressão de caminho. Contudo, quando nenhum especificador
explícito é colocado, existem algumas regras que nos permitem deduzir
valores implícitos para eles.

Primeiro que quando temos uma junção de concatenação (\monoespaco{\&})
ou de linha reta (\monoespaco{-{}-}), o especificador de direção no
segmento atual é irrelevante. No primeiro caso, porque duas
extremidades concatenadas terão o mesmo ponto e por isso não há
direção alguma entre eles. No segundo caso, o segmento será armazenado
diretamente no formato final como uma linha reta sem precisar de
especificadores de direção. Contudo, devemos colocar
um \monoespaco{curl 1} implícito antes e depois dos pontos em tais
casos. Basicamente transformamos as expressões abaixo:

\alinhaverbatim
z0 .. z1 & z2 .. z3
z0 .. z1 -- z2 .. z3
\alinhanormal

no código:

\alinhaverbatim
z0 .. {curl 1}z1 & z2{curl 1} .. z3
z0 .. {curl 1}z1 -- z2{curl 1} .. z3
\alinhanormal

e isso é feito pelo código abaixo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Direção se Existir@>+=
if(begin_j == end_j && (begin_j -> type == TYPE_AMPERSAND ||
                        begin_j -> type == TYPE_STRAIGHT_JOIN)){
  if(z0_point != NULL && z0_point -> format == PROVISIONAL_FORMAT &&
     isnan(z0_point -> prov.dir2_y)){
    z0_point -> prov.dir2_x = NAN;
    z0_point -> prov.dir2_y = 1.0;
  }
  if(z2_point -> format == PROVISIONAL_FORMAT &&
     isnan(z2_point -> prov.dir1_y)){
    z2_point -> prov.dir1_x = NAN;
    z2_point -> prov.dir1_y = 1.0;
  }
}
@
\fimcodigo

Outra dedução implícita de especificadores de direção ocorre quando o
ponto anterior ou o próximo ponto estão no formato final com pontos de
controle explícitos. A transformação que ocorre é convertendo as
expressões abaixo:

\alinhaverbatim
z0 .. controls u and v .. z1 .. z2 .. z3
z0 ..  z1 .. z2 .. controls u and v ..z3
\alinhanormal

Fazendo elas serem interpretadas como:

\alinhaverbatim
z0 .. controls u and v .. z1{z1-v} .. z2 ..z3
z0 ..  z1 .. {u-z2}z2 .. controls u and v ..z3
\alinhanormal

Este caso é tratado no momento em que interpretamos os pontos de
controle da junção quando eles são explícitos:

\iniciocodigo
@<Expressão de Caminho: Leu Pontos de Controle Explícitos@>+=
if(z0_point != NULL && z0_point -> format == PROVISIONAL_FORMAT &&
   isnan(z0_point -> prov.dir2_y)){
  z0_point -> prov.dir2_x = z1_point -> point.u_x - z1_point -> point.x;
  z0_point -> prov.dir2_y = z1_point -> point.u_y - z1_point -> point.y;
  if(z0_point -> prov.dir2_x == 0.0 && z0_point -> prov.dir2_y == 0.0){
    z0_point -> prov.dir2_x = NAN;
    z0_point -> prov.dir2_y = 1.0;
  }
}
if(z2_point -> format == PROVISIONAL_FORMAT && isnan(z2_point -> prov.dir1_y)){
  z2_point -> prov.dir1_x = z2_point -> prov.x - z1_point -> point.v_x;
  z2_point -> prov.dir1_y = z2_point -> prov.y - z1_point -> point.v_y;
  if(z2_point -> prov.dir1_x == 0.0 && z2_point -> prov.dir1_y == 0.0){
    z2_point -> prov.dir1_x = NAN;
    z2_point -> prov.dir1_y = 1.0;
  }
}
@
\fimcodigo

Especificadores de direção são também implicitamente copiados de um
lado de um ponto para o outro. Isso significa que as expressões
abaixo:

\alinhaverbatim
z0 .. {w1}z1 .. z2 ..z3
z0 .. z1{w1} .. z2 ..z3
\alinhanormal

Seriam interpretadas como:

\alinhaverbatim
z0 .. {w1}z1{w1} .. z2 ..z3
z0 .. {w1}z1{w1} .. z2 ..z3
\alinhanormal

E isso é feito pelo código:

\iniciocodigo
@<Expressão de Caminho: Interpreta Direção se Existir@>+=
if(!isnan(z1_point -> prov.dir2_y) &&
   z2_point -> format == PROVISIONAL_FORMAT && isnan(z2_point -> prov.dir1_y)){
  z2_point -> prov.dir1_x = z1_point -> prov.dir2_x;
  z2_point -> prov.dir1_y = z1_point -> prov.dir2_y;
}
if(z0_point != NULL && isnan(z0_point -> prov.dir2_y) &&
   !isnan(z1_point -> prov.dir1_y)){
  z0_point -> prov.dir2_x = z1_point -> prov.dir1_x;
  z0_point -> prov.dir2_y = z1_point -> prov.dir1_y;
}
@
\fimcodigo

Agora finalmente devemos interpretar a junção em si. A junção pode ter
as seguintes formas:

\alinhaverbatim
z1 & z2
z1 -- z2
z1 .. z2
z1 .. controls u and v .. z2
z1 .. tension a and b .. z2
\alinhanormal

Se nossa junção for um token ``\&'', então estamos lidando com a
concatenação de dois pontos ou (mais provavelmente)
sub-caminhos. Neste caso, devemos checar se os dois pontos que estão
sendo unidos ocupam a mesma posição (consideramos a mesma posição como
sendo uma distância menor que 0,00002). Se não estiverem, um erro deve
ser gerado. Se estiverem, juntaremos ambos os caminhos removendo a
primeira cópia do ponto onde está sendo feita a junção.

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>=
if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
  double dif_x = z1_point -> prov.x - z2_point -> prov.x;
  double dif_y = z1_point -> prov.y - z2_point -> prov.y;
  if(hypot(dif_x, dif_y) > 0.00002){
    RAISE_ERROR_DISCONTINUOUS_PATH(mf, cx, OPTIONAL(begin_j -> line));
    return false;
  }
  // Isso fará o primeiro ponto de extremidade ser sobrescrito
  result -> number_of_points --;
  if(z1_parent != result){
    z1_parent -> length --;
    z1_parent -> number_of_points --;
  }
  z1_point -> point.x = NAN;
  z1_point -> point.y = NAN;
}
@
\fimcodigo

O novo erro gerado quando concatenamos caminhos que não tem uma
extremidade em comum deve ser adicionado à lista de erros:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_DISCONTINUOUS_PATH,
@
\fimcodigo

E esta é a macro que o gera:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_DISCONTINUOUS_PATH(mf, cx, line) {\
  RAISE_GENERIC_ERROR(mf, cx, line, ERROR_DISCONTINUOUS_PATH);}
@
\fimcodigo

A mensagem de erro para avisar o usuário:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_DISCONTINUOUS_PATH:
  fprintf(stderr,
          "%s:%s Trying to concatenate paths without a common extremity.",
          mf -> file, line_number);
  break;
@
\fimcodigo

O próximo caso de junção será quando os pontos serão ligados por uma
linha reta. Neste caso, o nosso ponto terá seu formato modificado para
a forma final e os pontos de controle junto com os pontos de
extremidade estarão no mesmo segmento de reta:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN){
  z1_point -> format = FINAL_FORMAT;
  z1_point -> point.u_x = z1_point -> point.x + (1.0/3.0) *
                         (z2_point -> prov.x - z1_point -> point.x);
  z1_point -> point.u_y = z1_point -> point.y + (1.0/3.0) *
                         (z2_point -> prov.y - z1_point -> point.y);
  z1_point -> point.v_x = z1_point -> point.x + (2.0/3.0) *
                         (z2_point -> prov.x - z1_point -> point.x);
  z1_point -> point.v_y = z1_point -> point.y + (2.0/3.0) *
                         (z2_point -> prov.y - z1_point -> point.y);
}
@
\fimcodigo

Se a junção for simples, sem qualquer informação, ela será
interpretada como equivalente a tendo uma tensão igual a 1. Então as
duas expressões abaixo são equivalentes:

\alinhaverbatim
z1 .. z2
z1 .. tension 1 and 1 .. z2
\alinhanormal

Preencher a tensão neste caso é feito pelo código abaixo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_JOIN){
  z1_point -> prov.tension1 = 1.0;
  z1_point -> prov.tension2 = 1.0;
}
@
\fimcodigo

O próximo caso é quando tempos pontos de controle explícitos. Podem
haver dois formatos diferentes:

\alinhaverbatim
z1 .. controls u and v .. z2
z1 .. controls u .. z2
\alinhanormal

O segundo caso é equivalente a ter ambos os pontos de controle com o
mesmo valor. O modo como diferenciamos ambos os casos é devido ao
token \monoespaco{and}:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN && begin_j != end_j &&
        begin_j -> next -> type == TYPE_CONTROLS){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_u, *end_u, *begin_v = NULL, *end_v = NULL;
  struct pair_variable u, v;
  if(begin_j -> next == end_j || begin_j -> next -> next == end_j){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                   TYPE_T_PATH);
    return false;
  }
  begin_u = begin_j -> next -> next;
  end_u = begin_u;
  while(end_u -> next != end_j){
    COUNT_NESTING(end_u);
    if(IS_NOT_NESTED() && end_u -> next -> type == TYPE_AND)
      break;
    end_u = end_u -> next;
  }
  if(end_u -> next != end_j){
    if(end_u -> next -> next == end_j){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                     TYPE_T_PATH);
      return false;
    }
    begin_v = end_u -> next -> next;
    end_v = begin_v;
    while(end_v -> next != end_j)
      end_v = end_v -> next;
  }
  if(!eval_pair_primary(mf, cx, begin_u, end_u, &u))
    return false;
  z1_point -> format = FINAL_FORMAT;
  z1_point -> point.u_x = u.x;
  z1_point -> point.u_y = u.y;
  if(begin_v != NULL){
    if(!eval_pair_primary(mf, cx, begin_v, end_v, &v))
      return false;
    z1_point -> point.v_x = v.x;
    z1_point -> point.v_y = v.y;
  }
  else{
    z1_point -> point.v_x = u.x;
    z1_point -> point.v_y = u.y;  
  }
  @<Expressão de Caminho: Leu Pontos de Controle Explícitos@>
}
@
\fimcodigo

E finalmente, a junção pode ter o formato de descrição de tensão. Há
as seguintes possibilidades:

\alinhaverbatim
z1 .. tension t0 .. z2
z1 .. tension atleast t0 .. z2
z1 .. tension t0 and t1 .. z2
z1 .. tension atleast t0 and t1 .. z2
z1 .. tension t0 and atleast t1 .. z2
z1 .. tension atleast t0 and atleast t1 .. z2
\alinhanormal

O código que interpreta a junção dada uma descrição de tensão é:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN && begin_j != end_j &&
        begin_j -> next -> type == TYPE_TENSION){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_t0, *end_t0, *begin_t1 = NULL, *end_t1 = NULL;
  struct numeric_variable t0, t1;
  if(begin_j -> next == end_j || begin_j -> next -> next == end_j){
    RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                   TYPE_T_PATH);
    return false;
  }
  begin_t0 = begin_j -> next -> next;
  z1_point -> prov.atleast1 = (begin_t0 -> type == TYPE_ATLEAST);
  if(begin_t0 -> type == TYPE_ATLEAST){
    begin_t0 = begin_t0 -> next;
    if(begin_t0 == end_j){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                     TYPE_T_PATH);
      return false;
    }
  }
  end_t0 = begin_t0;
  while(end_t0 -> next != end_j){
    COUNT_NESTING(end_t0);
    if(IS_NOT_NESTED() && end_t0 -> next -> type == TYPE_AND)
      break;
    end_t0 = end_t0 -> next;
  }
  if(end_t0 -> next != end_j){
    if(begin_t0 -> next -> next == end_j){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                     TYPE_T_PATH);
      return false;
    }
    begin_t1 = end_t0 -> next -> next;
    z1_point -> prov.atleast2 = (begin_t1 -> type == TYPE_ATLEAST);
    if(begin_t1 -> type == TYPE_ATLEAST){
      begin_t1 = (struct generic_token *) begin_t1 -> next;
      if(begin_t1 == end_j){
        RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin_j -> line),
                                       TYPE_T_PATH);
        return false;
      }
    }
    end_t1 = begin_t1;
    while(end_t1 -> next != end_j)
      end_t1 = end_t1 -> next;
  }
  if(!eval_numeric_primary(mf, cx, begin_t0, end_t0, &t0))
    return false;
  z1_point -> prov.tension1 = t0.value;
  if(begin_t1 != NULL){
    if(!eval_numeric_primary(mf, cx, begin_t1, end_t1, &t1))
      return false;
    z1_point -> prov.tension2 = t1.value;
  }
  else{
    z1_point -> prov.atleast2 = z1_point -> prov.atleast1;
    z1_point -> prov.tension2 = z1_point -> prov.tension1;
  }
  if(z1_point -> prov.tension1 < 0.75){
    RAISE_ERROR_INVALID_TENSION(mf, cx, OPTIONAL(begin_t0 -> line),
                                z1_point -> prov.tension1, 0);
    return false;
  }
  if(z1_point -> prov.tension2 < 0.75){
    RAISE_ERROR_INVALID_TENSION(mf, cx, OPTIONAL(begin_t0 -> line),
                                z1_point -> prov.tension2, 1);
    return false;
  }
}
@
\fimcodigo

Conforme visto na Subseção 7.4.3, o valor de tensão não pode ser menor
que 3/4, ou a equação que nos permite deduzir o formato da curva pode
não ter solução. Caso o valor de tensão seja abaixo disso, o seguinte
erro será gerado:

\iniciocodigo
@<Tipos de Erros@>+=
ERROR_INVALID_TENSION,
@
\fimcodigo

A macro que o gera o erro armazena em \monoespaco{errno\_int} se a
tensão com valor inválido foi a primeira (0) ou a segunda (1). Em
seguida, armazena como string o valor de tensão que foi encontrado:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define RAISE_ERROR_INVALID_TENSION(mf, cx, line, value, position) {\
  if(!mf -> errno){\
    mf -> errno_str = (char *) permanent_alloc(64);\
    RAISE_GENERIC_ERROR(mf, cx, line, ERROR_INVALID_TENSION);\
    snprintf(mf -> errno_str, 63, "%g", value);\
    mf -> errno_str[63] = '\0';\
    mf -> errno_int = position;}}
@
\fimcodigo

A mensagem de erro para avisar o usuário:

\iniciocodigo
@<Imprime Mensagem de Erro@>+=
case ERROR_INVALID_TENSION:
  fprintf(stderr,
          "%s:%s %s tension value was smaller than 0.75 (Found value: %s).",
          mf -> file, line_number, (mf -> errno_int == 0)?"First":"Second",
          mf -> errno_str);
  break;
@
\fimcodigo

Uma vez que todas as tensões, pontos de controle e direções foram
coletadas, existem mais algumas operações que precisamos fazer após
percorrer todas as junções. Para estas operações finais, vamos mudar o
nosso ponteiro do ponto $z_0$ para apontar para o primeiro ponto do
caminho. Já os ponteiros para os pontos $z_1$ e $z_2$, não iremos
mudar: depois de passarmos pela última iteração $z_1$ é o penúltimo
ponto e $z_2$ é o último:

\iniciocodigo
@<Expressão de Caminho: Após Ler as Junções@>=
z0_point = &(result -> points[0]);
while(z0_point -> format == SUBPATH_FORMAT){
  struct path_variable *p = (struct path_variable *) z0_point -> subpath;
  z0_point = &(p -> points[0]);
}
@
\fimcodigo

Agora após termos iterado sobre todas as junções, é possível que
ainda não tenhamos de interpretar tudo o que há na expressão. Isso
porquê pode haver um último especificador de direção do lado direito
do último ponto. Caso ele exista, ele precisa ser validado. Em um
caminho não-cíclico, ele será copiado para o lado esquerdo daquele
ponto caso não haja especificador de direção. Em um caminho cíclico,
isso também pode acontecer, mas o especificador também terá efeito no
ponto em que ele está:

\iniciocodigo
@<Expressão de Caminho: Após Ler as Junções@>=
if(end_z1 != end){
  float w_x = NAN, w_y = NAN;
  if(!eval_direction_specifier(mf, cx, end_z1 -> next, end, &w_x, &w_y))
    return false;
  if(z1_point -> format == PROVISIONAL_FORMAT &&
     isnan(z1_point -> prov.dir2_y)){
    z1_point -> prov.dir2_x = w_x;
    z1_point -> prov.dir2_y = w_y;
  }
  if(result -> cyclic){
    z1_point -> prov.dir1_x = w_x;
    z1_point -> prov.dir1_y = w_y;
  }
}
@
\fimcodigo

Agora vamos aplicar algumas regras adicionais para detectar
especificadores de direção implícitos, que só podem ser feitas depois
que lemos a expressão inteira.

Se estamos com um caminho que não é cíclico, mas o começo ou o fim do
caminho não tem especificador de direção, devemos marcar o
especificador inicial e/ou final como \monoespaco{curl 1}. Em outras
palavras, as duas expressões abaixo devem ser vistas como
equivalentes:

\alinhaverbatim
p = z1 .. z2 .. z3;
p = z1{curl 1} .. z2 .. {curl 1}z3;
\alinhanormal

Além disso, o último ponto não tem nada o sucedendo. O seu formato
deve ser ajustado para o formato final, com os pontos de controle
sendo iguais ao do próprio ponto:

\iniciocodigo
@<Expressão de Caminho: Após Ler as Junções@>=
if(!(result -> cyclic)){
  if(z0_point -> format == PROVISIONAL_FORMAT &&
     isnan(z0_point -> prov.dir1_y)){
    z0_point -> prov.dir1_x = NAN;
    z0_point -> prov.dir1_y = 1.0;
  }
  if(z1_point -> format == PROVISIONAL_FORMAT &&
    isnan(z1_point -> prov.dir2_y)){
    z1_point -> prov.dir2_x = NAN;
    z1_point -> prov.dir2_y = 1.0;
  }
  if(z2_point -> format == PROVISIONAL_FORMAT){
    z2_point -> format = FINAL_FORMAT;
    z2_point -> point.u_x = z2_point -> point.v_x = z2_point -> point.x;
    z2_point -> point.u_y = z2_point -> point.v_y = z2_point -> point.y;
  }
}
@
\fimcodigo

Após avaliarmos todas as expressões, podemos garantir que as
coordenadas do primeiro e último ponto são as mesmas. Entretanto, pode
acontecer que eles estejam em formato diferente. Se o primeiro ponto
está em seu formato final e o último não, então o último deve passar a
ficar na forma final também, copiando os pontos de controle:

\iniciocodigo
@<Expressão de Caminho: Após Ler as Junções@>=
if(result -> cyclic && z0_point -> format == FINAL_FORMAT){
  memcpy(z2_point, z0_point, sizeof(struct path_points));
  if(z1_point -> format == PROVISIONAL_FORMAT &&
     isnan(z1_point -> prov.dir2_y)){
    z1_point -> prov.dir2_x = z2_point -> point.u_x - z2_point -> point.x;
    z1_point -> prov.dir2_y = z2_point -> point.u_y - z2_point -> point.y;
    if(z1_point -> prov.dir2_x == 0.0 && z1_point -> prov.dir2_y == 0.0){
      z1_point -> prov.dir2_x = NAN;
      z1_point -> prov.dir2_x = 1.0;
    }
  }
}
@
\fimcodigo

Se ambos os pontos estiverem no formato provisório, copiamos todos os
especificadores de direção que não estiverem vazios de um para o
outro. Caso haja algum conflito, como no exemplo abaixo, as
informações do primeiro ponto terão prioridade sobre o último:

\alinhaverbatim
% Exemplo de conflito:
p = (0, 0){1, 2} .. (1, 3) .. cycle{1, 3};
% Assim como no METAFONT, isso é interpretado como:
p = (0, 0){1, 2} .. (1, 3) .. {1, 3}cycle{1, 2};
\alinhanormal

E este é o código que deixa ambos os pontos consistentes:

\iniciocodigo
@<Expressão de Caminho: Após Ler as Junções@>=
else if(result -> cyclic){
  if(!isnan(z0_point -> prov.dir1_y)){
    z2_point -> prov.dir1_x = z0_point -> prov.dir1_x;
    z2_point -> prov.dir1_y = z0_point -> prov.dir1_y;
    if(z1_point -> format == PROVISIONAL_FORMAT &&
       isnan(z1_point -> prov.dir2_y)){
      z1_point -> prov.dir2_x = z2_point -> prov.dir1_x;
      z1_point -> prov.dir2_y = z2_point -> prov.dir1_y;
    }
  }
  else{
    z0_point -> prov.dir1_x = z2_point -> prov.dir1_x;
    z0_point -> prov.dir1_y = z2_point -> prov.dir1_y;
  }
  z2_point -> prov.dir2_x = z0_point -> prov.dir2_x;
  z2_point -> prov.dir2_y = z0_point -> prov.dir2_y;
}
@
\fimcodigo

Isso finaliza a construção de uma curva dados seus pontos e
sub-caminhos lidos. Agora iremos estabelecer como ler os pontos e
sub-caminhos.

\subsubsecao{8.4.2. Expressões Terciárias de Caminhos}

A gramática para expressões de caminho terciárias é:

\alinhaverbatim
<Terciário de Caminho> -> <Terciário de Par> | <Secundário de Caminho>
\alinhanormal

E é só isso. Então, para interpretar uma expressão terciária de
caminho, o que faremos é percorrer ela e verificar se encontramos uma
expressão terciária de par. Se encontrarmos, devemos interpretar a
expressão inteira como um terciário de par. Caso contrário, a
interpretaremos como um secundário de caminho. Se interpretarmos tudo
como um par, devemos também depois converter o resultado de um par
para um caminho com um único ponto.

De qualquer forma, depois de interpretar a expressão e obter um
caminho como resultado, nós retornamos o resultado.

A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin,
                        struct generic_token *end,
                        struct path_variable *result);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin,
                        struct generic_token *end,
                        struct path_variable *result){
  struct generic_token *p, *prev = NULL;
  bool this_expression_is_pair = false;
  DECLARE_NESTING_CONTROL();
  p = begin;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      this_expression_is_pair = true;
      break;
    }
    prev = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(this_expression_is_pair){
    struct pair_variable pair;
    if(!eval_pair_expression(mf, cx, begin, end, &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> number_of_points = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
      RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(begin -> line));
      return false;
    }
    result -> points -> format = FINAL_FORMAT;
    result -> points -> point.x = pair.x;
    result -> points -> point.y = pair.y;
    result -> points -> point.u_x = pair.x;
    result -> points -> point.u_y = pair.y;
    result -> points -> point.v_x = pair.x;
    result -> points -> point.v_y = pair.y;
    return true;
  }
  else
    return eval_path_secondary(mf, cx, begin, end, result);
}
@
\fimcodigo

\subsubsecao{8.4.3. Expressões Secundárias de Caminhos: Transformadores}

A gramática para expressões secundárias de caminho é:

\alinhaverbatim
<Secundário de Caminho> -> <Secundário de Par> | <Primário de Caminho> |
                           <Secundário de Caminho><Transformador>
\alinhanormal

Os transformadores são os mesmos que já foram apresentados na
expressão secundária de par, mas incluindo o
operador \monoespaco{transformed} introduzido na seção sobre
transformações. A primeira coisa que devemos testar é se temos um
transformador no fim e se temos uma operação secundária de par
(multiplicação e divisão). Depois de percorrer toda a expressão, se
houver o tranformador, aplicamos a terceira regra da gramática
acima. Se houver uma multiplicação e divisão, mas não um
transformador, aplicamos a segunda regra. E caso não haja nada disso,
aplicamos a primeira.

Transformar um caminho via rotação, escala e outras modificações
envolve aplicar tais modificações sobre cada ponto de extremidade e
cada ponto de controle.

A declaração da função que fará isso é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin,
                        struct generic_token *end,
                        struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin,
                        struct generic_token *end,
                        struct path_variable *result){
  bool have_transform = false, have_pair_operator = false;
  struct generic_token *p, *last_fraction = NULL, *transform_op = NULL,
                       *before_transform = NULL, *prev = NULL,
                       *prev_prev = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end && p -> next -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else if(p -> type == TYPE_DIVISION ||
               p -> type == TYPE_MULTIPLICATION)
         have_pair_operator = true;
       else{
         have_transform = true;
         transform_op = p;
         before_transform = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end)
      p = p -> next;
    else
      p = NULL;
  }while(p != NULL);
  RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
  if(have_transform){
    if(transform_op -> next == NULL){
      RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line),
                                     TYPE_T_PATH);
      return false;
    }
    if(!eval_path_secondary(mf, cx, begin, before_transform, result))
      return false;
    @<Transformação de Caminho: Rotação@>
    @<Transformação de Caminho: Escala@>
    @<Transformação de Caminho: Deslocamento@>
    @<Transformação de Caminho: Inclinação@>
    @<Transformação de Caminho: X-Escala@>
    @<Transformação de Caminho: Y-Escala@>
    @<Transformação de Caminho: Z-Escala@>
    @<Transformação de Caminho: Transformação Genérica@>
  }
  else if(have_pair_operator){
    struct pair_variable pair;
    if(!eval_pair_secondary(mf, cx, begin, end, &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> number_of_points = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
      RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(begin -> line));
      return false;
    }
    result -> points -> format = FINAL_FORMAT;
    result -> points[0].point.x = pair.x;
    result -> points[0].point.y = pair.y;
    result -> points[0].point.u_x = pair.x;
    result -> points[0].point.u_y = pair.y;
    result -> points[0].point.v_x = pair.x;
    result -> points[0].point.v_y = pair.y;
    return true;    
  }
  else
    return eval_path_primary(mf, cx, begin, end, result);
}
@
\fimcodigo

No código acima, quando verificamos se temos um transformador na
expressão, sempre armazenamos o último transformador encontrado na
variável \monoespaco{transform\_op} e o último token antes do
transformador em \monoespaco{before\_transform}. Isso nos permite
depois poder dividir a expressão em partes para poder interpretá-la e
obter o caminho sobre o qual devemos aplicar o transformador.

Podemos assumir que toda vez que aplicamos um transformador, o faremos
sobre um caminho já normalizado, isto é, sem recursões e com todos os
pontos no formato final. Isso ocorre porque a normalização acontece no
momento em que a função \monoespaco{eval\_path\_expression} retorna. E
a transformação no código acima sempre ocorrerá sobre o resultado de
expressões primárias de caminho. Nas expressões primárias teremos
variáveis (que para terem sido armazenadas, foram retornadas por
um \monoespaco{eval\_path\_expression}) ou então sub-expressões (que
são interpretadas recursivamente por
um \monoespaco{eval\_path\_expression}). Felizmente, isso limitará a
complexidade do código que lida com tais operações.

Se temos uma rotação, para interpretar um transformador de rotação
depois de termos obtido o caminho a ser rotacionado na
variável \monoespaco{result}, podemos então aplicar o código abaixo:

\iniciocodigo
@<Transformação de Caminho: Rotação@>=
if(transform_op -> type == TYPE_ROTATED){
  struct numeric_variable a;
  double theta, sin_theta, cos_theta;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  theta = 0.0174533 * a.value; // Converter de graus para radianos
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  path_rotate(result, sin_theta, cos_theta);
  return true;
}
@
\fimcodigo

E a função que efetivamente faz a rotação:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta){
  int i;
  for(i = 0; i < p -> length; i ++){
    double x = p -> points[i].prov.x, y = p -> points[i].prov.y;
    p -> points[i].prov.x = x * cos_theta - y * sin_theta;
    p -> points[i].prov.y = x * sin_theta + y * cos_theta;
    x = p -> points[i].point.u_x;
    y = p -> points[i].point.u_y;
    p -> points[i].point.u_x = x * cos_theta - y * sin_theta;
    p -> points[i].point.u_y = x * sin_theta + y * cos_theta;
    x = p -> points[i].point.v_x;
    y = p -> points[i].point.v_y;
    p -> points[i].point.v_x = x * cos_theta - y * sin_theta;
    p -> points[i].point.v_y = x * sin_theta + y * cos_theta;
  }
}
@
\fimcodigo

Agora vamos ao operador que muda a escala de um caminho. Ele deve
interpretar um valor numérico e depois multiplicar cada ponto do
caminho por tal valor numérico:

@<Transformação de Caminho: Escala@>=
else if(transform_op -> type == TYPE_SCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  path_xyscale(result, a.value, a.value);  
  return true;
}
@
\fimcodigo

A função que itera sobre os pontos do caminho fazendo a mudança de
escala:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y);
@
\fimcodigo

Note que a função é mais ampla e pode ser usada para aumentar de
maneira não-proporcional o tamanho de uma curva no eixo $x$ e $y$,
apesar de aqui só a estarmis usando para esticá-la a mesma quantidade
na horizontal e vertical. A sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    p -> points[i].point.x *= x;
    p -> points[i].point.y *= y;
    p -> points[i].point.u_x *= x;
    p -> points[i].point.u_y *= y;
    p -> points[i].point.v_x *= x;
    p -> points[i].point.v_y *= y;
  }
}
@
\fimcodigo

A próxima transformação é uma simples translação ou
deslocamento. Recebemos um par e este par determina o quanto cada
ponto deve ser deslocado no eixo $s$ e $y$:

\iniciocodigo
@<Transformação de Caminho: Deslocamento@>=
else if(transform_op -> type == TYPE_SHIFTED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  path_shift(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

E a função recursiva que faz o deslocamento:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    p -> points[i].point.x += x;
    p -> points[i].point.y += y;
    p -> points[i].point.u_x += x;
    p -> points[i].point.u_y += y;
    p -> points[i].point.v_x += x;
    p -> points[i].point.v_y += y;
  }
}
@
\fimcodigo

Vamos agora à inclinação, o transformador que empurra os pontos mais à
direita se estiverem acima do 0 no eixo $y$ e mais à esquerda se
estiverem mais abaixo da origem no eixo $y$:

\iniciocodigo
@<Transformação de Caminho: Inclinação@>=
else if(transform_op -> type == TYPE_SLANTED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  path_slant(result, a.value);  
  return true;
}
@
\fimcodigo

E a função que faz a inclinação em si:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_slant(struct path_variable *p, float s);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_slant(struct path_variable *p, float s){
  int i;
  for(i = 0; i < p -> length; i ++){
    p -> points[i].point.x += s * p -> points[i].point.y;
    p -> points[i].point.u_x += s * p -> points[i].point.u_y;
    p -> points[i].point.v_x += s * p -> points[i].point.v_y;
  }
}
@
\fimcodigo

A próxima transformação muda o tamanho horizontal do caminho, mas
preserva o tamanho vertical. Devemos ler um valor numérico e ele
determina o quanto o caminho deve ser esticado horizontalmente:


\iniciocodigo
@<Transformação de Caminho: X-Escala@>=
else if(transform_op -> type == TYPE_XSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  path_xyscale(result, a.value, 1.0);  
  return true;
}
@
\fimcodigo

Aqui estamos usando uma função já definida, então não precisamos
defini-la novamente. Além de transformar esticando horizontalmente,
vamos agora esticar verticalmente:

\iniciocodigo
@<Transformação de Caminho: Y-Escala@>=
else if(transform_op -> type == TYPE_YSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  path_xyscale(result, 1.0, a.value);  
  return true;
}
@
\fimcodigo

A penúltima transformação é a mudança de escala Z que lê um par, o
interpreta como número complexo, e também interpreta cada ponto do
caminho como número complexo fazendo a multiplicação:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

Interpretamos e realizamos a transformação da forma abaixo, lembrando
também que esta é a última transformação possível:

\iniciocodigo
@<Transformação de Caminho: Z-Escala@>=
else if(transform_op -> type == TYPE_ZSCALED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  path_zscale(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

E a função que fará isso:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    float x0 = p -> points[i].point.x;
    float y0 = p -> points[i].point.y;
    p -> points[i].point.x = x0 * x - y0 * y;
    p -> points[i].point.y = x0 * y + y0 * x;
    x0 = p -> points[i].point.u_x;
    y0 = p -> points[i].point.u_y;
    p -> points[i].point.u_x = x0 * x - y0 * y;
    p -> points[i].point.u_y = x0 * y + y0 * x;
    x0 = p -> points[i].point.v_x;
    y0 = p -> points[i].point.v_y;
    p -> points[i].point.v_x = x0 * x - y0 * y;
    p -> points[i].point.v_x = x0 * y + y0 * x;
  }
}
@
\fimcodigo

E o último tipo de transformador é a transformação genérica, onde
teremos um transformador que irá indicar como iremos mudar todos os
pontos do caminho. Tratamos este caso da seguinte forma:

\iniciocodigo
@<Transformação de Caminho: Transformação Genérica@>=
else if(transform_op -> type == TYPE_TRANSFORMED){
  struct transform_variable a;
  if(!eval_transform_primary(mf, cx, transform_op -> next, end, &a))
    return false;
  path_transform(result, a.value);
  return true;
}
else{
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PATH);
  return false;
}
@
\fimcodigo

Para isso usamos a seguinte função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M);
@
\fimcodigo

A função é definida como:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M){
  int i;
  for(i = 0; i < p -> length; i ++){
    float x0 = p -> points[i].point.x;
    float y0 = p -> points[i].point.y;
    p -> points[i].point.x = LINEAR_TRANSFORM_X(x0, y0, M);
    p -> points[i].point.y = LINEAR_TRANSFORM_Y(x0, y0, M);
    x0 = p -> points[i].point.u_x;
    y0 = p -> points[i].point.u_y;
    p -> points[i].point.u_x = LINEAR_TRANSFORM_X(x0, y0, M);
    p -> points[i].point.u_y = LINEAR_TRANSFORM_Y(x0, y0, M);
    x0 = p -> points[i].point.v_x;
    y0 = p -> points[i].point.v_y;
    p -> points[i].point.v_x = LINEAR_TRANSFORM_X(x0, y0, M);
    p -> points[i].point.v_x = LINEAR_TRANSFORM_Y(x0, y0, M);
  }
}
@
\fimcodigo

\subsubsecao{8.4.4. Expressões Primárias: Variáveis, Reversos
e Subcaminhos}

A gramática para expressões primárias de caminho é:

\alinhaverbatim
<Primário de Caminho> -> <Primário de Par> | <Variável de Caminho> |
                       ( <Expressão de Caminho> ) |
                       reverse <Primário de Caminho> |
                       subpath <Expressão de Par> of <Primário de Caminho> |
                       ...
\alinhanormal

As regras estão incompletas porque um operador primário adicional
relacionado à variáveis de caneta será definido na Subseção 8.5.4.

Por hora devemos registrar tokens
novos: \monoespaco{reverse}, \monoespaco{subpath} e \monoespaco{of}:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_REVERSE,        // O token simbólico 'reverse'
TYPE_SUBPATH,        // O token simbólico 'subpath'
TYPE_OF,             // O token simbólico 'of'
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"reverse", "subpath", "of",
@
\fimcodigo

O que as regras gramaticais dizem é que no fim de toda expressão de
caminho, terminaremos encontrando no fim uma variável de caminho, um
parênteses, ou algum destes operadores primários novos. Se não, em
todos os outros casos, temos uma expressão primária de parque nos dará
um par. Devemos então testar se estamos nestes casos, e se não
estivermos, basta interpretar como par.

A função que irá interpretar expressões primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin,
                      struct generic_token *end,
                      struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin,
                      struct generic_token *end,
                      struct path_variable *result){
  if(begin -> type == TYPE_REVERSE){
    @<Caminho Primário: Reverso@>
  }
  else if(begin -> type == TYPE_SUBPATH){
    @<Caminho Primário: Subcaminho@>
  }
  else if(begin == end && begin -> type == TYPE_SYMBOLIC){
    @<Caminho Primário: Variável@>
  }
  else if(begin -> type == TYPE_OPEN_PARENTHESIS &&
          end -> type == TYPE_CLOSE_PARENTHESIS){
    @<Caminho Primário: Parênteses@>
  }
  @<Caminho Primário: Outras Expressões@>
  { // Se ainda não retornou, é um par primário
    @<Caminho Primário: Par Primário@>
  }
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PATH);
  return false;
}
@
\fimcodigo

Vamos ao primeiro caso: devemos calcular o reverso de um caminho. Para
isso, devemos inverter a ordem na qual aparecem os pontos de
extremidade e mover os pontos de controle para suas novas
posições. Toda vez que esta operação é feita, será sempre sobre uma
variável de caminho já normalizada, sem recursão e com todos os pontos
no formato final.

\iniciocodigo
@<Caminho Primário: Reverso@>=
struct path_variable tmp;
if(begin -> next == NULL ||  begin == end){
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PATH);
  return false;
}
if(!eval_path_primary(mf, cx, begin -> next, end, &tmp))
  return false;
if(!reverse_path(mf, cx, result, &tmp))
  return false;
if(temporary_free != NULL)
  path_recursive_free(temporary_free, &tmp, false);
return true;
@
\fimcodigo

E a função que realiza a reversão:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool reverse_path(struct metafont *mf, struct context *cx,
                  struct path_variable *dst,
                  struct path_variable *origin);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool reverse_path(struct metafont *mf, struct context *cx,
                  struct path_variable *dst,
                  struct path_variable *origin){
  int i;
  dst -> cyclic = origin -> cyclic;
  dst -> length = origin -> number_of_points;
  dst -> number_of_points = origin -> number_of_points;
  dst -> points = (struct path_points *)
     temporary_alloc(sizeof(struct path_points) * dst -> length);
  if(dst -> points == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, 0);
    return false;
  }
  for(i = 0; i < origin -> length - 1; i ++){
    dst -> points[i].format = FINAL_FORMAT;
    dst -> points[i].point.x = origin-> points[origin->length-1-i].point.x;
    dst -> points[i].point.y = origin-> points[origin->length-1-i].point.y;
    dst -> points[i].point.u_x = origin-> points[origin->length-2-i].point.v_x;
    dst -> points[i].point.u_y = origin-> points[origin->length-2-i].point.v_y;
    dst -> points[i].point.v_x = origin-> points[origin->length-2-i].point.u_x;
    dst -> points[i].point.v_y = origin-> points[origin->length-2-i].point.u_y;
  }
  dst -> points[i].format = FINAL_FORMAT;
  dst -> points[i].point.x = origin -> points[0].point.x;
  dst -> points[i].point.y = origin -> points[0].point.y;
  dst -> points[i].point.u_x = origin -> points[0].point.x;
  dst -> points[i].point.u_y = origin -> points[0].point.y;
  dst -> points[i].point.v_x = origin -> points[0].point.x;
  dst -> points[i].point.v_y = origin -> points[0].point.y;
  return true;
}
@
\fimcodigo


O próximo passo é calcular um subcaminho. O subcaminho gera um novo
caminho que é parte de um caminho maior. Por exemplo:

\alinhaverbatim
subpath (0, 2) of p1 -- p2 -- p3;
\alinhanormal

O código acima avalia para o novo caminho \monoespaco{p1 -- p2},
assumindo que \monoespaco{p1} e \monoespaco{p2} são um único ponto
cada um.

No METAFONT original, é possível calcular sub-caminhos entre pontos em
posições não-inteiras. Por exemplo, calcular o sub-caminho do ponto 0,5
até 1,8. O METAFONT obteria um ponto intermediário entre os pontos de
controle 0 e 1 e entre 1 e 2 conforme pedido. Novos pontos de
extremidade e de controle adequados seriam gerados.  Aqui por hora
iremos suportar só uma versão mais simples de sub-caminhos. Somente
sub-caminhos inteiros serão suportados.

No caso de caminhos não-cíclicos, se tentarmos especificar um
sub-caminho com uma posição menos que zero, tal índice será tratado
como zero. E se tentarmos especificar uma posição maior que seu índice
máximo, será tratada como igual ao seu índice máximo.

No caso de caminhos cíclicos, índices negativos são contados
caminhando no ciclo na direção oposta do caminho. E também não há um
índice máximo permitido. Desta forma, você pode criar um subcaminho de
um caminho cíclico que é maior que o caminho original. Mas a natureza
cíclica do caminho será sempre perdida após a operação.

\iniciocodigo
@<Caminho Primário: Subcaminho@>=
DECLARE_NESTING_CONTROL();
struct pair_variable a;
struct path_variable b;
struct generic_token *of, *end_pair_expr = begin;
struct generic_token *begin_subexpr;
if(begin -> next == NULL ||  end_pair_expr -> type == TYPE_OF || begin == end){
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PATH);
  return false;
}
of = end_pair_expr -> next;
while(of != NULL && of != end){
  COUNT_NESTING(of);
  if(IS_NOT_NESTED() && of -> type == TYPE_OF)
    break;
  end_pair_expr = of;
  of = of -> next;
}
RAISE_ERROR_AND_EXIT_IF_WRONG_NESTING(mf, cx, OPTIONAL(begin -> line));
if(of == NULL || of == end){
  RAISE_ERROR_UNKNOWN_EXPRESSION(mf, cx, OPTIONAL(begin -> line), TYPE_T_PATH);
  return false;
}
if(!eval_pair_expression(mf, cx, begin -> next, end_pair_expr, &a))
  return false;
begin_subexpr = of -> next;
if(!eval_path_primary(mf, cx, begin_subexpr, end, &b))
  return false;
{
  int final_path_size, offset, i;
  result -> cyclic = false;
  // Ignora último ponto igual primeiro:
  if(b.cyclic)
    b.length = b.length - 1;
  if(a.x < 0 && !b.cyclic)
    a.x = 0;
  if(a.y < 0  && !b.cyclic)
    a.y = 0;
  if(a.x >= b.length  && !b.cyclic)
    a.x = b.length - 1;
  if(a.y >= b.length  && !b.cyclic)
    a.y = b.length - 1;
  final_path_size = a.y - a.x;
  if(final_path_size < 0)
    final_path_size *= -1;
  final_path_size ++;
  offset = ((int) ((a.x <= a.y)?(a.x):(a.y))) % b.length;
  if(offset < 0)
    offset *= -1;
  result -> length = final_path_size;
  result -> number_of_points = final_path_size;
  result -> points = (struct path_points *)
                       temporary_alloc(final_path_size *
                                       sizeof(struct path_points));
  if(result -> points == NULL){
    RAISE_ERROR_NO_MEMORY(mf, cx, OPTIONAL(begin -> line));
    return false;
  }
  for(i = 0; i < result -> length; i ++)
    memcpy(&(result -> points[i]), &(b.points[(offset + i) % b.length]),
           sizeof(struct path_points));
  // Ajusta últimos pontos de controle se perdemos o caráter cíclico:
  result -> points[result -> length - 1].point.u_x =
                                result -> points[result -> length - 1].point.x;
  result -> points[result -> length - 1].point.u_y =
                                result -> points[result -> length - 1].point.y;
  result -> points[result -> length - 1].point.v_x =
                                result -> points[result -> length - 1].point.x;
  result -> points[result -> length - 1].point.v_y =
                                result -> points[result -> length - 1].point.y;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  if(a.x > a.y){
    struct path_variable c;
    if(!reverse_path(mf, cx, &c, result))
      return false;
    if(temporary_free != NULL)
      temporary_free(result -> points);
    result -> points = c.points;
  }
  return true;
}
@
\fimcodigo

O próximo caso a tratar é quando estamos diante de uma variável. Neste
caso, devemos determinar seu tipo. Pode ser um par ou um caminho. Em
seguida, alocamos o tamanho certo para nosso resultado e copiamos o
conteúdo da variável para ele:

\iniciocodigo
@<Caminho Primário: Variável@>=
{
  struct symbolic_token *v = (struct symbolic_token *) begin;
  struct path_variable *var = v -> var;
  if(var == NULL){
    RAISE_ERROR_UNDECLARED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                   v -> value);
    return false;
  }
  if(((struct pair_variable *) var) -> type == TYPE_T_PAIR){
    if(isnan(((struct pair_variable *) var) -> x)){
      RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                        v -> value);
      return false;
    }
    result -> length = 1;
    result -> number_of_points = 1;
    result -> cyclic = false;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    result -> points[0].format = FINAL_FORMAT;
    result -> points[0].point.x = ((struct pair_variable *) var) -> x;
    result -> points[0].point.y = ((struct pair_variable *) var) -> y;
    result -> points[0].point.u_x = ((struct pair_variable *) var) -> x;
    result -> points[0].point.u_y = ((struct pair_variable *) var) -> y;
    result -> points[0].point.v_x = ((struct pair_variable *) var) -> x;
    result -> points[0].point.v_y = ((struct pair_variable *) var) -> y;
    return true;
  }
  else if(var -> type == TYPE_T_PATH){
    if(var -> length == -1){
      RAISE_ERROR_UNINITIALIZED_VARIABLE(mf, cx, OPTIONAL(begin -> line),
                                        v -> value);
      return false;
    }
    return recursive_copy_points(mf, cx, temporary_alloc, &result, var, false);
  }
  else{
    RAISE_ERROR_WRONG_VARIABLE_TYPE(mf, cx, OPTIONAL(v -> line), v -> value,
                                   var -> type, TYPE_T_PATH);
    return false;
  }
}
@
\fimcodigo

O próximo caso a ser tratado é quando a expressão primária de caminho
começa e termina com parênteses. E não estamos diante de um par. Neste
caso, devemos avaliar a expressão entre parênteses como uma nova
expressão de caminho. Mas para isso temos antes que checar que não há
uma vírgula dentro dela, caso em que estamos diante de um par:

\iniciocodigo
@<Caminho Primário: Parênteses@>=
struct generic_token *t = begin -> next;
bool found_comma = false;
DECLARE_NESTING_CONTROL();
if(begin -> next == end){
  RAISE_ERROR_EMPTY_DELIMITER(mf, cx, OPTIONAL(begin -> line), '(');
  return false;
}
while(t != NULL && t -> next != end){
  COUNT_NESTING(t);
  if(IS_NOT_NESTED() && t -> type == TYPE_COMMA){
    found_comma = true;
    break;
  }
  t = t -> next;
}
if(!found_comma){
  return eval_path_expression(mf, cx, begin -> next, t, result);
}
@
\fimcodigo

E finalmente, o último caso de expressãso primária é quando temos uma
expressão primária de par. Neste caso, alocamos o único ponto de nosso
caminho, avaliamos a expressão de par e passamos o resultado para o
ponto alocado:

\iniciocodigo
@<Caminho Primário: Par Primário@>=
struct pair_variable v;
if(!eval_pair_primary(mf, cx, begin, end, &v))
  return false;
result -> length = 1;
result -> number_of_points = 1;
result -> cyclic = false;
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points));
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = v.x;
result -> points[0].point.y = v.y;
result -> points[0].point.u_x = v.x;
result -> points[0].point.u_y = v.y;
result -> points[0].point.v_x = v.x;
result -> points[0].point.v_y = v.y;
return true;
@
\fimcodigo

\subsubsecao{8.4.5. Caminhos em Expressões Numéricas}

Existe a expressão numérica primária com o
operador \monoespaco{length} que retorna o número de pontos de
extremidade de um caminho menos um. A sua sintaxe é:

\alinhaverbatim
<Primário Numérico> -> length <Caminho Primário>
\alinhanormal
%                       turningnumber <Caminho Primário> |
%                       directiontime <Expressão de Par> of <Caminho Primário>

Não precisamos aqui de nenhum tipo de token novo. A
expressão \monoespaco{length} já era usada para obter o módulo de
números e de pares. Para o caso deste operador obter um caminho, sua
implementação é ainda mais simples:

\iniciocodigo
@<Avalia 'length'@>+=
else if(expr_type == TYPE_T_PATH){
  struct path_variable p;
  if(!eval_path_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) (p.number_of_points - 1);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &p, false);
  return true;
}
@
\fimcodigo

\subsubsecao{8.4.6. Caminhos em Expressões de Pares}

Dado um caminho, nós podemos extrair pares dele. O par pode ser um dos
pontos de extremidade ou algum dos pontos de controle. A sintaxe para
isso é:

\alinhaverbatim
<Primário de Par> -> point <Expressão Numérica> of <Primário de Caminho> |
                     precontrol <Expressão Numérica> of <Primário de Caminho> |
                     postcontrol <Expressão Numérica> of <Primário de Caminho>
\alinhanormal

Isso requer adicionarmos os seguintes novos tipos de tokens:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_POINT,             // O token simbólico 'point'
TYPE_PRECONTROL,        // O token simbólico 'precontrol'
TYPE_POSTCONTROL,       // O token simbólico 'postcontrol'
@
\fimcodigo

E os adicionamos à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"point", "precontrol", "postcontrol",
@
\fimcodigo

Todos estes operadores requerem que nós encontremos determinado ponto
na posição $n$ de um caminho. Para isso, será útil uma função auxiliar
que irá receber uma variável de caminho e um número e irá retornar um
ponteiro para um dos pontos desta variável. Essa função irá primeiro
verificar se temos um caminho onde o tamanho total é igual ao tamanho
(\monoespaco{length == total\_length}). Se for o caso, assumiremos
estar diante de um caminho sem subcaminhos recursivos e retornar o
ponto correto será fácil e rápido. Caso contrário, vamos chamar uma
função recursiva auxiliaar para nos responder qual é o ponto correto:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n){
  if(v -> length == v -> number_of_points){
    struct path_points *ret = (struct path_points *) &(v -> points[n]);
    while(ret -> format == SUBPATH_FORMAT)
      ret = &(((struct path_variable *) (ret -> subpath)) -> points[0]);
    return ret;
  }
  else{
    int count = 0;
    return _get_point(v, n, &count);
  }
}
@
\fimcodigo

Essa função auxiliar recursiva para obter o ponto correto no caso de
caminhos com subcaminhos recursivos irá percorrer os pontos do caminho
na ordem, contando quantos são encontrados. E irá retornar o ponto
quando chegar ao correto. Para isso ela precisa saber qual a variável
de caminho, qual o índice $n$ do ponto e por fim, quantos pontos já
foram percorridos:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count);
@
\fimcodigo

A definição desta função será:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count){
  int i;
  for(i = 0; i < v -> length; i ++){
    if(v -> points[i].format != SUBPATH_FORMAT) {
      if(*count == n && !isnan(v -> points[i].point.x))
	return ((struct path_points *) &(v -> points[i]));
      else if(!isnan(v -> points[i].point.x))
	(*count) ++;
    }
    else{
      struct path_points *r =
	_get_point((struct path_variable *) (v -> points[i].subpath),
		   n, count);
      if(r != NULL)
	return r;
    }
  }
  return NULL;
}
@
\fimcodigo


No caso do primeiro operador, \monoespaco{point}, ele nos retorna o
ponto de extremidade indicado. Se o caminho não for cíclico, os pontos
de índice menor que zero serão iguais ao de índice zero (o primeiro) e
os pontos de índice maior ou igual ao tamanho serão iguais ao último
ponto. Se o caminho for cíclico, o índice é contado seguindo o
ciclo. No METAFONT original, índices não-positivos eram permitidos,
mas aqui eles serão convertidos para inteiros.

O operador \monoespaco{postcontrol} é semelhante, mas ele obtém o
primeiro ponto de controle imediatamente após o ponto cujo índice é
indicado. E o \monoespaco{precontrol} obtém o ponto de controle
imediatamente antes do ponto indicado.

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>=
if(begin -> type == TYPE_POINT ||
   begin -> type == TYPE_PRECONTROL ||
   begin -> type == TYPE_POSTCONTROL){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_num, *end_num , *of = NULL, *begin_path, *end_path;
  struct numeric_variable a;
  struct path_variable b;
  begin_num = begin -> next;
  end_num = begin_num;
  int index;
  while(end_num != NULL && end_num -> next != end){
    COUNT_NESTING(end_num);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_num -> next) -> type == TYPE_OF){
      of = end_num -> next;
      break;
    }
    end_num = end_num -> next;
  }
  if(of == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'of' in 'point' expression\n",
            mf -> file, begin -> line);
#endif
    return false;
  }
  if(of -> next == NULL || of == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing path expression in "
            "'point' expression\n", mf -> file, begin -> line);
#endif
    return false;
  }
  begin_path = of -> next;
  end_path = end;
  if(!eval_numeric_expression(mf, cx, begin_num, end_num, &a))
    return false;
  if(!eval_path_primary(mf, cx, begin_path, end_path, &b))
    return false;
  if(b.cyclic){
    index = ((int)(a.value)) % (b.number_of_points - 1);
    if(begin -> type == TYPE_PRECONTROL)
      index = (index - 1) % (b.number_of_points - 1);
  }
  else{
    index = (int) (a.value);
    if(index < 0) index = 0;
    if(index >= b.number_of_points) index = b.number_of_points - 1;
    if(begin -> type == TYPE_PRECONTROL)
      index --;
  }
  if(begin -> type == TYPE_POINT){
    result -> x = get_point(&b, index) -> point.x;
    result -> y = get_point(&b, index) -> point.y;
  }
  else if(begin -> type == TYPE_PRECONTROL){
    if(index < 0){
      result -> x = get_point(&b, 0) -> point.x;
      result -> y = get_point(&b, 0) -> point.y;
    }
    else{
      result -> x = get_point(&b, index) -> point.v_x;
      result -> y = get_point(&b, index) -> point.v_y;
    }
  }
  else{
    result -> x = get_point(&b, index) -> point.u_x;
    result -> y = get_point(&b, index) -> point.u_y;
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  return true;
}
@
\fimcodigo

\subsecao{8.5. Atribuições e Expressões de Caneta}

Para realizar a atribuição de canetas a variáveis do tipo certo,
usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Caneta@>=
else if(type == TYPE_T_PEN){
  int i;
  struct pen_variable result;
  if(!eval_pen_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    if(!assign_pen_variable(mf, (struct pen_variable *) var -> var,
                            &result))
      return false;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL && result.format !=  NULL)
    path_recursive_free(temporary_free, result.format, true);
  if(result.gl_vbo != 0 && result.referenced == NULL)
    glDeleteBuffers(1, &(result.gl_vbo));
}
@
\fimcodigo

A declaração da função que faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool assign_pen_variable(struct metafont *mf,
                         struct pen_variable *target,
                         struct pen_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool assign_pen_variable(struct metafont *mf,
                         struct pen_variable *target,
                         struct pen_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  struct variable *next = target -> next;
  if(target -> permanent){
    disalloc = permanent_free;
    alloc = permanent_alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> format != NULL && disalloc != NULL)
    path_recursive_free(disalloc, target -> format, true);
  if(target -> gl_vbo != 0)
    glDeleteBuffers(1, &(target -> gl_vbo));
  memcpy(target, source, sizeof(struct pen_variable));
  target -> type = TYPE_T_PEN;
  target -> next = next;
  if(! (source -> flags & (FLAG_CIRCULAR | FLAG_SQUARE | FLAG_NULL)))
    if(!recursive_copy_points(mf, NULL, alloc, &(target -> format),
                             source -> format, true))
      return false;
  target -> gl_vbo = 0;
  target -> indices = 0;
  target -> referenced = NULL;
  // Se estamos atribuindo para 'currentpen', devemos retriangular a caneta.
  // Conforme descrito na Seção 10.
  if(target == &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]))
    triangulate_pen(mf, target, target -> gl_matrix);
  return true;
}
@
\fimcodigo

\subsubsecao{8.5.1. Expressão Terciária de Caneta}

Por enquanto não existe nenhum operador terciário de caneta:

\alinhaverbatim
<Expressão de Caneta> -> <Terciário de Caneta>
<Terciário de Caneta> -> <Secundário de Caneta>
\alinhanormal

Então a função que avalia expressão terciária de canetas apenas
repassa a expressão para a expressão secundária (mas podemos adicionar
algumas linhas para detectar erros comuns):

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result){
  if(begin_expression -> type != TYPE_SYMBOLIC &&
     begin_expression -> type != TYPE_NULLPEN &&
     begin_expression -> type != TYPE_OPEN_PARENTHESIS &&
     begin_expression -> type != TYPE_PENCIRCLE &&
     begin_expression -> type != TYPE_MAKEPEN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
    return false;
  }
  return eval_pen_secondary(mf, cx, begin_expression, end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.5.2. Transformadores de Caneta}

A sintaxe para expressões secundárias de caneta é:

\alinhaverbatim
<Secundário de Caneta> -> <Primário de Caneta> |
                          <Secundário de Caneta> <Transformador>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> |
                   transformed <Primário de Transformação>
\alinhanormal

Transformadores não são coisas novas, eles já eram usados em
expressões de pares, transformações e de caminho. Mas aplicá-los sobre
canetas é ligeiramente diferente, pois ao invés de modificar cada um
de seus pontos, nós modificamos apenas sua matriz de transformação
OpenGL.

A declaração da função que avaliará expressões secundárias de caneta
é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

Sua implementação consiste em percorrer os tokens da expressão até
achar o último transformador, se houver. Se não houver, é só repassar
a avaliação para a função que avalia expressões primárias. Se houver,
então avaliamos como expressão secundária o que vem antes e então
realizamos a transformação adequada:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct pen_variable *pen){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_pen_primary(mf, cx, begin_expression, end_expression, pen);
  else{
    if(!eval_pen_secondary(mf, cx, begin_expression, before_last_transformer, pen))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Secundário de Caneta: Rotação@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Secundário de Caneta: Escala@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Secundário de Caneta: Deslocamento@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Secundário de Caneta: Inclinação@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Secundário de Caneta: X-Escala@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Secundário de Caneta: Y-Escala@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Secundário de Caneta: Z-Escala@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Secundário de Caneta: Transformação Genérica@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Primeiro cuidaremos da rotação em um ângulo $\theta$. Primeiro fazemos
a conversão entre o ângulo medido em graus que o WeaveFONT usa e a
medida em radianos esperada pela biblioteca padrão C. Rotacionar
significa aplicar a transformação de rotação sobre a matriz de
transformação da caneta:

\iniciocodigo
@<Secundário de Caneta: Rotação@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(pen -> gl_matrix, rotation);
return true;
@
\fimcodigo

Para fazer a operação de escala também aplicamos tal transformação
sobre a matriz da caneta:

\iniciocodigo
@<Secundário de Caneta: Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(pen -> gl_matrix, a.value);
// Canetas curvas devem ser retrianguladas se aumentam de tamanho:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

A transformação de deslocamento que desloca a caneta na horizontal e
vertical é tratada abaixo:

\iniciocodigo
@<Secundário de Caneta: Deslocamento@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SHIFT(pen -> gl_matrix, p.x, p.y);
return true;
@
\fimcodigo

O próximo transformador é a inclinação. 

\iniciocodigo
@<Secundário de Caneta: Inclinação@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(pen -> gl_matrix, a.value);
// Inclinar canetas curvas não-circulares requer retriangulação:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT) &&
   !(pen -> flags & FLAG_CIRCULAR)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

A transformação de escala no eixo $x$ é igual à transformação de
escala, mas a caneta é esticada ou comprimida somente no eixo
horizontal:

\iniciocodigo
@<Secundário de Caneta: X-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(pen -> gl_matrix, a.value);
// Canetas curvas devem ser retrianguladas se aumentam de tamanho:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Da mesma forma, mudar a escala somente no eixo $y$ é feito no código
abaixo:

\iniciocodigo
@<Secundário de Caneta: Y-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(pen -> gl_matrix, a.value);
// Canetas curvas devem ser retrianguladas se aumentam de tamanho:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

A mudança de escala $z$ înterpreta dois pares como números
complexos e os multiplica:

$$
(x+yi)(a+bi) = ax + (bx)i + (ay)i + (by)i^2 = (ax - by) + (bx+ay)i
$$

Podemos então realizar a operação acima usando o código abaixo:

\iniciocodigo
@<Secundário de Caneta: Z-Escala@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(pen -> gl_matrix, p.x, p.y);
// Canetas curvas devem ser retrianguladas neste caso:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Por fim, a última transformação é a genérica que envolve aplicar a
transformação linear que está armazenada em um transformador:

\iniciocodigo
@<Secundário de Caneta: Transformação Genérica@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression, &t))
  return false;
MATRIX_MULTIPLICATION(pen -> gl_matrix, t.value);
// Canetas curvas devem ser retrianguladas neste caso:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

\subsubsecao{8.5.3. Expressões Primárias: Caneta Nula, Circular,
Arbitrária e Variáveis}

A gramática das expressões primárias de caminho é definida como:

\alinhaverbatim
<Primário de Caneta> -> <Variável de Caneta> |
                        nullpen | ( <Expressão de Caneta> ) |
                        pencircle | makepen <Primário de Caminho>
\alinhanormal


Isso requer registrar três novas palavras reservadas:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_NULLPEN,        // O token simbólico 'nullpen'
TYPE_PENCIRCLE,      // O token simbólico 'pencircle'
TYPE_MAKEPEN,        // O token simbólico 'makepen'
@
\fimcodigo

E adicionamos uma string com o nome delas na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"nullpen", "pencircle", "makepen",
@
\fimcodigo

A função que irá interpretar expressões primárias de caneta é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Caneta Primária: Variável@>
    }
    else if(begin_expression -> type == TYPE_NULLPEN){
      @<Caneta Primária: Caneta Nula@>
    }
    else if(begin_expression -> type == TYPE_PENCIRCLE){
      @<Caneta Primária: Caneta Circular@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Caneta Primária: Parênteses@>
    }
    else if(begin_expression -> type == TYPE_MAKEPEN){
      @<Caneta Primária: Formato Personalizado@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

Se a expressão avaliar para uma variável, devemos copiar o conteúdo da
variável. Se avaliar para uma variável que aponta para outra (o caso
do \monoespaco{currentpen}), devemos ao invés disso copiar o conteúdo
da variável referenciada. Mas depois disso devemos multiplicar a
matriz da variável que aponta pela matriz obtida copiada.

\iniciocodigo
@<Caneta Primária: Variável@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct pen_variable *content = v -> var, *to_copy = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-pen variable (%d) in pen expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
if(content -> referenced != NULL)
  to_copy = content -> referenced;
memcpy(result, to_copy, sizeof(struct pen_variable));
if(to_copy -> format != NULL)
  if(!recursive_copy_points(mf, cx, temporary_alloc, &(result -> format),
                        to_copy -> format, true))
    return false;
if(to_copy != content)
  MATRIX_MULTIPLICATION(result -> gl_matrix, content -> gl_matrix);
return true;
@
\fimcodigo

Se a expressão avaliar para uma caneta nula, devemos apenas gerar uma
nova caneta com a flag de \monoespaco{FLAG\_NULL} ativa. Esta caneta
nunca será triangulada e nunca produzirá qualquer desenho:

\iniciocodigo
@<Caneta Primária: Caneta Nula@>=
result -> format = NULL;
result -> flags = FLAG_NULL;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

Se a expressão avaliar para uma caneta circular, geraremos uma nova
caneta com as flags de ser circular e convexa. Também inicializamos a
matriz de transformação como sendo a matriz identidade:

\iniciocodigo
@<Caneta Primária: Caneta Circular@>=
result -> format = NULL;
result -> flags = FLAG_CONVEX | FLAG_CIRCULAR;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

Avaliar parênteses envolve avaliar como expressão de caneta os tokens
do que vem após o abrir parênteses até o que vem imediatamente antes
do fechar parênteses:

\iniciocodigo
@<Caneta Primária: Parênteses@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_pen_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

O último caso de expressão primária de caneta é quando o usuário
escolhe um formato personalizado. Neste caso devemos avaliar a
expressão de caminho indicada e com ela criamos a nova caneta com tal
formato:

\iniciocodigo
@<Caneta Primária: Formato Personalizado@>=
struct generic_token *p = begin_expression -> next;
result -> format =
        (struct path_variable *) temporary_alloc(sizeof(struct path_variable));
if(result -> format == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, p, end_expression, result -> format))
  return false;
if(!(result -> format -> cyclic)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr,
          "METAFONT: Error: %s:%d: Using 'makepen' with non-cyclic path.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
result -> flags = read_flags(result -> format); // Função a ser implemementada
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

O que falta implementar para que o código acima funcione é a função
que percorra os pontos de uma variável de caminho e retorne quais
flags teria uma caneta com aquele formato.

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int read_flags(struct path_variable *path);
@
\fimcodigo

Já sabemos que ela nunca seria circular, pois círculos perfeitos não
podem ser expressos como curvas de Beziér. Iremos então verificar se
ela é reta ou convexa percorrendo os seus pontos:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int read_flags(struct path_variable *path){
  int i, positive_cross_product = -1;
  int flag = FLAG_CONVEX | FLAG_STRAIGHT;
  for(i = 0; i < path -> number_of_points - 1; i ++){
    struct path_points *current, *next;
    current = get_point(path, i);
    next = get_point(path, i + 1);
    if(flag & FLAG_STRAIGHT){
      // Ela não é reta se os pontos de extremidade e de controle não estão
      // na mesma reta. Eles estão na mesma reta se a área de seu triângulo
      // é igual a zero (ou suficientemente próxima):
      double area =  current -> point.x * (current -> point.u_y - next -> point.y) +
                     current -> point.u_x * (next -> point.y - current -> point.y) +
                     next -> point.x * (current -> point.y - current -> point.u_y);
      if(area > 0.00002)
        flag -= FLAG_STRAIGHT;
      area =  current -> point.x * (current -> point.v_y - next -> point.y) +
              current -> point.v_x * (next -> point.y - current -> point.y) +
              next -> point.x * (current -> point.y - current -> point.v_y);
      if((flag & FLAG_STRAIGHT) && area > 0.00002)
        flag -= FLAG_STRAIGHT;
    }
    if(flag & FLAG_CONVEX){
      // Ela é convexa somente se o componente z do produto vetorial dos
      // vetores formados pelos pontos de extremidade e controle na ordem
      // de desenho são todos ou não-positivos ou não-negativos.
      int j;
      double d1_x, d1_y, d2_x, d2_y, z_cross_product;
      double p1_x, p1_y, p2_x, p2_y, p3_x, p3_y; // Pontos
      for(j = 0; j < 3; j ++){
        switch(j){
          case 0:
            p1_x = current -> point.x; p1_y = current -> point.y;
            p2_x = current -> point.u_x; p2_y = current -> point.u_y;
            p3_x = current -> point.v_x; p3_y = current -> point.v_y;
            break;
          case 1:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> point.x; p3_y = next -> point.y;
            break;
          default:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> point.u_x; p3_y = next -> point.u_y;
            break;
        }
        d1_x = p2_x - p1_x;
        d1_y = p2_y - p1_y;
        d2_x = p3_x - p2_x;
        d2_y = p3_y - p2_y;
        z_cross_product = d1_x * d2_y - d1_y * d2_x;
        if(z_cross_product > 0.004 || z_cross_product < -0.004){
          if(positive_cross_product == -1)
            positive_cross_product = (z_cross_product > 0);
          else if((z_cross_product > 0) != positive_cross_product){
            //flag -= FLAG_CONVEX;
            break;
          }
        }
      }
    }
  }
  return flag;
}
@
\fimcodigo

\subsubsecao{8.5.4. Canetas em Expressões de Caminho}

Expressões primárias de caneta podem aparecer também quando avaliamos
uma expressão primária de caminho. Isso permite que possamos extrair
um caminho à partir do formato de uma caneta. A gramática de tal
operação é:

\alinhaverbatim
<Primário de Caminho> -> makepath <Primário de Caneta>
\alinhanormal

Temos que registrar um novo token para o ``makepath'':

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_MAKEPATH,       // O token simbólico 'makepath'
@
\fimcodigo

E adicionamos a string com seu nome à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"makepath",
@
\fimcodigo

O operador ``makepath'' deve avaliar tudo o que vem depois dele como
sendo uma expressão primária da caneta. Em seguida, o resultado da
avaliação é um caminho com o formato da caneta. Contudo, devemos
lembrar que nem sempre armazenamos o formato de uma caneta
explicitamente. Caso tenhamos uma \monoespaco{nullpen},
um \monoespaco{circlepen} ou se estivermos diante de um quadrado,
então precisamos gerar um caminho novo, já que não temos caminho nenhum:

\iniciocodigo
@<Caminho Primário: Outras Expressões@>=
else if(begin -> type == TYPE_MAKEPATH){
  struct pen_variable tmp;
  if(begin -> next == NULL || begin == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n",  mf -> file, begin -> line);
#endif
    return false;
  }
  if(!eval_pen_primary(mf, cx, begin -> next, end, &tmp))
    return false;
  if(tmp.flags & FLAG_NULL){ // nullpen: Avalia para ponto único (0, 0)
    @<'makepath': 'nullpen'@>
  }
  else if(tmp.flags & FLAG_CIRCULAR){ // circlepen: Cria aproximação de círculo
    @<'makepath': 'pencircle'@>
  }
  else if(tmp.flags & FLAG_SQUARE){ // Caneta quadrada
    @<'makepath': 'pensquare'@>
  }
  else{ // Caneta com formato personalizado
    @<'makepath': Formato Personalizado@>
  }
  @<'makepath': Realiza Transformação Linear@>
  return true;
}
@
\fimcodigo

Assim como na linguagem METAFONT original, o \monoespaco{nullpen}
significa um único ponto na posição $(0, 0)$ que nunca é desenhado:

\iniciocodigo
@<'makepath': 'nullpen'@>=
result -> length = 1;
result -> number_of_points = 1;
result -> cyclic = false;
result -> points =
  (struct path_points *) temporary_alloc(sizeof(struct path_points));
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = 0.0;
result -> points[0].point.y = 0.0;
result -> points[0].point.u_x = 0.0;
result -> points[0].point.u_y = 0.0;
result -> points[0].point.v_x = 0.0;
result -> points[0].point.v_y = 0.0;
@
\fimcodigo

Caso estejamos diante de um caminho circular, usaremos como
representação do caminho os mesmos valores que o METAFONT original usa
para representar o caminho na macro \monoespaco{fullcircle}. O
resultado será algo próximo a um círculo.

\iniciocodigo
@<'makepath': 'pencircle'@>=
result -> length = 9;
result -> number_of_points = 9;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 9);
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = 0.5; result -> points[0].point.y = 0.0;
result -> points[0].point.u_x = 0.5; result -> points[0].point.u_y = 0.13261;
result -> points[0].point.v_x = 0.44733; result -> points[0].point.v_y = 0.2598;
result -> points[1].format = FINAL_FORMAT;
result -> points[1].point.x = 0.35356; result -> points[1].point.y = 0.35356;
result -> points[1].point.u_x = 0.2598; result -> points[1].point.u_y = 0.44733;
result -> points[1].point.v_x = 0.13261; result -> points[1].point.v_y = 0.5;
result -> points[2].format = FINAL_FORMAT;
result -> points[2].point.x = 0.0; result -> points[2].point.y = 0.5;
result -> points[2].point.u_x = -0.13261; result -> points[2].point.u_y = 0.5;
result -> points[2].point.v_x = -0.2598; result -> points[2].point.v_y = 0.44733;
result -> points[3].format = FINAL_FORMAT;
result -> points[3].point.x = -0.35356; result -> points[3].point.y = 0.35356;
result -> points[3].point.u_x = -0.44733; result -> points[3].point.u_y = 0.2598;
result -> points[3].point.v_x = -0.5; result -> points[3].point.v_y = 0.13261;
result -> points[4].format = FINAL_FORMAT;
result -> points[4].point.x = -0.5; result -> points[4].point.y = 0.0;
result -> points[4].point.u_x = -0.5; result -> points[4].point.u_y = -0.13261;
result -> points[4].point.v_x = -0.44733; result -> points[4].point.v_y = -0.2598;
result -> points[5].format = FINAL_FORMAT;
result -> points[5].point.x = -0.35356; result -> points[5].point.y = -0.35356;
result -> points[5].point.u_x = -0.2598; result -> points[5].point.u_y = -0.44733;
result -> points[5].point.v_x = -0.13261; result -> points[5].point.v_y = -0.5;
result -> points[6].format = FINAL_FORMAT;
result -> points[6].point.x = 0.0; result -> points[6].point.y = -0.5;
result -> points[6].point.u_x = 0.13261; result -> points[6].point.u_y = -0.5;
result -> points[6].point.v_x = 0.2598; result -> points[6].point.v_y = -0.44733;
result -> points[7].format = FINAL_FORMAT;
result -> points[7].point.x = 0.35356; result -> points[7].point.y = -0.35356;
result -> points[7].point.u_x = 0.44733; result -> points[7].point.u_y = -0.2598;
result -> points[7].point.v_x = 0.5; result -> points[7].point.v_y = -0.13261;
result -> points[7].format = FINAL_FORMAT;
result -> points[8].point.x = 0.5; result -> points[8].point.y = 0.0;
result -> points[8].point.u_x = 0.5; result -> points[8].point.u_y = 0.13261;
result -> points[8].point.v_x = 0.44733; result -> points[8].point.v_y = 0.2598;
result -> cyclic = true;
@
\fimcodigo

Se acaneta for quadrada, geramos seu formato verdadeiro preenchendo
manualmente seus pontos de extremidade e de controle:

\iniciocodigo
@<'makepath': 'pensquare'@>=
result -> length = 5;
result -> number_of_points = 5;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 5);
result -> points[0].format = FINAL_FORMAT;
result -> points[0].point.x = -0.5; result -> points[0].point.y = -0.5;
result -> points[0].point.u_x = (-0.5+(1.0/3.0));
result -> points[0].point.u_y = -0.5;
result -> points[0].point.v_x = (-0.5+(2.0/3.0));
result -> points[0].point.v_y = -0.5;
result -> points[1].format = FINAL_FORMAT;
result -> points[1].point.x = 0.5; result -> points[1].point.y = -0.5;
result -> points[1].point.u_x = 0.5;
result -> points[1].point.u_y = (-0.5+(1.0/3.0));
result -> points[1].point.v_x = 0.5;
result -> points[1].point.v_y = (-0.5+(2.0/3.0));
result -> points[2].format = FINAL_FORMAT;
result -> points[2].point.x = 0.5; result -> points[2].point.y = 0.5;
result -> points[2].point.u_x = (0.5-(1.0/3.0));
result -> points[2].point.u_y = 0.5;
result -> points[2].point.v_x = (0.5-(2.0/3.0));
result -> points[2].point.v_y = 0.5;
result -> points[3].format = FINAL_FORMAT;
result -> points[3].point.x = -0.5; result -> points[3].point.y = 0.5;
result -> points[3].point.u_x = -0.5;
result -> points[3].point.u_y = (0.5-(1.0/3.0));
result -> points[3].point.v_x = -0.5;
result -> points[3].point.v_y = (0.5-(2.0/3.0));
result -> points[4].format = FINAL_FORMAT;
result -> points[4].point.x = -0.5; result -> points[4].point.y = -0.5;
result -> points[4].point.u_x = (-0.5+(1.0/3.0));
result -> points[4].point.u_y = -0.5;
result -> points[4].point.v_x = (-0.5+(2.0/3.0));
result -> points[4].point.v_y = -0.5;
result -> cyclic = true;
@
\fimcodigo

Por fim, se estivermos diante de uma caneta com formato personalizado,
então nós já temos uma representação de seu formato na forma de um
caminho e nós só temos que copiá-la:

\iniciocodigo
@<'makepath': Formato Personalizado@>=
if(!recursive_copy_points(mf, cx, temporary_alloc, &result, tmp.format, false))
  return false;
if(temporary_free != NULL){
  temporary_free(tmp.format -> points);
  temporary_free(tmp.format);
}
@
\fimcodigo

E finalmente, uma vez que tenhamos o nosso caminho, devemos aplicar
todas as transformações de rotação, translação e demais transformações
lineares que estiverem registradas na matriz de transformação OpenGL:

\iniciocodigo
@<'makepath': Realiza Transformação Linear@>=
{
  int i;
  for(i = 0; i < result -> length; i ++){
    float x0 = result -> points[i].point.x, y0 = result -> points[i].point.y;
    result -> points[i].point.x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].point.y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].point.u_x;
    y0 = result -> points[i].point.u_y;
    result -> points[i].point.u_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].point.u_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].point.v_x;
    y0 = result -> points[i].point.v_y;
    result -> points[i].point.v_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].point.v_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
  }
}
@
\fimcodigo

\subsecao{8.6. Atribuições e Expressões de Imagens}

Para realizar a atribuição de imagens a variáveis do tipo certo,
usamos o código abaixo. O que ele faz é avaliar uma expressão de
imagem e coletar o resultado. Em seguida, ele precisa fazer com que
todas as variáveis da atribuição recebam uma cópia da imagem
avaliada. Se existe somente uma variável a ser atribuída, nós apenas
copiamos o identificador textura já obtida e desenhada na
avaliação. Se houver mais de uma variável, a primeira delas recebe uma
cópia direta do identificador da imagem já obtida. Para as demais,
precisaremos usar comandos OpenGL para copiar a textura avaliada para
o destino.

\iniciocodigo
@<Atribuição de Variável de Imagem@>=
else if(type == TYPE_T_PICTURE){
  int i;
  struct picture_variable result;
  if(!eval_picture_expression(mf, cx, begin_expression, *end, &result))
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    if(i == 0){
      struct picture_variable *pic = (struct picture_variable *) var -> var;
      if(pic -> texture != 0)
        glDeleteTextures(1, &(pic -> texture));
      pic -> width = result.width;
      pic -> height = result.height;
      pic -> texture = result.texture;
      pic -> type = TYPE_T_PICTURE;
      // Se atribuindo para 'currentpicture', precisamos de código adicional
      if(pic ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
        // O código abaixo será definido na Subseção 11.2:
        @<Gera nova 'currentpicture'@>
      }
    }
    else 
      assign_picture_variable(mf, (struct picture_variable *) var -> var,
                              &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }  
}
@
\fimcodigo

A função \monoespaco{assign\_picture\_variable} acima precisa gerar
uma nova textura na variável de destino (apagando a textura já
existente se for o caso) e copiar o conteúdo da textura de origem no
destino. Isso significa que nós precisaremos renderizar o conteúdo de
uma textura na outra.

Para renderizar algo, primeiro precisaremos de vértices. Como tudo que
vamos renderizar são sempre imagens e texturas retangulares, os únicos
vértices que precisaremos renderizar são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
const static float square[20] = {
  -1.0, -1.0, //Primeiro vértice
  0.0, 0.0, // Coordenada da textura
  1.0, -1.0, // Segundo vértice
  1.0, 0.0, // Textura
  1.0, 1.0, // Terceiro vértice
  1.0, 1.0, // Textura
  -1.0, 1.0, // Quarto vértice
  0.0, 1.0}; // Textura
static GLuint vbo; // OpenGL Vertex Buffer Object
@
\fimcodigo

Associamos acima a cada vértice uma coordenada de textura. Desta forma
conseguiremos enviar para a placa de vídeo ambas as informações de uma
só vez. Note que o que definimos acima é um quadrado de lado 2
centralizado na origem. Este é o tamanho padrão para que ele seja
renderizado em todo o espaço disponível nas convenções OpenGL. Nós
também definimos o quadrado definindo seus vértices no sentido
anti-horário, o que faz com que por convenção ele seja renderizado de
frente para a câmera. Isso é necessário para que o quadrado sempre
seja renderizado, mesmo que otimizações estejam ativas fazendo com que
o lado de trás dos polígonos não sejam desenhados.

Na inicialização do Weaver Metafont nós enviamos estes vértices para
a placa de vídeo:

\iniciocodigo
@<Inicialização WEAVEFONT@>=
glGenBuffers(1, &vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// Enviando os vértices para a placa de vídeo:
glBufferData(GL_ARRAY_BUFFER, sizeof(square), square, GL_STATIC_DRAW);
@
\fimcodigo

Na finalização nós removemos os vértices da placa de vídeo:

\iniciocodigo
@<Finalização WEAVEFONT@>=
glDeleteBuffers(1, &vbo);
@
\fimcodigo

Além de vértices, precisamos de um shader de vértice que nos indique
como renderizar tais vértices. O programa deve ser versátil o bastante
para receber como argumento uma matriz com transformações lineares a
serem aplicadas a cada vértice. Os atributos do programa são a
coordenada do vértice e da textura. O valor uniforme recebido é a
matriz para transformação linear. E o valor de retorno a ser passado para o shader de
fragmento é a posição final da coordenada depois da transformação,
além da coordenada de textura. 

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "varying highp vec2 texture_coordinate;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "  texture_coordinate = vertex_data.zw;\n"
  "}\n";
@
\fimcodigo

Já o código do shader de fragmento recebe a saída do shader de vértice
acima além de uma textura:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  gl_FragColor = texture2D(texture1, texture_coordinate);"
  "}\n";
static GLuint program; // Armazenará o programa após compilar os shaders acima
GLint uniform_matrix; // Armazenará a posição da matriz de modelo visualização acima
GLint uniform_texture; // A posição da variável de textura no código acima
@
\fimcodigo

Estes shaders simples precisam ser compilados na inicialização. Vamos
criar uma função auxiliar local para nos ajudar na compilação:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source);
@
\fimcodigo

Esta função irá retornar o identificador do programa compilado à
partir dos códigos-fontes dos shaders passados como argumento. Se algo
der errado, irá retornar zero.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source){
  GLuint vertex, fragment, prog;
  GLint status = GL_TRUE;
  // Criando shader de vértice e de fragmento
  vertex = glCreateShader(GL_VERTEX_SHADER);
  fragment = glCreateShader(GL_FRAGMENT_SHADER);
  // Passando o código-fonte a cada um deles
  glShaderSource(vertex, 1, &vertex_shader_source, NULL);
  glShaderSource(fragment, 1, &fragment_shader_source, NULL);
  // Compilando shader de vértice:
  glCompileShader(vertex);
  glGetShaderiv(vertex, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont vertex shader compilation failed!\n");
    return 0;
  }
  // Compilando shader de fragmento:
  glCompileShader(fragment);
  glGetShaderiv(fragment, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont fragment shader compilation failed!\n");
    return 0;
  }
  // Criando programa:
  prog = glCreateProgram();
  // Ligando o programa:
  glAttachShader(prog, vertex);
  glAttachShader(prog, fragment);
  glBindAttribLocation(prog, 0, "vertex_data");
  glLinkProgram(prog);
  glGetProgramiv(prog, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr, "ERROR: Weaver Metafont shader linking failed!\n");
    return 0;
  }
  // Finalização:
  glDeleteShader(vertex);
  glDeleteShader(fragment);
  return prog;
}
@
\fimcodigo

E podemos usar esta função para inicializar nosso programa de shader padrão:

\iniciocodigo
@<Inicialização WEAVEFONT@>+=
{
  program = compile_shader_program(vertex_shader, fragment_shader);
  uniform_matrix = glGetUniformLocation(program, "model_view_matrix");
  uniform_texture = glGetUniformLocation(program, "texture1");
}
@
\fimcodigo

Na finalização iremos destruir o programa compilado acima:

\iniciocodigo
@<Finalização WEAVEFONT@>+=
glDeleteProgram(program);
@
\fimcodigo

Para a parte de renderizar o conteúdo de uma textura para dentro de
outra, devemos criar um framebuffer com uma nova textura associada a
ele. A função abaixo cria tanto um novo framebuffer como uma nova
textura, deixando-os ligados e ativos. Tudo o que for renderizado em
seguida será renderizado na nova textura, e não na tela.

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height){
  glGenFramebuffers(1, new_framebuffer);
  glGenTextures(1, new_texture);
  glBindTexture(GL_TEXTURE_2D, *new_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
               GL_UNSIGNED_BYTE, NULL);
  glBindFramebuffer(GL_FRAMEBUFFER, *new_framebuffer);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                         *new_texture, 0);
  if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: OpenGL cannot create framebuffer!\n");
#endif
    glBindTexture(GL_TEXTURE_2D, 0);
    return false;
  }
  glBindTexture(GL_TEXTURE_2D, 0);
  return true;
}
@
\fimcodigo

Outro código que vamos usar muito e por isso é importante isolar em
uma função é para renderizar uma imagem usando o framebuffer atual e o
programa de shader padrão que fizemos:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background);
// XXX:
void print_picture(struct picture_variable *pic);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background){
  glColorMask(true, true, true, true);
  glViewport(0, 0, dst_width, dst_height);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *) 0);
  glEnableVertexAttribArray(0);
  glUseProgram(program);
  glUniformMatrix3fv(uniform_matrix, 1, true, matrix);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, pic -> texture);
  glUniform1i(uniform_texture, 0);
  if(clear_background){
    // Limpando o destino para branco transparente antes de renderizar:
    glClearColor(1.0, 1.0, 1.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
  }
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBindTexture(GL_TEXTURE_2D, 0);
}
// XXX:
void print_picture(struct picture_variable *pic){
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  GLuint framebuffer;
  GLuint texture;
  unsigned char data[100000];
  get_new_framebuffer(&framebuffer, &texture, pic -> width, pic -> height);
  render_picture(pic, model_view_matrix, pic -> width, pic -> height, true);
  // Ler dados do framebuffer:
  glFinish();
  glReadPixels(0, 0, pic -> width, pic -> height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    int i, j;
    for(i = pic -> width * (pic -> height - 1) * 4;
        i >= 0; i -= (pic -> width * 4)){
      for(j = 0; j < (pic -> width * 4); j += 4)
        printf("(%hu %hu %hu %hu)", (unsigned char) data[i + j], (unsigned char) data[i+j+1], (unsigned char) data[i+j+2], (unsigned char) data[i+j+3]);
        printf("\n");
    }
  }
}
@
\fimcodigo

Agora vamos declarar a função que atribui o conteúdo de uma variável
de imagem à outra, gerando uma nova textura e copiando o conteúdo das
texturas:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source){
  GLuint temporary_framebuffer;
  GLint previous_framebuffer;
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(target -> texture != 0)
    glDeleteTextures(1, &(target -> texture));
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(target -> texture),
                      source -> width, source -> height);
  render_picture(source, model_view_matrix, source -> width, source -> height, true);
  // Finalizando
  glBindTexture(GL_TEXTURE_2D, 0);
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  if(target ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
    // O código abaixo será definido na Subseção 11.2:
    @<Gera nova 'currentpicture'@>
  }
}
@
\fimcodigo

\subsubsecao{8.6.1. Expressões Terciárias de Imagem: Soma e Subtração}

A operação terciária de imagem é a soma e a subtração:

\alinhaverbatim
<Expressão de Imagem> -> <Terciário de Imagem>
<Terciário de Imagem> -> <Terciário de Imagem><Mais ou Menos><Secundário de Imagem>
<Mais ou Menos> -> + | -
\alinhanormal

Imagens então podem ser somadas ou subtraídas. O resultado de
$p_1+p_2$ representa uma nova imagem composta por todos os pixels da
primeira imagem mais os pixels da segunda imagem. Já $p_1-p_2$ são os
pixels da primeira menos os pixels da segunda.  A imagem resultante
sempre terá a largura igual ao maior valor em ambas as imagens e terá
a altura igual ao maior valor em ambas as imagens. A soma dos seus
pixels sempre ocorrerá com ambas as imagens centralizadas uma na
outra.

A função que avalia expressões terciárias de imagem:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct picture_variable *result);
@
\fimcodigo

A implementação da função consiste em identificar o operador $+$ ou o
operador $-$ que estiver mais ao fim da expressão. Se ele não existe,
então devemos avaliar tudo como uma expressão secundária. Se ele
existe, o lado à esquerda dele será avaliado como expressão terciária
e o lado à direita como expressão secundária. E só então fazemos a
soma ou subtração.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct picture_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_SUM || p -> type == TYPE_SUBTRACT) &&
       prev -> type != TYPE_SUM && prev -> type != TYPE_SUBTRACT){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL || before_last_operator == NULL){
    struct picture_variable a;
    struct picture_variable *sec = &a;
    @<Imagem: Avalia Expressão Secundária em 'sec'@>
    return true;
  }
  else{
    struct picture_variable a, b;
    struct picture_variable *sec = &b;
    if(last_operator == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Incomplete picture expression "
                      "ending with '+' or '-'.\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_picture_expression(mf, cx, begin_expression, before_last_operator, &a))
      return false;
    @<Imagem: Avalia Expressão Secundária em 'sec'@>
    @<Expressão de Imagem: Soma ou Subtração@>
    if(a.texture != 0)
      glDeleteTextures(1, &(a.texture));
    if(b.texture != 0)
      glDeleteTextures(1, &(b.texture));
    return true;
  }
}
@
\fimcodigo

Para somar ou subtrair as imagens, devemos primeiro obter qual deve
ser o tamanho da imagem de destino. Ela terá a maior altura e maior
largura dentre as imagens sendo somadas. Em seguida, a criamos e a
inicializamos como sendo uma imagem transparente. Tanto na soma como
na subtração, desenhamos o primeiro operando no destino. Em seguida,
dependendo se estamos realizando soma ou subtração, usamos o OpenGL
para ajustar como as cores serão misturadas. No caso da soma,
ajustamos para que seja feita uma mistura de cores de modo que a nova
cor $(y_R, y_G, y_B, y_A)$ seja multiplicada pelo seu valor alfa e
somada à cor de destino $(x_R, x_G, x_B, x_A)$ multiplicada pelo
complemento do alfa da nova cor:

$$(1-y_A)(x_R, x_G, x_B, x_A) + y_A(y_R, y_G, y_B, y_A)$$

O caso da subtração é mais complexo e para entendê-la, devemos
entender as regras de como representamos nossas texturas com
imagens. Por padrão, assumimos que uma imagem inicializada vazia com
um dado tamanho é toda preenchida por uma cor branca totalmente
transparente (representada pelo vetor RGBA $(1, 1, 1, 0)$). Já quando
escrevemos algo em uma imagem usando canetas ou outro método, usamos
uma tinta preta totalmente opaca (representada pelo vetor RGBA $(0, 0,
0, 1)$). Para nós a cor branca é o zero, a ausência de tinta e a cor
preta é a presença de tinta. O branco é o elemento neutro da
subtração, remover o branco não deve mudar nada. Já remover o preto
remove toda a tinta. Isso é o oposto da representação do branco como 1
e o preto como 0 usada no OpenGL. Por causa disso, a equação de quando
subtraímos uma cor existente $(x_R, x_G, x_B, x_A)$ por uma nova cor
$(y_R, y_G, y_B, y_A)$ é:

$$
(max(x_R, 1-y_R), max(x_G, 1-y_G), max(x_B, 1-y_B), x_A-y_A)
$$

Infelizmente não é possível expressar a equação acima usando apenas o
recurso de ajuste da equação de combinação de cores. O OpenGL ES 3.0 e
OpenGL 4 suporta o uso da função $max$, mas quando a usa, ele ignora
os fatores configurados. O que significa que é possível calcular
$max(x_R, y_R)$, mas não $max(x_R, 1- y_R)$. Essa inversão precisa ser
feita então a nível de shader. O shader de fragmento que inverte uma
cor deixando o alfa intacto é:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char fragment_shader_inverse[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  vec4 texture = texture2D(texture1, texture_coordinate);\n"
  "  gl_FragColor = vec4(1.0 - texture.r, 1.0 - texture.g, 1.0 - texture.b, \n"
  "                      texture.a);\n"
  "}\n";
static GLuint inv_program; // O programa acima compilado
static GLint uniform_inv_texture; // A posição da textura acima
static GLint uniform_inv_matrix; // A posição da matriz do programa acima
@
\fimcodigo

Um novo programa de shader deve ser então compilado na inicialização
para podermos inverter os valores RGB de imagens:

\iniciocodigo
@<Inicialização WEAVEFONT@>+=
{
  inv_program = compile_shader_program(vertex_shader, fragment_shader_inverse);
  uniform_inv_matrix = glGetUniformLocation(inv_program, "model_view_matrix");
  uniform_inv_texture = glGetUniformLocation(inv_program, "texture1");
}
@
\fimcodigo

E na finalização nós destruimos este programa:

\iniciocodigo
@<Finalização WEAVEFONT@>+=
glDeleteProgram(inv_program);
@
\fimcodigo

E usando esse novo programa shader para ajudar a inverter valores RGB,
podemos enfim computar a equação de mistura de cores no caso da
subtração:

\iniciocodigo
@<Expressão de Imagem: Soma ou Subtração@>=
// Alocando e declarando dados, gerando imagem vazia inicial
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
result -> width = ((a.width >= b.width)?(a.width):(b.width));
result -> height = ((a.height >= b.height)?(a.height):(b.height));
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Renderizando imagem 'a'
model_view_matrix[0] = (double) a.width / (double) result -> width;
model_view_matrix[4] = (double) a.height / (double) result -> height;
render_picture(&a, model_view_matrix, result -> width, result -> height, true);
// Renderizando imagem 'b'
model_view_matrix[0] = (double) b.width / (double) result -> width;
model_view_matrix[4] = (double) b.height / (double) result -> height;
if(last_operator -> type == TYPE_SUBTRACT){
  glEnable(GL_BLEND);
  // Os fatores a serem usados na mistura
  glBlendFunc(GL_ONE, GL_ONE);
  // Função 'max' para RGB e subtração para o canal alfa:
  glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  glUseProgram(inv_program);
  glUniformMatrix3fv(uniform_inv_matrix, 1, true, model_view_matrix);
  glUniform1i(uniform_inv_texture, 0);
  glBindTexture(GL_TEXTURE_2D, b.texture);
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBlendEquation(GL_FUNC_ADD);
  glDisable(GL_BLEND);
}
else{ // Soma
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glBlendEquation(GL_FUNC_ADD);
  render_picture(&b, model_view_matrix, result -> width, result -> height, false);
  glDisable(GL_BLEND);
}
// Finalizando
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glBindTexture(GL_TEXTURE_2D, 0);
glDeleteFramebuffers(1, &temporary_framebuffer);
@
\fimcodigo

\subsubsecao{8.6.2. Expressões Secundárias de Imagem: Transformadores}

Uma expressão secundária de imagem tem a seguinte sintaxe:

\alinhaverbatim
<Secundário de Imagem> -> <Primário de Imagem> |
                          <Secundário de Imagem><Transformador>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> |
                   transformed <Primário de Transformação>
\alinhanormal

Os mesmos transformadores que podem ser usados em pares,
transformações, caminhos e canetas podem também ser usados em
imagens. Mas o modo como transformamos as imagens é diferente. Assim
como canetas, as transformações lineares sobre imagens são armazenadas
na forma de uma matriz que acumula todas as transformações. Desta
forma, podemos realizar as transformações de uma só vez somente depois
que o usuário especificar todas as que serão necessárias. Mas ao
contrário de canetas, as variáveis de imagem não possuem uma matriz
própria armazenada na variável.

As matrizes são recursos que irão existir somente enquanto estivermos
avaliando expressões secundárias de imagem. E serão efetivamente
usadas para transformar a imagem somente ao terminarmos a avaliação de
uma expressão tercisária. Desta forma, no código abaixo:

\alinhaverbatim
a = img totated 45 slanted 0.2 zscaled(2, 3)
\alinhanormal

Ao invés de realizarmos três transformações diferentes, nós apenas
acumularemos as transformações em uma matriz. Já quando não houver
mais transformação e estivermos terminando de interpretar a expressão
terciária, é quando usaremos a matriz para efetivamente transformar a
imagem em sua forma final. Isso significa que a função que avaliará as
expressões secundárias de imagem deverá ser diferente das demais. Ela
irá receber dois argumentos adicionais: uma matriz pré-inicializada
como a matriz identidade e um ponteiro para uma variável booleana
pré-inicializada como falso. Esta variável será mudada para verdadeira
somente se a matriz passada for modificada.

\iniciocodigo
@<Imagem: Avalia Expressão Secundária em 'sec'@>=
{
  float matrix[9];
  bool modified = false;
  INITIALIZE_IDENTITY_MATRIX(matrix);
  if(last_operator == NULL){
     if(!eval_picture_secondary(mf, cx, begin_expression, end_expression, sec,
                             matrix, &modified))
      return false;
  }
  else if(!eval_picture_secondary(mf, cx, last_operator -> next,
                                  end_expression, sec, matrix, &modified))
    return false;
  if(modified){
    if(!apply_image_transformation(mf, result, sec, matrix))
      return false;
    if(sec -> texture != 0)
      glDeleteTextures(1, &(sec -> texture));
  }
  else{
    result -> width = sec -> width;
    result -> height = sec -> height;
    result -> texture = sec -> texture;
  }
}
@
\fimcodigo

A declaração da função que avalia expressões secundárias de imagem é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct picture_variable *result,
                            float *matrix, bool *modified);
@
\fimcodigo

E a sua implementação consiste primeiramente em percorrermos toda a
expressão até achar o último token com um operador secundário de
transformação. Se não achamos nada, é só avaliar tudo como expressão
primária. Se achamos um, avaliamos tudo antes dele como expressão
secundária e aplicamos a transformação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct picture_variable *result,
                            float *matrix, bool *modified){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_picture_primary(mf, cx, begin_expression, end_expression, result);
  else{
    if(!eval_picture_secondary(mf, cx, begin_expression,
                               before_last_transformer, result, matrix, modified))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Secundário de Imagem: Rotação@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Secundário de Imagem: Escala@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Secundário de Imagem: Deslocamento@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Secundário de Imagem: Inclinação@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Secundário de Imagem: X-Escala@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Secundário de Imagem: Y-Escala@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Secundário de Imagem: Z-Escala@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Secundário de Imagem: Transformação Genérica@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Avaliar cada um dos diferentes tipos de transformadores significa
modificar a matriz multiplicando ela pela matriz que representa a
transformação. Exatamente como fizemos com as canetas. Conforme
descrito por código da Subseção X.Y.

Esta é a mudança de escala:

\iniciocodigo
@<Secundário de Imagem: Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

Este é o código que realiza a rotação:

\iniciocodigo
@<Secundário de Imagem: Rotação@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(matrix, rotation);
*modified = true;
return true;
@
\fimcodigo

O código que desloca a imagem uma coordenada $(x, y)$ segue
abaixo. Para imagens, nós representamos o deslocamento em pixels,
então antes de aplicá-lo à matriz, devemos convertê-lo para
coordenadas OpenGL que dependem do tamanho da imagem:

\iniciocodigo
@<Secundário de Imagem: Deslocamento@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
p.x = 2.0 * (p.x / result -> width);
p.y = 2.0 * (p.y / result -> height);
TRANSFORM_SHIFT(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

O código que inclina uma imagem:

\iniciocodigo
@<Secundário de Imagem: Inclinação@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

O código que muda a escala somente no eixo $x$:

\iniciocodigo
@<Secundário de Imagem: X-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

O código que muda a escala somente no eixo $y$:

\iniciocodigo
@<Secundário de Imagem: Y-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

Mudança de escala usando o plano complexo e multiplicaçãop por número
complexo:

\iniciocodigo
@<Secundário de Imagem: Z-Escala@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

Finalmente, a transformação genérica que aplica a transformação linear
armazenada em um transformador:

\iniciocodigo
@<Secundário de Imagem: Transformação Genérica@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression,
                           &t))
  return false;
MATRIX_MULTIPLICATION(matrix, t.value);
*modified = true;
return true;
@
\fimcodigo

Agora resta definir como iremos aplicar as transformações lineares
sobre uma imagem uma vez que tenhamos a matriz, a variável de imagem
de origem e a de destino. Isso é feito com ajuda da seguinte função
auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix);
@
\fimcodigo

Aplicar a transformação da imagem envolve usar a matriz de
transformação obtida para transformar a imagem de origem gerando assim
a nova imagem de destino. Para isso aplicamos as seguintes etapas:

1) Devemos descobrir qual deve ser o tamanho em pixels da imagem de
destino. Para isso, multiplicamos as coordenadas da origem pela
matriz. Mas neste caso, medidmos tais coordenadas por pixels, não
pelas coordenadas OpenGL. Se a imagem de origem é um quadrado de 5
pixels de lado, um de seus vértices será $(-5/2, -5/2)$ e outro será
$(5/2, 5/2)$. O resultado da transformação serão as coordenadas dos
vértices medidos por pixels, à partir das quais obtemos o tamanho em
pixels. Nesta etapa, podemos ignorar a translação presente na matriz.

2) Para levar em conta a translação, devemos somar o dobro da
distância em píxels da translação ao tamanho da imagem. Lembre-se que a
translação não muda o centro da imagem. Então, ao deslocar $(1, 1)$
uma imagem com um píxel preto $1\times 1$, geramos nova imagem de
$3\times 3$ com o píxel preto no canto. O centro da imagem continua
sendo a posição em que o píxel preto estava antes do deslocamento.

3) A mudança de tamanho do desenho da imagem original será obtida
simplesmente renderizando o desenho transformado em uma imagem de
destino ou menor. Então devemos remover da matriz de transformação a
mudança de tamanho e escala que estiver presente. Também devemos
ajustar levando em conta isso qualquer translação sendo feita. Isso é
feito aplicando um valor calculado de correção para as posições $x$ e
$y$ da matriz.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix){
  int i;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  // Para calcular o tamanho final da imagem, armazenaremos as maiores e
  // menores coordenadas que encontrarmos nas extremidades da imagem
  // nos dois eixos após aplicar a matriz de transformação. (Etapa 1)
  float min_x = INFINITY, min_y = INFINITY, max_x = -INFINITY, max_y = -INFINITY;
  float origin_coordinates[8];
  origin_coordinates[0] = -((float) origin -> width) / 2.0;
  origin_coordinates[1] = -((float) origin -> height) / 2.0;
  origin_coordinates[2] = ((float) origin -> width) / 2.0;
  origin_coordinates[3] = -((float) origin -> height) / 2.0;
  origin_coordinates[4] = ((float) origin -> width) / 2.0;
  origin_coordinates[5] = ((float) origin -> height) / 2.0;
  origin_coordinates[6] = -((float) origin -> width) / 2.0;
  origin_coordinates[7] = ((float) origin -> height) / 2.0;
  for(i = 0; i < 8; i += 2){
    float x = LINEAR_TRANSFORM_X(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    float y = LINEAR_TRANSFORM_Y(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    if(x > max_x) max_x = x;
    if(x < min_x) min_x = x;
    if(y > max_y) max_y = y;
    if(y < min_y) min_y = y;
  }
  // Ajuste de tamanho da imagem final devido ao deslocamento (Etapa 2)
  dst -> width = (int) (max_x - min_x) +
                 (int) (origin -> width * matrix[6]);
  dst -> height = (int) (max_y - min_y) +
                  (int) (origin -> height * matrix[7]);
  // Ajustando escala e translação da imagem final levando em conta novo tamanho
  // do destino (Etapa 3):
  {
    double x_correction = ((double) origin -> width) / (double) dst -> width;
    double y_correction = ((double) origin -> height) / (double) dst -> height;
    matrix[0] = matrix[0] * x_correction;
    matrix[3] = matrix[3] * x_correction;
    matrix[6] = matrix[6] * x_correction;
    matrix[1] = matrix[1] * y_correction;
    matrix[4] = matrix[4] * y_correction;
    matrix[7] = matrix[7] * y_correction;
  }
  // Gerando textura inicial, framebuffer
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(dst -> texture), dst -> width,
                    dst -> height);
  // Renderizando:
  render_picture(origin, matrix, dst -> width, dst -> height, true);
  // Finalização
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.3. Expressões Primárias: Inversores, Identidade e
Imagens Vazias}

Segundo a gramática da linguagem, a sintaxe para expressões primárias
de imagens é:

\alinhaverbatim
<Primário de Imagem> -> <Variável de Imagem> |
                        nullpicture <Primário de Par> |
                        ( <Expressão de Imagem> ) |
                        <Mais ou Menos> <Primário de Imagem> |
                        subpicture <Primário de Par> and <Primário de Par> of
                                   <Primário de Imagem>
\alinhanormal

Isso requer registrar ``nullpicture'' e ``subpicture'' como um token:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_NULLPICTURE,        // O token simbólico 'nullpicture'
TYPE_SUBPICTURE,         // O token simbólico 'subpicture'
@
\fimcodigo

E requer que essas strings seja adicionada à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"nullpicture", "subpicture",
@
\fimcodigo

A função que irá interpretar expressões primárias de imagem é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct picture_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct picture_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Imagem Primária: Variável@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Imagem Primária: Parênteses@>
    }
    else if(begin_expression -> type == TYPE_NULLPICTURE){
      @<Imagem Primária: Imagem em Branco@>
    }
    else if(begin_expression -> type == TYPE_SUM){
      @<Imagem Primária: Identidade@>
    }
    else if(begin_expression -> type == TYPE_SUBTRACT){
      @<Imagem Primária: Inverso@>
    }
    else if(begin_expression -> type == TYPE_SUBPICTURE){
      @<Imagem Primária: Subimagem@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O primeiro caso de expressão primária de imagem é ler uma imagem de
uma variável. Isso envolve copiar o conteúdo da variável armazenada no
resultado da avaliação.

\iniciocodigo
@<Imagem Primária: Variável@>=
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct picture_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PICTURE){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-picture variable (%d) in "
                  "picture expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
// Preparar renderização:
result -> width = content -> width;
result -> height = content -> height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Renderiza:
render_picture(content, identity_matrix, result -> width, result -> height, true);
// Finaliza:
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

Lidar com os parênteses envolve percorrer os tokens até encontrar o
último token antes do fechar de parênteses. E avaliar como uma nova
expressão de imagem tudo aquilo que estiver entre o parênteses inicial
e o final:

\iniciocodigo
@<Imagem Primária: Parênteses@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_picture_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

A próxima expressão primária é a criação de uma imagem em branco com
um dado tamanho. Isso ocorre quando lemos um
token \monoespaco{nullpicture} seguido de um par primário. Criar a
imagem vazia envolve primeiro interpretar o par primário que contém o
seu tamanho e em seguida criar uma textura vazia com tal tamanho.

\iniciocodigo
@<Imagem Primária: Imagem em Branco@>=
struct generic_token *begin_pair_expression, *end_pair_expression;
struct pair_variable p;
unsigned char *data;
begin_pair_expression = begin_expression -> next;
end_pair_expression = end_expression;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing pair expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_primary(mf, cx, begin_pair_expression, end_pair_expression, &p))
  return false;
result -> width = p.x;
result -> height = p.y;
data = temporary_alloc(p.x * p.y * 4);
if(data == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
  return false;
}
// Pintando a nova textura de branco
memset(data, 255, result -> width * result -> height * 4);
{ // E deixando ela totalmente transparente:
  int i, size = result -> width * result -> height * 4;
  for(i = 3; i < size; i += 4)
    data[i] = 0;
}
glGenTextures(1, &(result -> texture));
glBindTexture(GL_TEXTURE_2D, result -> texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, result -> width, result -> height, 0,
             GL_RGBA, GL_UNSIGNED_BYTE, data);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glBindTexture(GL_TEXTURE_2D, 0);
if(temporary_free != NULL)
  temporary_free(data);
return true;
@
\fimcodigo

E agora o antepenúltimo caso de imagem primária: quando vem um
token \monoespaco{+} antes de uma imagem. Neste caso o operador não faz
nada, é um operador de identidade para imagens. Então só precisamos
ignorar ele e avaliar os tokens restantes:

\iniciocodigo
@<Imagem Primária: Identidade@>=
struct generic_token *p = begin_expression -> next;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing image expression "
                  "after '+'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
return eval_picture_primary(mf, cx, p, end_expression, result);
@
\fimcodigo

Para o operador \monoespaco{-} que é usado para inverter uma imagem,
nós iremos novamente renderizar ativando a equação de mistura de
cores, mas fazendo com que a nova cor seja obtida usando $(1, 1, 1,
1)$ como a cor atural e subtraindo disso a nova cor. Isso é obtido
tratando os fatores de mistura como 1 (GL\_ONE) e usando a subtração
como operador (GL\_FUNC\_SUBTRACT):


\iniciocodigo
@<Imagem Primária: Inverso@>=
struct picture_variable p;
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                  "'-'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_picture_primary(mf, cx, begin_expression -> next, end_expression, &p))
  return false;
// Preparar renderização:
result -> width = p.width;
result -> height = p.height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Inicializar nova textura com branco opaco (1, 1, 1, 1)
glClearColor(1.0, 1.0, 1.0, 1.0);
glClear(GL_COLOR_BUFFER_BIT);
// Ajustar equação de mistura pra subtrair ela do branco opaco:
glEnable(GL_BLEND);
glBlendFuncSeparate(GL_ONE, GL_ONE, GL_ONE, GL_ONE);
glBlendEquationSeparate(GL_FUNC_REVERSE_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT);
// Renderiza:
render_picture(&p, identity_matrix, result -> width, result -> height, false);
// Finaliza:
glDisable(GL_BLEND);
glDeleteTextures(1, &(p.texture));
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

FInalmente, a expressão primária de computar sub-imagens. Esta
expressão começa com um token \monoespaco{subpicture}, recebe um par
primário (o offset em pixels), um token \monoespaco{and}, um segundo
par (com o tamanho da sub-imagem a ser extraída), o
token \monoespaco{of} e uma expressão primária de imagem (de onde a
sub-imagem deve ser extraída).

A primeira parte da avaliação desta expressão envolve extrair os pares
e a imagem das subexpressões. A segunda parte é executar o comando de
gerar uma sub-imagem:

\iniciocodigo
@<Imagem Primária: Subimagem@>=
struct pair_variable pair_offset, subpicture_size;
struct picture_variable original_picture;
@<Subimagem: Extrai Subexpressões@>
@<Subimagem: Extrai Subimagem@>
return false;
@
\fimcodigo

Extrair as subexpressões envolve delimitar o começo e fim de cada uma
delas. Para isso percorremos a expressão como um todo buscando pelos
tokens de auxílio \monoespaco{of} e \monoespaco{and}. Armazenamos
também um estado para saber quantas subexpressões já delimitamos. Isso
nos ajuda a detectar se temos uma expressão mal-formada onde os tokens
de auxílio aparecem, mas na ordem errada ou sem expressões entre eles:

\iniciocodigo
@<Subimagem: Extrai Subexpressões@>=
{
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_pair1 = NULL, *end_pair1 = NULL,
                       *begin_pair2 = NULL, *end_pair2 = NULL,
                       *begin_pic = NULL, *end_pic = NULL,
                       *p = begin_expression -> next,
                       *last_token = begin_expression;
  int state = 0;
  begin_pair1 = p;
  while(p != end_expression && p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p -> type == TYPE_AND){
      if(state != 0 || last_token -> type == TYPE_SUBPICTURE){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair1 = last_token;
      state ++;
      begin_pair2 = p -> next;
    }
    else if(IS_NOT_NESTED() && p -> type == TYPE_OF){
      if(state != 1 || last_token -> type == TYPE_AND){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair2 = last_token;
      state ++;
      begin_pic = p -> next;
    }
    last_token = p;
    p = p -> next;
  }
  if(p == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
            mf -> file, p -> line);
#endif
    return false;
  }
  end_pic = p;
  if(!eval_pair_primary(mf, cx, begin_pair1, end_pair1, &pair_offset))
    return false;
  if(!eval_pair_primary(mf, cx, begin_pair2, end_pair2, &subpicture_size))
    return false;
  if(!eval_picture_primary(mf, cx, begin_pic, end_pic, &original_picture))
    return false;
}
@
\fimcodigo

Extrair a sub-imagem requer gerar uma nova textura com o tamanho
indicado pelo segundo par e renderizar a imagem lida nesta nova
textura, de acordo com as informações presentes nos pares sobre
tamanho e offset:

\iniciocodigo
@<Subimagem: Extrai Subimagem@>=
{
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  float render_matrix[9];
  INITIALIZE_IDENTITY_MATRIX(render_matrix);
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                      subpicture_size.x, subpicture_size.y);
  result -> width = subpicture_size.x;
  result -> height = subpicture_size.y;
  // Inicializar nova textura com branco transparente (1, 1, 1, 0)
  glClearColor(1.0, 1.0, 1.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT);
  // Ajustando tamanho da renderização na textura
  render_matrix[0] = original_picture.width / subpicture_size.x;
  render_matrix[4] = original_picture.height / subpicture_size.y;
  // Passando o offset para a matriz de renderização
  render_matrix[6] = -2.0 * (pair_offset.x +
                      0.5 * (subpicture_size.x - original_picture.width)) /
                      subpicture_size.x;
  render_matrix[7] = -2.0 * (pair_offset.y +
                      0.5 * (subpicture_size.y - original_picture.height)) /
                      subpicture_size.y;
  // Renderiza:
  render_picture(&original_picture, render_matrix, result -> width, result -> height,
                 false);
  
  // Finaliza:
  glDisable(GL_BLEND);
  glDeleteTextures(1, &(original_picture.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.4. Imagens em Expressões Numéricas}

Há casos nos quais precisamos avaliar uma expressão de imagem dentro
de uma expressão numérica. Há três expressões primárias numéricas
adicionais onde devemos avaliar uma imagem:

\alinhaverbatim
<Primário Numérico> -> totalweight <Primário de Imagem> |
                       width <Primário de Imagem> |
                       height <Primário de Imagem>
\alinhanormal

Os dois últimos operadores apenas retornam respectivamente a largura e
altura da imagem. Já o operador \monoespaco{totalweight} avalia
uma expressão de imagem, lê a imagem obtida e retorna a soma do
``peso'' de cada pixel. O peso de um pixel branco transparente deve
ser zero e o de um pixel preto opaco deve ser 1. Já para calcular
valores intermediários, converteremos um pixel colorido para um tom de
cinza. Para isso obteremos uma média ponderada entre os valores entre
0 e 1 deles, dando um peso maior para o verde e menor para o
azul. Isso porque a visão humana é mais sensível ao verde que ao
azul. O resultado desta média sera o peso do píxel colorido. Depois de
obter o valor, multiplicamos pela transparência.

Primeiro vamos adicionar novos tipos de tokens para esses operadores:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_TOTALWEIGHT,        // O token simbólico 'totalweight'
TYPE_WIDTH,              // O token simbólico 'width'
TYPE_HEIGHT,             // O token simbólico 'height'
@
\fimcodigo

E adicionamos seus nomes à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"totalweight", "width", "height",
@
\fimcodigo

Para o primeiro operador, o modo pelo qual iremos obter os pixels de
uma textura será renderizando ela para um framebuffer e lendo
usando \monoespaco{glReadPixels} para obter o conteúdo do framebuffer:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin -> type == TYPE_TOTALWEIGHT){
  struct picture_variable p;
  char *data;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  GLuint temporary_texture = 0;
  float identity_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(begin == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'totalweight'.\n", mf -> file, begin -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, begin -> next, end, &p))
    return false;
  data = temporary_alloc(p.width * p.height * 4);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Not enough memory!\n", mf -> file);
#endif
    return false;
  }
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(temporary_texture),
                    p.width, p.height);
  // Renderiza:
  render_picture(&p, identity_matrix, p.width, p.height, true);
  // Ler dados do framebuffer:
  glReadPixels(0, 0, p.width, p.height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    //printf("--WEIGHT---\n");
    int i, size = p.width * p.height * 4;
    double sum = 0.0;
    for(i = 0; i < size; i += 4){
      //if(i%(4*p.width) == 0) printf("\n");
      //printf("(%d %d %d %d)", (unsigned char) data[i], (unsigned char) data[i+1], (unsigned char) data[i+2], (unsigned char) data[i+3]);
      // If the values are equal, let's avoid rounding errors:
      if(data[i] == data[i+1] && data[i+1] == data[i+2]){
        sum += ((255 - (unsigned char) data[i]) / 255.0) *
               (((unsigned char) data[i+3]) / 255.0);
      }
      else{
        double r = ((255 - (unsigned char) data[i]) / 255.0) * 0.2989,
               g = ((255 - (unsigned char) data[i+1]) / 255.0) * 0.5870,
               b = ((255 - (unsigned char) data[i+2]) / 255.0) * 0.1140,
               a = ((unsigned char) data[i+3]) / 255.0;
        sum += ((r+g+b) * a);
      }
    }
    result -> value = sum;
  }
  // Finalização:
  if(temporary_free != NULL)
    temporary_free(data);
  glDeleteTextures(1, &temporary_texture);
  glDeleteTextures(1, &(p.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

Para os operadores \monoespaco{width} e \monoespaco{height}, tudo é
mais simples. Basta obter a imagem e retornar respectivamente a
largura e altura. No caso da largura:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin -> type == TYPE_WIDTH){
  struct picture_variable p;
  if(begin == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'width'.\n", mf -> file, begin -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) p.width;
  return true;
}
@
\fimcodigo

E no caso da altura:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin -> type == TYPE_HEIGHT){
  struct picture_variable p;
  if(begin == end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'height'.\n", mf -> file, begin -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, begin -> next, end, &p))
    return false;
  result -> value = (float) p.height;
  return true;
}
@
\fimcodigo


\subsecao{8.7. Atribuições e Expressões Booleanas}

Como em todos os outros tipos de atribuições e expressões, começamos
definindo o código que faz a atribuição de variáveis após avaliar a
expressão:

\iniciocodigo
@<Atribuição de Variável Booleana@>=
else if(type == TYPE_T_BOOLEAN){
  int i;
  bool ret;
  struct boolean_variable result;
  ret = eval_boolean_expression(mf, cx, begin_expression, *end, &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin;
  for(i = 0; i < number_of_variables; i ++){
    ((struct boolean_variable *) var -> var) -> value = result.value;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Podendo atribuir o resultado de expressões às variáveis, vamos agora à
parte de escrever código para avaliar as expressões booleanas.

\subsubsecao{8.7.1. Comparações}

Comparações são feitas usando relações. Elas permitem avaliar se duas
variáveis ou expressões nos dão o mesmo resultado, um resultado
diferente, bem como avaliar a relação de ordem entre seus
resultados. As regras gramaticais para comparar valores são:

\alinhaverbatim
<Expressão Booleana> -> <Terciário Booleano> |
                        <Expressão Numérica> <Relação> <Terciário Numérico> |
                        <Expressão de Par> <Relação> <Terciário de Par>     |
                        <Expressão Booleana> <Relação> <Terciário Booleano> |
                        <Expressão de Transformação> <Relação>
                                           <Terciário de Transformação>
<Relação> -> < | <= | > | >= | = | <>
\alinhanormal

Isso significa que as comparações usando estas relações são expressões
quarternárias. Elas tem uma precedência ainda menor que as expressões
terciárias booleanas. Para outros tipos de expressão, nós consideramos
uma expressão terciária como sendo sinônimo para a expressão daquele
tipo. Mas para expressões booleanas, expressões terciárias são um tipo
interno das expressões mais gerais.

As relações mostradas acima requerem que novos tipos de tokens sejam
considerados:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_LT,                    // O token simbólico '<'
TYPE_LEQ,                   // O token simbólico '<='
TYPE_GT,                    // O token simbólico '>'
TYPE_GEQ,                   // O token simbólico '>='
TYPE_NEQ,                   // O token simbólico '<>'
@
\fimcodigo

E adicionamos seus nomes à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"<", "<=", ">", ">=", "<>",
@
\fimcodigo

A declaração da função que avaliará expressões booleanas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct boolean_variable *result);
@
\fimcodigo

Esta função deverá checar se temos um dos operadores de relações
booleanas. Se não tivermos, a expressão deve ser avaliada como
terciária. Se tivermos, devemos identificar a relação mais à direita e
avaliar ela após avaliar as duas outras sub-expressões. Mas antes de
fazer isso, precisamos saber qual o tipo destas expressões. Para isso,
vamos assumir que temos uma função que dada uma expressão terciária,
retorna seu tipo. Ela será
chamada \monoespaco{get\_tertiary\_expression\_type}. Iremos definir
ela na Subseção 8.8. Mas por hora, vamos simplesmente assumir que ela
existe.

A implementação desta função é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_LT || p -> type == TYPE_LEQ ||
        p -> type == TYPE_GT || p -> type == TYPE_GEQ ||
        p -> type == TYPE_NEQ || p -> type == TYPE_EQUAL)){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_tertiary(mf, cx, begin_expression, end_expression,
                                 result);
  else{
    int type;
    if(before_last_operator == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Relational operator without "
                      "l-value.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    type = get_tertiary_expression_type(mf, cx,  last_operator -> next,
                                        end_expression);
    switch(type){
    case TYPE_T_NUMERIC:
    {
      struct numeric_variable a, b;
      if(!eval_numeric_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_numeric_expression(mf, cx, last_operator -> next,
                                  end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_EQUAL:
        result -> value = a.value == b.value;
        return true;
      case TYPE_NEQ:
        result -> value = a.value != b.value;
        return true;
      }
      break;
    }
    case TYPE_T_PAIR:
    {
      struct pair_variable a, b;
      if(!eval_pair_expression(mf, cx, begin_expression,
                               before_last_operator, &a))
        return false;
      if(!eval_pair_expression(mf, cx, last_operator -> next,
                               end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y < b.y);
        return true;
      case TYPE_LEQ:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y <= b.y);
        return true;
      case TYPE_GT:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_GEQ:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_EQUAL:
        result -> value = (a.x == b.x && a.y == b.y);
        return true;
      case TYPE_NEQ:
        result -> value = (a.x != b.x || a.y != b.y);
        return true;
      }
      break;
    }
    case TYPE_T_TRANSFORM:
    {
      struct transform_variable a, b;
      int i, order[6] = {6, 7, 0, 3, 1, 4};
      if(!eval_transform_expression(mf, cx, begin_expression,
                                    before_last_operator, &a))
        return false;
      if(!eval_transform_expression(mf, cx, last_operator -> next,
                                    end_expression, &b))
        return false;
      switch(last_operator -> type){
        case TYPE_LT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] < b.value[order[i]]);
          return true;
        case TYPE_LEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] <= b.value[order[i]]);
          return true;
        case TYPE_GT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] > b.value[order[i]]);
          return true;
        case TYPE_GEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] >= b.value[order[i]]);
          return true;
        case TYPE_EQUAL:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = false;
              return true;
            }
          result -> value = (a.value[order[i]] == b.value[order[i]]);
          return true;
        case TYPE_NEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = true;
              return true;
            }
          result -> value = (a.value[order[i]] != b.value[order[i]]);
          return true;
      }          
      break;
    }
    case TYPE_T_BOOLEAN:
    {
      struct boolean_variable a, b;
      a.value = b.value = -1;
      if(!eval_boolean_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_boolean_tertiary(mf, cx, last_operator -> next,
                                end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_EQUAL:
        result -> value = (a.value == b.value);
        return true;
      case TYPE_NEQ:
        result -> value = (a.value != b.value);
        return true;
      }
      break;
    }
    default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression after boolean operator.\n",  mf -> file,
              begin_expression -> line);
#endif
      return false;
    }
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.2. A Operação OR}

O operador booleano OR é a única operação booleana terciária. A
gramática das expressões booleanas terciárias é:

\alinhaverbatim
<Terciário Booleano> -> <Terciário Booleano> or <Secundário Booleano> |
                        <Secundário Booleano>
\alinhanormal

Para implementarmos esta expressão, precisamos então
definir \monoespaco{or} como um novo tipo de token simbólico:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_OR,                    // O token simbólico 'or'
@
\fimcodigo

O qual deve ser adicionado à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"or",
@
\fimcodigo

A declaração da função que tratará expressões terciárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result);
@
\fimcodigo

E a implementação desta função segue o modelo esperado. Ela percorre a
lista de tokens até achar o último \monoespaco{or} não-aninhado em
parênteses e outros delimitadores e aplica o operador sobre o
resultado das subexpressões que o cercam. Se não existir um
operador \monoespaco{or}, toda a expressão é tradada como uma
expressão secundária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_OR){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_secondary(mf, cx, begin_expression, end_expression,
                                  result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_secondary(mf, cx, begin_expression,
                               before_last_operator, &a))
      return false;
    if(!eval_boolean_tertiary(mf, cx, last_operator -> next,
                              end_expression, &b))
      return false;
    result -> value =  (a.value || b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.3. A Operação AND}

O operador booleano AND é a única operação booleana secundária. A
gramática das expressões booleanas secundárias é:

\alinhaverbatim
<Secundário Booleano> -> <Secundário Booleano> and <Primário Booleano> |
                         <Primário Booleano>
\alinhanormal

O token \monoespaco{and} já foi definido previamente. Ele é também
usado para descrever caminhos, quando há dois pontos de controle
diferentes em uma curva.

A declaração da função que tratará expressões secundárias booleanas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result);
@
\fimcodigo

E a implementação desta função é praticamente igual ao do operador OR,
apenas mudando qual operador estamos procurando e a operação que
aplicamos sobre o resultado das subexpressões que delimitam o AND. E,
caso não haja um operador AND não-aninhado na expressão, nós tratamos
ela inteira como uma expressão booleana primária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_AND){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_primary(mf, cx, begin_expression, end_expression,
                                result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_secondary(mf, cx, begin_expression,
                               before_last_operator, &a))
      return false;
    if(!eval_boolean_primary(mf, cx, last_operator -> next,
                             end_expression, &b))
      return false;
    result -> value = (a.value && b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.4. Expressões Primárias Booleanas: Literais e Predicados Simples}

A gramática das expressões primárias booleanas é:

\alinhaverbatim
<Primário Booleano> -> <Variável Booleana> | true | false |
                       cycle <Caminho Primário> | odd <Primário Numérico> |
                       not <Primário Booleano> |
                       ( <Expressão Booleana> )
\alinhanormal

A maioria destas expressões é auto-explictiva. Uma variável booleana é
avaliada para seja qual for o seu valor armazenado. Os
valores \monoespaco{true} e \monoespaco{false} representam verdadeiro
e falso. O \monoespaco{not} é o operador NOT de negação. Parênteses
podem ser usados para mudar a ordem de avaliação de operadores. O
token \monoespaco{odd} serve para checar se o número à seguir é ímpar
após arredondá-lo para o inteiro mais próximo. E \monoespaco{cycle}
serve para checar se um caminho é cíclico ou não.

Os seguintes novos tipos de token não foram ainda definidos:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_TRUE,                    // O token simbólico 'true'
TYPE_FALSE,                   // O token simbólico 'false'
TYPE_ODD,                     // O token simbólico 'odd'
TYPE_NOT,                     // O token simbólico 'not'
@
\fimcodigo

E o nome de cada um deles deve ser adicionado à lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"true", "false", "odd", "not",
@
\fimcodigo

A função que avaliará expressões booleanas primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result);
@
\fimcodigo

No caso de expressões booleanas primárias, é perfeitamente possível
identificar qual regra gramatical seguir após observar o primeiro
token encontrado. Então a função apenas observa o primeiro token, e
depois disso ela decide o que fazer:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result){
  switch(begin_expression -> type){
    case TYPE_SYMBOLIC: // Variável
      struct boolean_variable *var;
      var = ((struct symbolic_token *) begin_expression) -> var;
      if(var -> value == -1){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
                "'%s'.\n", mf -> file, begin_expression -> line,
                ((struct symbolic_token *) begin_expression) -> value);
#endif
        return false;
      }
      result -> value = var -> value;
      return true;
    break;
    case TYPE_TRUE: // Verdadeiro
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        return false;
      }
      result -> value = 1;
      return true;
    break;
    case TYPE_FALSE: // Falso
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        return false;
      }
      result -> value = 0;
      return true;
    break;
    case TYPE_CYCLE: // 'cycle'
      struct path_variable path;
      if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                            &path))
        return false;
      result -> value = path.cyclic;
      if(temporary_free != NULL)
        path_recursive_free(temporary_free, &path, false);
      return true;
    break;
    case TYPE_ODD: // 'odd'
      struct numeric_variable num;
      if(!eval_numeric_primary(mf, cx, begin_expression -> next, end_expression,
                               &num))
        return false;
      result -> value = (((int) round(num.value)) % 2);
      return true;
    break;
    case TYPE_NOT: // 'not'
      struct boolean_variable b;
      if(!eval_boolean_primary(mf, cx, begin_expression -> next, end_expression,
                              &b))
        return false;
      result -> value = !(b.value);
      return true;
    break;
    case TYPE_OPEN_PARENTHESIS: // '('
      if(end_expression -> type != TYPE_CLOSE_PARENTHESIS){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
        return false;
      }
      struct generic_token *last_token = begin_expression;
      while(last_token -> next != end_expression)
        last_token = last_token -> next;
      return eval_boolean_expression(mf, cx, begin_expression -> next,
                                     last_token, result);
    break;
    default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

\subsecao{8.8. Identificando Tipos de Expressões}

Muitas vezes temos uma expressão e devemos identificar qual o tipo da
expressão para tratá-la corretamente. Por exemplo, quando temos uma
expressão booleana comparando qual valor é maior, o que estamos
comparando pode ser uma expressão numérica, de par, de transformação
ou outra expressão booleana. Em uma expressão numérica, podemos usar o
operador \monoespaco{length} sobre outros números ou sobre pares. Uma
multiplicação pode ser entre números ou entre um escalar e um
vetor. Os operadores \monoespaco{xpart} funcionam tanto em pares como
em transformadores.

Note que nenhuma das vezes em que precisamos identificar o tipo de uma
expressão espera-se que encontremos um caminho, imagem ou uma caneta. Por
causa disso, vamos ignorar esses tipos nas nossas funções.

Identificar o tipo de uma expressão pode ser complexo e
trabalhoso. Felizmente, os casos mais comuns tentem a ser simples e
serão avaliados rapidamente. De qualquer forma, vamos usar funções
diferentes para poder identificar expressões primárias, secundárias e
terciárias:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr);
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr);
@
\fimcodigo

Para identificar expressões primárias, primeiro podemos tratar os
casos mais simples (a expressão é composta por um único token) e
depois lidar com os casos mais complexos. As regras que nos permitem
identificar são:

1) Uma variável é uma expressão com o tipo da variável.

2) São expressões booleanas as que tem como único
token \monoespaco{true} ou \monoespaco{false}. Ou que começam
com \monoespaco{cycle}, \monoespaco{odd} e
\monoespaco{not}.

3) São expressões de pares os que começam
com \monoespaco{point}, \monoespaco{precontrol}
e \monoespaco{postcontrol}. Ou se dentro da expressão tivermos
um \monoespaco{[}. E também algo que começa com token numérico e tem
parênteses ou o começo de um primário de par um pouco depois
(\monoespaco{-3(8, 4)}).

4) É expressão numérica um único token numérico, o
token \monoespaco{normaldeviate}, um token numérico seguido
por \monoespaco{/} e toda expressão que começa
com \monoespaco{length}, \monoespaco{xpart}, \monoespaco{ypart}, \monoespaco{xxpart},
\monoespaco{xypart}, \monoespaco{yxpart}, \monoespaco{yypart}, \monoespaco{angle},
\monoespaco{sqrt}, \monoespaco{sind}, \monoespaco{cosd}, \monoespaco{log},
\monoespaco{mexp}, \monoespaco{floor}, \monoespaco{uniformdeviate}.

5) Se temos um \monoespaco{+} ou \monoespaco{-}, descobrimos o tipo
avaliando o tipo do restante da expressão.

6) Se temos parênteses e dentro deles temos uma vírgula, é um par. Se
houverem mais vírgulas, é uma transformação. Se não houverem vírgulas,
devemos avaliar o tipo da expressão terciária interna.

7) Nos demais casos, o tipo é desconhecido e um erro deve ter ocorrido.

Na nossa implementação, para testar mais rapidamente, primeiro
checamos se temos ou não um caso simples composto por um único
token. Todos os casos acima são tratados separadamente de acordo com
isso:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_SYMBOLIC){ // Caso 1
      struct variable *var = (struct variable *)
                               ((struct symbolic_token *) begin_expr) -> var;
      return var -> type;
    }
    if(begin_expr -> type == TYPE_TRUE || begin_expr -> type == TYPE_FALSE ||
       begin_expr -> type == TYPE_NOT) // Caso 2
      return TYPE_T_BOOLEAN;
    if(begin_expr -> type == TYPE_NUMERIC ||
       begin_expr -> type == TYPE_NORMALDEVIATE) // Caso 4
      return TYPE_T_NUMERIC;
    else
      return -1;
  }
  else{
    if(begin_expr -> type == TYPE_CYCLE || begin_expr -> type == TYPE_ODD ||
       begin_expr -> type == TYPE_NOT) // Caso 2
      return TYPE_T_BOOLEAN;
    // Expressão de par (caso 3):
    if(begin_expr -> type == TYPE_POINT ||
       begin_expr -> type == TYPE_PRECONTROL ||
       begin_expr -> type == TYPE_POSTCONTROL ||
       begin_expr -> type == TYPE_BOT || begin_expr -> type == TYPE_TOP ||
       begin_expr -> type == TYPE_LFT || begin_expr -> type == TYPE_RT)
      return TYPE_T_PAIR;    
    // Expressão numérica (Caso 4):
    if(begin_expr -> type == TYPE_LENGTH || begin_expr -> type == TYPE_XPART ||
       begin_expr -> type == TYPE_YPART || begin_expr -> type == TYPE_ANGLE ||
       begin_expr -> type == TYPE_XXPART || begin_expr -> type == TYPE_FLOOR ||
       begin_expr -> type == TYPE_XYPART || begin_expr -> type == TYPE_SIND ||
       begin_expr -> type == TYPE_YXPART || begin_expr -> type == TYPE_SQRT ||
       begin_expr -> type == TYPE_YYPART || begin_expr -> type == TYPE_LOG ||
       begin_expr -> type == TYPE_COSD ||   begin_expr -> type == TYPE_EXP ||
       begin_expr -> type == TYPE_UNIFORMDEVIATE) // Caso 4
      return TYPE_T_NUMERIC;
    // Caso 5:
    if(begin_expr -> type == TYPE_SUM || begin_expr -> type == TYPE_SUBTRACT)
      return get_primary_expression_type(mf, cx, begin_expr -> next, end_expr);
    // Token numérico, pode ser expressão numérica ou de par:
    if(begin_expr -> type == TYPE_NUMERIC){
      struct generic_token *t = begin_expr;
      while(t != NULL && t != end_expr){
        if(t -> type == TYPE_OPEN_BRACKETS || t -> type == TYPE_PRECONTROL ||
           t -> type == TYPE_OPEN_PARENTHESIS || t -> type == TYPE_POINT ||
           t -> type == TYPE_POSTCONTROL)
          return TYPE_T_PAIR;
        t = t -> next;
      }
      return TYPE_T_NUMERIC;
    }
    // Pode haver expressão de par que começa com parênteses e não termina:
    // (1+1)[p1, p2] e também: normaldeviate[p1, p2]
    if((begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
        end_expr -> type != TYPE_CLOSE_PARENTHESIS) ||
       begin_expr -> type == TYPE_NORMALDEVIATE)
      return TYPE_T_PAIR;
    if(begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
       end_expr -> type == TYPE_CLOSE_PARENTHESIS &&
       begin_expr -> next != end_expr){
      DECLARE_NESTING_CONTROL();
      int number_of_commas = 0;
      struct generic_token *t = begin_expr -> next;
      while(t != NULL && t -> next != end_expr){
        COUNT_NESTING(t);
        if(IS_NOT_NESTED() && t -> type == TYPE_COMMA)
          number_of_commas ++;
        t = t -> next;
      }
      if(number_of_commas == 0)
        return get_tertiary_expression_type(mf, cx, begin_expr -> next, t);
      else if(number_of_commas == 1)
        return TYPE_T_PAIR;
      else if(number_of_commas == 5)
        return TYPE_T_TRANSFORM;
    }
    return -1;
  }
}
@
\fimcodigo

Agora vamos às expressões secundárias. As regras que usaremos são:

1) Se temos um único token, avaliamos tudo como expressão primária.

2) Se temos \monoespaco{and}, a expressão é booleana.

3) Se temos um transformador (\monoespaco{transformed}, \monoespaco{rotated},
\monoespaco{scaled}, \monoespaco{shifted}, \monoespaco{slanted},
\monoespaco{xscaled}, \monoespaco{yscaled}, \monoespaco{zscaled}), ignoramos
ele e o que há depois dele, voltando a avaliar o restante da expressão
como expressão secundária. Pode ser um transformador ou um par.

4) Se temos multiplicações e divisões, devemos checar a que está mais
à direita. Se um dos operandos for um par, é um par. Caso contrário, é
expressão numérica. Lembrando que a regra para a divisão é um pouco
complexa. Um token \monoespaco{/} só é divisão quando não é delimitada
por dois tokens numéricos. Neste caso, temos uma fração, não uma
divisão, e não há aí um operador secundário. A exceção é quando o
token anterior já faz parte de uma fração. Assim, 1/3 é fração ao
invésd e divisão, e não há nenhum operador secundário aí. Já 1/3/1/3
contém um operador secundário de divisão, dividindo duas frações de
1/3.

5) Nos demais casos, não pudemos identificar e o tipo deve ser
avaliado como se a expressão fôsse primária.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  struct generic_token *last_fraction = NULL;
  struct generic_token *before_last_op = NULL, *prev_prev = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_AND)
        return TYPE_T_BOOLEAN;
      if(t -> type == TYPE_TRANSFORMED || t -> type == TYPE_ROTATED ||
         t -> type == TYPE_SCALED || t -> type == TYPE_SHIFTED ||
         t -> type == TYPE_SLANTED || t -> type == TYPE_XSCALED ||
         t -> type == TYPE_YSCALED || t -> type == TYPE_ZSCALED){
        if(prev == NULL)
          return -1;
        return get_secondary_expression_type(mf, cx, begin_expr, prev);
      }
      if(t -> type == TYPE_MULTIPLICATION || t -> type == TYPE_DIVISION){
        if(t -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
           t != end_expr &&
           ((struct generic_token *) t -> next) -> type != TYPE_NUMERIC &&
           last_fraction != prev_prev)
          last_fraction = t;
        else{
          last_op = t;
          before_last_op = prev;
        }
      }
    }
    prev_prev = prev;
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL){
    int s = get_primary_expression_type(mf, cx, last_op -> next, end_expr) +
            get_secondary_expression_type(mf, cx, begin_expr, before_last_op);
    if(s == 2 * TYPE_T_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(s == TYPE_T_NUMERIC + TYPE_T_PAIR)
      return TYPE_T_PAIR;
    else return -1;
  }
  else return get_primary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

Por fim, as expressões terciárias. Neste caso, as regras seguidas são:

1) Se temos um único token, avaliamos tudo como expressão primária.

2) Se temos um \monoespaco{or} ou uma relação
(\monoespaco{<}, \monoespaco{<=}, \monoespaco{>}, \monoespaco{>=},
\monoespaco{=}, \monoespaco{<>}), então é uma expressão booleana. Tecnicamente as
relações não são expressões terciárias. A ordem de precedência delas
seria de expressões quarternárias. Mas podemos considerar todos esses
operadores aqui, já que não estamos de fato avaliando as expressões,
onde seguir regras de precedência é fundamental.

3) Se temos soma e subtração pitagóricos
(\monoespaco{++}, \monoespaco{+-+}), então é expressão numérica.

4) Se temos soma ou subtração, o tipo da expressão é o mesmo de
qualquer um de seus operandos.

5) Nos demais casos, tentamos novamente avaliando a expressão como
secundária.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_OR || t -> type == TYPE_LT ||
           t -> type == TYPE_GT || t -> type == TYPE_GEQ ||
           t -> type == TYPE_LEQ || t -> type == TYPE_EQUAL ||
           t -> type == TYPE_NEQ){
        return TYPE_T_BOOLEAN;
      }
      if(t -> type == TYPE_PYTHAGOREAN_SUM ||
         t -> type == TYPE_PYTHAGOREAN_SUBTRACT){
        return TYPE_T_NUMERIC;
      }
      if(IS_VALID_SUM_OR_SUB(prev, t) && t != end_expr)
        last_op = t;
    }
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL)
    return get_secondary_expression_type(mf, cx, last_op -> next, end_expr);
  else return get_secondary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

\secao{9. Declaração Composta: Declaração Condicional}

Uma declaração condicional é um \monoespaco{if}, uma estrutura que
garante que certos trechos de código sejam executados somente se
certas condições forem verdadeiras. A gramática completa para
expressões deste tipo é:

\alinhaverbatim
<Bloco Condicional> -> if <Expressão Booleana> :
                         <Lista de Instruções>
                         <Alternativas>
                       fi
<Alternativas> -> <Vazio> |
                  elseif <Expressão Booleana>:
                    <Lista de Instruções>
                  <Alternativas> |
                  else: <Lista de Instruções>
\alinhanormal

Declararemos então os seguintes novos tipos de tokens:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_ELSEIF,  // O token simbólico 'elseif'
TYPE_ELSE,    // O token simbólico 'else'
TYPE_COLON,   // O token simbólico ':'
@
\fimcodigo

Os quais devem ser adicionados à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"elseif", "else", ":",
@
\fimcodigo

Na Seção 6 nós vimos a primeira das declarações compostas. A que
começa com \monoespaco{begingroup} e termina
com \monoespaco{endgroup}. A declaração condicional
usando \monoespaco{if} também é uma declaração composta do tipo, que
contém dentro de si várias outras declarações.

Lembre-se que código é primeiro avaliado na
função \monoespaco{eval\_list\_of\_statement}, qe separa o código
usando ponto-e-vírgula como delimitador e passa para a
função \monoespaco{eval\_statement} tratar cada parte. Esta função
deve interpretar o código que recebe, mas tem também a liberdade de
mudar a posição do ponteiro que delimita o fim da expressão que
avaliou, o qual é usado para depois escolher os próximos tokens a
serem lidos. É nessa segunda função que o código que trata
um \monoespaco{if} é localizado.

Assim como no caso do \monoespaco{begingroup} da Seção 6,
quando encontramos tokens a serem avaliados que começam
com \monoespaco{if}, o que fazemos é iniciar um novo nível de
aninhamento e depois disso corrigimos a posição do ponteiro do último
token avaliado para que os próximos tokens a serem avaliados sejam os
corretos. Mas aqui, para determinar a posição do ponteiro do próximo
token temos que executar uma lógica mais complexa, avaliando
expressões booleanas.

Basicamente, diante de um \monoespaco{if}, primeiro avaliamos a
expressão booleana diante dele. Se ela for verdadeira, posicionamos o
ponteiro para o próximo dois pontos (``:'') encontrado. Se não, então
percorremos os próximos tokens tentando encontrar o
próximo \monoespaco{elseif} ou \monoespaco{else}. No caso de
um \monoespaco{elseif}, novamente avaliamos sua expressão booleana
para saber se devemos colocar o ponteiro diante do código de seu
corpo. Já no caso de um \monoespaco{else}, sempre devemos colocar o
ponteiro diante de seu corpo. E se não encontrarmos nem
um \monoespaco{else}, e nem um \monoespaco{elseif} onde a expressão
booleana é verdadeira, então pulamos a declaração condicional,
colocando o ponteiro de fim no \monoespaco{fi}.

Entretanto, mesmo o código que iremos ignorar por estar dentro de um
bloco condicional que não deve ser executado, deve passar por um
mínimo de checagem para que erros de sintaxe não sejam ignorados. Por
exemplo, pode haver um \monoespaco{endgroup} ou \monoespaco{endchar}
solto, sem que qualquer uma destas declarações compostas tenha sido
iniciada com um \monoespaco{begingroup} ou \monoespaco{beginchar}
correspondente. Esse tipo de erro pode ser um sintoma de que
o \monoespaco{if} foi finalizado incorretamente e por isso não devemos
ignorar tais erros. À medida que percorremos código que não deve ser
executado por corresponder à uma expressão falsa de um \monoespaco{if}
ou \monoespaco{elseif}, devemos fazer uma checagem ao passarmos por
tokens que aumentam ou diminuem o nível de aninhamento para garantir
que eles estão corretos.

O código que trata então um \monoespaco{if} é:

\iniciocodigo
@<Instrução: Composta@>+=
else if(begin -> type == TYPE_IF){
  struct generic_token *begin_bool, *end_bool;
  struct boolean_variable b;
  int current_nesting_level;
  // Iniciando o aninhamento
  begin_nesting_level(mf, cx, begin);
  current_nesting_level = cx -> nesting_level;
  // Delimitando a expressão booleana
  begin_bool = begin -> next;
  end_bool = begin_bool;
  while(end_bool != *end && end_bool -> next -> type != TYPE_COLON)
    end_bool = end_bool -> next;
  if(end_bool == *end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Error delimiting boolean "
                    "condition.\n", mf -> file, end_bool -> line);
#endif
    return false;
  }
  // Avaliando a expressão booleana:
  if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
    return false;
  if(b.value == 1){ // Verdadeiro: código no 'if' deve ser avaliado
    *end = end_bool -> next;
    return true;
  }
  else{ // Falso: pulamos o código no 'if'
    struct generic_token *t = end_bool -> next;
    while(t -> next != NULL){
      if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
        // Achamos o 'fi' correspondente ao nosso 'if'
        if(!end_nesting_level(mf, cx, t))
          return false;
        *end = t;
        return true;
      }
      else if(t -> type == TYPE_ELSE &&
              cx -> nesting_level == current_nesting_level){
        // Achamos o 'else' correspondente ao nosso 'if'
        *end = t -> next;
        if((*end) -> type != TYPE_COLON){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Expected ':' after "
                  "'else'.\n", mf -> file,
                  (*end) -> line);
#endif
          return false;
        }
        return true;
      }
      else if(t -> type == TYPE_ELSEIF &&
              cx -> nesting_level == current_nesting_level){
        // Achamos um 'elseif' correspondente ao nosos 'if'
        begin_bool = t -> next;
        end_bool = begin_bool;
        while(end_bool != *end && end_bool -> next -> type != TYPE_COLON)
          end_bool = end_bool -> next;
        if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
          return false;
        if(b.value == 1){ // Verdadeiro: código no 'elseif' deve ser avaliado
          *end = end_bool -> next;
          return true;
        }
      }
      // Outros tokens que mudam nível de aninhamento
      else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
              t -> type == TYPE_BEGINCHAR)
        begin_nesting_level(mf, cx, t);
      else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
              t -> type == TYPE_ENDCHAR)
        if(!end_nesting_level(mf, cx, t))
          return false;
      t = t -> next;
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'if' statement.\n", mf -> file,
          begin -> line);
#endif  
  return false;
}
@
\fimcodigo

A responsabilidade de encontrar o código certo a ser executado é do
trecho acima que trata o \monoespaco{if}. Mas nós podemos também
encontrar um \monoespaco{elseif} ou um \monoespaco{else} no começo de
uma declaração a ser avaliada. Quando isso ocorre, ou indica que é um
erro de sintaxe, quando um destes tokens está solto, sem
um \monoespaco{if} correspondenteo, ou então significa que estamos
dentro de um \monoespaco{if}, onde já terminamos de executar o código
correto e encontramos um delimitador onde novas expressões booleanas
podems ser testadas. Independente da expressão que estiver lá, nós já
terminamos de executar o nosso \monoespaco{if}. Então devemos ignorar
tudo que vem a seguir até achar o \monoespaco{fi} que encerra
o \monoespaco{if} em que estamos:

\iniciocodigo
@<Instrução: Composta@>+= 
else if(begin -> type == TYPE_ELSEIF || begin -> type == TYPE_ELSE){
  int current_nesting_level;
  struct generic_token *t;
  if(cx -> end_token_stack == NULL ||
     cx -> end_token_stack -> type != TYPE_FI){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Token 'elseif' or 'else' should "
          "have a corresponding 'if'.\n", mf -> file,
          begin -> line);
#endif  
    return false;
  }
  current_nesting_level = cx -> nesting_level;
  t = begin;
  while(t != NULL){
    if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
      // Achamos o 'fi' correspondente ao nosso 'if'
      if(!end_nesting_level(mf, cx, t))
        return false;
      *end = t;
      return true;
    }
    else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
            t -> type == TYPE_BEGINCHAR)
      begin_nesting_level(mf, cx, t);
    else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
            t -> type == TYPE_ENDCHAR)
      if(!end_nesting_level(mf, cx, t))
        return false;
    t = t -> next;
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'else' or 'elseif' statement.\n", mf -> file,
          begin -> line);
#endif
  return false;
}
@
\fimcodigo

Finalmente, nós podemos também encontrar um \monoespaco{fi} no começo
de declaração a ser avaliada. Neste caso, nós apenas diminuimos o
nível de aninhamento e marcamos o fim do que avaliamos para o próprio
token \monoespaco{fi}:

\iniciocodigo
@<Instrução: Composta@>+=
else if(begin -> type == TYPE_FI){
  if(!end_nesting_level(mf, cx, begin))
    return false;
  *end = begin;
  return true;
}
@
\fimcodigo

\secao{10. O Comando \monoespaco{pickup}}

Agora podemos começar a definir o nosso primeiro comando. A sintaxe do
comando \monoespaco{pickup} é dada por:

\alinhaverbatim
<Comando> -> <Comando 'pickup'>
<Comando 'pickup'> -> pickup <Variável de Caneta, 'nullpen' ou 'pencircle'>
                             <Transformadores Opcionais>
<Variável de Caneta ou 'nullpen'> -> nullpen | pencircle | <Variável de Caneta>
<Transformadores Opcionais> -> <Vazio> |
                               <Transformador> <Transformadores Opcionais>
\alinhanormal

O comando requer que criemos um novo token e palavra reservada:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_PICKUP,   // O token simbólico 'pickup'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"pickup",
@
\fimcodigo

O que este comando faz é armazenar um novo valor na
variável \monoespaco{currentpen}, a qual usaremos para fazer desenhos
(conforme definiremos na próxima Seção).

\subsecao{10.1. Pontos de Extremidade de Caneta}

Uma coisa que devemos fazer ao recebermos uma caneta com o
comando \monoespaco{pickup} é armazenar 4 valores internamente. Dois
deles para armazenar o menor e maior valor na coordenada $x$ que esta
caneta gera ao ser renderizada e também o menor e maior valor na
coordenada $y$. Armazenar tais valores será útil para que possamos
ajustar melhor os pontos que vamos desenhar. Por exemplo, podemos
querer desenhar com a caneta o mais próximo possível do canto inferior
esquerdo da imagem, sem que a caneta saia para fora da imagem. Tal
tipo de controle requer que saibamos o tamanho da caneta. Por isso
vamos ter que armazenar internamente os
valores \monoespaco{pen\_lft}, \monoespaco{pen\_rt}, \monoespaco{pen\_top}
e \monoespaco{pen\_bot}. Como estes valores são sempre referentes
à \monoespaco{currentpen}, uma variável com escopo global, vamos
armazenar ela no \monoespaco{struct metafont}:

\iniciocodigo
@<Atributos (struct metafont)@>+=
float pen_lft, pen_rt, pen_top, pen_bot;
@
\fimcodigo

Estes valores são inicializados como zero porque
a \monoespaco{currentpen} começa como uma \monoespaco{nullpen}:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> pen_lft = mf -> pen_rt = mf -> pen_top = mf -> pen_bot = 0.0;
@
\fimcodigo

Uma operação muito comum que faremos nesta Seção será, ao gerar novos
vértices que irão compor o formato da caneta, verificar se geramos um
ponto mais à esquerda que \monoespaco{pen\_lft}, mais à direita
que \monoespaco{pen\_rt}, acima de \monoespaco{pen\_top} ou abaixo
de \monoespaco{pen\_bot}. Em tais casos devemos atualizar a informação
sobre os pontos de extremidade da caneta.

Para reduzir o tamanho do código, a macro abaixo vai representar o
código no qual declaramos as variáveis que armazenam a coordenada mais
à esquerda, direito, acima ou abaixo de um vértice que geramos:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define DECLARE_PEN_EXTREMITIES() float _max_x = -INFINITY, _min_x = INFINITY,\
                                  _max_y = -INFINITY, _min_y = INFINITY;
@
\fimcodigo

Diante de um novo ponto, vamos usar a macro abaixo para obter sua
coordenada $(x, y)$, multiplicar por uma amtriz de transformação e
assim checar se temos algo que deve ser armazenado como um dos menores
ou maiores pontos da caneta no eixo $x$ ou eixo $y$:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define CHECK_PEN_EXTREMITIES(x, y, matrix) {\
   float _x, _y;\
   _x = LINEAR_TRANSFORM_X(x, y, matrix);\
   _y = LINEAR_TRANSFORM_Y(x, y, matrix);\
   if(_x < _min_x) _min_x = _x;\
   if(_x > _max_x) _max_x = _x;\
   if(_y < _min_y) _min_y = _y;\
   if(_y > _max_y) _max_y = _y;\
  }
// Se a matriz é a identidade, podemos usar esta macro:
#define CHECK_PEN_EXTREMITIES_I(x, y) {\
   if(x < _min_x) _min_x = x;\
   if(x > _max_x) _max_x = x;\
   if(y < _min_y) _min_y = y;\
   if(y > _max_y) _max_y = y;\
  }
@
\fimcodigo

Depois de checarmos todos os pontos de uma caneta, podemos então
atualizar seus pontos de extremidade:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define UPDATE_PEN_EXTREMITIES() {\
  mf -> pen_lft = _min_x;\
  mf -> pen_rt = _max_x;\
  mf -> pen_top = _max_y;\
  mf -> pen_bot = _min_y;\
}
@
\fimcodigo

As macros anteriores presumem que iremos iterar sobre cada um dos
pontos que compõe o perímetro de uma caneta. Fazendo isso, podemos
chamar \monoespaco{CHECK\_PEN\_EXTREMITIES} em todos os pontos e assim
obtemos os que forem maiores no eixo $x$ e $y$. Nos casos em que não
queremos iterar sobre todos os pontos, vamos criar também algumas
funções para deduzi-los para nós. Por exemplo, caso tenhamos usado o
comando \monoespaco{pickup} sobre \monoespaco{pencircle} e a nossa
caneta tenha passado por uma transformação linear representada por uma
matriz. A função abaixo pode ser usada para obter os pontos de
extremidade para esta caneta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix);
@
\fimcodigo

Um \monoespaco{pencircle} padrão, sem senhuma transformação é uma
caneta circular de raio $1/2$. O que quer dizer que toda coordenada
$(x,y)$ atende à seguinte fórmula:

$$
x^2+y^2= 0.25
$$

Ou, de maneira equivalente:

$$
x=\pm\sqrt{0.25-y^2}
$$

$$
y=\pm\sqrt{0.25-x^2}
$$

Dada uma transformação linear definida pela matriz $M$, obtemos os novos
valores de $x$ e $y$ seguindo a fórmula abaixo:

$$
f_x(x) = M_{11}x \pm M_{21}\sqrt{0.25-x^2} + M_{31}
$$

$$
f_y(y) = M_{22}y \pm M_{12}\sqrt{0.25-y^2} + M_{32}
$$

Quando $M_{11}$ é igual à 0, os pontos mais extremos no eixo $x$ serão
a transformação linear dada por $M$ de $(-0.5, 0)$ e $(0.5, 0)$. Se
$M_{21}$ for igual à zero, os pontos mais extremos serão dados por
$(0, -0.5)$ e $(0, 0.5)$ transformados por $M$. A mesma lógica se
aplica aos extremos no eixo $y$ quando $M_{22}$ ou $M_{12}$ é igual à
zero. Em todos estes casos, o valor depende somente de maximizar ou a
coordenada $x$ ou $y$.

Para todos os demais casos, achar o ponto de máximo ou de mínimo
destas funções requer calcular a derivada das fórmulas acima e
igualamos à zero:

$$
f_x'(x)=M_{11} \pm (M_{21}x)/(\sqrt{0.25-x^2})=0
$$

$$
f_y'(y)=M_{22} \pm (M_{12}y)/(\sqrt{0.25-y^2})=0
$$

Como não há uma fórmula que nos dê a solução de maneira direta, temos
que usar métodos iterativos como o Método de Newton. para achar os
valores $x$ e $y$ que tornam as fórmulas acima corretas. Para poder
usar o médodo de Newton, começamos calculando a derivada de segunda
ordem destas fórmulas:

$$
f_x''(x)= \pm (M_{21}\sqrt{0.25-x^2}+(M_{21}x^2)/(\sqrt{0.25-x^2}))
$$

$$
f_y''(y)= \pm (M_{12}\sqrt{0.25-x^2}+(M_{12}x^2)/(\sqrt{0.25-x^2}))
$$

Pelo Método de Newton, uma vez que tenhamos uma estimativa $x_n$ e
$y_n$ para o zero da função $f'_x$ e $f'_y$, podemos obter uma
estimativa melhor calculando:

$$
x_{n+1} = x_{n} - (f'_x(x_n)/f''_x(x_n))
$$

$$
y_{n+1} = y_{n} - (f'_y(y_n)/f''_y(y_n))
$$

O problema do Método de Newton é que como nossa função $f_x$ e $f_y$
está definida somente entre -0,5 e +0,5, se o valor que estamos
buscando estiver muito próximo destas extremidades, ele pode acabar
nos empurrando para fora do Domínio da função. Caso isso ocorra,
teremos que recorrer a outro método. No caso, usaremos o mais lento
Método da Bissecção. Note que $f'_x(-0,5)$ e $f'_x(+0,5)$ tem sinais
opostos sempre, assumindo que um zero da função exista. Sendo assim,
este método começa com este intervalo e depois checa o sinal de $f_x$
no meiio das duas extremidades. Baseado no sinal ele reduz o tamanho
do intervalo até reduzi-lo à zero e encontrar o valor.

Após revisar toda a teoria, podemos enfim implementar a função que
obtém os pontos de extremidade de uma caneta redonda:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix){
  DECLARE_PEN_EXTREMITIES();
  int i, index[4] = {0, 3, 4, 1};
  for(i = 0; i < 2; i ++){ // i=0 computa eixo x, i=1 computa eixo y
    // Primeiro os casos mais simples:
    if((i == 0 && matrix[3] == 0.0) ||
       (i == 1 && matrix[4] == 0.0)){
      CHECK_PEN_EXTREMITIES(-0.5, 0.0, matrix);
      CHECK_PEN_EXTREMITIES(0.5, 0.0, matrix);
    }
    else if((i == 0 && matrix[0] == 0.0) ||
            (i == 1 && matrix[1] == 0.0)){
      CHECK_PEN_EXTREMITIES(0.0, 0.5, matrix);
      CHECK_PEN_EXTREMITIES(0.0, -0.5, matrix);
    }
    else{
      // Método de newton
      float x0 = INFINITY, x1 = 0.0;
      do{
        x0 = x1;
        x1 = x0 - ((matrix[index[2*i]]+(matrix[index[2*i+1]]*
                  x0/sqrt(0.25-x0*x0))) /
             (matrix[index[2*i+1]]*sqrt(0.25-x0*x0)+
                  ((matrix[index[2*i+1]]*x0*x0)/
             (sqrt(0.25-x0*x0)))));
        if(x1 <= -0.5 || x1 >= 0.5){
          // Convergência falhou, usar método da Bissecção
          float y1;
          x0 = -0.5;
          x1 = 0.5;
          y1 = matrix[3-i*2] * sqrt(0.25-x1*x1) +
               (matrix[index[3-i*2]]*x1/sqrt(0.25-x1*x1));
          while(x0 != x1){
            float x2 = (x0+x1)/2;
            float y2 = matrix[index[3-i*2]] * sqrt(0.25-x2*x2) +
                       (matrix[index[3-i*2]]*x2/sqrt(0.25-x2*x2));
            if(y2 == 0.0 || x0 == x2 || x1 == x2)
              x0 = x1 = x2;
            else if(y2 > 0){
              if(y1 > 0)
                x1 = x2;
              else
                x0 = x2;
            }
            else{
              if(y1 > 0)
                x0 = x2;
              else
                x1 = x2;
            } 
          }
        }
      } while(x0 != x1);
      if(i == 0){
        CHECK_PEN_EXTREMITIES(x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(x0, -sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, -sqrt(0.25-x0*x0), matrix);
      }
      else{
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), -x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), -x0, matrix);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo

Também podemos querer achar os pontos de extremidade não para um
círculo, mas para um caminho definido como curvas de Bézier:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix);
@
\fimcodigo

Curiosamente, neste caso as fórmulas são mais simples. Uma curva de
Bézier cúbica como as que usamos tem a seguinte fórmula, com $t$
variando entre 0 e 1, com $z_1$ e $z_4$ sendo pontos de extremidade e
com  $z_2$ e $z_3$ sendo pontos de controle:

$$
z(t) = (1-t)^3z_1+3(1-t)^2tz_2+3(1-t)t^2z_3+t^3z_4
$$

A derivada da função é:

$$
z'(t) = (-3z_1+9z_2-9z_3+3z_4)t^2+(6z_1-12z_2+6z_3)t+(-3z_1+3z_2)
$$

Descobrir em quais valores isso é igual à zero requer meramente usar a
fórmula de Bháskara.

Achar os pontos de extremidade então será feito iterando sobre os
pontos do caminho e computando os zeros de $z'(t)$. Se acharmos um
zero entre 0 e 1, checamos o valor para ver se precisamos
armazená-lo. Também checamos cada um dos pontos de extremidade. Os
pontos $z_1, z_2, z_3, z_4$ que usamos são aqueles que estão
armazenados após passar pela transformação linear da matriz
correspondente:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix){
  int i, j, length = p -> length;
  DECLARE_PEN_EXTREMITIES();
  for(i = 0; i < length; i ++){
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    CHECK_PEN_EXTREMITIES(p -> points[i].point.x, p -> points[i].point.y, matrix);
    x0 = LINEAR_TRANSFORM_X(p -> points[i].point.x, p -> points[i].point.y, matrix);
    y0 = LINEAR_TRANSFORM_Y(p -> points[i].point.x, p -> points[i].point.y, matrix);
    u_x = LINEAR_TRANSFORM_X(p -> points[i].point.u_x, p -> points[i].point.u_y, matrix);
    u_y = LINEAR_TRANSFORM_Y(p -> points[i].point.u_x, p -> points[i].point.u_y, matrix);
    v_x = LINEAR_TRANSFORM_X(p -> points[i].point.v_x, p -> points[i].point.v_y, matrix);
    v_y = LINEAR_TRANSFORM_Y(p -> points[i].point.v_x, p -> points[i].point.v_y, matrix);    
    x1 = LINEAR_TRANSFORM_X(p -> points[(i+1)%length].point.x, p -> points[i].point.y,
                            matrix);
    y1 = LINEAR_TRANSFORM_Y(p -> points[(i+1)%length].point.y, p -> points[i].point.y,
                            matrix);
    // Fórmula de Bháskara (eixo x)
    float a, b, c, deltah, t;
    a = (-3*x0+9*u_x-9*v_x+3*x1);
    b = (6*x0-12*u_x+6*v_x);
    c = (-3*x0+3*u_x);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(deltah)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
    // Fórmula de Bháskara (eixo y)
    a = (-3*y0+9*u_y-9*v_y+3*y1);
    b = (6*y0-12*u_y+6*v_y);
    c = (-3*y0+3*u_y);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(b * b - 4 * a * c)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo

\subsecao{10.2. Triangulação}

Vamos agora lidar com o código de triangulação. As placas de vídeo e o
OpenGL trabalha com triângulos. Nós devemos então triangular um pincel
antes de podermos representá-lo graficamente. Devemos representá-lo
como uma lista de triângulos. Isso chegou a ser mencionado na Subseção
7.5. sobre variáveis de caneta, mas o processo de triangulação não foi
definido lá.

Para recapitular, estas são as variáveis relevantes para a
triangulação que estão definidas dentro de um \monoespaco{struct
pen\_variable}:

* \monoespaco{struct path\_variable *format}: Possui um caminho
  cíclico com o formato da caneta.

* \monoespaco{GLuint gl\_vbo}: Referência para os vértices armazenados
  na placa de vídeo. Será 0 se a caneta ainda não foi triangulada.

* \monoespaco{float triang\_resolution}: Uma medida interna do nível
  de detalhamento de nossa triangulação. Relevante para saber se devemos
  retriangular uma caneta curva ou circular para podermos mostrar mais
  detalhes dela quando seu tamanho muda.

* \monoespaco{int flags}: Possui informação se o caminho acima define
  uma forma convexa ou côncava, um polígono ou uma figura com curvas,
  se é um quadrado, um círculo ou um polígono nulo sem lados. Além
  disso, nesta seção vamos definir e usar os novos valores desta flag:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define FLAG_ORIENTATION      32
#define FLAG_COUNTERCLOCKWISE 64
@
\fimcodigo

A segunda flag acima será usada para indicar se estamos armazenando
osvértices do formato da caneta no sentido anti-horário (se estiver
ativa) ou horário (se não estiver ativa). Entretanto, só vamos
considerar o valor válido e inicializado se a flag anterior acima
estiver ativa.

Vamos usar a seguinte função para obter tal informação de uma caneta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen);
@
\fimcodigo

A função funciona checando se temos tal informação armazenada na flag
e a retornando. Se não, ela busca descobrir. Ela faz isso encontrando
o vértice com a menor coordenada $y$ (e o maior $x$ se houver
empate). Seja $A$ este vértice, $P$ o vértice anterior e $N$ o
próximo. O sinal do resultado do produto escalar de $AP$ e $AN$
determina a orientação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen){
  int i, index = 0;
  int size = pen -> format -> length;
  float smallest_y = INFINITY, biggest_x = -INFINITY;
  if(pen -> flags & FLAG_ORIENTATION)
    return (pen -> flags & FLAG_COUNTERCLOCKWISE);
  if(pen -> format == NULL || size <= 0)
    return true;
  for(i = 0; i < size; i ++){
    if(pen -> format -> points[i].point.y < smallest_y ||
       (pen -> format -> points[i].point.y == smallest_y &&
        pen -> format -> points[i].point.y > biggest_x)){
      smallest_y = pen -> format -> points[i].point.y;
      biggest_x = pen -> format -> points[i].point.x;
      index = i;
    }
  }
  {
    int n = (index - 1) % size, p = (index + 1) % size;
    if(n < 0)
      n += size;
    if(p < 0)
      p += size;
    while(pen -> format -> points[index].point.x ==
                                 pen -> format -> points[n].point.x &&
          pen -> format -> points[index].point.y ==
                                 pen -> format -> points[n].point.y)
      n = (n + 1) % size;
    while(pen -> format -> points[index].point.x ==
                                 pen -> format -> points[p].point.x &&
          pen -> format -> points[index].point.y ==
                                  pen -> format -> points[p].point.y)
      p = (p - 1) % size;
    float ap_x = pen -> format -> points[p].point.x -
                 pen -> format -> points[index].point.x;
    float ap_y = pen -> format -> points[p].point.y -
                 pen -> format -> points[index].point.y;
    float an_x = pen -> format -> points[n].point.x -
                 pen -> format -> points[index].point.x;
    float an_y = pen -> format -> points[n].point.y -
                 pen -> format -> points[index].point.y;
    float prod = ap_x * an_x + ap_y * an_y;
    pen -> flags += FLAG_ORIENTATION;
    pen -> flags += FLAG_COUNTERCLOCKWISE * (prod > 0);
    return (prod > 0);
  }
}
@
\fimcodigo

A função que fará a triangulação é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix);
@
\fimcodigo

E a sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix){
  @<Triangulação: Caneta Nula@>
  @<Triangulação: Caneta Quadrada@>
  @<Triangulação: Polígono Convexo@>
  @<Triangulação: Círculo@>
  @<Triangulação: Forma Curva Convexa@>
  @<Triangulação: Forma Côncava@>
}
@
\fimcodigo

O caso mais simples é se tentarmos triangular uma caneta nula,
definida pelo comando \monoespaco{nullpen}. Essas canetas nunca serão
trianguladas, pois elas não fazem desenho algum. Consideramos elas
como sendo somente o ponto $(0, 0)$. Embora ela possa ser deslocada
com uma matriz de transformação. Este caso mais simples é tratado
abaixo:

\iniciocodigo
@<Triangulação: Caneta Nula@>=
if((pen -> flags & FLAG_NULL)){
  pen -> indices = 0;
  DECLARE_PEN_EXTREMITIES();
  CHECK_PEN_EXTREMITIES(0, 0, transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

O próximo caso é quando temos uma caneta quadrada. Este tipo de caneta
não precisa ser triangulada porque durante a inicialização nós já
fazemos uma só triangulação que será usada por toda e qualquer caneta
quadrada. Seus vértices serão armazenados aqui:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static GLuint pensquare_vbo;
@
\fimcodigo

E o código de triangulação que será usado na inicialização:

\iniciocodigo
@<Inicialização WEAVEFONT@>+=
{
  float square_vertices[8] = {-0.5, -0.5,
                               +0.5, -0.5,
                               +0.5, +0.5,
                               -0.5, +0.5};
  glGenBuffers(1, &pensquare_vbo);
  glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  glBufferData(GL_ARRAY_BUFFER, 8 * sizeof(float), square_vertices,
               GL_STATIC_DRAW);
}
@
\fimcodigo

Na finalização podemos remover os vértices da placa de vídeo:

\iniciocodigo
@<Finalização WEAVEFONT@>+=
glDeleteBuffers(1, &pensquare_vbo);
@
\fimcodigo

Sendo assim, quando temos que triangular uma caneta quadrada, nós não
a triangulamos. Mesmo assim, devemos obter os seus pontos de
extremidades:

\iniciocodigo
@<Triangulação: Caneta Quadrada@>=
if((pen -> flags & FLAG_SQUARE)){
  float square_vertices[8] = {-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5};
  pen -> indices = 4;
  DECLARE_PEN_EXTREMITIES();
  int i;
  for(i = 0; i < 4; i ++)
    CHECK_PEN_EXTREMITIES(square_vertices[2 * i], square_vertices[2 * i + 1],
                          transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

O próximo caso mais simples é quando temos um polígono convexo. Neste
caso, podemos usar o algoritmo mais simples. Escolhemos um único
vértice como pivô e fazemos uma triangulação gerando triângulos usando
o pivô e cada um dos vértices adjacentes que temos. É o método de
triangulação em leque:

\imagem{images/triangulacao_leque.eps}

Para isso basta passarmos os vértices da caneta na ordem anti-horária
para a placa de vídeo usando o OpenGL. Depois, quando chegar a hora de
desenhar, é só pedir para o OpenGL usar a triangulação em leque:

\iniciocodigo
@<Triangulação: Polígono Convexo@>=
if((pen -> flags & FLAG_STRAIGHT) && (pen -> flags & FLAG_CONVEX)){
  int i, index, increment;
  DECLARE_PEN_EXTREMITIES();
  GLsizei size = sizeof(float) * 2 * pen -> format -> length;
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  if(is_pen_counterclockwise(pen)){
    index = 0;
    increment = 1;
  }
  else{
    index = pen -> format -> length - 1;
    increment = -1;
  }
  for(i = 0; i < pen -> format -> length; i ++){
    data[2 * i] = pen -> format -> points[index].point.x;
    data[2 * i + 1] = pen -> format -> points[index].point.y;
    CHECK_PEN_EXTREMITIES(data[2 * i], data[2 * i + 1], transform_matrix);
    index += increment;
  }
  if(pen -> gl_vbo == 0){
    glGenBuffers(1, &(pen -> gl_vbo));
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
    glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
    pen -> indices = pen -> format -> length;
  }
  if(temporary_free != NULL)
    temporary_free(data);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

Vamos agora passar para o próximo caso de triangulação: o círculo. Uma
caneta circular é gerada com a expressão \monoespaco{pencircle}. Para
este tipo de caneta, devemos gerar seus vértices na hora para fazer a
triangulação. Com saber quantos vértices gerar? Se o círculo tiver um
único pixel de diâmetro, 4 vértices já seriam o suficiente para
aproximá-lo e ninguém notaria estar diante de um quadrado ao invés de
um círculo. Mas quanto maior ele fica, maior o número de vértices que
devemos usar.

Devemos levar em conta a fórmula do arco de circunferência $L=\theta
r$. Aqui $\theta$ é um ângulo interno do círculo e $r$ seu raio. O
valor de $L$ é o comprimento de arco definido port ais
valores. Devemos então fazer com que cada arco que desenhamos tenha um
tamanho de 1 pixel, fazendo com que o desenho sempre se pareça com um
círculo. Para isso o ângulo interno entre cada um deles em radianos
deve ser $1/r$. Como o ângulo total é $2\pi$, então devemos
representar $2\pi r$ vértices diferentes no perímetro do círculo.

A triangulação que usaremos será a mesma triangulação em leque
anterior. Mas vamos escolher como pivô o centro do círculo. Desta
forma, vamos armazenar $2\pi r + 1$ vértices.

Já o raio do círculo é escolhido como sendo metade do maior lado do
quadrado de lado 1 que passa pela mesma transformação linear definida
pela matriz de transformação do círculo. Como um círculo de diâmetro 1
é inscrito em um quadrado de lado 1, então este valor nos dá um limite
superior adequado para representar o raio do círculo em cada ponto de
seu perímetro, mesmo depois de uma transformação linear possivelmente
transformar nosso círculo em uma elipse.

Esse maior número de diâmetro do quadrado no qual o círculo está
inscrito é também como mediremos a resolução da triangulação de um
círculo. Se um círculo já estiver triangulado e tivermos que desenhar
um com resolução menor, não é necessário triangular novamente. Mas se
tivermos que desenhar um com resoluçao maior, temos que triangulá-lo
novamente, mesmo que ele já tenha sido triangulado.

O código para a triangulação do círculo é:

\iniciocodigo
@<Triangulação: Círculo@>=
if((pen -> flags & FLAG_CIRCULAR)){
  float radius;
  // Obter pontos de extremidade:
  pencircle_extremity_points(mf, transform_matrix);
  // Checando resolução (raio):
  {
    float side1, side2;
    side1 = abs(mf -> pen_rt - mf -> pen_lft);
    side2 = abs(mf -> pen_top - mf -> pen_bot);
    radius = ((side1 >= side2)?(side1):(side2))/ 2.0;
  }
  // Só retriangula se raio for maior que resolução já triangulada:
  if(pen -> gl_vbo != 0){
    if(radius > pen -> triang_resolution)
      glDeleteBuffers(1, &(pen -> gl_vbo));
    else
      return true;
  }
  pen -> triang_resolution = radius;
  GLsizei size = sizeof(float) * 2 * (((int) (2 * M_PI * radius)) + 4);
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    int i;
    float angle = 0.0;
    data[0] = 0.0;
    data[1] = 0.0; // Centro do círculo
    for(i = 2; i < (size / sizeof(float)); i ++){
      data[i] = 0.5 * sin(angle);
      i ++;
      data[i] = 0.5 * cos(angle);
      angle += 1/radius;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
  pen -> indices = (size / (2 * sizeof(float)));
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

Vamos tratar agora o último caso restante de caneta convexa: quando
temos uma caneta cujo formato tem curvas, mas ela é convexa. Neste
caso, assim como no círculo, devemos levar em conta seu tamanho para
decidir quantos vértices devemos usar para aproximar corretamente a
curva. Mas agora temos que fazer isso iterando sobre cada par
adjacente de pontos de extremidade, levando em conta os pontos de
controle.

Para cada par de pontos $(A, D)$ de pontos de extremidade, com os
pontos de controle $(B, C)$, o número de vértices que geraremos será
dado pela soma das distâncias $AB$, $BC$ e $CD$. A estimativa gerará
valores razoáveis, exceto em casos nos quais os pontos de controle
aparecem em ordens problemáticas, nas quais a curva acabaria cruzando
sobre si mesma. Como não suportamos formas não-simples para canetas,
este é um caso indefinido e não nos preocuparemos com ele.

Esse cálculo de distância, somando a distância dos pontos ao iterar
sobre toda a curva é também como representaremos a resolução da
triangulação de uma caneta curva. Se a soma das distâncias for menor
do que a resolução da triangulação, então não precisamos triangular
novamente, pois a caneta já está triangulada em um nível de detalhe
aceitável.

Podemos também economizar o número de vértices quando a curva na
verdade é uma linha reta entre $A$ e $D$. Em tais casos, só é
necessário ter vértices para os pontos de extremidade.

Para gerar os pontos, após determinar o número de vértices, podemos
gerar cada um deles, modificando o valor de $t$ na fórmula abaixo,
variando entre 0 e 1 passando por um valor intermediário para cada
vértice a mais a ser gerado:

$$
P(t) = (1-t)^3A + 3(1-t)^2tB + 3(1-t)t^2C + t^3D
$$

Naturalmente, devemos também percorrer os pontos em um sentido
anti-horário, o que não necessariamente é a orientação na qual eles
estão armazenados. Outra coisa a lembrar é que ao medir a distância
entre os pontos, nós devemos levar em conta a transformação linear
armazenada na matriz de transformação. Mas ao renderizar os vértices,
isso não deve ser levado em conta, já que tal transformação será
aplicada pela placa de vídeo ao renderizar a caneta.

O código para triangular uma caneta neste caso é:

\iniciocodigo
@<Triangulação: Forma Curva Convexa@>=
if((pen -> flags & FLAG_CONVEX)){
  bool counterclockwise = is_pen_counterclockwise(pen);
  int i, number_of_vertices = 1;
  // Obtém pontos de extremidade:
  path_extremity_points(mf, pen -> format, transform_matrix);
  for(i = 0; i < pen -> format -> length - 1; i ++){
    int distance = 0;
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    float dx, dy;
    x0 = LINEAR_TRANSFORM_X(pen -> format -> points[i].point.x,
                            pen -> format -> points[i].point.y, transform_matrix);
    y0 = LINEAR_TRANSFORM_Y(pen -> format -> points[i].point.x,
                            pen -> format -> points[i].point.y, transform_matrix);
    u_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].point.u_x,
                            pen -> format -> points[i].point.u_y, transform_matrix);
    u_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].point.u_x,
                            pen -> format -> points[i].point.u_y, transform_matrix);
    dx = u_x - x0;
    dy = u_y - y0;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    v_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].point.v_x,
                            pen -> format -> points[i].point.v_y, transform_matrix);
    v_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].point.v_x,
                            pen -> format -> points[i].point.v_y, transform_matrix);
    dx = v_x - u_x;
    dy = v_y - u_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    x1 = LINEAR_TRANSFORM_X(pen -> format -> points[i + 1].point.x,
                            pen -> format -> points[i + 1].point.y,
                            transform_matrix);
    y1 = LINEAR_TRANSFORM_Y(pen -> format -> points[i + 1].point.x,
                            pen -> format -> points[i + 1].point.y,
                            transform_matrix);
    dx = x1 - v_x;
    dy = y1 - v_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = x1 - x0;
    dy = y1 - y0;
    if(distance == (int) round(sqrt(dx * dx + dy * dy)))
      number_of_vertices ++; // Linha reta
    else
      number_of_vertices += distance;
  }
  if(pen -> gl_vbo != 0){
    if(number_of_vertices <= pen -> triang_resolution)
      return true; // No need to triangulate again
    else
      glDeleteBuffers(1, &(pen -> gl_vbo)); // Need to retriangulate
  }
  pen -> triang_resolution = number_of_vertices;
  float *data = (float *) temporary_alloc(number_of_vertices * 2 *
                                          sizeof(float));
    if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    struct path_points *p0, *p1;
    int v;
    if(counterclockwise)
      p0 = &(pen -> format -> points[0]);
    else
      p0 = &(pen -> format -> points[pen -> format -> length - 1]);
    data[0] = p0 -> point.x;
    data[1] = p0 -> point.y;
    v = 2;
    for(i = 0; i < pen -> format -> length - 1; i ++){
      float b_x, b_y, c_x, c_y, dx, dy, x0, y0, x1, x2, y1, y2;
      int distance = 0;
      if(counterclockwise){
        p1 = &(pen -> format -> points[1 + i]);
        b_x = p0 -> point.u_x;
        b_y = p0 -> point.u_y;
        c_x = p0 -> point.v_x;
        c_y = p0 -> point.v_y;
      }
      else{
        p1 = &(pen -> format -> points[pen -> format -> length - 2 - i]);
        b_x = p1 -> point.v_x;
        b_y = p1 -> point.v_y;
        c_x = p1 -> point.u_x;
        c_y = p1 -> point.u_y;
      }
      x0 = LINEAR_TRANSFORM_X(p0 -> point.x, p0 -> point.y, transform_matrix);
      y0 = LINEAR_TRANSFORM_Y(p0 -> point.x, p0 -> point.y, transform_matrix);
      x2 = LINEAR_TRANSFORM_X(b_x, b_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(b_x, b_y, transform_matrix);
      dx = x2 - x0;
      dy = y2 - y0;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(c_x, c_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(c_x, c_y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(p1 -> point.x, p1 -> point.y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(p1 -> point.x, p1 -> point.y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      dx = x2 - x0;
      dy = y2 - y0;
      if(distance == (int) round(sqrt(dx * dx + dy * dy))){
        data[v++] = p1 -> point.x;
        data[v++] = p1 -> point.y;
      }
      else{
        int j;
        float dt = 1.0 / ((float) distance);
        for(j = 1; j <= distance; j ++){
          float t = dt * j;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> point.x + 3*(1-t)*(1-t)*t * b_x +
                      3*(1-t)*t*t * c_x + t * t * t * p1 -> point.x;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> point.y + 3*(1-t)*(1-t)*t * b_y +
                      3*(1-t)*t*t * c_y + t * t * t * p1 -> point.y;
        }
      }
      p0 = p1;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, number_of_vertices * 2 *
                                sizeof(float), data, GL_STATIC_DRAW);
  pen -> indices = number_of_vertices;
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

Com relação à canetas com formas côncavas, por enquanto nós não iremos
suportá-las, mas isso deve mudar futuramente:

\iniciocodigo
@<Triangulação: Forma Côncava@>=
if(!(pen -> flags & FLAG_CONVEX)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Concave pens still not supported.\n");
#endif
  return false;
}
return false;
@
\fimcodigo

\subsecao{10.3. Interpretando o Comando 'pickup'}

Agora vamos ao que efetivamente ocorre quando lemos o
comando \monoespaco{pickup}.

1) Primeiro lemos o próximo token. Se for \monoespaco{nullpen},
fazemos com que \monoespaco{currentpen} se torne uma caneta nula e se
for um \monoespaco{pencircle} se torna uma caneta circular. Se for uma
variável de caneta, fazemos com que ela aponte para essa variável. Em
ambos os casos, reiniciamos a matriz de transformação
de \monoespaco{currentpen} para a de uma identidade. Nos demais casos,
ou se a variável não estiver inicializada, nós retornamos um erro.

\iniciocodigo
@<Instrução: Comando@>=
else if(begin -> type == TYPE_PICKUP){
  struct generic_token *end_expression = *end;
  struct generic_token *next_token = begin -> next;
  if(begin == *end ||
     (next_token -> type != TYPE_NULLPEN &&
      next_token -> type != TYPE_SYMBOLIC &&
      next_token -> type != TYPE_PENCIRCLE)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Expected 'nullpen' or pen "
                    "variable after 'pickup'. Not an arbitrary "
                    "expression.\n",
            mf -> file, next_token -> line);
#endif
    return false;
  }
  if(mf -> internal_pen_variables[0].gl_vbo != 0)
    glDeleteBuffers(1, &(mf -> internal_pen_variables[0].gl_vbo));
  if(next_token -> type == TYPE_NULLPEN){
    mf -> internal_pen_variables[0].flags = FLAG_NULL;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else if(next_token -> type == TYPE_PENCIRCLE){
    mf -> internal_pen_variables[0].flags = FLAG_CONVEX | FLAG_CIRCULAR;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else{
    struct pen_variable *var = ((struct symbolic_token *) next_token) -> var;
    if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-initialized variable after "
                      "after 'pickup' command.\n",
              mf -> file, next_token -> line);
#endif
      return false;
    }
    if(var -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable '%s' is not a "
                      "pen variable.\n",
              mf -> file, next_token -> line,
              ((struct symbolic_token *) next_token) -> value);
#endif
      return false;
    }
    mf -> internal_pen_variables[0].referenced = var;
  }
  INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[0].gl_matrix);
  @<Comando 'pickup': Continuação@>
  return true;
}
@
\fimcodigo

Depois de saber a forma base da caneta, é hora de ler as
transformações lineares específicas que vamos aplicar
à \monoespaco{currentpen}. Enquanto não estivermos no fim da expressão
a ser interpretada, lemos o próximo token. Ele indicará qual
transformação linear devemos aplicar à matriz de transformação
de \monoespaco{nullpen}. Baseado nele, lemos uma expressão numérica,
de par ou de transformação que descreve a transformação em
questão. Fazemos isso até chegar ao fim da expressão, quando não
houver mais transformações a serem feitas.

\iniciocodigo
@<Comando 'pickup': Continuação@>=
while(next_token != end_expression){
  struct generic_token *begin_subexpr, *end_subexpr;
  DECLARE_NESTING_CONTROL();
  next_token = next_token -> next;
  if(next_token == NULL || next_token == end_expression){
    printf("END: %p\n", end_expression);
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                      "command format.\n",
              mf -> file, next_token -> line);
#endif
    return false;
  }
  begin_subexpr = next_token -> next;
  end_subexpr = begin_subexpr;
  while(end_subexpr != end_expression){
    struct generic_token *next = end_subexpr -> next;
    COUNT_NESTING(end_subexpr);
    if(IS_NOT_NESTED() &&
       (next -> type == TYPE_ROTATED || next -> type == TYPE_SCALED ||
        next -> type == TYPE_SHIFTED || next -> type == TYPE_SLANTED ||
        next -> type == TYPE_XSCALED || next -> type == TYPE_YSCALED ||
        next -> type == TYPE_ZSCALED || next -> type == TYPE_TRANSFORMED))
      break;
    end_subexpr = next;
  }
  switch(next_token -> type){
    struct numeric_variable a;
    struct pair_variable p;
    struct transform_variable t;
  case TYPE_ROTATED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_ROTATE(mf -> internal_pen_variables[0].gl_matrix,
                     a.value * 0.0174533);
    break;
  case TYPE_SCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_SHIFTED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SHIFT(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    break;
  case TYPE_SLANTED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SLANT(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Slant non-circular curved pens always require retriangulation:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT) &&
         !(v -> flags & FLAG_CIRCULAR)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_XSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_X(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_YSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_Y(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_ZSCALED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SCALE_Z(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_TRANSFORMED:
    if(!eval_transform_expression(mf, cx, begin_subexpr, end_subexpr, &t))
      return false;
    MATRIX_MULTIPLICATION(mf -> internal_pen_variables[0].gl_matrix, t.value);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  default:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                    "command format.\n",
            mf -> file, next_token -> line);
#endif
    return false;  
  }
  next_token = end_subexpr;
}
@
\fimcodigo

Depois de termos obtido tanto o formato da caneta nova, se ela é um
ponteiro e qual a sua transformação linear, enfim iremos à etapa de
triangular a caneta. Para isso, se a caneta atual ter sido ajustada
para um ponteiro, sua transformação é a multiplicação da matriz
armazenada na \monoespaco{currentpen} pela matriz da caneta para a
qual ela aponta. Ou, se não for um ponteiro, é apenas a matriz
armazenada em \monoespaco{currentpen}. Após obter a matriz final de
transformação, a passamos para a função que fará a triangulação:

\iniciocodigo
@<Comando 'pickup': Continuação@>+=
{
  float final_transform_matrix[9];
  if(mf -> internal_pen_variables[0].referenced == NULL){
    memcpy(final_transform_matrix, mf -> internal_pen_variables[0].gl_matrix,
           9 * sizeof(float));
    if(!triangulate_pen(mf, &(mf -> internal_pen_variables[0]),
                        final_transform_matrix))
      return false;
  }
  else{
    memcpy(final_transform_matrix,
           mf -> internal_pen_variables[0].referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(final_transform_matrix,
                          mf -> internal_pen_variables[0].gl_matrix);
    if(!triangulate_pen(mf, mf -> internal_pen_variables[0].referenced,
                        final_transform_matrix))
      return false;
  }
}
@
\fimcodigo

\subsecao{10.4. Os Operadores \monoespaco{bot}, \monoespaco{top}, \monoespaco{lft},
\monoespaco{rt}}

Embora tenhamos definido quase todos os operadores de pares na
Subseção 8.2, existem quatro operadores primários que deixamos para
definir aqui. A gramática deles é:

\alinhaverbatim
<Primário de Par> -> bot <Primário de Par> | top <Primário de Par> |
                     lft <Primário de Par> | rt <Primário de Par>
\alinhanormal

Isso requer adicionar 4 novos tokens para tais operadores:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_BOT,  // O token simbólico 'bot'
TYPE_TOP,  // O token simbólico 'top'
TYPE_LFT,  // O token simbólico 'lft'
TYPE_RT,   // O token simbólico 'rt'
@
\fimcodigo

E também adicionar o nome dos tokens como palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"bot", "top", "lft", "rt",
@
\fimcodigo

O que estes operadores fazem é deslocar um par uma distância que
depende do tamanho da caneta atual que estamos usando.  Se temos um
ponto $(x_0, y_0)$, então \monoespaco{bot (x0, y0)} representa $(x_0,
y_0)$ deslocado para baixo, de modo que fique embaixo da caneta quando
ela é centralizada no ponto $(x_0, y_0)$. Assumindo que uma caneta
padrão é centralizada na origem, o menor ponto $y$ dela será um valor
negativo. Então isso é obtido somando o ponto inicial com o ponto mais
abaixo da caneta:

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin -> type == TYPE_BOT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> y += mf -> pen_bot;
  return true;
}
@
\fimcodigo

O operador \monoespaco{top} desloca o par para cima de modo
que \monoespaco{top (x0, y0)} passa a estar posicionado acima da
caneta se esta for posicionada em $(x_0, y_o)$.

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin -> type == TYPE_TOP){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> y += mf -> pen_top;
  return true;
}
@
\fimcodigo

O operador \monoespaco{lft} desloca o ponto à esquerda uma quantidade
igual à menor coordenada $x$ da caneta. Assim, \monoespaco{lft (x0,
y0)} passa a estar posicionado à esquerda da caneta se esta for
posicionada em $(x_0, y_o)$. Como em uma caneta centrada na origem
temos que seu ponto mais à esquerda é negativo, basta somarmos o valor
$x_0$ com o menor valor no eixo $x$ do perímetro da caneta:

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin -> type == TYPE_LFT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> x += mf -> pen_lft;
  return true;
}
@
\fimcodigo

Por fim, o operador \monoespaco{rt} desloca o par $(x_0, y_0)$ para a
direita uma quantidade equivalente à maior coordenada $x$ da caneta
atual, de modo que se as coordenadas do ponto ficarão à direita de uma
caneta centralizada em $(x_0, y_0)$:

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin  -> type == TYPE_RT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin -> next,
                        end, result))
    return false;
  result -> x += mf -> pen_rt;
  return true;
}
@
\fimcodigo

\secao{11. O Comando \monoespaco{draw} e \monoespaco{erase}}

Finalmente podemos começar a especificar dois dos mais importantes
comandos da linguagem. O comando que usa uma caneta para caminhos em
uma imagem ou para apagar eles. A sintaxe do comando de desenho e de
apagar é:

\alinhaverbatim
<Comando> -> <Comando 'draw'> | <Comando 'erase'> | ...
<Comando 'draw'> -> draw <Expressão de Caminho>
<Comando 'erase'> -> erase <Expressão de Caminho>
\alinhanormal

Os quais requerem dois tokens e palavras reservada novas:

\iniciocodigo
@<WEAVEFONT: Definição de Token Simbólico@>+=
TYPE_DRAW,   // O token simbólico 'draw'
TYPE_ERASE,  // O token simbólico 'erase'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"draw", "erase",
@
\fimcodigo

\subsecao{11.1. Preparando o Framebuffer}

Para desenhar ou apagar com uma caneta na
imagem \monoespaco{currentpicture}, nós precisamos de um framebuffer
associado com esta imagem. Isso não é muito diferente do que quando
definimos as operações sobre variáveis do tipo imagem. Em boa parte
das operações, nós criamos um framebuffer novo, salvamos o framebuffer
anterior, mudamos para o novo, renderizamos, apagamos o framebuffer
novo e voltamos ao antigo. Para a \monoespaco{currentpicture}, ao
invés disso, vamos manter uma variável armazenando seu framebuffer:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static GLuint currentpicture_fb;
@
\fimcodigo

A qual é inicializada como zero:

\iniciocodigo
@<Inicialização WEAVEFONT@>+=
currentpicture_fb = 0;
@
\fimcodigo

Antes de renderizar para \monoespaco{currentpicture}, devemos executar
o código abaixo que checa se o framebuffer está inicializado, e o
inicializa se não estiver:

\iniciocodigo
@<Prepara 'currentpicture' para Desenho@>=
{
  if(currentpicture_fb == 0){
    int width, height;
    GLuint texture;
    width = mf ->
             internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].width;
    height = mf ->
            internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].height;
    texture = mf ->
           internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].texture;
    glGenFramebuffers(1, &currentpicture_fb);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
                 GL_UNSIGNED_BYTE, NULL);
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                           texture, 0);
    if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: OpenGL cannot create framebuffer!\n");
#endif
      return false;
    }
  }
  else
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
}
@
\fimcodigo

Se por algum motivo nós mudarmos a nossa \monoespaco{currentpicture}
para outra imagem, devemos remover o framebuffer anterior:

\iniciocodigo
@<Gera nova 'currentpicture'@>=
{
  if(currentpicture_fb != 0){
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glBindTexture(GL_TEXTURE_2D, 0);
    glDeleteFramebuffers(1, &currentpicture_fb);
  }
  currentpicture_fb = 0;
}
@
\fimcodigo

Antes de renderizar para nossa \monoespaco{currentpicture}, nós não
armazenamos o framebuffer anterior em uma variável. E depois de
renderizar, nós não restauramos o framebuffer anterior. Ao contrário
do que fazíamos em outras operações de imagens. Isso ocorre porque
enquanto estivermos interpretando nosso código, renderizar
na \monoespaco{currentpicture} é uma operação muito mais comum que
renderizar em outros lugares. Por causa disso, vamos sempre
preferencialmente manter o nosso framebuffer atual para o
da \monoespaco{currentpicture}.

Antes de começar a avaliar código, é quando nós salvamos o framebuffer
anterior. Para isso usamos a variável abaixo:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static GLint previous_fb;
@
\fimcodigo

E abaixo temos onde salvamos o framebuffer anterior antes de começar a
executar qualquer código
em \monoespaco{eval\_list\_of\_expressions}. Salvamos também as
dimensões do ``viewport'', já que podemos mudar tais valores ao
renderizar uma imagem:

\iniciocodigo
@<Antes de Avaliar Código@>=
GLint _viewport[4];
glGetIntegerv(GL_VIEWPORT, _viewport);
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_fb);
@
\fimcodigo

E aqui nós restauramos o framebuffer e o ``viewport'' de antes de
começarmos a interpretar código:

\iniciocodigo
@<Depois de Avaliar Código@>=
glBindFramebuffer(GL_FRAMEBUFFER, previous_fb);
glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);
@
\fimcodigo

\subsecao{11.2. Shaders de Desenho}

Desenhar e apagar com uma caneta vai exigir dois novos shaders (um
para cada operação) que precisamos definir. Os shaders que definimos
anteriormente era para fazermos operações envolvendo variáveis de
imagem, e eles exigiam que enviássemos uma textura. Já o shader para
desenhar e apagar não requer uma textura, ao invés disso ele requer a
cor que devemos usar para desenhar. Por hora vamos deixar que a cor
sempre seja preto opaco, mas isso pode mudar no futuro.

O código de nosso shader de vértice será então:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char pen_vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "}\n";
@
\fimcodigo

Ele é idêntico ao que já definimos, mas não precisará receber e
extrair coordenadas de textura. Já os dois novos shaders de fragmento:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char pen_erase_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, \n"
  "                      color.a);\n"
  "}\n";
static const char pen_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = color;"
  "}\n";
static GLuint pen_program, pen_erase_program; // O programa após compilar
static GLint pen_uniform_matrix, pen_erase_uniform_matrix; // Matriz
static GLint pen_uniform_color, pen_erase_uniform_color; // Cor
@
\fimcodigo

Na inicialização nós compilamos estes dois shaders e obtemos a
localização de suas variáveis uniformes:

\iniciocodigo
@<Inicialização WEAVEFONT@>+=
{
  pen_program = compile_shader_program(pen_vertex_shader, pen_fragment_shader);
  pen_uniform_matrix = glGetUniformLocation(pen_program, "model_view_matrix");
  pen_uniform_color = glGetUniformLocation(pen_program, "color");
  pen_erase_program = compile_shader_program(pen_vertex_shader,
                                            pen_erase_fragment_shader);
  pen_erase_uniform_matrix = glGetUniformLocation(pen_erase_program,
                                                  "model_view_matrix");
  pen_erase_uniform_color = glGetUniformLocation(pen_erase_program, "color");
}
@
\fimcodigo

E na finalização nós destruimos estes programas:

\iniciocodigo
@<Finalização WEAVEFONT@>+=
glDeleteProgram(pen_program);
glDeleteProgram(pen_erase_program);
@
\fimcodigo

\subsecao{11.3. Desenhando Caminhos}

Terminada a preparação da triangulação, do framebuffer e do shader
usado, podemos escrever agora códigos que fazem o desenho.

\iniciocodigo
@<Instrução: Comando@>=
else if(begin -> type == TYPE_DRAW){
  struct path_variable path;
  // Avaliar a expressão de caminho
  if(!eval_path_expression(mf, cx, begin -> next, *end, &path))
    return false;
  if(!drawing_commands(mf, cx, &path, 0))
    return false;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &path, false);
  return true;
}
else if(begin -> type == TYPE_ERASE){
  struct path_variable path;
  // Avaliar a expressão de caminho
  if(!eval_path_expression(mf, cx, begin -> next, *end, &path))
    return false;
  if(!drawing_commands(mf, cx, &path, 1))
    return false;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &path, false);
  return true;
}
@
\fimcodigo

O código acima detecta um comando \monoespaco{draw} e obtém o caminho
a ser desenhado. A função que efetivamente realiza o desenho é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool drawing_commands(struct metafont *mf, struct context *cx,
                      struct path_variable *path, unsigned int flags);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
#define ERASE_FLAG 1
bool drawing_commands(struct metafont *mf, struct context *cx,
                      struct path_variable *path, unsigned int flags){
  int i, j;
  float transform_matrix[9];
  struct pen_variable *currentpen = &(mf -> internal_pen_variables[0]);
  struct picture_variable *currentpicture =
                                        &(mf -> internal_picture_variables[0]);
  // Preparar a caneta, a imagem de destino e parâmetros OpenGL
  if(currentpen -> referenced != NULL){
    memcpy(transform_matrix, currentpen -> referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(transform_matrix, currentpen -> gl_matrix);
    currentpen = currentpen -> referenced;
  }
  else
    memcpy(transform_matrix, currentpen -> gl_matrix, 9 * sizeof(float));
  @<Prepara 'currentpicture' para Desenho@>
  glEnable(GL_BLEND);
  if(flags & ERASE_FLAG){
    glBlendFunc(GL_ONE, GL_ONE);
    glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  }
  else{
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glBlendEquation(GL_FUNC_ADD);
  }
  // Loop de desenho
  for(i = 0; i < path -> length - 1; i ++){
    int distance = 0;
    float dx, dy, dt;
    dx = path -> points[i].point.u_x - path -> points[i].point.x;
    dy = path -> points[i].point.u_y - path -> points[i].point.y;
    distance += (int) ceil(sqrt(dx * dx + dy * dy));
    dx = path -> points[i].point.v_x - path -> points[i].point.u_x;
    dy = path -> points[i].point.v_y - path -> points[i].point.u_y;
    distance += (int) ceil(sqrt(dx * dx + dy * dy));
    dx = path -> points[(i+1) % (path -> length)].point.x - path -> points[i].point.v_x;
    dy = path -> points[(i+1) % (path -> length)].point.y - path -> points[i].point.v_y;
    distance +=  (int) ceil(sqrt(dx * dx + dy * dy));
    dt = 1 / ((float) distance);
    for(j = 0; j <= distance; j ++){
      float t = dt * j;
      float x = (1-t)*(1-t)*(1-t) * path -> points[i].point.x +
                3*(1-t)*(1-t)*t * path -> points[i].point.u_x +
                3*(1-t)*t*t * path -> points[i].point.v_x +
                t*t*t * path -> points[(i + 1) % (path -> length)].point.x;
      float y = (1-t)*(1-t)*(1-t) * path -> points[i].point.y +
                3*(1-t)*(1-t)*t * path -> points[i].point.u_y +
                3*(1-t)*t*t * path -> points[i].point.v_y +
                t*t*t * path -> points[(i + 1) % (path -> length)].point.y;
      drawpoint(mf, currentpen, currentpicture, x, y, transform_matrix,
                flags & ERASE_FLAG);
    }
  }
  // Quando é um único ponto e o loop acima não foi executado:
  if(path -> length == 1)
    drawpoint(mf, currentpen, currentpicture, path -> points[0].point.x,
              path -> points[0].point.y, transform_matrix, flags & ERASE_FLAG);
  // Finalização
  glDisable(GL_BLEND);
  return true;
}
@
\fimcodigo

O código acima primeiro obtém as variáveis relevantes ao comando
(\monoespaco{currentpen}, \monoespaco{currentpicture}).

Em seguida, obtemos qual caneta que devemos usar, a
triangulamos e inicializamos os parâmetros OpenGL específicos deste
tipo de desenho, que definimos nas Subseções anteriores. Um dos dois
únicos lugares em que tratamos de forma diferente o \monoespaco{draw}
e \monoespaco{erase} aparece nesta parte. Dependendo do comando, nós
mudamos a operação de como misturamos os pixels novos desenhados com
os pixels já existentes na imagem de destino. As escolhas feitas são
análogas às que fizemos quando definimos a soma e subtração de
imagens.

Depois temos o loop no qual iremos desenhar ponto-a-ponto o nosso
caminho usando a função que ainda será
definida \monoespaco{drawpoint}. Para obter casa um dos pontos, usamos
a fórmula das curvas de Beziér cúbicas $z(t) = (1-t)^3z_1 +
3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4$. E para saber quantos pontos
intermediários devem ser desenhados entre dois pontos de extremidade,
nós somamos a distância em pixels de todos os pontos envolvidos em
cada curva: os dois pontos de extremidade e os de controle.

Resta apenas definir a função \monoespaco{drawpoint}. O seu cabeçalho
é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing);
@
\fimcodigo

A caneta possui todas as coordenadas de seus vértices triangulados
usando o número de pixels como coordenada. A imagem tem sua altura e
largura conhecida. Ao renderizar usando OpenGL, devemos usar as
coordenadas padrão, onde o centro da imagem é a origem e a imagem tem
sempre 2 de altura e de largura. Isso significa que devemos fazer uma
última transformação linear para converter a caneta na renderização.

Seja $h$ a altura da imagem em pixels e $w$ sua largura. Isso
significa que 1 pixel horizontal é $2/w$ e um vertical é $2/h$. Então,
basta multiplicarmos a matriz de transformação pela matriz diagonal
com $2/w$ como primeiro valor, $2/h$ como segundo valor na diagonal e
com o resto da diagonal sendo 1.

O próximo passo seria depois de converter de pixels para coordenadas
OpenGL, ajustar a matriz de transformação para deslocar cada vértice
da caneta $x$ e $y$ pixels, o que daria $2x/w$ e $2y/h$ nas
coordenadas OpenGL. E aí fazemos outro deslocamento para corrigirmos o
fato do OpenGL tratar o centro da imagem como origem, enquanto nós
tratamos o canto inferior esquerdo da imagem como origem.

Contudo, existe uma última complicação: na verdade nem sempre tratamos
o canto inferior esquerdo da imagem como origem. Existe um tipo de
valor interno $d$ que pode mudar verticalmente a posição do eixo $x$
que usamos para medir nossas coordenadas. Um valor interno de
profundidade. Ele é armazenado aqui:

\iniciocodigo
@<Atributos (struct metafont)@>+=
int current_depth;
@
\fimcodigo

E seu valor inicial é zero:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> current_depth = 0;
@
\fimcodigo

Este valor $d$ mostra o quão deslocado para cima está o eixo $x$ em
quando medimos em pixels (e ele vira $2d/h$ ao ser convertido nas
coordenadas OpenGL). Se ele é zero, então o eixo $x$ será o limite
inferior do espaço da imagem e a origem o canto inferior esquerdo da
imagem. Se for um valor positivo, ele estará deslocado $d$ pixels para
cima. 

Para fazer todos este ajustes, devemos então multiplicar a matriz de
transformação da caneta pela seguinte nova matriz:

$$
\left[{{a \atop c}\atop
      {\atop e}}{{b \atop d}\atop { \atop f}}{{0 \atop 0}\atop{\atop 1}}\right]
\left[{{2/w \atop 0}\atop
      {\atop 2x/w-1}}{{0 \atop 2/h}\atop { \atop
      2d/h+2y/w-1}}{{0 \atop 0}\atop{\atop
      1}}\right]=
\left[{{2a/w \atop 2c/w}\atop
      {\atop (2e+2x)/w-1}}{{2b/h \atop 2d/h}\atop { \atop
      (2f+2d+2y)/h-1}}{{0 \atop 0}\atop{\atop
      1}}\right]
$$

E isso é feito internamente pela função \monoespaco{drawpoint}
imediatamente antes de desenhar. Depois de ajustar a matriz, só temos
que renderizar o resultado, e aqui também devemos usar programas de
shaders diferentes se estamos desenhando ou apagando:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing){
  float gl_matrix[9];
  gl_matrix[0] = (2 * matrix[0]) /  pic -> width;  // 2a/w
  gl_matrix[1] = (2 * matrix[1]) /  pic -> height; // 2b/h
  gl_matrix[2] = 0.0;
  gl_matrix[3] = (2 * matrix[3]) /  pic -> width;  // 2c/w
  gl_matrix[4] = (2 * matrix[4]) /  pic -> height; // 2d/h
  gl_matrix[5] = 0.0;
  gl_matrix[6] = 2 * (matrix[6] + x) /  pic -> width - 1.0;
  gl_matrix[7] = 2 * (matrix[7] + mf -> current_depth + y) / pic -> height -
                 1.0;
  gl_matrix[8] = 1.0;
  glViewport(0, 0, pic -> width, pic -> height); 
  // Se a caneta for quadrada, usamos a triangulação padrão de quadrado.
  // Se não for, usamos a triangulação da própria caneta.
  if(pen -> flags & FLAG_SQUARE)
    glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  else 
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, (void *) 0);
  if(erasing){
    glUseProgram(pen_erase_program);
    glUniformMatrix3fv(pen_erase_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_erase_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  else{
    glUseProgram(pen_program);
    glUniformMatrix3fv(pen_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  glEnableVertexAttribArray(0);
  glDrawArrays(GL_TRIANGLE_FAN, 0, pen -> indices);
}
@
\fimcodigo

\secao{12. Declaração Composta: Declaração de Caractere}

Vamos agora à parte que é o prinicpal objetivo da linguagem: definir
novos caracteres para fontes tipográficas, ou então definir uma imagem
que será usada como ilustração, ou animação.

A sintaxe para isso é:

\alinhaverbatim
<Composta> -> <Declaração de Caractere>
<Declaração de Caractere> -> beginchar ( <Token de String> ,
                                         <Expressão Numérica> ,
                                         <Expressão Numérica> ,
                                         <Expressão Numérica> )
                             <Corpo do 'beginchar'>
                             endchar
<Corpo do 'beginchar'> -> <Declaração, exceto 'beginchar'>
<Declaração, exceto 'beginchar'> -> <Simples> | <Composta, exceto 'beginchar'>
<Composta, exceto 'beginchar'> -> <Bloco Composto> | <Bloco Condicional>
\alinhanormal

O token \monoespaco{beginchar} começa a definição de um novo caractere
e o token \monoespaco{endchar} termina. O token de string é o nome do
caractere definido. Para fontes tipográficas, deve ser a representação
em UTF-8 do caractere. Para animações e ilustrações, pode ser qualquer
nome, o token terminará sendo ignorado. Os valores numéricos após o
token de string representam respectivamente a largura, altura e
profundidade do caractere (profundidade sendo a altura dele abaixo da
linha de base, para caracteres como ``p'' com partes dele ficando
abaixo da linha).

A linguagem WEAVEFONT tem dois modos de operação: ela pode estar
carregando ou executando. O modo determina o comportamento dela ao
encontrar o token \monoespaco{beginchar}. No modo de carregamento, ela
copia o código que representa o caractere para uma posição adequada,
para que se necessário, o código seja executado para renderizar o
caractere. O código dentro do corpo de \monoespaco{beginchar} nem
chega a ser executado e interpretado. No modo de execução, aí sim este
código será executado para que o caracteres seja renderizado.

\subsecao{12.1 Unicode e UTF-8}

Mas onde devemos armazenar o código de um caractere quando estamos no
modo de carregamento? Vamos definir a seguinte estrutura que armazena
o código de um caractere. Ela armazena o código, as dimensões do
caractere, a textura OpenGL onde ele foi renderizado e um atributo
booleano que diz se podemos usar essa textura ou se devemos renderizar
novamente o caractere:

\iniciocodigo
@<Declarações Gerais (metafont.h)@>=
struct _glyph;
@
\fimcodigo

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct _glyph{
  struct generic_token *begin, *end;
  int width, height, depth;
  int italic_correction;
  struct kerning *kern;
  GLuint texture;
  bool need_rendering;
};
#define INITIALIZE_GLYPH(a) {a.begin = NULL; \
                            a.end = NULL; \
                            a.width = 0; \
                            a.height = 0;\
                            a.depth = 0; \
                            a.italic_correction = 0; \
                            a.kern = NULL; \
                            a.texture = 0; \
                            a.need_rendering = true; \
                            }
@
\fimcodigo

O ``kerning'' que é armazenado será uma lista encadeada listando
quanto de espaço adicional deve ser colocado antes do próximo
caractere baseado em qual é o próximo caractere.

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct kerning{
  char next_char[5];
  int kern;
  struct kerning *next;
};
@
\fimcodigo

A lista de todos os glifos possíveis ficará na estrutura global da
linguagem, assim como um ponteiro para o primeiro glifo definido:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct _glyph *glyphs[332];
struct _glyph *first_glyph;
int number_of_glyphs;
@
\fimcodigo

O número 332 comporta a quantidade de diferentes blocos Unicode
existentes (327) mais algumas regiões adicionais que não são usadas
pelo Unicode no momento, mas podemvir a ser no futuro. Cada bloco
potencialmente armazena de 1 a milhares de diferentes glifos
relacionados entre si, tipicamente pertencentes a um mesmo sistema de
escrita. Inicialmente, todos estes blocos serão inicializados como
vazios. Mas à medida que encontrarmos caracteres pertencentes à eles,
teremos que alocar cada um deles:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
memset(mf -> glyphs, 0, sizeof(struct _glyph *) * 332);
mf -> first_glyph = NULL;
mf -> number_of_glyphs = 0;
@
\fimcodigo

A função que irá alocar e retornar a estrutura de um novo glifo, ou de
um glifo existente é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *utf8,
                                bool create_if_not_exist);
@
\fimcodigo

A função começa convertendo a representação UTF-8 para UTF-32,
tornando-a idêntica ao seu número Unicode. Em seguida, consultamos uma
tabela como maior valor existente em cada um dos blocos Unicode para
saber a qual bloco o caractere pertence, qual a sua posição dentro do
bloco e também o tamanho do bloco. Se o bloco não existir e o último
parâmetro da função for verdadeiro, alocamos o bloco. No fim,
retornamos o glifo representando o caractere (que pode ter sido
inicializado ou não). Ou NULL se não forpossível fazer isso (o bloco
não existe e foi pedido para não alocá-lo, o símbolo UTF-8 é inválido,
o código Unicode não existe ou não é suportado ou não há memória
suficiente para alocar o bloco).

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
static const uint32_t greatest_point[332] = {
  // Plano Multilingual Básico (164 blocos)
0x7f, 0xff, 0x17f, 0x24f, 0x2af, 0x2ff, 0x36f, 0x3ff, 0x4ff, 0x52f,
0x58f, 0x5ff, 0x6ff, 0x74f, 0x7ff, 0x7bf, 0x7ff, 0x83f, 0x85f, 0x86f,
0x89f, 0x8ff, 0x97f, 0x9ff, 0xa7f, 0xaff, 0xb7f, 0xbff, 0xc7f, 0xcff,
0xd7f, 0xdff, 0xe7f, 0xeff, 0xfff, 0x109f, 0x10ff, 0x11ff, 0x137f, 0x139f,
0x13ff, 0x167f, 0x169f, 0x16ff, 0x171f, 0x173f, 0x175f, 0x177f, 0x17ff, 0x18af,
0x18ff, 0x194f, 0x197f, 0x19df, 0x19ff, 0x1a1f, 0x1aaf, 0x1aff, 0x1b7f, 0x1bbf,
0x1bff, 0x1c4f, 0x1c7f, 0x1c8f, 0x1cbf, 0x1ccf, 0x1cff, 0x1d7f, 0x1dbf, 0x1dff,
0x1eff, 0x1fff, 0x206f, 0x209f, 0x20cf, 0x20ff, 0x214f, 0x218f, 0x21ff, 0x22ff,
0x23ff, 0x243f, 0x245f, 0x24ff, 0x257f, 0x259f, 0x25ff, 0x26ff, 0x27bf, 0x27ef,
0x27ff, 0x28ff, 0x297f, 0x29ff, 0x2aff, 0x2bff, 0x2c5f, 0x2c7f, 0x2cff, 0x2d2f,
0x2d7f, 0x2ddf, 0x2dff, 0x2eff, 0x2fdf, 0x2fff, 0x303f, 0x309f, 0x30ff, 0x312f,
0x318f, 0x319f, 0x31bf, 0x31ef, 0x31ff, 0x32ff, 0x33ff, 0x4dbf, 0x4dff, 0x9fff,
0xa48f, 0xa4cf, 0xa4ff, 0xa63f, 0xa69f, 0xa69f, 0xa6ff, 0xa71f, 0xa7ff, 0xa82f,
0xa83f, 0xa87f, 0xa8df, 0xa8ff, 0xa92f, 0xa95f, 0xa97f, 0xa9df, 0xa9ff, 0xaa5f,
0xaa7f, 0xaadf, 0xaaff, 0xab2f, 0xab6f, 0xabbf, 0xabff, 0xd7af, 0xd7ff, 0xdb7f,
0xdbff, 0xdfff, 0xf8ff, 0xfaff, 0xfb4f, 0xfdff, 0xfe0f, 0xfe1f, 0xfe2f, 0xfe4f,
0xfe6f, 0xfeff, 0xffef, 0xffff,
  // Plano Multilingual Suplementar (151 blocos)
0x1007f, 0x100ff, 0x1013f, 0x1018f, 0x101cf, 0x101ff, 0x1029f, 0x102df,
0x102ff, 0x1032f, 0x1034f, 0x1037f, 0x1039f, 0x103df, 0x1044f, 0x1047f,
0x104af, 0x104ff, 0x1052f, 0x1056f, 0x105bf, 0x1077f, 0x107bf, 0x1083f,
0x1085f, 0x1087f, 0x108af, 0x108ff, 0x1091f, 0x1093f, 0x1099f, 0x109ff,
0x10a5f, 0x10a7f, 0x10a9f, 0x10aff, 0x10b3f, 0x10b5f, 0x10b7f, 0x10baf,
0x10c4f, 0x10cff, 0x10d3f, 0x10e7f, 0x10ebf, 0x10eff, 0x10f2f, 0x10f6f,
0x10faf, 0x10fdf, 0x10fff, 0x1107f, 0x110cf, 0x110ff, 0x1114f, 0x1117f,
0x111df, 0x111ff, 0x1124f, 0x112af, 0x112ff, 0x1137f, 0x1147f, 0x114df,
0x115ff, 0x1166f, 0x1167f, 0x116cf, 0x1174f, 0x1184f, 0x118ff, 0x1195f,
0x119ff, 0x11a4f, 0x11aaf, 0x11abf, 0x11aff, 0x11b5f, 0x11c6f, 0x11cbf,
0x11d5f, 0x11daf, 0x11eff, 0x11f5f, 0x11fbf, 0x11fff, 0x123ff, 0x1247f,
0x1254f, 0x12fff, 0x1342f, 0x1345f, 0x1467f, 0x16a3f, 0x16a6f, 0x16acf,
0x16aff, 0x16b8f, 0x16e9f, 0x16f9f, 0x16fff, 0x187ff, 0x18aff, 0x18cff,
0x18d7f, 0x1afff, 0x1b0ff, 0x1b12f, 0x1b16f, 0x1b2ff, 0x1bc9f, 0x1bcaf,
0x1cfcf, 0x1d0ff, 0x1d1ff, 0x1d24f, 0x1d2df, 0x1d2ff, 0x1d35f, 0x1d37f,
0x1d7ff, 0x1daaf, 0x1dfff, 0x1e02f, 0x1e08f, 0x1e14f, 0x1e2bf, 0x1e2ff,
0x1e4ff, 0x1e7ff, 0x1e8df, 0x1e95f, 0x1ecbf, 0x1ed4f, 0x1eeff, 0x1f02f,
0x1f09f, 0x1f0ff, 0x1f1ff, 0x1f2ff, 0x1f5ff, 0x1f64f, 0x1f67f, 0x1f6ff,
0x1f77f, 0x1f7ff, 0x1f8ff, 0x1f9ff, 0x1fa6f, 0x1faff, 0x1fbff,
  // Não Usado
  0x1ffff,
  // Plano Ideográfico Suplementar
  0x2a6df, 0x2b73f, 0x2b81f, 0x2ceaf, 0x2ebef, 0x2fa1f,
  // Não Usado
  0x2ffff,
  // Plano Ideográfico Terciário
  0x3134f, 0x323af,
  // Não Usado
  0xdffff,
  // Plano de Propósito Geral (a região do meio é não usada)
  0xe007f, 0xe00ff, 0xe01ef,
  // Não Usado
  0xeffff,
  // Área de Uso Privado Suplementar A
  0xfffff,
  // Área de Uso Privado Suplementar B
  0x10ffff
};
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *c,
                                bool create_if_not_exist){
  uint32_t code_point;
  int block, block_size, index;
  // UTF-8 -> UTF-32
  if(c[0] < 128)
    code_point = c[0];
  else if(c[0] >= 192 && c[0] <= 223 && c[1] >= 128 && c[1] <= 159){
    code_point = c[1] - 128;
    code_point += (c[0] - 192) * 64;
  }
  else if(c[0] >= 224 && c[0] <= 239 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159){
    code_point = c[2] - 128;
    code_point += (c[1] - 128) * 64;
    code_point += (c[0] - 224) * 4096;
  }
  else if(c[0] >= 240 && c[0] <= 247 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159 && c[3] >= 128 && c[3] <= 159){
    code_point = c[3] - 128;
    code_point += (c[2] - 128) * 64;
    code_point += (c[1] - 128) * 4096;
    code_point += (c[0] - 240) * 262144;
  }
  else return NULL; // String UTF-8 inválida
  if(code_point > greatest_point[331])
    return NULL; // Código Unicode não-existente ou não-suportado
  for(block = 0; code_point > greatest_point[block]; block ++);
  if(block == 0){
    block_size = greatest_point[block] + 1;
    index = code_point;
  }
  else{
    block_size = greatest_point[block] - greatest_point[block - 1];
    index = code_point - greatest_point[block - 1] - 1;
  }
  if(mf -> glyphs[block] == NULL){
    int i;
    if(!create_if_not_exist)
      return NULL;
    mf -> glyphs[block] = permanent_alloc(sizeof(struct _glyph) * block_size);
    if(mf -> glyphs[block] == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s: No memory to allocate "
                      "Unicode block.\n", mf -> file);
#endif
      return NULL;
    }
    for(i = 0; i < block_size; i ++)
      INITIALIZE_GLYPH(mf -> glyphs[block][i]);
  }
  return &(mf -> glyphs[block][index]);
}
@
\fimcodigo

Note que umavez que glifos podem ser alocados, isso significa que na
finalização, teremos que desalocar eles. Também temos que remover a
lista encadeada de kerning quando ela existir:

\iniciocodigo
@<Finalização (struct metafont)@>+=
{
  int block, block_size, index;
  // Percorre todos os blocos:
  for(block = 0; block < 332; block ++){
    if(mf -> glyphs[block] != NULL){
      // Obtém tamanho do bloco
      if(block == 0)
        block_size = greatest_point[block] + 1;
      else
        block_size = greatest_point[block] - greatest_point[block - 1];
      // Percorre todos os glifos:
      for(index = 0; index < block_size; index ++){
        struct kerning *kern = mf -> glyphs[block][index].kern;
        if(mf -> glyphs[block][index].texture != 0)
          glDeleteTextures(1, &(mf -> glyphs[block][index].texture));
        while(kern != NULL && permanent_free != NULL){
          struct kerning *to_be_erased;
          to_be_erased = kern;
          kern = kern -> next;
          permanent_free(to_be_erased);          
        }
      }
      if(permanent_free != NULL)
        permanent_free(mf -> glyphs[block]);
    }
  }
}
@
\fimcodigo

O comportamento da linguagem, quando está em modo de carregamento e lê
o token \monoespaco{beginchar} será ler o token de string e
interpretá-lo como um caractere codificado em UTF-8. Baseado nele, a
função acima é executada para obter a estrutura do glifo
correspondente, e alocá-la se necessário. Se já existir um glifo
totalmente inicializado para tal caractere, um erro será gerado: isso
significa que o mesmo caractere foi definido mais de uma vez. Se não,
todo o código que vai do token \monoespaco{beginchar} até
o \monoespaco{endchar} será armazenadono glifo e ele será considerado
completamente inicializado (mas não renderizado). O token de string
que especificou o glifo também será atualizado para que seu ponteiro
interno aponte para o novo glifo criado. Um erro também deve ser
gerado se existir um \monoespaco{beginchar} dentro de
outro \monoespaco{beginchar}:

\iniciocodigo
@<Instrução: Composta@>+=
else if(begin -> type == TYPE_BEGINCHAR && mf -> loading){
  DECLARE_NESTING_CONTROL();
  struct _glyph *glyph;
  struct generic_token *t = begin -> next;
  if(t -> type != TYPE_OPEN_PARENTHESIS || begin == *end){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing '(' "
                    "after 'beginchar'.\n", mf -> file,
                    begin -> line);
#endif
    return false;
  }
  if(t != *end)
    t = t -> next;
  if(t -> type != TYPE_STRING){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing UTF-8 string "
                    "after 'beginchar('.\n", mf -> file,
            begin  -> line);
#endif
    return false;
  }
  {
    struct string_token *str = (struct string_token *) t;
    glyph = get_glyph(mf, (unsigned char *) str -> value, true);
    if(glyph == NULL)
      return false;
    if(mf -> first_glyph == NULL)
      mf -> first_glyph = glyph;
    if(glyph -> begin != NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Glyph \"%s\" is defined "
                      "twice.\n", mf -> file,
              begin -> line,
              str -> value);
#endif
      return false;
    }
    glyph -> begin = begin;
    str -> glyph = glyph;
  }
  {
    int number_of_commas = 0;
    struct generic_token *prev = t;
    while(t != NULL && t != *end){
      COUNT_NESTING(t);
      if(IS_NOT_NESTED()){
        if(t -> type == TYPE_COMMA && prev -> type != TYPE_COMMA)
          number_of_commas ++;
      }
      prev = t;
      t = t -> next;
      if(IS_NOT_NESTED() && t -> type == TYPE_CLOSE_PARENTHESIS)
        break;
    }
    if(t == NULL || number_of_commas != 3 ||
       t -> type != TYPE_CLOSE_PARENTHESIS){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Malformed 'beginchar' "
                      "compound command.\n", mf -> file,
              begin -> line);
#endif
      return false;
    }
    t = t -> next;
    while(t != NULL && t -> type != TYPE_ENDCHAR){
      if(t -> type == TYPE_BEGINCHAR){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Nested 'beginchar'.\n",
                mf -> file, t -> line);
#endif
        return false;
      }
      t = t -> next;
    }
    if(t == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'endchar' "
                      "after'beginchar' command.\n", mf -> file,
              begin -> line);
#endif
      return false;
    }
    glyph -> end = t;
    *end = t;
  }
  mf -> number_of_glyphs ++;
  return true;
}
@
\fimcodigo

Já se estivermos em modo de carregamento e lermos um
token \monoespaco{endchar}, isso sempre será um erro: significa que o
código possui um \monoespaco{endchar}, mas não
um \monoespaco{beginchar}. Já que os tokens de \monoespaco{endchar}
são tratados na mesma iteração em que tratamos
o \monoespaco{beginchar}:

\iniciocodigo
@<Instrução: Composta@>+=
else if(begin -> type == TYPE_ENDCHAR && mf -> loading){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Found 'endchar' token "
                  "without previous 'beginchar'.\n", mf -> file,
                  begin -> line);
#endif
  return false;
}
@
\fimcodigo

Depois, quando estivermos em modo de execução, e não em modo de
carregamento, iremos ler todo esse código entre \monoespaco{beginchar}
e \monoespaco{endchar} novamente. E será importante memorizar qual o
glifo que estamos tratando anquele instante. Por causa disso,
armazenaremos no contexto qual glifo dvemos renderizar:

\iniciocodigo
@<Atributos (struct context)@>+=
struct _glyph *current_glyph;
@
\fimcodigo

Finalmente, vamos tratar o \monoespaco{beginchar} quando estamos em
modo de execução. Primeiro lemos o token de string que vem em
sequência. Como já havíamos executado este código no modo de
carregamento, o token de string possui um ponteiro para um glifo já
alocado e totalmente inicializado. Precisamos apenas renderizá-lo.

O próximo passo será obter os valores no cabeçalho
do \monoespaco{beginchar}, lendo os valores numéricos de largura,
altura e profundidade e usando tais valores para gerar uma
nova \monoespaco{currentpicture}. A imagem renderizada terá o dobro
dos valores indicados para que possamos obter tons de cinza realizando
uma multi-amostragem, gerando cada pixel à partir de 4 outros pixels
de amostragem. Exceto se a
macro \monoespaco{W\_WEAVEFONT\_DISABLE\_MULTISAMPLE} estiver
definida, caso em que não usaremos a técnica.  Por fim, a caneta atual
é modificada para ser uma caneta nula.


\iniciocodigo
@<Instrução: Composta@>+=
else if(begin -> type == TYPE_BEGINCHAR){
  DECLARE_NESTING_CONTROL();
  begin_nesting_level(mf, cx, begin);
  struct generic_token *t, *begin_expr, *end_expr;
  struct string_token *str;
  struct numeric_variable width, height, depth;
  // Primeiro obtemos o glifo atual:
  t = begin -> next;
  t = t -> next;
  str = (struct string_token *) t;
  cx -> current_glyph = str -> glyph;
  memset(cx -> current_character, 0, 5);
  memcpy(cx -> current_character, str -> value, 4);
  // Lendo os valores no cabeçalho
  t = t -> next;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(!IS_NOT_NESTED() || t -> type != TYPE_COMMA);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &width))
    return false;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(!IS_NOT_NESTED() || t -> type != TYPE_COMMA);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &height))
    return false;
  t = t -> next;
  begin_expr = t;
  do{
    COUNT_NESTING(t);
    end_expr = t;
    t = t -> next;
  } while(!IS_NOT_NESTED() || t -> type != TYPE_CLOSE_PARENTHESIS);
  if(!eval_numeric_expression(mf, cx, begin_expr, end_expr, &depth))
    return false;
  *end = t;
  { // Inicializando currentpicture = nullpicture(width, height + depth):
    unsigned char *data;
    struct numeric_variable *vars;
    size_t size;
    struct picture_variable *pic = &(mf -> internal_picture_variables[0]);
     if(pic -> texture != 0)
       glDeleteTextures(1, &(pic -> texture));
     vars = ((struct numeric_variable *) mf -> internal_numeric_variables);
#ifdef W_WEAVEFONT_DISABLE_MULTISAMPLE
    mf -> current_depth = round(depth.value);
    pic -> width = round(width.value);
    pic -> height = (round(height.value) + round(depth.value));
    vars[INTERNAL_NUMERIC_W].value = round(width.value);
    vars[INTERNAL_NUMERIC_H].value = round(height.value);
    vars[INTERNAL_NUMERIC_D].value = round(depth.value);
#else
    mf -> current_depth = 2 * round(depth.value);
    pic -> width = 2 * round(width.value);
    pic -> height = 2 * (round(height.value) + round(depth.value));
    vars[INTERNAL_NUMERIC_W].value = 2 * round(width.value);
    vars[INTERNAL_NUMERIC_H].value = 2 * round(height.value);
    vars[INTERNAL_NUMERIC_D].value = 2 * round(depth.value);
#endif
    size = pic -> width * pic -> height * 4;
    data = temporary_alloc(size);
    if(data == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
      return false;
    }
    // Pintando a nova textura de branco
    memset(data, 255, size);
    { // E deixando ela totalmente transparente:
      int i;
      for(i = 3; i < size; i += 4)
        data[i] = 0;
    }
    glGenTextures(1, &(pic -> texture));
    glBindTexture(GL_TEXTURE_2D, pic -> texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, pic -> width, pic -> height, 0,
                 GL_RGBA, GL_UNSIGNED_BYTE, data);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glBindTexture(GL_TEXTURE_2D, 0);
    if(temporary_free != NULL)
      temporary_free(data);
    @<Gera nova 'currentpicture'@>
  }
  { // Inicializando currentpen = nullpen:
    mf -> internal_pen_variables[0].format = NULL; // A caneta 'currentpen'
    mf -> internal_pen_variables[0].type = TYPE_T_PEN;
    mf -> internal_pen_variables[0].flags = FLAG_NULL;
    mf -> internal_pen_variables[0].referenced = NULL;
    if(mf -> internal_pen_variables[0].gl_vbo != 0)
      glDeleteBuffers(1, &(mf -> internal_pen_variables[0].gl_vbo));
    mf -> internal_pen_variables[0].gl_vbo = 0;
    mf -> internal_pen_variables[0].indices = 0;
    mf -> pen_lft = mf -> pen_rt = mf -> pen_top = mf -> pen_bot = 0.0;
  }
  return true;
}
@
\fimcodigo

Finalmente, quando lemos um \monoespaco{endchar} em modo de execução,
significa que terminamos de renderizar um novo glifo. Devemos então
copiar a imagem renderizada de \monoespaco{currentícture} para o
glifo. E se estivermos usando multi-amostragem, devemos ajustatr o
tamanho do glifo para a metade, para ser renderizado na tela com
metade do tamanho que tem na memória. Por fim, devemos marcar o glifo
como já renderizado e apagar o conteúdo
de \monoespaco{currentpicture}:

\iniciocodigo
@<Instrução: Composta@>+=
else if(begin -> type == TYPE_ENDCHAR){
  struct picture_variable *currentpicture =
                                        &(mf -> internal_picture_variables[0]);
  end_nesting_level(mf, cx, begin);
  cx -> current_glyph -> width = round(currentpicture -> width);
  cx -> current_glyph -> depth = round(mf -> current_depth);
  cx -> current_glyph -> height = round(currentpicture -> height -
                                        mf -> current_depth);
  cx -> current_glyph -> texture = currentpicture -> texture;
#ifndef W_WEAVEFONT_DISABLE_MULTISAMPLE
  cx -> current_glyph -> width /= 2;
  cx -> current_glyph -> depth /= 2;
  cx -> current_glyph -> height /= 2;
#endif
  cx -> current_glyph -> need_rendering = false;
  currentpicture -> width = -1;
  currentpicture -> height = -1;
  currentpicture -> texture = 0;
  *end = begin;
  return true;
}
@
\fimcodigo

\secao{13. Funções de API para Usar as Fontes}

Um código WEAVEFONT pode ter suas variáveis globais modificadas e
assim atualizar a renderização de glifos e imagens sem que o código
precise ser reescrito e reinterpretado. Para escrever e ler variáveis
globais numéricas, usamos as seguintes funções que serão exportadas:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
bool _Wwrite_numeric_variable(struct metafont *mf, char *name, float value);
float _Wread_numeric_variable(struct metafont *mf, char *name);
@
\fimcodigo

O que a primeira função fará será mudar a variável global indicada por
tal nome e irá marcar todos os glifos como necessitando ser
renderizados novamente. Se não existir variável numérica com tal nome,
retornamos falso. Se não, retornamos verdadeiro:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>+=
bool _Wwrite_numeric_variable(struct metafont *mf, char *name, float value){
  struct named_variable *var = (struct named_variable *) mf -> named_variables;
  while(var != NULL){
    if(!strcmp(name, var -> name)){
      struct numeric_variable *n = (struct numeric_variable *) var -> var;
      if(n -> type != TYPE_T_NUMERIC)
        return false;
      n -> value = value;
      {
        int i, j;
        for(i = 0; i < 332; i ++){
          struct _glyph *g = mf -> glyphs[i];
          int size = ((i == 0)?(greatest_point[0] + 1):
                               (greatest_point[i] - greatest_point[i - 1]));
          if(g != NULL){
            for(j = 0; j < size; j ++)
                g[j].need_rendering = true;
          }
        }
      }
      return true;
    }
    var = var -> next;
  }
  return false;
}
@
\fimcodigo

O código para lermos uma variável numérica será similar. Se a variável
numérica global com tal nome não existir, retornamos NAN:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>+=
float _Wread_numeric_variable(struct metafont *mf, char *name){
  struct named_variable *var = (struct named_variable *) mf -> named_variables;
  while(var != NULL){
    if(!strcmp(name, var -> name)){
      struct numeric_variable *n = (struct numeric_variable *) var -> var;
      if(n -> type != TYPE_T_NUMERIC)
        return NAN;
      return n -> value;
    }
    var = var -> next;
  }
  return NAN;
}
@
\fimcodigo


Já a função que lê um arquivo com código WEAVEFONT e carrega uma nova
meta-fonte é:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>+=
struct metafont *_Wnew_metafont(char *filename){
  struct metafont *mf;
  struct context *cx;
  struct generic_token *first, *last;
  bool ret;
  mf = init_metafont(filename);
  lexer(mf, filename, &first, &last);
  cx = init_context(mf);
  ret = eval_program(mf, cx, first, last);
  destroy_context(mf, cx);
  if(!ret){
    _Wdestroy_metafont(mf);
    return NULL;
  }
  return mf;
}
@
\fimcodigo

Finalmente, se quisermos renderizar um caractere e obter informações
sobre suas dimensões em pixels (largura, altura, profundidade,
correção itálica e ``kerning''), executamos a seguinte função:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
bool _Wrender_glyph(struct metafont *mf, char *glyph,
                    char *next_glyph, GLuint *texture,
                    int *width, int *height, int *depth,
                    int *italcorr, int *kerning);
@
\fimcodigo

E a implementação da função:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>+=
bool _Wrender_glyph(struct metafont *mf, char *glyph,
                    char *next_glyph, GLuint *texture,
                    int *width, int *height, int *depth,
                    int *italcorr, int *kerning){
  struct _glyph *current;
  struct kerning *k;
  struct context *cx = NULL;
  MUTEX_WAIT(mf -> mutex);
  current = get_glyph(mf, (unsigned char *) glyph, false);
  if(current == NULL || current -> begin == NULL || current -> end == NULL){
    MUTEX_SIGNAL(mf -> mutex);
    return false;
  }
  if(current -> need_rendering){
    cx = init_context(mf);
    if(cx  == NULL){
      MUTEX_SIGNAL(mf -> mutex);
      return false;
    }
    if(!eval_list_of_statements(mf, cx, current -> begin, current -> end)){
      destroy_context(mf, cx);
      MUTEX_SIGNAL(mf -> mutex);
      return false;
    }
  }
  *texture = current -> texture;
  *width = current -> width;
  *height = current -> height;
  *depth = current -> depth;
  *italcorr = current -> italic_correction;
  k = current -> kern;
  *kerning = 0;
  while(k != NULL && next_glyph != NULL){
    if(!strcmp(k -> next_char, next_glyph)){
      *kerning = k -> kern;
      break;
    }
    k = k -> next;
  }
  if(cx != NULL)
    destroy_context(mf, cx);
  MUTEX_SIGNAL(mf -> mutex);
  return true;
}
@
\fimcodigo


\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}

\referencia{Hobby, J. D. (1986), ``Smooth, easy to compute interpolating
 splines'', Discrete \& computational geometry, 1(2), 123-140}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim


