\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\def\matrix#1#2#3#4#5#6#7#8#9{\left[{{#1 \atop #4}\atop
      {\scriptstyle #7}}{{#2 \atop #5}\atop {\scriptstyle #8}}{{#3\atop
      #6}\atop{\scriptstyle #9}}\right]}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\twelvebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Usuário Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém uma implementação de um interpretador para
 uma linguagem baseada no METAFONT. Esta linguagem é projetada para
 permitir a definição de fontes tipográficas flexíveis e
 parametrizadas que podem ser interpretadas e renderizadas rapidamente
 à medida que são lidas. Por causa disso, nós sacrificamos alguma
 flexibilidade da linguagem METAFONT original para sermos capazes de
 criar resultados mais rápidos. A implementação será usada pelo Motor
 de Jogos Weaver como um módulo e usará OpenGL moderno para renderizar
 as fontes.}

\secao{1. Introdução}

A linguagem METAFONT original é uma linguagem feita para descrever
fontes tipográficas. Ela foi criada em 1984 por Donald Knuth e difere
de outros formatos de fontes tipográficas por permitir a criação de
fontes à partir da modificação de parâmetros definidos na descrição
básica da fonte. Desta forma, o projetista de uma fonte não deve criar
uma simples fonte tipográfica, mas uma meta-fonte, a qual pode por sua
vez gerar muitas outras fontes tipográficas diferentes mediante a
simples modificação dos parâmetros.

A especificação original da linguagem METAFONT pode ser encontrada em
[KNUTH, 1989], mas a implementação aqui não será compatível com a
linguagem original. Ao invés disso uma nova linguagem será definida,
mas ela terá objetivos similares.

Como este artigo define um subsistema do Motor de Jogos Weaver, e mais
especificamente um subsistema de interface de usuário, nosso objetivo
aqui será definir a seguinte função que irá interpretar um arquivo com
código METAFONT e irá gerar uma interface de usuário com as letras
lidas como textura:

\iniciocodigo
@<Declaração de Função (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
                        void (*permanent_free)(void *),
                        void *(*temporary_alloc)(size_t),
                        void (*temporary_free)(void *),
                        void (*before_loading_interface)(void),
                        void (*after_loading_interface)(void),
                        char *source_filename,
                        struct user_interface *target);
@
\fimcodigo

E nós precisamos inserir o cabeçalho Weaver de interface de usuário:

\iniciocodigo
@<Inclui Cabeçalhos Gerais (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

Mas além de simplesmente carregar as fontes tipográficas lidas para um
arquivo, é importante poder gerar também uma estrutura de dados
representando a fonte lida, para que ela depois possa ser usada por
uma função que renderiza texto:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Antes de chamar qualquer uma das funções acima, será importante chamar
a seguinte função de inicialização que especifica ãlgumas das funções
que devem ser usadas, e além disso nos informa quantos píxels
correspontem à unidade de medida de ``1pt'':



\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
bool _Winit_metafont(void *(*temporary_alloc)(size_t),
                     void (*temporary_free)(void *),
                     void *(*permanent_alloc)(size_t),
                     void (*permanent_free)(void *),
                     uint64_t (*rand)(void), int pt);
@
\fimcodigo

As funções passadas como argumento para tal inicializador são
respectivamente uma para fazer alocações temporárias de memória, outra
para desalocar o que foi alocado com ela (pode ser NULL), outra para
fazer alocações mais permanentes, outra para desalocar o que foi
alocado com ela (pode ser NULL também), uma para gerar 64 bits
aleatórios e por fim a medida de quantos píxels correspondem a 1pt. A
função retorna verdadeiro se a inicialização foi bem-sucedida.

Após terminar o uso de nossas funções, deve-se chamar a função abaixo
que finaliza e desaloca qualquer coisa que tenha sido gerada pela
função de inicialização:

\iniciocodigo
@<Declaração de Função (metafont.h)@>+=
void _Wfinish_metafont(void);
@
\fimcodigo



\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{metafont.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
#if !defined(_WIN32)
#include <sys/param.h> // Necessário no BSD, mas causa problema no Windows
#endif
@<Inclui Cabeçalhos Gerais (metafont.h)@>
//@<Macros Gerais (metafont.h)@>
@<Declarações Gerais (metafont.h)@>
@<Estrutura de Dados (metafont.h)@>
@<Declaração de Função (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (metafont.h)'', o mesmo nome apresentado no
trecho de código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{metafont.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Cabeçalhos Locais (metafont.c)@>
@<Macros Locais (metafont.c)@>
@<Estrutura de Dados Locais (metafont.c)@>
@<Variáveis Locais (metafont.c)@>
@<Declaração de Função Local (metafont.c)@>
@<Funções Auxiliares Locais (metafont.c)@>
@<Definição de Funções da API (metafont.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{X. Código Auxiliar Geral}

O código apresentado nesta seção tem como característica ser usado em
diferentes partes de nossa linguagem e também ser independente de
estruturas de dados específicas deste projeto. Por causa disso, vamos
defini-lo como uma introdução, antes do código mais específico.

\subsecao{X.Y. Código de Álgebra Linear}

Iremos usar com uma frequência muito grande matrizes $3\times 3$, que
serão usadas tipicamente para representar transformações lineares em
um espaço vetorial de 3 dimensões. Tais matrizes serão simplesmente um
array de 9 elementos, representando os elementos da matriz.

Os valores da matriz estarão dispostos da seguinte forma, de acordo
como os armazenamos no array M:

$$
\matrix{M[0]}{M[1]}{M[2]}{M[3]}{M[4]}{M[5]}{M[6]}{M[7]}{M[8]}
$$

Sendo assim, podemos inicializar uma matriz identidade com:

\iniciocodigo
@<Macros Locais (metafont.c)@>=
#define INITIALIZE_IDENTITY_MATRIX(I) {\
  int _i;\
  for(_i = 0; _i < 9; _i++)\
    I[_i] = ((_i%4)?(0.0):(1.0));\
}   
@
\fimcodigo

Apesar de nossas matrizes lidarem com espaço vetorial de 3 dimensões,
na prática todos os valores que usaremos estarão contidos no plano
$\{(x, y, 1)\}$. tal que $x$ e $y$ são números reais. O motivo de
trabalharmos no espaço de 3 dimensões é poder representar a translação
(ou deslocamento) de pontos como transformações lineares, algo que só
se torna possível no espaço 2D se o tratarmos como inscrito dentro de
um espaço vetorial 3D.

Dado um vetor de 3 dimensões $(x, y, 1)$, podemos transformá-lo em um
novo vetor $(x', y', 1)$ aplicando a transformação linear representada
por uma matriz abaixo:

$$\left[x\; y\; 1\right]
\matrix{M[0]}{M[1]}{0}{M[3]}{M[4]}{0}{M[6]}{M[7]}{1}
=\left[x'\;\; y'\;\; 1\right]
$$

As novas coordenadas $(x', y')$ do novo vetor podem ser calculadas com
ajuda das macros abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define LINEAR_TRANSFORM_X(x, y, M) (x * M[0] + y * M[3] + M[6])
#define LINEAR_TRANSFORM_Y(x, y, M) (x * M[1] + y * M[4] + M[7])
@
\fimcodigo

A multiplicação de matrizes tem a propriedade de associatividade
abaixo:

$$
\left((x, y, 1)\cdot A\right) \cdot B = (x, y, 1)\cdot \left(A \cdot B\right)
$$

Isso quer dizer que podemos acumular várias transformações em uma só
matriz. Aplicar a transformaçao $AB$ sobre um vetor é o mesmo que
aplicar primeiro a transformação $A$ e depois a transformação $B$. O
código abaixo acumula duas transformações lineares, calculando $AB$ e
armazenando o resultado em $A$. Note que o código sempre assume que a
última coluna de toda matriz é $(0, 0, 1)^{T}$:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define MATRIX_MULTIPLICATION(A, B) {\
  float _a0 = A[0], _a1 = A[1], _a3 = A[3], _a4 = A[4], _a6 = A[6],\
        _a7 = A[7];\
  A[0] = _a0 * B[0] + _a1 * B[3];\
  A[1] = _a0 * B[1] + _a1 * B[4];\
  A[3] = _a3 * B[0] + _a4 * B[3];\
  A[4] = _a3 * B[1] + _a4 * B[4];\
  A[6] = _a6 * B[0] + _a7 * B[3] + B[6];\
  A[7] = _a6 * B[1] + _a7 * B[4] + B[7];\
}
@
\fimcodigo

Existem algumas transformações lineares que são muito mais comuns do
que outras. Para realizá-las mais facilmente vamos criar macros
especiais para elas. Por exemplo, rotacionar um vetor $(x, y, 1)$ em
relação ao ponto $(0, 0, 1)$ um ângulo $\theta$ é feito multiplicando
pela matriz:

$$\left[x\; y\; 1\right]
\matrix{cos(\theta)}{sin(\theta)}{0}{-\sin(\theta)}{cos(\theta)}{0}{0}{0}{1}
=\left[x\cdot cos(\theta) - y\cdot sin(\theta)\;\; x\cdot sin(\theta)
+ y\cdot cos(\theta)\;\; 1\right]
$$

Acumular a transformação acima sobre uma matriz é feito com a macro
seguinte:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_ROTATE(M, theta) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  double _cos_theta, _sin_theta;\
  _sin_theta = sin(theta);\
  _cos_theta = cos(theta);\
  M[0] = _m0 * _cos_theta - _m1 * _sin_theta;\
  M[1] = _m0 * _sin_theta + _m1 * _cos_theta;\
  M[3] = _m3 * _cos_theta - _m4 * _sin_theta;\
  M[4] = _m3 * _sin_theta + _m4 * _cos_theta;\
  M[6] = _m6 * _cos_theta - _m7 * _sin_theta;\
  M[7] = _m6 * _sin_theta + _m7 * _cos_theta;\
}
@
\fimcodigo

Outra transformação relevante é ampliar ou reduzir vetores, os
esticando ou comprimindo. Para fazer isso no eixo $x$, multiplicamos
pela seguinte matriz:

$$\left[x\; y\; 1\right]
\matrix{s}{0}{0}{0}{1}{0}{0}{0}{1}
=\left[sx\;\; y\;\; 1\right]
$$

O que é feito pela macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE_X(M, s) {\
  M[0] = M[0] * s;\
  M[3] = M[3] * s;\
  M[6] = M[6] * s;\
}
@
\fimcodigo

Fazer isso no eixo $y$ envolve a multiplicação:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{s}{0}{0}{0}{1}
=\left[x\;\; sy\;\; 1\right]
$$

E pra isso usamos a macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE_Y(M, s) {\
  M[1] = M[1] * s;\
  M[4] = M[4] * s;\
  M[7] = M[7] * s;\
}
@
\fimcodigo

E fazer isso nos dois eixos é feito simplesmente combinando ambas as
operações:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE(M, s) {\
  TRANSFORM_SCALE_X(M, s);\
  TRANSFORM_SCALE_Y(M, s);\
}
@
\fimcodigo

Uma translação, ou deslocamento é a única operação que exige que
usemos três dimensões ao invés de duas. Deslocar um vetor uma
distância $a$ na horizontal e uma distância $b$ na vertical é feito
pela transformação:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{0}{1}{0}{a}{b}{1}
=\left[x+a\;\; y+b\;\; 1\right]
$$

E essa multiplicação de matrizes é feita usando a seguinte macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SHIFT(M, a, b) {\
  M[6] = M[6] + a;\
  M[7] = M[7] + b;\
}
@
\fimcodigo

Inclinar com intensidade $s$ é uma operação feita pela multiplicação:

$$\left[x\; y\; 1\right]
\matrix{1}{0}{0}{s}{1}{0}{0}{0}{1}
=\left[x+sy\;\; y\;\; 1\right]
$$

Que realizamos sobre outras matrizes com a macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SLANT(M, s) {\
  M[0] = M[0] + s * M[1];\
  M[3] = M[3] + s * M[4];\
  M[6] = M[6] + s * M[7];\
}
@
\fimcodigo

A última transformação especial que iremos tratar aqui é a mudança de
escala no plano complexo. Isso significa multiplicar os pontos por um
par $(s, t)$, interpretado como um número complexo. Isso obtém ao
mesmo tempo tanto rotação como mudança de escala. É feito pela
multiplicação de matriz:

$$\left[x\; y\; 1\right]
\matrix{s}{t}{0}{-t}{s}{0}{0}{0}{1}
=\left[sx-ty\;\; tx+sy\;\; 1\right]
$$

Realizar esta multiplicação por outra matriz é feito com essa macro:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define TRANSFORM_SCALE_Z(M, s, t) {\
  float _m0 = M[0], _m1 = M[1], _m3 = M[3], _m4 = M[4], _m6 = M[6],\
        _m7 = M[7];\
  M[0] = _m0 * s - _m1 * t;\
  M[1] = _m0 * t + _m1 * s;\
  M[3] = _m3 * s - _m4 * t;\
  M[4] = _m3 * t + _m4 * s;\
  M[6] = _m6 * s - _m7 * t;\
  M[7] = _m6 * t + _m7 * s;\
}
@
\fimcodigo


\secao{2. Inicialização e Finalização}

Primeiro vamos definir a função de inicialização. O que ela fará será
armazenar em uma série de variáveis estáticas várias das funções que
iremos usar no programa, além de nos informar quantos píxels
correspondem a 1 pt. As variáveis que armazenarão tais informações são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

E a função de inicialização consiste em preencher tais variáveis:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>=
bool _Winit_metafont(void *(*t_alloc)(size_t),
                     void (*t_free)(void *),
                     void *(*p_alloc)(size_t),
                     void (*p_free)(void *),
                     uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
  @<Inicialização de Weaver Metafont@>
  return true;
}
@
\fimcodigo

A função de finalização também existe e à medida que adicionarmos mais
coisas à inicialização, poderemos precisar adicionar código
correspondente à finalização:

\iniciocodigo
@<Definição de Funções da API (metafont.c)@>=
void _Wfinish_metafont(void){
  @<Finalização de Weaver Metafont@>
}
@
\fimcodigo

\secao{3. Analisador Léxico}

A primeira coisa a criar para uma linguagem é seu analisador
léxico. Ele irá ler o código-fonte da linguagem presente em um arquivo
e irágerar uma lista de ``tokens'', sendo cada token a unidade mais
básica da linguagem, basicamente uma palavra.

METAFONT reconhece três tipos de tokens: numéricos, strings e
simbólicos. Na prática nós iremos dividir os tokens simbólicos em
diferentes tipos de subtokens para podermos armazená-los e lê-los de
maneira mais eficiente.

Um token numérico será representado internamente como um número em
ponto flutuante. Nisso iremos diferir do METAFONT original que usava
uma representação própria de números. Em nome de operações mais
rápidas, usaremos a forma moderna de representar números. Então essa é
a aparência de um token numérico:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>=
enum { // Tipos de Tokens
  TYPE_NUMERIC = 1, TYPE_STRING, TYPE_SYMBOLIC,
  // Os 3 primeiros tipos básicos (numérico, string e simbólico) estão acima.
  // Os outros serão colocados logo abaixo:
  @<METAFONT: Definição de Token Simbólico@>
  // E um último tipo que não deve ser usado:
  TYPE_INVALID_TOKEN
};
struct numeric_token{
  int type;   // Deve ser igual a 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

E isso é como representaremos tokens de strings:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct string_token{
  int type;   // Deve ser igual a 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

Nós iremos armazenar apenas os primeiros 5 bytes de cada string que
encontrarmos, mesmo que no código-fonte a string seja maior. Isso será
feito porque ao contrário do METAFONT original, a única utilidade para
strings aqui será indicar qual caractere Unicode deve estar associado
a cada glifo definido. Para isso nós precisamos de apenas 5 bytes (no
máximo 4 para o caractere mais o byte 0 final). E também podemos usar
eles para associar certos glifos a ligaduras como ``ff'', que também
cabe em 5 bytes.

Já no caso de tokens simbólicos, precisamos armazenar todo o seu
conteúdo para podermos saber qual token temos, e vamos alocar
dinamicamente de acordo com o tamanho do símbolo:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct symbolic_token{
  int type;   // Deve ser igual a 'TYPE_SYMBOLIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  void *var;
  char *value;
};
@
\fimcodigo

Também colocamos neste token o ponteiro \monoespaco{var}, já que ele
pode corresponder a uma variável, e por isso pode precisar apontar
para a região da memória com o conteúdo da variável.

Mas isso pode consumir mais espaço na memória do que é
necessário. Alguns símbolos são muito comuns e são definidos por
padrão na própria linguagem e podem usar menos espaço que isso. Por
exemplo, parênteses e vírgulas. Podemos representar eles com a
seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

Precisamos apenas definir para eles um tipo de token que indique o quê
eles são:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>=
TYPE_OPEN_PARENTHESIS,  // '('
TYPE_CLOSE_PARENTHESIS, // ')'
TYPE_COMMA,             // ','
TYPE_SEMICOLON,         // ';'
@
\fimcodigo

Podemos definir posteriormente muitos outros tipos de tokens
simbólicos reservados. Note que pelas regras da enumeração em C que
usamos, qualquer token cujo tipo é um número igual ou maior que 3 é
simbólico.

Todo token possui um ponteiro para um próximo token. Isso ocorre
porque eles geralmente formarão uma lista encadeada de tokens. Para
desalocar a memória ocupada por uma lista de tokens dada uma função de
desalocação e apagá-los, pode-se usar a seguinte função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Agora a função que fará a análise léxica. Ela receberá como argumento
a estrutura da fonte, uma função de alocação de memória e uma string
com caminho para arquivo com código-fonte METAFONT. Ela retornará uma
lista encadeada de tokens:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Análise Léxica: Regra 1@>
    @<Análise Léxica: Regra 2@>
    @<Análise Léxica: Regra 3@>
    @<Análise Léxica: Regra 4@>
    @<Análise Léxica: Regra 5@>
    @<Análise Léxica: Regra 6@>
    // Nenhuma regra aplicada: erro
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, como usamos o tipo \monoespaco{FILE}, precisamos inserir o
cabeçalho de entrada e saída padrão para podermos abrir e ler
arquivos:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

As regras para ler os tokens consiste em ler cada linha do código
fonte aplicando as seguintes regras para cada novo caractere lido:

1) Se o próximo caractere é um espaço ou um ponto que não é sucedido
por um dígito decimal ou um novo ponto, ignore-o e siga em frente.

\iniciocodigo
@<Análise Léxica: Regra 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

Como estamos usando a função \monoespaco{isdigit}, devemos inserir o
seguinte cabeçalho que a declara:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) Se o próximo caractere é o símbolo de porcentagem, ignore-o e
ignore todos os outros caracteres seguintes na linha. Este símbolo
marca o começo de comentários na linguagem.

\iniciocodigo
@<Análise Léxica: Regra 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) Se o próximo caractere é um dígito decimal ou um ponto seguido por
um dígito decimal, então o próximo token será numérico. E é formado
pela maior sequência possível de ser lida envolvendo dígitos decimais
e opcionalmente um único ponto representando o ponto decimal.

\iniciocodigo
@<Análise Léxica: Regra 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


4) Se o próximo caractere é uma aspa dupla, então o próximo token deve
ser uma string e será composto pela sequência de caracteres até a
próxima aspa dupla, que deve estar na mesma linha. Se existir uma aspa
dupla iniciando uma string, mas não existir outra para finalizar a
string na mesma linha, um erro será gerado.

\iniciocodigo
@<Análise Léxica: Regra 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

5) Se o próximo caractere for um parêntese, ponto-e-vírgula ou uma
vírgula, então o próximo token será um token simbólico formado por
este único caractere.

\iniciocodigo
@<Análise Léxica: Regra 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Caso contrário, o próximo token será simbólico e formado pela
sequência mais longa dentre 12 famílias de caracteres:

\iniciocodigo
@<Análise Léxica: Regra 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer é lido de acordo com as subregras 6-a a 6-l
  @<Análise Léxica: Regra A@>
  @<Análise Léxica: Regra B@>
  @<Análise Léxica: Regra C@>
  @<Análise Léxica: Regra D@>
  @<Análise Léxica: Regra E@>
  @<Análise Léxica: Regra F@>
  @<Análise Léxica: Regra G@>
  @<Análise Léxica: Regra H@>
  @<Análise Léxica: Regra I@>
  @<Análise Léxica: Regra J@>
  @<Análise Léxica: Regra K@>
  @<Análise Léxica: Regra L@>
  // De acordo com conteúdo do buffer, gera o próximo token
  @<Análise Léxica: Gera Token Simbólico Reservado@>
  @<Análise Léxica: Gera Token Simbólico Genérico@>
}
@
\fimcodigo


a) A primeira família de letras são as letras de A a Z maiúsculas e
minúsculas além do ``underline'' e dígitos. Um dígito não pode ser o
primeiro caractere da sequência, ou ele seria interpretado como um
token numérico.


\iniciocodigo
@<Análise Léxica: Regra A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) A segunda família são os símbolos de maior, menor, igual, dois
pontos e a barra vertical.

\iniciocodigo
@<Análise Léxica: Regra B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acento agudo e grave.

\iniciocodigo
@<Análise Léxica: Regra C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Mais e menos.

\iniciocodigo
@<Análise Léxica: Regra D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Barra, barra invertida e símbolo de multiplicação.

\iniciocodigo
@<Análise Léxica: Regra E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Ponto de interrogação e exclamação.

\iniciocodigo
@<Análise Léxica: Regra F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Cerquilha, ``e'' comercial, arroba e cifrão.

\iniciocodigo
@<Análise Léxica: Regra G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Acento circunflexo e til.

\iniciocodigo
@<Análise Léxica: Regra H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Abrir colchetes.

\iniciocodigo
@<Análise Léxica: Regra I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Fechar colchetes.

\iniciocodigo
@<Análise Léxica: Regra J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Abrir e fechar chaves.

\iniciocodigo
@<Análise Léxica: Regra K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Análise Léxica: Regra L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

Depois de ler todos os caracteres do próximo token, primeiro vemos se
estamos diante de um token simbólico reservado. Estes são tokens
simbólicos com o que seriam palavras-chave da linguagem. Podemos
identificá-los porque iremos armazenar uma lista de palavras-chave
reservadas da linguagem aqui:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static char* list_of_keywords[] = {
@<Lista de Palavras Reservadas@>
  NULL};
@
\fimcodigo

Sendo assim, sabemos que temos um token que corresponde a uma
palavra-chave reservada se ele estiver presente nesta lista terminada
em NULL. Se for o caso, geramos um token especial com um tipo
dependendo de sua posição na lista:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Reservado@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // O tipo de tokens reservados começa no 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(dealloc, first_token);
      return NULL;
    }
    @<Muda Tipo na Geração de Tokens em Casos Especiais@>
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(first_token == NULL)
      first_token = last_token = new_token;
    else{
      ((struct generic_token *) last_token) -> next = new_token;
      last_token = new_token;
    }
    continue;
  }
}
@
\fimcodigo

Para usar a função \monoespaco{strcmp}, precisamos do seguinte
cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>=
#include <string.h>
@
\fimcodigo

Se não for um token simbólico reservado, e se existir algo copiado
para o nosso buffer, então geramos um novo token simbólico genérico:

\iniciocodigo
@<Análise Léxica: Gera Token Simbólico Genérico@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Preenche Ponteiro para Variável Interna@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


\secao{4. Programas METAFONT}

Quando avaliamos um programa METAFONT, vamos precisar de duas
extruturas adicionais. A primeira delas, a qual chamaremos
de \monoespaco{struct metafont} irá conter as informações finais da
fonte tipográfica que foi lida e que terá tudo que for necessário para
que tal fonte possa ser usada para renderizar cada um dos glifos. A
segunda estrutura, a qual chamaremos de \monoespaco{struct context}
representa o estado atual do analisador sintático e representa
informações que devemos saber para poder continuar interpretando
corretamente uma lista de tokens. Essa segunda estrutura pode ser
descartada depois de terminarmos de ler os tokens de nossa fonte.

A primeira coisa que nosso analisador sintático precisa saber é que
todo programa METAFONT é uma sequência de declarações (possivelmente
vazia) finalizada por um token simbólico que
representa \monoespaco{end} ou \monoespaco{dump}:

\alinhaverbatim
<Programa> -> <Lista de Declarações> end | <Lista de Declarações> dump
\alinhanormal

Para nós não haverá nenhuma diferença entre \monoespaco{end}
e \monoespaco{dump}. No METAFONT original, o primeiro era usado para
finalizar o programa de uma fonte tipográfica e o segundo para
finalizar a descrição de um arquivo-base (algo como uma biblioteca
padrão básica).

Vamos definir então um novo tipo de token simbólico que será uma
abreviação deste símbolo de finalização, seja qual ele for:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>=
TYPE_END,  // O token simbólico 'end'
TYPE_DUMP, // O token simbólico 'dump'
@
\fimcodigo

E vamos adicionar tanto a palavra-chave \monoespaco{end}
como \monoespaco{dump} na lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>=
"end", "dump",
@
\fimcodigo

Mas para simplificar, não iremos usar o \monoespaco{TYPE\_DUMP}, ele
será sempre transformado em \monoespaco{TYPE\_END} para facilitar o
nosso código no analisador sintático:

\iniciocodigo
@<Muda Tipo na Geração de Tokens em Casos Especiais@>=
if(token_type == TYPE_DUMP)
  token_type = TYPE_END;
@
\fimcodigo

A primeira função de análise sintática que definiremos é a que
reconhece um programa inteiro. Ela basicamente checa se o programa é
corretamente finalizado e se não o for, retorna erro. Caso ele esteja
corretamente finalizado, ela passa o programa para a próxima função de
análise sintática que interpreta lista de declarações, marcando o
começo e o fim da lista de declarações:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  while(end != NULL && end -> type != TYPE_END)
    end = (struct generic_token *) (end -> next);
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file);
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, end);
}
@
\fimcodigo

A estrutura de contexto ainda não será definida inteiramente. Iremos
mostrar o conteúdo dela à medida que for necessário:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>=
struct context{
  @<Atributos (struct context)@>
};
@
\fimcodigo

E como indicado acima, um dos conteúdos de \monoespaco{struct
metafont} é o arquivo de onde saiu a fonte que ele representa. Também
vamos armazenar o que é necessário para alocar e desalocar a estrutura
e seus elementos:

\iniciocodigo
@<Estrutura de Dados (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Atributos (struct metafont)@>
};
@
\fimcodigo

Ambas as estruturas de dados terão uma função que as inicializa e as
finaliza:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct metafont *mf, struct context *cx);
@
\fimcodigo

A estrutura \monoespaco{metafont} precisa armazenar mais informações,
e também pode tanto ser alocada com a função permanente ou temporária
de alocação. Já o contexto sempre será temporário, e por isso sempre
será alocado e desalocado com as funções temporárias de memória.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Inicialização (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Inicialização (struct context)@>
  return cx;
}
@
\fimcodigo

Já a definição das funções que finalizam e desalocam as estruturas:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalização (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct metafont *mf, struct context *cx){
  if(temporary_free != NULL){
    @<Finalização (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo

O quão rápido executa o nosso código de inicialização e finalização
comparado ao METAFONT original? Para responder isso, foi feito um
``benchmark'' comparando a execução de um programa vazio formado só
pela palavra ``end'' ao ser interpretado pelo programa METAFONT
original e pela nossa implementação do Weaver Metafont. O teste foi
feito em um Ubuntu 20.04.4 rodando em um Intel(R) Core(TM) i5-3210M
CPU @ 2.50GHz com 4GB de RAM. O resultado é apresentado abaixo:


\vbox{%A forma mais geral de remover espaçamento entre linhas:
\baselineskip-1000pt\lineskip0pt\lineskiplimit16383.99999pt\tabskip0pt
\def\linha{\noalign{\hrule}}
\def\hidewidth{\hskip-1000pt plus 1fill}
\def\col{\hbox{\vrule height12pt depth3.5pt width0pt}}
\halign to15cm{\col#& \vrule#\tabskip=1em plus2em&
\hfil#& \vrule#& \hfil#\hfil& \vrule#&
\hfil#& \vrule#&\hfil#& \vrule#\tabskip=0pt\cr\linha
&&\omit\hidewidth Versão\hidewidth&&\omit\hidewidth
Tempo (s)\hidewidth&&
\omit\hidewidth Versão\hidewidth&&Tempo (s)&\cr\linha
&&METAFONT&&0,121&&Weaver Metafont&&0.001&\cr\linha}}

A diferença de valores se dá provavelmente devido ao fato do METAFONT
original necessariamente imprimir mensagens na tela e ter uma lista
muito maior de variáveis internas que precisam ser inicializadas. Além
disso, o programa original foi feito em uma versão primitiva de Pascal
onde não havia uma maneira padronizada de se lidar com strings,
números em ponto flutuante, etc. Tudo isso exigiu do METAFONT original
uma burocracia muito maior na inicialização e finalização para
preparar rotinas que lidam com tais tarefas básicas. Nada disso é
necessário em nossa implementação que já conta com um ambiente padrão
mais rico e com mais capacidades. Tudo o que temos que fazer é apenas
alocar memória necessária e realizar algumas inicializações mais
básicas.

\secao{5. Listas de Declarações}

Uma lista de declarações é uma série de declarações (potencialmente
vazias) sempre separadas por ponto-e-vírgula:

\alinhaverbatim
<Lista de Declarações> -> <Vazio> | <Declaração> ; <Lista de Declarações>
\alinhanormal

A função que iremos usar para avaliar e interpretar uma lista de
declarações é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

O que esta função fará será iterar sobre cada declaração e executar em
cada uma delas na ordem, a função de avaliação de declaração
individual. Para isso seu trabalho será ver onde cada declaração é
delimitada por cada ponto-e-vírgula e passar os limites de cada
declaração para essa próxima função de avaliação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  @<Antes de Avaliar Código@>
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
      if(!ret)
        return false;
      begin = end -> next;
    }
  }
  @<Depois de Avaliar Código@>
  return ret;
}
@
\fimcodigo

A função acima itera sobre cada declaração, passando direto por
declarações vazias, e para cada declaração não-vazia, faz com que os
ponteiros \monoespaco{begin} e \monoespaco{end} a delimitem. Durante a
iteração avançamos os ponteiros para os próximos tokens, mas cuidamos
para nunca sair de dentro da região delimitada
por \monoespaco{begin\_token\_list} e \monoespaco{end\_token\_list}.

\secao{6. Declaração Composta: Bloco Composto}

Uma declaração individual na linguagem pode na verdade ser composta
por muitas outras declarações. A sintaxe para isso é:

\alinhaverbatim
<Declaração> -> <Simples> | <Composta>
<Simples> -> <Vazia> | <Declaração de Variável> | <Atribuição> | <Comando>
<Composta> -> <Bloco Composto> | <Bloco Condicional> | <Declaração de Caractere>
<Bloco Composto> -> begingroup <Lista de Declarações> endgroup
<Bloco Condicional> -> if <Expressão Booleana> :
                         <Lista de Declarações>
                         <Alternativas>
                       fi
<Definição de Caractere> -> beginchar <Descrição de Caractere>
                              <Lista de Declarações>
                            endchar
\alinhanormal

Pela gramática acima, declarações podem ser simples ou compostas. As
simples podem ser vazias, declaração de variável, atribuição ou
comando. As declarações compostas são os blocos compostos (começam
com \monoespaco{begingroup} e terminam com \monoespaco{endgroup}),
comandos condicionais (começam com \monoespaco{if} e terminam
com \monoespaco{fi}) ou de definição de caractere (começam
com \monoespaco{beginchar} e terminam com \monoespaco{endchar}).

As declarações compostas são formadas por múltiplas declarações, já
que dentro delas há listas de outras declarações. Podem haver outras
declarações simples e compostas dentro de cada declaração
composta. Mas cada declaração composta deve ser iniciada e finalizada
na ordem correta. Se o último começo de declaração composta que lemos
foi um \monoespaco{begingroup}, se encontramos um \monoespaco{fi} ou
um \monoespaco{endchar}, o programa não está correto.

Para ler corretamente declarações compostas, devemos sevar em conta os
tokens que as delimitam, definidos abaixo:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_BEGINGROUP,            // O token simbólico 'begingroup'
TYPE_ENDGROUP,              // O token simbólico 'endgroup'
TYPE_IF,                    // O token simbólico 'if'
TYPE_FI,                    // O token simbólico 'fi'
TYPE_BEGINCHAR,             // O token simbólico 'beginchar'
TYPE_ENDCHAR,               // O token simbólico 'endchar'
@
\fimcodigo

E adicionamos eles à nossa lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"begingroup", "endgroup", "if", "fi", "beginchar", "endchar",
@
\fimcodigo

E agora a função que irá avaliar uma declaração individual. Como
visto, há 8 tipos diferentes de declarações:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Declaração: Vazia@>
  @<Declaração: Composta@>
  @<Declaração: Declaração de Variável@>
  @<Declaração: Atribuição@>
  @<Declaração: Comando@>
  // Se estamos aqui, não identificamos o tipo de declaração:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement (%s).\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line,
            list_of_keywords[((struct generic_token *) begin_token_list) -> type - 8]);
#endif
  return false;
}
@
\fimcodigo

No caso da declaração vazia, geralmente não precisaremos lidar com
ela. A função \monoespaco{eval\_list\_of\_statements} silenciosamente
as ignora antes de passar para cá. Mas só para o caso de uma delas
aparecer por outros motivo, vamos explicitamente aceitá-las como
válidas abaixo:

\iniciocodigo
@<Declaração: Vazia@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Agora vamos à declaração composta. A primeira coisa a lembrarmos é que
será importante para a linguagem saber em qual nível de aninhamento
estamos para saber o escopo de eventuais variáveis declaradas. Por
causa disso, o contexto de nossa análise deve memorizar o nível de
aninhamento atual. Cada início de declaração composta
(\monoespaco{begingroup}, \monoespaco{if}, \monoespaco{beginchar})
aumenta esse nível em 1 e cada fim de declaração composta
(\monoespaco{endgroup}, \monoespaco{fi}, \monoespaco{endchar}) diminui
o nível em 1. Também devemos saber qual o token que criou o último
nível de aninhamento caso estejamos aninhados em uma declaração
composta e devemos armazenar uma cópia do token esperado que o
finalizará em uma pilha. Desta forma, saberemos se uma declaração
composta está sendo finalizada pelo token correspondente. Declaramos o
nível de aninhamento atual e a pilha de tokens esperados de
finalização:

\iniciocodigo
@<Atributos (struct context)@>=
  int nesting_level;
  struct generic_token *end_token_stack;
@
\fimcodigo

O nível de aninhamento deve ser inicializada como zero e a pilha de
tokens de finalização deve ser vazia inicialmente:

\iniciocodigo
@<Inicialização (struct context)@>=
  cx -> nesting_level = 0;
  cx -> end_token_stack = NULL;
@
\fimcodigo

Para facilitar a escrita de código que lida com estes níveis de
aninhamento, vamos criar duas funções auxiliares. Ambas recebem
um \monoespaco{struct context} com o contexto de execução atual e um
token. A primeira deve aumentar em 1 o nível de aninhamento dado um
token que começa uma declaração composta e a segunda deve diminuir
dado um token que finaliza um nível de aninhamento. A primeira deve
retornar erro se receber um token incorreto que não inicia uma
declaração composta e a segunda também vai gerar erro se o token
passado não for o correto que finaliza o nível de aninhamento atual:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok);
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok);
@
\fimcodigo

A implementação da primeira função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool begin_nesting_level(struct metafont *mf, struct context *cx,
                         struct generic_token *tok){
  struct generic_token *end_token;
  end_token = (struct generic_token *)
                    temporary_alloc(sizeof(struct generic_token));
  if(end_token == NULL){
    fprintf(stderr, "ERROR: No memory.");
    return false;
  }
  switch(tok -> type){
  case TYPE_BEGINGROUP:
    end_token -> type = TYPE_ENDGROUP;
    break;
  case TYPE_IF:
    end_token -> type = TYPE_FI;
    break;
  case TYPE_BEGINCHAR:
    end_token -> type = TYPE_ENDCHAR;
    break;
  default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Invalid token beginning"
              " compound statement.\n", mf -> file,
              ((struct generic_token *) tok) -> line);
#endif
      return false;
  }
  cx -> nesting_level ++;
  end_token -> next = cx -> end_token_stack;
  cx -> end_token_stack = end_token;
  return true;
}
@
\fimcodigo

E a implementação da segunda função:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool end_nesting_level(struct metafont *mf, struct context *cx,
                       struct generic_token *tok){
  struct generic_token *end_tok = cx -> end_token_stack;
  if(end_tok == NULL || end_tok-> type != tok -> type){
#if defined(W_DEBUG_METAFONT)
    printf("DEBUG: end_tok: %p\n", end_tok);
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Invalid token ending"
            " compound statement.\n", mf -> file,
            ((struct generic_token *) tok) -> line);
#endif
    return false;
  }
  cx -> nesting_level --;
  cx -> end_token_stack = end_tok -> next;
  if(temporary_free != NULL)
    temporary_free(end_tok);
  return true;
}
@
\fimcodigo

Como exatamente uma declaração composta é avaliada? Primeiro lembre-se
que a função \monoespaco{eval\_list\_of\_statements} separa o código
em partes usando o ponto-e-vírgula como delimitador. Em seguida, ele
passa cada parte para a função \monoespaco{eval\_statement}. Esse
comportamento é um pouco ingênuo, pois declarações compostas são
declarações que podem possuir outras declarações e ponto-e-vírgula
dentro delas. Além disso, considere a seguinte lista de tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][T5];
\alinhanormal

Nessa sequência, os três primeiros tokens seriam passados para serem
avaliados. depois, seria o \monoespaco{[T3][T4]}. E por fim,
o \monoespaco{[endgroup]}. Mas vamos fazer as coisas um pouco
diferentes. Quando recebermos um \monoespaco{[begingroup][T5]},
devemos avaliar só ele iniciando um novo aninhamento. Esta é uma ordem
incorreta. Idealmente nós deveríamos primeiro
avaliar \monoespaco{[begingroup]}, iniciando um novo bloco de
aninhamento. Depois, cada uma das declarações dentro do bloco. Depois,
o fim do bloco com \monoespaco{[endgroup]}. E só então o
token \monoespaco{[T5]}.

Felizmente, é fácil tornar a avaliação nesta ordem. Isso pode ser
feito porque a função \monoespaco{eval\_statement} pode modificar a
posição do ponteiro que marca o fim da expressão que ela
avaliou. Sendo assim, ao receber os três primeiros tokens onde o
primeiro é um \monoespaco{[begingroup]}, ela pode tratar só o primeiro
token e colocar o ponteiro de fim da expressão nele. Isso faz com
que \monoespaco{eval\_list\_of\_statements} envie de novo
tokens \monoespaco{[T1][T2]} para serem avaliados.

O código para tratar então qualquer declaração que comece
com \monoespaco{begingroup } é:

\iniciocodigo
@<Declaração: Composta@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  begin_nesting_level(mf, cx, begin_token_list);
  *end_token_list = begin_token_list;
  return true;
}
@
\fimcodigo

Da mesma forma, se recebermos uma função que começa
com \monoespaco{endgroup}, nós tratamos só este priemiro token
encerrando o aninhamento do bloco:

\iniciocodigo
@<Declaração: Composta@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_ENDGROUP){
  if(!end_nesting_level(mf, cx, begin_token_list))
    return false;
  *end_token_list = begin_token_list;
  return true;
}
@
\fimcodigo

Esse também é um bom momento para avaliarmos o fim do programa, quando
há um token \monoespaco{end} (apesar dele não ser uma declaração
composta). Neste caso, devemos gerar um erro se estivermos dentro de
um aninhamento de declaração composta:

\iniciocodigo
@<Declaração: Composta@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_END){
  if(cx -> nesting_level > 0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Program ending with unclosed "
                    "compound statement.\n", mf -> file);
#endif
    return false;
  }
  @<Fim do Código: 'end' ou 'dump'@>
  return true;
}
@
\fimcodigo


\secao{7. Declaração de Variáveis}

A sintaxe para declarar variáveis é:

\alinhaverbatim
<Declaração de Variável> -> <Tipo> <Lista de Declaração>
<Tipo> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<Lista de Declaração> -> <Tag> | <Tag> , <Lista de Declaração>
\alinhanormal

Uma ``tag'' é basicamente um token simbólico sem um significado
pré-definido na linguagem. Por exemplo, ``\monoespaco{tag}'' é uma tag,
mas ``\monoespaco{begingroup}'' não é.

Para interpretar a declaração de variáveis, vamos então introduzir no
nosso analisador léxico os seguintes tokens especiais:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_T_BOOLEAN,               // O token simbólico 'boolean'
TYPE_T_PATH,                  // O token simbólico 'path'
TYPE_T_PEN,                   // O token simbólico 'pen'
TYPE_T_PICTURE,               // O token simbólico 'picture'
TYPE_T_TRANSFORM,             // O token simbólico 'transform'
TYPE_T_PAIR,                  // O token simbólico 'pair'
TYPE_T_NUMERIC,               // O token simbólico 'numeric'
@
\fimcodigo

E adicionamos todos à lsita de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


Quando uma variável é declarada, devemos fazer duas coisas:

1) Se a variável não existir no nível de aninhamento atual, devemos
alocar uma estrutura da memória para armazenar seu conteúdo. Se ela já
existir, um erro é gerado. A variável é inicialmente preenchida com um
valor padrão que depende de seu tipo. Ela não poderá ser usada antes
de ser inicializada.

2) Devemos percorrer a lista de tokens e procurar por ocorrências
desta variável mais adiante no mesmo nível de aninhamento, ou em
aninhamento inferior. E devemos atualizar o ponteiro destes tokens
para que apontem para a região de memória recém-alocada para esta
variável.

Como cada variável possui diferentes informações e conteúdo,
dependendo de seu tipo, o modo pelo qual cada uma delas é criada pode
diferir. O que todas as variáveis tem em comum é a seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
// Variável genérica
struct variable{
  int type;
  int nesting_level;
  void *next;
};
@
\fimcodigo

Todas armazenam primeiro o seu tipo, depois o nível de aninhamento em
que estão e um ponteiro para a próxima. Mas dependendo do tipo da
variável haverá mais informações após o ponteiro para a próxima.

Se estivermos diante de uma variável global, podemos querer preservar
e armazenar o nome da variável para o caso de querermos depois
modificar o seu valor dado o seu nome. Então vamos usar a seguinte
estrutura que armazena o nome e a variável:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

E a estrutura de dados da fonte possui ponteiros para as variáveis
globais com nome armazenado e as sem nome armazenado:

\iniciocodigo
@<Atributos (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

Tais ponteiros para variáveis são inicializados como NULL:

\iniciocodigo
@<Inicialização (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

Para desalocar a lista de variáveis globais, basta percorrer a lista
encadeada que elas formam. Algumas variáveis mais complexas precisarão
de operações adicionais para serem removidas, mas trataremos delas
posteriormente.

\iniciocodigo
@<Finalização (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável Global 'v'@>
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

Já desalocar a lista de variáveis globais com nomes preservados é
feito de maneira semelhante:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) (named -> var);
    next = (struct named_variable *) (named -> next);
    mf -> free(named -> name);
    @<Finaliza Variável Global 'v'@>
    mf -> free(v);
    mf -> free(named);
    named = next;
  }
}
@
\fimcodigo

No caso das variáveis que não são globais, elas serão armazenadas no
contexto, não na estrutura da fonte. Afinal, a duração delas será
sempre temporária:

\iniciocodigo
@<Atributos (struct context)@>=
  void *variables;
@
\fimcodigo

A lista de variáveis é inicializada como vazia:

\iniciocodigo
@<Inicialização (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

E finalizamos ela assim como finalizamos a lista de variáveis globais:

\iniciocodigo
@<Finalização (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finaliza Variável Local 'v'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

Agora vamos à interpretação da declaração de variável:

\iniciocodigo
@<Declaração: Declaração de Variável@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // Todos os tipos de declaração
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insere Variável Declarada@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

A inserção de uma nova variável segue a seguinte lógica:

\iniciocodigo
@<Insere Variável Declarada@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

A função que insere uma nova variável sem o nome é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

Ela aloca uma nova variável e a coloca no local indicado
por \monoespaco{target}:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    case TYPE_T_PAIR:
      var_size = sizeof(struct pair_variable);
      break;
    case TYPE_T_PATH:
      var_size = sizeof(struct path_variable);
      break;
    case TYPE_T_PEN:
      var_size = sizeof(struct pen_variable);
      break;
    case TYPE_T_PICTURE:
      var_size = sizeof(struct picture_variable);
      break;
    case TYPE_T_TRANSFORM:
      var_size = sizeof(struct transform_variable);
      break;
    case TYPE_T_BOOLEAN:
      var_size = sizeof(struct boolean_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Inicialização de Nova Variável@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Já inserir uma variável nova com o nome é feito com a seguinte função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

Ela funciona de maneira similar, apenas alocando a estrutura do nome e
colocando a nova variável ali:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));
  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL){
    mf -> named_variables = named;
  }  
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

E finalmente, a função que percorre uma lista de tokens procurando por
tokens simbólicos com o mesmo nome da variável alocada e fazendo o
ponteiro deles apontar para onde a variável está:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

A função percorre todos os tokens que vem depois do token com o nome
da nova variável e só para quando percorre a lista inteira ou quando
sai do nível de aninhamento atual para um onde a variável não existe
mais (quando acha um \monoespaco{endgroup} encerrando o nível de
aninhamento da variável):

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP || p -> type == TYPE_IF ||
       p -> type == TYPE_BEGINCHAR)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP || p -> type == TYPE_FI ||
            p -> type == TYPE_ENDCHAR)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Variáveis Numéricas}

Uma variável numérica será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparando uma variável numérica com uma variável genérica, a
diferença é a variável de ponto-flutuante \monoespaco{value} que
armazena o valor numérico. Durante a criação da variável, o valor é
inicializado como NaN, que para nós representa uma variável com valor
desconhecido:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

O uso da macro \monoespaco{NAN} requer que usemos o cabeçalho
matemático:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

No caso das variáveis numéricas, nada a mais é necessário durante a
finalização, já que não há nada muito complexo além de um número em
ponto flutuante nelas.

Entretanto, além de variáveis declaradas pelo usuário, a nossa versão
da linguagem Metafont irá possuir algumas variáveis internas numéricas
próprias. Elas sempre estarão presentes e não precisam ser
declaradas. Iremos ter ao todo três
delas: \monoespaco{pt}, \monoespaco{cm} e \monoespaco{mm}. Basicamente
elas irão armazenar quantos pixels correspondem a 1pt, 1cm e 1mm
respectivamente.

Tais variáveis numéricas internas serão armazenadas na estrutura
metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

Na inicialização alocamos espaço para as três variáveis e as preenchemos:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   pt;
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   28.3465 * pt; // 1cm = 28.3465pt
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   2.83465 * pt; // 1mm = 2.83465pt
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;

  }
}
@
\fimcodigo

Criamos as seguintes macros para acessar cada uma destas variáveis
mais facilmente:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

Para finalizar a estrutura metafont, devemos desalocar tais variáveis
internas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL)
  mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

Quando o nosso analisador léxico gera um novo token simbólico que não
é uma palavra reservada, ele já deve checar se este token tem o nome
de uma variável interna. Se tiver, o ponteiro para ela já é preenchido
corretamente:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\subsecao{7.2. Variáveis de Pares}

Uma variável de par serve para armazenar coordenadas de um ponto. Ela
será armazenada na seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct pair_variable{
  int type; // Deve ser 'TYPE_T_PAIR'
  int nesting_level;
  void *next;
  float x, y;
};
@
\fimcodigo

A diferença é que elas possuem espaço para dois valores em ponto
flutuante ao invés de um. Inicialmente vamos representar o primeiro
deles como NaN, para representar uma variável não-inicializada:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Variáveis de Transformação}

Se um variável de par é uma tupla de dois valores numéricos, uma
variável de transformação é uma tupla com seis valores
diferentes. Sejam os valores $(a, b, c, d, e, f)$, o que eles
representam é uma transformação linear na qual o par $(x, y)$ é
transformado em $(x', y')$ da seguinte forma:

$$\left[x\; y\;
      1\right]\matrix{c}{e}{0}{d}{f}{0}{a}{b}{1}=\left[x'\;\; y'\;\;
      1\right]
$$

Ou: $(x', y') = (a+cx+dy, b+ex+fy)$.

A ordem em que os elementos são representados pode parecer estranha,
mas é feito assim como compatibilidade com a linguagem METAFONT
original criada por Knuth.

Uma variável de transformação então simplesmente deve armazenar uma
transformação linear na forma de uma matriz:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct transform_variable{
  int type; // Deve ser 'TYPE_T_TRANSFORM'
  int nesting_level;
  void *next;
  float value[9];
};
@
\fimcodigo

Uma transformação com valores não-inicializados possui seu primeiro
valor marcado como NAN:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_TRANSFORM)
  ((struct transform_variable *) var) -> value[0] = NAN;
@
\fimcodigo

Existe uma variável de transformação interna que sempre estará
presente sem precisar ser declarada. É a
variável \monoespaco{identity}, que representa a ausência de uma
transformação. É uma transformação que não irá mudar o ponto. Ela é
representada pela tupla $(0, 0, 1, 0, 0, 1)$ e sua transformação na
forma matricial é representada pela multiplicação por uma matriz
identidade.

As variáveis internas de transformação serão armazenadas na estrutura
Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct transform_variable *internal_transform_variables;
@
\fimcodigo

Na inicialização o espaço para armazenar as variáveis internas será
alocado e as variáveis internas são inicializadas:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_transform_variables =
  (struct transform_variable *)
    mf -> alloc(sizeof(struct transform_variable));
if(mf -> internal_transform_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL; //ERRO: Sem memória suficiente
}
// A transformação 'identity':
mf -> internal_transform_variables[0].type = TYPE_T_TRANSFORM;
INITIALIZE_IDENTITY_MATRIX(mf -> internal_transform_variables[0].value);
@
\fimcodigo

A variável \monoespaco{identity} deve ser registrada como tendo a
primeira posição:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_TRANSFORM_IDENTITY 0
@
\fimcodigo

E durante a leitura do código-fonte, podemos já ajustar corretamente
todas as referências para esta variável colocando o valor correto de
seu endereço nos tokens lidos:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>+=
else if(!strcmp(buffer, "identity"))
  new_token -> var =
          &(mf -> internal_transform_variables[INTERNAL_TRANSFORM_IDENTITY]);
@
\fimcodigo

\subsecao{7.4. Variáveis de Caminhos}

Uma variável de caminho armazena uma sequência de pontos e uma
sequência de pontos de controle formando uma sequência de Curvas de
Beziér cúbicas.

Uma Curva de Beziér cúbica é definida por dois pontos de extremidade
($z_1$ e $z_4$) e dois pontos de controle ($z_2'$ e $z_3'$). Os dois
pontos de extremidade fazem parte da curva. Para obter todos os outros
pontos que fazem parte da curva à partir de quatro pontos $(z_1, z_2',
z_3', z_4)$, usa-se o seguinte procedimento:

1) Obtenha o ponto intermediário $z_{12}'$, que fica na metade do
caminho entre $z_1$ e $z_2'$, o ponto intermediário $z_{23}'$, que
fica no meio do caminho entre $z_2'$ e $z_3'$ e o ponto intermediário
$z_{34}'$, que fica no meio do caminho entre $z_3'$ e $z_4$.

2) Obtenha agora os dois pontos intermediários novos: $z_{123}'$, que
fica no meio do caminho entre $z_{12}'$ e $z_{23}'$ e o ponto
$z_{234}'$ que fica entre os pontos $z_{23}'$ e $z_{34}'$.

3) O novo ponto que faz parte da curva gerado é o ponto $z_{1234}$,
que fica no meio do caminho entre $z_{123}'$ e $z_{234}'$.

4) Gere os outros pontos da curva aplicando este procedimento
recursivamente sobre $(z_1, z_{12}', z_{123}', z_{1234})$ e sobre
$(z_{1234}, z_{234}', z_{34}', z_4)$.

É possível também obter uma fórmula para tais curvas. Dado dois pontos
de extremidade e dois de controle, todos os pontos intermediários
podem ser obtidos usando a fórmula abaixo, variando $t$ entre 0 e 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

A estrutura de dados que armazena a sequência de Curvas de Beziér
Cúbicas é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct path_points{
  float x, y; // Ponto de extremidade
  float u_x, u_y, v_x, v_y;   // Pontos de controle
  void *subpath;
};
struct path_variable{
  int type; // Deve ser 'TYPE_T_PATH'
  int nesting_level;
  void *next;
  bool cyclic;
  int length, total_length;
  struct path_points *points;
};
@
\fimcodigo

Basicamente seus pontos estarão apontados pelo
ponteiro \monoespaco{points}, um vetor de estrutura que terá um número
de elementos igual a \monoespaco{length}. Cada estrutura representará
um ponto $(x, y)$ ou então terá um ponteiro para outra variável de
caminho que contém um subcaminho (sempre que \monoespaco{subpath} não
for nulo, e nesta caso ignoraremos $x$ e $y$). Essa outra variável de
caminho pode conter recursivamente muitos pontos. Para armazenar a
quantidade total de pontos que o caminho contém recursivamente,
usamos \monoespaco{total\_length}. Enquanto a
variável \monoespaco{length} armazena apenas o tamanho do
array \monoespaco{points}.

Os pontos de controle definidos
por \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
e \monoespaco{v\_y} são os pontos de controle entre o ponto ou
subcaminho atual e o próximo, se houver. Caso seja um caminho cíclico,
os pontos de controle do último ponto ou subcaminho determinam como
ele será ligado ao primeiro ponto. Se não for cíclico, os pontos de
controle do último ponto são ignorados.

O modo como representaremos uma variável de caminho não-inicializada é
mantendo seu tamanho (\monoespaco{length}) como sendo igual a -1:

\iniciocodigo
@<Inicialização de Nova Variável@>=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
  ((struct path_variable *) var) -> points = NULL;
}
@
\fimcodigo

Quando vamos remover uma variável global, se ela for do tipo caminho e
estiver inicializada, precisamos remover a lista de pontos alocada:

\iniciocodigo
@<Finaliza Variável Global 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && mf -> free != NULL)
    path_recursive_free(mf -> free, path, false);
}
@
\fimcodigo

Se a variável não for global fazemos o mesmo, mas usando uma função de
desalocação para variáveis temporárias:


\iniciocodigo
@<Finaliza Variável Local 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL)
    path_recursive_free(temporary_free, path, false);
}
@
\fimcodigo

Como um caminho pode conter subcaminhos e cada um deles também pode
ter seus próprios subcaminhos, em tais casos usamos uma função
recursiva para desalocar memória. Dada a função de desalocação e um
ponteiro para uma variável de caminho, nós desalocamos todos os seus
subcaminhos e depois a desalocamos. A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer);
@
\fimcodigo

E sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path,
                         bool free_first_pointer){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].subpath != NULL)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath, true);
    }
    free_func(path -> points);
    if(free_first_pointer)
      free_func(path);
  }
}
@
\fimcodigo

\subsecao{7.5. Variáveis de Caneta}

Uma variável de caneta armazena a estrutura utilizada para desenhar
formas no METAFONT. As canetas especificam o diâmetro e formato das
linhas e pontos a serem desenhados. Elas são armazenadas na seguinte
estrutura:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
struct pen_variable;
@
\fimcodigo

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct pen_variable{
  int type; // Deve ser 'TYPE_T_PEN'
  int nesting_level;
  void *next;
  struct path_variable *format; // O formato como caminho cíclico
  int flags;
  struct pen_variable *referenced; // Não-nulo só em 'currentpen'
  float gl_matrix[9]; // Matriz de transformação OpenGL
  // As variáveis abaixo serão manipuladas só na Seção 10.
  GLuint gl_vbo; // Os vértices OpenGL após triangulação
  GLsizei indices; // Número de vértices presentes acima
  // Esta armazena o quão detalhada é a triangulação, necessária para
  // saber se devemos triangular novamente ou não em alguns casos:
  float triang_resolution; 
};
@
\fimcodigo

Aqui vamos dar uma breve explicação do que são cada uma destas
variáveis e por que elas são necessárias:

As variáveis \monoespaco{type}, \monoespaco{nesting\_level}
e \monoespaco{next} são comuns a todos os tipos de variáveis e não
apresentam novidade. Servem para que saibamos qual tipo de dado está
sendo armazenado na variável, qual o seu escopo e qual a próxima
variável caso ela esteja em uma lista encadeada.

A variável \monoespaco{format} especifica o formato de nossa caneta
como um caminho cíclico. No METAFONT original, era necessário que além
de cíclico, o caminho seja convexo. Para nós, será necessário apenas
que o caminho seja cíclico e simples. O que significa que o perímetro
do caminho não pode ter ter intersecções e cruzar consigo mesmo. Caso
isso não seja respeitado, o resultado será indefinido e não iremos
garantir que as canetas gerem o resultado esperado.

Não importa o quão complexo seja o formato da caneta, para que ele
possa ser desenhado na tela via OpenGL, ele deve ser convertido para
um conjunto de triângulos em um processo chamado de
triangulação. Detalhes sobre como triangular, ou mesmo se precisamos
triangular serão definidos pela variável \monoespaco{flags}. As flags
possíveis são:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define FLAG_CONVEX   1
#define FLAG_STRAIGHT 2
#define FLAG_CIRCULAR 4
#define FLAG_SQUARE   8
#define FLAG_NULL    16
@
\fimcodigo


A flag \monoespaco{FLAG\_CONVEX} armazena se estamos diante de um
formato convexo. Se esse for o caso, fazer a triangulação será um
processo muito simples. Poderemos usar um algoritmo muito mais simples
e rápido que fará tudo em O(n) quando precisarmos.

A flag \monoespaco{FLAG\_STRAIGHT} armazena se o formato de nossa caneta
é formado apenas por linhas retas, sem curvas. Se isso for verdade,
então quer dizer que uma vez que ele seja triangulado, nunca mais
precisaremos fazer isso novamente, mesmo que a caneta depois seja
ampliada ou reduzida. Se ela é formada só por linhas retas, os
triângulos são capazes de represerntar seu formato com perfeição, não
estamos usando nenhum tipo de aproximação. Por isso, não precisamos
gerar a triangulação novamente para poder mostrar mais detalhes
quando, por exempolo, a caneta se torna maior.

A flag \monoespaco{FLAG\_CIRCULAR} armazena se nós sabemos que a caneta
tem um formato circular. Neste caso, seremos capazes de fazer a
triangulação sem olhar para os pontos da variável de caminho
representando o formato.

A flag \monoespaco{FLAG\_SQUARE} armazena se a caneta é uma caneta
quadrada. Neste caso também não precisamos dos pontos da variável de
caminho e podemos usar uma triangulação já feita antes sem precisar
triangular novamente.

A flag \monoespaco{FLAG\_NULL} armazena se esta é uma caneta
nula. Neste caso ela nunca precisa ser triangulada, pois ela
representa um único ponto sem largura nem altura.

A variável \monoespaco{referenced} só poderá ter um valor não-nulo
quando estivermos nos referindo à caneta 'currentpen'. Neste caso, a
'currentpen' atuará como um ponteiro para outra caneta
definida. Devemos considerar então que 'currentpen' tem o formato e
triangulação da caneta apontada, mas a sua matriz de transformação
(descrita abaixo) na verdade deverá ser considerada como a matriz da
caneta apontada multiplicada pela matriz de \monoespaco{currentpen}.

A variável \monoespaco{gl\_matrix} armazena a matriz de transformação
OpenGL. Como as canetas possuem um formato bem-definido e não serão
depois subdivididos ou concatenados como podem ser os subcaminhos,
então podemos representar eventuais transformações lineares nela por
meio dessa matriz ao invés de ter que computar novos valores para seus
pontos.

As demais variáveis serão usadas mais na Seção
10. A \monoespaco{gl\_vbo} referenciará os vértices da caneta após ela
ser triangulada para poder ser desenhada. Se a caneta não foi
triangulada, seu valor será zero. Tais vértices, se existirem, estarão
armazenados na memória da placa de vídeo. Por
fim, \monoespaco{triang\_resolution} será uma medida interna do quão
detalhada é a triangulação. Ela ajudará a determinar se precisamos
criar uma triangulação mais detalhada, ou se a que temos já é a
suficiente.

Uma variável de caneta declarada, mas ainda não inicializada terá seu
formato igual ao ponteiro nulo, será não-circular e como ela ainda não
foi triangulada, terá seu ID de vértices OpenGL igual a zero.

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PEN){
  ((struct pen_variable *) var) -> format = NULL;
  ((struct pen_variable *) var) -> gl_vbo = 0;
  ((struct pen_variable *) var) -> indices = 0;
  ((struct pen_variable *) var) -> flags = false;
  ((struct pen_variable *) var) -> referenced = NULL;
}
@
\fimcodigo

O que significa que ao remover uma variável global e ela for de
caminho, devemos fazer a desalocação do formato e jogar fora os
vértices:

\iniciocodigo
@<Finaliza Variável Global 'v'@>=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && mf -> free != NULL)
    path_recursive_free(mf -> free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
}
@
\fimcodigo

Se a variável for local ao invés de global, nós fazemos o mesmo usando
uma função diferente de desalocação.

\iniciocodigo
@<Finaliza Variável Local 'v'@>+=
if(v -> type == TYPE_T_PEN){
  struct pen_variable *pen = (struct pen_variable *) v;
  if(pen -> format != NULL && temporary_free != NULL)
    path_recursive_free(temporary_free, pen -> format, true);
  if(pen -> gl_vbo != 0)
    glDeleteBuffers(1, &(pen -> gl_vbo));
  @<Finalizando Caneta Local 'pen'@>
}
@
\fimcodigo

Além das variáveis de caneta definidas pelo usuário, iremos suportar a
existência de duas outras variáveis interna de caneta. Uma delas será
chamada de \monoespaco{currentpen} e irá representar a caneta atual
com a qual iremos escrever e desenhar. A outra será uma caneta de
formato perfeitamente quadrado que estará já inicializada à disposição
do usuário e que deixamos já alocada para fins de melhor performance.

Tais variáveis serão armazenadas na estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct pen_variable *internal_pen_variables;
@
\fimcodigo

Na inicialização iremos alocar espaço para ambas e inicializaremos
elas. A variável \monoespaco{currentpen} por padrão começará sendo uma
caneta vazia e a \monoespaco{pensquare} será um quadrado de lado
1.

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_pen_variables = (struct pen_variable *)
                                 mf -> alloc(2 * sizeof(struct pen_variable));
if(mf -> internal_pen_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL;
}
mf -> internal_pen_variables[0].format = NULL; // A caneta 'currentpen'
mf -> internal_pen_variables[0].type = TYPE_T_PEN;
mf -> internal_pen_variables[0].flags = FLAG_NULL;
mf -> internal_pen_variables[0].referenced = NULL;
mf -> internal_pen_variables[0].gl_vbo = 0;
mf -> internal_pen_variables[0].indices = 0;
mf -> internal_pen_variables[1].format = NULL; // A caneta 'pensquare'
mf -> internal_pen_variables[1].type = TYPE_T_PEN;
mf -> internal_pen_variables[1].flags = FLAG_CONVEX | FLAG_STRAIGHT |
                                        FLAG_SQUARE;
mf -> internal_pen_variables[1].referenced = NULL;
mf -> internal_pen_variables[1].gl_vbo = 0;
mf -> internal_pen_variables[1].indices = 4;
{ // Inicializando a matriz de transformação de ambas
  int j;
  for(j = 0; j < 2; j ++)
    INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[j].gl_matrix);
}
@
\fimcodigo

As seguintes macros nos permitirão acessar mais fácil a posição de
cada variável interna:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_PEN_CURRENTPEN 0
#define INTERNAL_PEN_PENSQUARE  1
@
\fimcodigo

Para finalizar a estrutura metafont, devemos desalocar as variáveis
internas:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> free != NULL){
  if(mf -> internal_pen_variables[1].format != NULL){
    mf -> free(mf -> internal_pen_variables[1].format -> points);
    mf -> free(mf -> internal_pen_variables[1].format);
  }
  mf -> free(mf -> internal_pen_variables);
}
@
\fimcodigo

E ao ler um código-fonte, devemos ajustar corretamente os ponteiros
das variáveis que apontam para tais variáveis internas:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
else if(!strcmp(buffer, "currentpen"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]);
else if(!strcmp(buffer, "pensquare"))
  new_token -> var =
          &(mf -> internal_pen_variables[INTERNAL_PEN_PENSQUARE]);
@
\fimcodigo

A caneta '\monoespaco{currentpen}' é especial por ser a única caneta
que pode ao invés de ter um conteúdo próprio, referenciar o conteúdo
de outra caneta como um ponteiro. Mas o que acontece se desalocamos
uma caneta que era uma variável local, mas que era referenciada
pela \monoespaco{currentepen}? Fácil. Neste caso,
a \monoespaco{currentpen} volta a ter seu valor padrão e ser uma
caneta nula:

\iniciocodigo
@<Finalizando Caneta Local 'pen'@>=
if(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced == pen){
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].format = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].type = TYPE_T_PEN;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].flags = FLAG_NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].referenced = NULL;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].gl_vbo = 0;
  mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN].indices = 0;
}
@
\fimcodigo

\subsecao{7.6. Variáveis de Imagens}

Uma variável de imagem armazena uma imagem renderizada, possivelmente
por meio de pincéis e comandos de desenho do Weaver Metafont. Ao
contrário do METAFONT original, o Weaver Metafont requer que cada
imagem tenha um tamanho bem-definido. Todas elas terão uma altura e
largura. E além disso terão um índice representando uma textura
OpenGL, onde estará a iamgem renderizada:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct picture_variable{
  int type; // Deve ser 'TYPE_T_PICTURE'
  int nesting_level;
  void *next;
  int width, height;
  GLuint texture;
};
@
\fimcodigo

Uma variável de imagem que foi declarada, mas ainda não inicializada
terá altura e largura negativa, e seu índice de textura será zero:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_PICTURE){
  ((struct picture_variable *) var) -> width = -1;
  ((struct picture_variable *) var) -> height = -1;
  ((struct picture_variable *) var) -> texture = 0;
}
@
\fimcodigo

Ao remover uma variável global, se ela for de imagem, pedir via OpenGL
que a textura seja destruída caso exista:

\iniciocodigo
@<Finaliza Variável Global 'v'@>=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

Se a variável for local ao invés de global, nós fazemos o mesmo:

\iniciocodigo
@<Finaliza Variável Local 'v'@>+=
if(v -> type == TYPE_T_PICTURE){
  struct picture_variable *pic = (struct picture_variable *) v;
  if(pic -> texture != 0)
    glDeleteTextures(1, &(pic -> texture));
}
@
\fimcodigo

Existirá uma variável interna de imagem no Weaver Metafont chamada
de \monoespaco{currentpicture}. No início de todo programa esta
variável estará pré-declarada. Para criar uma lista de variáveis
internas de imagem, a declaramos na estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct picture_variable *internal_picture_variables;
@
\fimcodigo

E na inicialização deixamos a variável \monoespaco{currentpicture}
declarada, mas deixada como não-inicializada:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> internal_picture_variables = (struct picture_variable *)
                                   mf-> alloc(sizeof(struct picture_variable));
if(mf -> internal_picture_variables == NULL){
  if(disalloc != NULL)
    disalloc(mf);
  return NULL;
}
// A imagem 'currentpicture':
mf -> internal_picture_variables[0].type = TYPE_T_PICTURE;
mf -> internal_picture_variables[0].width = -1;
mf -> internal_picture_variables[0].height = -1;
mf -> internal_picture_variables[0].texture = 0;
@
\fimcodigo

Para deixar consistente com as outras variáveis internas, criamos esta
macro para nos referir à posição dela:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define INTERNAL_PICTURE_CURRENTPICTURE 0
@
\fimcodigo

No momento em que chegar a hora de desalocar as variáveis internas,
devemos eliminar a textura dela também caso ela tenha sido
inicializada:

\iniciocodigo
@<Finalização (struct metafont)@>+=
if(mf -> internal_picture_variables[0].texture != 0)
  glDeleteTextures(1, &(mf -> internal_picture_variables[0].texture));
if(mf -> free != NULL)
  mf -> free(mf -> internal_picture_variables);
@
\fimcodigo

E à medida que lemos um código fonte, devemos ajustar corretamente as
variáveis chamadas ``\monoespaco{currentpicture}'' para apontar para a
variável interna:

\iniciocodigo
@<Preenche Ponteiro para Variável Interna@>=
else if(!strcmp(buffer, "currentpicture"))
  new_token -> var =
          &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE]);
@
\fimcodigo

\subsecao{7.7. Variáveis Booleanas}

A mais simples de todas as variáveis, uma variável booleana armazena
somente verdadeiro ou falso. O formato de sua estrutura é:

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct boolean_variable{
  int type; // Deve ser 'TYPE_T_BOOLEAN'
  int nesting_level;
  void *next;
  short value;
};
@
\fimcodigo

O valor \monoespaco{value} armazenado pela variável será 0 se for
falso ou 1 se for verdadeiro. No caso de ser uma variável
não-inicializada, armazenaremos -1:

\iniciocodigo
@<Inicialização de Nova Variável@>+=
if(type == TYPE_T_BOOLEAN)
  ((struct boolean_variable *) var) -> value = -1;
@
\fimcodigo


\secao{8. Atribuições}

Atribuições são como fazemos com que as variáveis sejam inicializadas,
como modificamos seus valores e como armazenamos nelas o resultado de
expressões.

A sintaxe de uma atribuição é:

\alinhaverbatim
<Atribuição> -> <Variável> = <Lado Direito> |
                <Variável> := <Lado Direito>
<Lado Direito> -> <Expressão> | <Atribuição>
\alinhanormal

Isso significa que podemos realizar atribuições encadeadas, por
exemplo, todas as variáveis abaixo, se forem numéricas, passarão a
valer 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

Se no começo de uma declaração nós encontramos uma variável, então
certamente estamos diante de uma atribuição.

Vamos começar então ensinando ao nosso analizador léxico que ambos os
tokens ``\monoespaco{=}'' e ``\monoespaco{:=}'' são equivalentes,
representam a mesma coisa e tem significado especial:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_ASSIGNMENT,            // O token simbólico '='
TYPE_ASSIGNMENT2,           // O token simbólico ':='
@
\fimcodigo

Ambos os tipos de atribuição vão para a lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"=", ":=",
@
\fimcodigo

Mas vamos tratar ambos como sinônimos e transformar o segundo tipo no
primeiro para simplificar o código:

\iniciocodigo
@<Muda Tipo na Geração de Tokens em Casos Especiais@>+=
else if(token_type == TYPE_ASSIGNMENT2)
  token_type = TYPE_ASSIGNMENT;
@
\fimcodigo

Agora que temos este novo tipo de token, o código para avaliar uma
atribuição segue em seguida. O que ele faz é percorrer a atribuição
detectando todas as variáveis que deverão passar pela
atribuição. Enquanto faz isso, o código checa se todas estão
declaradas, se todas possuem o mesmo tipo, se tentamos atribuir para
algo que não é uma variável, se não colocamos um símbolo de atribuição
ou se está faltando uma expressão depois do último símbolo de
atribuição. Em qualquer um destes casos, um erro é gerado.

A parte que ainda não está sendo mostrada no código abaixo, mas será
definida nas próximas subseções é como avaliar a expressão após o
último símbolo de atribuição e como efetivamente fazemos a
atribuição. Isso porque o modo de fazer isso depende do tipo das
variáveis. DEpendendo do tipo delas, esperaremos encontrar um tipo
diferente de expressão, e realizar o armazenamento de tais variáveis
também será diferente. Estes detalhes veremos nas próximas subseções.

\iniciocodigo
@<Declaração: Atribuição@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  struct generic_token *begin_expression;
  int type = 0; // Tipo das variáveis na atribuição
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment (type: %d).\n",
              mf -> file,
              var -> line, var -> type);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Atribuição de Variável Numérica@>
  @<Atribuição de Variável de Par@>
  @<Atribuição de Variável de Transformação@>
  @<Atribuição de Variável de Caminho@>
  @<Atribuição de Variável de Caneta@>
  @<Atribuição de Variável de Imagem@>
  @<Atribuição de Variável Booleana@>
  return true;
}
@
\fimcodigo

\subsecao{8.1. Atribuições e Expressões Numéricas}

Como então realizar a atribuição de variáveis numéricas dado o código
acima? Usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável Numérica@>=
if(type == TYPE_T_NUMERIC){
  int i;
  bool ret;
  struct numeric_variable result;
  ret = eval_numeric_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_numeric_variable((struct numeric_variable *) var -> var,
                            &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

A função que efetivamente faz a atribuição é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source);

@
\fimcodigo

E a sua implementação bastante simples é essa:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source){
  target -> value = source -> value;
}
@
\fimcodigo

Agora passemos para definir como interpretar expressões numéricas.

\subsubsecao{8.1.1. Soma e Subtração: Normal e Pitagórica}

As regras iniciais de expressões numéricas seguem abaixo:

\alinhaverbatim
<Expressão Numérica> -> <Terciário Numérico>
<Terciário Numérico> -> <Secundário Numérico> |
                        <Terciário Numérico> <T-Op> <Secundário Numérico>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

Os símbolos de \monoespaco{+} e \monoespaco{-} corespondem à adição e
subtração. O símbolo \monoespaco{++} corresponde à soma pitagórica:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

Isso pode ser facilmente calculado em C usando a função da biblioteca
padrão matemática \monoespaco{hypot}.

Já o símbolo \monoespaco{+-+} corresponde à ``subtração pitagórica''
definida abaixo:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

Na subtração pitagórica, nós vamos usar a última definição envolvendo
a multiplicação de duas raízes quadradas em nossa implementação, pois
é a forma de cálculo que minimiza erros e presença de overflows e
underflows.

Os quatro operadores acima serão aqueles com a menor precedência. Tais
operações de soma e subtração serão feitas apenas depois que todas as
outras operações forem feitas.

Vamos agora aperfeiçoar o nosso analisador léxico para identificar e
gerar os tokens destes quatro operadores. Temos que criar tipos novos,
um para cada operador. Vamos aproveitar e criar tipos novos para
``['', ``]'', ``{'' e ``}'', pois vamos também precisar no nosso
analisador sintático:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_SUM,                   // O token simbólico '+'
TYPE_SUBTRACT,              // O token simbólico '-'
TYPE_PYTHAGOREAN_SUM,       // O token simbólico '++'
TYPE_PYTHAGOREAN_SUBTRACT,  // O token simbólico '+-+'
TYPE_OPEN_BRACKETS,         // O token simbólico '['
TYPE_CLOSE_BRACKETS,        // O token simbólico ']'
TYPE_OPEN_BRACES,           // O token simbólico '{'
TYPE_CLOSE_BRACES,          // O token simbólico '}'
@
\fimcodigo

E os adicionamos na lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo


Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo


As expressões numéricas começam nas expressões terciárias numéricas
onde aparecem essas somas e subtrações. Pelas regras de sintaxe, o que
temos que fazer é percorrer toda a expressão até chegar ao último
símbolo de soma ou subtração que não estiver delimitado por
parênteses, colchetes ou chaves.

Para ajudar com isso, as seguintes macros vão declarar variáveis para
armazenar o aninhamento de delimitadores como parênteses e chaves, vão
checar se o aninhamento está aumentando ou diminuindo e verificar se
estamos dentro de um aninhamento ou não:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define DECLARE_NESTING_CONTROL() int nesting_parenthesis = 0, \
                                      nesting_brackets = 0, \
                                      nesting_braces = 0;
#define COUNT_NESTING(p) if(p -> type == TYPE_OPEN_PARENTHESIS)           \
                               nesting_parenthesis ++;                    \
                             else if(p -> type == TYPE_CLOSE_PARENTHESIS) \
                               nesting_parenthesis --;                    \
                             else if(p -> type == TYPE_OPEN_BRACKETS)     \
                               nesting_brackets ++;                       \
                             else if(p -> type == TYPE_CLOSE_BRACKETS)    \
                               nesting_brackets --;                       \
                             else if(p -> type == TYPE_OPEN_BRACES)       \
                               nesting_braces ++;                         \
                             else if(p -> type == TYPE_CLOSE_BRACES)      \
                               nesting_braces --;
#define IS_NOT_NESTED() (nesting_parenthesis == 0 && nesting_brackets == 0 && \
                         nesting_braces == 0)
#define RESET_NESTING_COUNT() nesting_parenthesis = 0; \
                              nesting_brackets = 0; \
                              nesting_braces = 0;
@
\fimcodigo

Tudo que estiver do lado esquerdo
deve ser avaliado recursivamente como outra expressão terciária
numérica. Já o que estiver à direita será interpretado como uma
expressão secundária numérica. Por fim, se nenhum símbolo de soma e
subtração for encontrada, a expressão inteira será avaliada como uma
expressão secundária numérica.

Contudo, existem exceções, casos nos quais não devemos considerar os
tokens \monoespaco{+} e \monoespaco{-} como soma e subtração. Isso
ocorre quando tais símbolos estiverem no começo da expressão numérica,
ou então caso sejam precedidos por vírgula, abrir de colchetes,
símbolo de multiplicação, divisão, outro operador terciário ou então
um dos tokens seguintes que veremos mais
adiante: \monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}.

Se nós temos um token anterior (\monoespaco{prev}) e um atual
(\monoespaco{cur}), podemos checar se ele representa uma adição ou
subtração válida com a macro abaixo:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_OF &&                    \
          prev -> type != TYPE_POINT &&                 \
          prev -> type != TYPE_PRECONTROL &&            \
          prev -> type != TYPE_POSTCONTROL &&           \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo

O código abaixo interpreta as expressões numéricas terciárias e trata
a execução de operadores terciários, identificando-os corretamente com
ajuda da macro:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_PYTHAGOREAN_SUM ||
                          p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
                          IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_numeric_secondary(mf, cx, begin_secondary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM)
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT)
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM)
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Negative square root "
                " in pythagorean subtraction.\n", mf -> file,
                last_sum -> line);
#endif
        return false;
      }
    }
    return true;
  }
  else
    return eval_numeric_secondary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.2. Multiplicação e Divisão}

As regras para lidar com expressões secundárias são:

\alinhaverbatim
<Secundário Numérico> -> <Primário Numérico> |
                         <Secundário Numérico> <S-Op> <Primário Numérico>
<S-Op> -> * | /
\alinhanormal

Os operadores \monoespaco{*} e \monoespaco{/} são respectivamente a
multiplicação e divisão.

Vamos adicionar estes operadores à lista de palavras-chave reservadas
e definir seus tipos:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_MULTIPLICATION,        // O token simbólico '*'
TYPE_DIVISION,              // O token simbólico '/'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"*", "/",
@
\fimcodigo

A função que irá avaliar expressões secundárias é:

Vamos agora à avaliação das expressões. A função que as avalia para
expressões numéricas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct numeric_variable *result);
@
\fimcodigo

E a sua definição é muito semelhante à da função que avalia expressões
terciárias, exceto que ela lida com o cálculo de multiplicação e
divisão.

Entretanto, deve-se levar em conta que o token de divisão só deve ser
tratado neste estágio se aquilo que estiver antes e depois dele não
forem dois tokens numéricos. See forem, estamos diante de uma fração e
elas serão tratadas com um nível de precedência ainda maior. Por outro
lado, se já consideramos o token retrasado como uma fração, então
neste caso sim, o símbolo será de divisão, mesmo que esteja cercado de
tokens numéricos. Assim o código \monoespaco{1/3/1/3} é interpretado
como a divisão de duas frações $(1/3)/(1/3)$:


\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
                          p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_token_list &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ // Multiplicação ou divisão válida
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secondary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secondary(mf, cx, begin_expression, end_secondary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end_token_list, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION)
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){
      if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.\n",
                mf -> file, last_mul -> line);
#endif
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else
    return eval_numeric_primary(mf, cx, begin_expression,
                                end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.3. Módulo,
    Funções Trigonométricas, Exponenciais, Piso e Valores Aleatórios
    Uniformes}

As regras de expressões numéricas primárias é:

\alinhaverbatim
<Primário Numérico> -> <Átomo Numérico> |
                       length <Primário Numérico> | (...) |
                       <Operador Numérico> <Primário Numérico>
<Operador Numérico> -> sqrt | sind | cosd | log | exp | floor |
                       uniformdeviate |
                       <Operador de Multiplicador Escalar>
<Operador de Multiplicador  Escalar> -> + | - |
                       <Token Numérico Primário antes de var>
<Token Numérico Primário> -> <Token Numérico> / <Token Numérico> |
                             <Token Numérico não sucedido por ``/ num''>
\alinhanormal

O operador \monoespaco{length}, quando sucedido por um primário
numérico significa que queremos o módulo do valor. Ele pode ter outros
significados se sucedido por outro tipo de expressão primária.

O novo operador de módulo precisa ser adicionado à lista de palavras
reservadas. Vamos adicionar também os outros operadores da lista de
operadores numéricos. Os colchetes Já pertencem à esta lista:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_LENGTH,         // O token simbólico 'length'
TYPE_SQRT,           // O token simbólico 'sqrt'
TYPE_SIND,           // O token simbólico 'sind'
TYPE_COSD,           // O token simbólico 'cosd'
TYPE_LOG,            // O token simbólico 'log'
TYPE_EXP,            // O token simbólico 'exp'
TYPE_FLOOR,          // O token simbólico 'floor'
TYPE_UNIFORMDEVIATE, // O token simbólico 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

A função que interpreta uma expressão numéria primária será esta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result);
@
\fimcodigo

Podemos decidir qual regra deve ser aplicada na avaliação da expressão
numérica primária por meio de sete regras de interpretação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result){
  @<Primário Numérico: Regra 1@>
  @<Primário Numérico: Regra 2@>
  @<Primário Numérico: Regra 3@>
  @<Primário Numérico: Operadores Adicionais@>
  @<Primário Numérico: Regra 4@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

As regras são:

1) Se a expressão for composta por um único token, se começar com
``('' e terminar com ``)'' ou se for composta por três tokens, um
numérico, um \monoespaco{/} e outro numérico, então toda a expressão é
um átomo numérico:

\iniciocodigo
@<Primário Numérico: Regra 1@>=
if(begin_expression == end_expression ||
   (begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
    end_expression -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin_expression -> type == TYPE_NUMERIC &&
     begin_expression -> next != end_expression &&
     ((struct generic_token *) begin_expression -> next) -> type ==
       TYPE_DIVISION &&
     ((struct generic_token *) begin_expression -> next) -> next ==
       end_expression &&
     end_expression -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin_expression, end_expression,
                          result);
}
@
\fimcodigo

2) Se encontramos o operador \monoespaco{length}, apenas checamos se a
expressão depois dele é numérica, e se for, calculamos o seu
módulo. Se for de outro tipo, será definido depois como iremos
calcular. Isso assume que temos uma função que identifica o tipo de
uma expressão.

\iniciocodigo
@<Primário Numérico: Regra 2@>=
else if(begin_expression -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx,
                                             (struct generic_token *)
                                             begin_expression -> next,
                                             end_expression);
  if(expr_type == TYPE_T_NUMERIC){
    bool ret;
    struct numeric_variable num;
    ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                               begin_expression -> next,
                               end_expression, &num);
    if(!ret)
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Avalia 'length'@>
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "primary expression after 'length'.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;
  }
}
@
\fimcodigo

Note que identificar se estamos ou não em uma expressão numérica
primária envolve usar a
função \monoespaco{get\_primatry\_expression\_type}. Esta função é
definida na Subseção 8.8. Mas por hora, só é necessário saber que ela
recebe o começo e fim de uma expressão e à partir daí retorna o tipo
da expressão.

3) Se encontrarmos algum dos operadores numéricos, temos um operador
numérico seguido de um primário numérico.

O primeiro dos operadores numéricos é o de raíz quadrada:

\iniciocodigo
@<Primário Numérico: Regra 3@>=
else if(begin_expression -> type == TYPE_SQRT){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value < 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Square root "
            "of negative number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;
}
@
\fimcodigo

Em seguida, temos o \monoespaco{sind}, que interpreta o próximo número
em graus (``degrees'', por isso a letra ``d'' no fim) e calcula seu
seno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SIND){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = sinf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

O cálculo do cosseno:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_COSD){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 grau = 0,0174533 radianos
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Em seguida calculamos o logaritmo na base $e$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_LOG){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value <= 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Computing logarithm of "
            "non-positive number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = logf(num.value);
  return true;
}
@
\fimcodigo

E a exponencial correspondente à $exp x = e^x$:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_EXP){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = expf(num.value);
  return true;
}
@
\fimcodigo

O piso de um valor:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_FLOOR){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = floorf(num.value);
  return true;
}
@
\fimcodigo

Com relação ao operador \monoespaco{uniformdeviate}, o que ele faz é
gerar um número uniforme e aleatório entre 0 e o valor passado para o
operador. O modo que usaremos para fazer isso é gerar um número
aleatório em ponto flutuante entre 0 e 1, para em seguida
multiplicá-lo pelo operando.

Gerar um número em ponto flutuante entre 0 e 1 seguindo uma
distribuição próxima à uniforme, basicamente podemos gerar um inteiro
aleatório de 64 bits e multiplicá-lo por $2^{-64}$. Nem todos os valores
em ponto flutuante podem ser gerados desta forma, estaremos ignorando
valores menores que $2^{-64}$ e o arredondamento fará com que alguns
números mais próximos de 1 sejam mais comuns, embora a densidade
destes números mais comuns também seja menor. Entretanto, o resultado
será suficientemente próximo para nossos propósitos:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_UNIFORMDEVIATE){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;
  }
  return true;
}
@
\fimcodigo

O próximo operador numérico é o símbolo de \monoespaco{+}. Este
símbolo significa uma multiplicação por 1, e pode ser ignorado:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SUM){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  return true;
}
@
\fimcodigo

Já se tivermos um símbolo de \monoespaco{-}, então isso significa uma
multiplicação por -1:

\iniciocodigo
@<Primário Numérico: Regra 3@>+=
else if(begin_expression -> type == TYPE_SUBTRACT){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  result -> value *= -1;
  return true;
}
@
\fimcodigo


4) Nos demais casos, temos uma multiplicação escalar em que o escalar
é um token numérico primário, que não é sucedido
por \monoespaco{+}, \monoespaco{-} ou por outro token numérico. Para
lidar com isso, teremos que identificar o começo e o fim do token
numérico primário. Pelas regras ele é um único token numérico, ou
então três tokens (dois tokens numéricos separados pelo
token \monoespaco{/} representando uma fração). Depois de realizar a
separação, a primeira parte é multiplicada pela segunda (que é
interpretada como primário numérico):

\iniciocodigo
@<Primário Numérico: Regra 4@>=
else{
  bool ret;
  float token_value;
  struct generic_token *after_token;
  if(begin_expression -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  token_value = ((struct numeric_token *) begin_expression) -> value;
  after_token = (struct generic_token *) (begin_expression -> next);
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    after_token = (struct generic_token *) (after_token -> next);
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = (struct generic_token *) (after_token -> next);
  }
  ret = eval_numeric_primary(mf, cx, after_token, end_expression, result);
  if(!ret)
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Números Isolados e Valores Aleatórios Normais}

As regras finais para as expressões numéricas que iremos tratar são:

\alinhaverbatim
<Átomo Numérico> -> <Variável Numérica> |
                    <Token Numérico Primário> |
                    normaldeviate |
                    ( <Expressão Numérica> )
\alinhanormal

O único token novo a ser tratado é \monoespaco{normaldeviate}:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_NORMALDEVIATE,  // O token simbólico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"normaldeviate",
@
\fimcodigo

Este operador serve para gerar um novo número aleatório com uma
distribuição normal com média 0 e desvio padrão 1.

A função que interpreta átomos numéricos é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result);
@
\fimcodigo

Vamos decidir qual regra aplicar para interpretar o átomo primeiro com
base nele ser um único token ou não. E depois, aplicamos diferentes
regras em cada caso:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result){
  if(begin_expression == end_expression){
    @<Átomo Numérico: Regra 1@>
    @<Átomo Numérico: Regra 2@>
    @<Átomo Numérico: Regra 3@>
  }
  else{
    @<Átomo Numérico: Regra 4@>
    @<Átomo Numérico: Regra 5@>
  }
  return false;
}
@

1) Se temos um único token e ele é um token numérico, basta retornar o
seu valor:

\iniciocodigo
@<Átomo Numérico: Regra 1@>=
if(begin_expression -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin_expression) -> value;
  return true;
}
@
\fimcodigo

2) Se temos um único token e ele é uma variável, retornamos o conteúdo
da variável. Mas temos que checar se ela foi declarada, se é numérica
e se foi inicializada:

\iniciocodigo
@<Átomo Numérico: Regra 2@>=
if(begin_expression -> type == TYPE_SYMBOLIC){
  struct numeric_variable *var;
  var = ((struct symbolic_token *) begin_expression) -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric variable "
            "'%s' in numeric expression.\n", mf -> file,
            begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(isnan(var -> value)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

3) Por fim, se temos um único token e ele é \monoespaco{normaldeviate},
então temos que gerar um número aleatório de uma distribuição
normal. Dado que temos uma função que gera números aleatórios, podemos
fazer isso procedendo da seguinte forma:

a) Geramos dois números aleatórios e uniformes entre -1 e 1, os quais
chamaremos de $u$ e $v$. Isso pode ser feito obtendo 64 bits,
multiplicando os 63 primeiros por $2^{-63}$ e usando o último bit para
definir o sinal. O resultado é suficientemente próximo de uniforme
para nossos propósitos.

b) Se $u^2+v^2 \geq 1$, isso significa que eles correspondem a pontos
fora de um círculo de raio 1. Neste caso, os descartamos e voltamos ao
passo 1. Também voltamos ao passo um se ambos forem zero, pois neste
caso o método não funcionaria.

c) Isso permite gerar dois valores que terão uma distribuição
uniforme:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

Um dos valores pode ser retornado. O outro pode ser armazenado na
estrutura Metafont:

\iniciocodigo
@<Atributos (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Inicialmente a estrutura não tem nenhum valor destes armazenado, vamos
armazenar nela só depois de usarmos o método acima:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

Então, quando precisarmos gerar um valor aleatório de uma distribuição
normal, sempre verificamos se existe um valor pré-obtido, e se não nós
geramos os dois valores:

\iniciocodigo
@<Átomo Numérico: Regra 3@>=
if(begin_expression -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    random_bits = random_func();
    do{
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Agora os casos em que o átomo numérico tem mais de um token. O
primeiro caso é quanto o primeiro token é ``('' e o último é
``)''. Neste caso, a parte interna aos parênteses é interpretada como
uma expressão numérica:

\iniciocodigo
@<Átomo Numérico: Regra 4@>=
if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
   end_expression -> type == TYPE_CLOSE_PARENTHESIS){
   bool ret;
   struct generic_token *p = begin_expression;
   while(p -> next != end_expression)
     p = (struct generic_token *) p -> next;
   if(p == begin_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.",
            mf -> file, begin_expression -> line);
#endif
     return false;
   }
   ret = eval_numeric_expression(mf, cx, (struct generic_token *)
                                         begin_expression -> next, p,
                                         result);
   if(!ret)
     return false;
   return true;
}
@
\fimcodigo

5) Finalmente, o caso em que o átomo numérico é uma fração composta
por um token numérico, \monoespaco{/} e outro token numérico. O
resultado deve ser obtido dividindo ambos os tokens numéricos:

\iniciocodigo
@<Átomo Numérico: Regra 5@>=
if(begin_expression -> type == TYPE_NUMERIC &&
   end_expression -> type == TYPE_NUMERIC &&
   ((struct generic_token * ) begin_expression -> next) -> type ==
   TYPE_DIVISION){
  result -> value = ((struct numeric_token *) begin_expression) -> value /
           ((struct numeric_token *) end_expression) -> value;
  return true;
}
@
\fimcodigo


\subsecao{8.2. Atribuições e Expressões de Pares}

Para realizar a atribuição de pares a variáveis do tipo certo, usamos
o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Par@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pair_variable((struct pair_variable *) var -> var, &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

A declaração da função faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source){
  target -> x = source -> x;
  target -> y = source -> y;
}
@
\fimcodigo

Vamos agora à avaliação de expressões de pares.

\subsubsecao{8.2.1. Soma e Subtração}

As regras gramaticais para as expressões de pares começam com:

\alinhaverbatim
<Expressão de Par> -> <Terciário de Par>
<Terciário de Par> -> <Secundário de Par> | (...) |
                      <Terciário de Par> <PT-Op> <Secundário de Par>
<PT-Op> -> + | -
\alinhanormal

A soma e subtração é tratada exatamente como se espera de uma soma e
subtração de vetores.

A função que avalia expressões de pares é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result);
@
\fimcodigo

O método de avaliar as expressões de pares terciárias não é diferente
do que já fizemos com as expressões numéricas. Apenas temos menos
operadores terciários aqui.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secondary,
                       *last_sum = NULL, *p, *prev = NULL;
  DECLARE_NESTING_CONTROL();
  struct pair_variable a, b;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secondary = (struct generic_token *) (last_sum -> next);
    eval_pair_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_pair_secondary(mf, cx, begin_secondary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM){
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else
    return eval_pair_secondary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo


\subsubsecao{8.2.2. Transformações, Multiplicação e Divisão Escalar}

A gramática para expressões de pares secundárias é:

\alinhaverbatim
<Secundário de Par> -> <Primário de Par> |
                       <Par Secundário><Mul ou Div><Numérico Primário> |
                       <Secundário Numérico> * <Primário de Par> |
                       <Secundário de Par><Transformador>
<Mul ou Div> -> * | /
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> | (...)
\alinhanormal

Vamos adicionar as sete novas palavras-chave representando
transformadores:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_ROTATED,  // O token simbólico 'rotated'
TYPE_SCALED,   // O token simbólico 'scaled'
TYPE_SHIFTED,  // O token simbólico 'shifted'
TYPE_SLANTED,  // O token simbólico 'slanted'
TYPE_XSCALED,  // O token simbólico 'xscaled'
TYPE_YSCALED,  // O token simbólico 'yscaled'
TYPE_ZSCALED,  // O token simbólico 'zscaled'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo

A declaração da função que avaliará expressões secundárias de pares:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct pair_variable *result);
@
\fimcodigo


Interpretar uma expressão secundária aqui é similar ao que fizemos
para as expressões numéricas. Também devemos percorrer a lista de
tokens até achar a operação secundária mais à direita, ignorando
aquilo que está aninhado entre parênteses e colchetes. Deve-se seguir
as mesmas regras para determinar se o \monoespaco{/} é mesmo uma
divisão ou se é uma fração. Mas como aqui temos um total de nove
operadores secundários, incluindo os transformadores, devido à
quantidade, vamos mostrar separadamente cada um deles ao invés de
colocá-los todos neste bloco de código abaixo:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_secondary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct pair_variable *result){
  struct generic_token *end_secondary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             // O operador 'transformed' não foi ainda definido. Será visto na
             // Subsubseção 8.3.4.
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else{ //  Divisão ou operadores válidos
         last_mul = p;
         end_secondary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secondary != NULL){
    bool ret;
    begin_primary = (struct generic_token *) (last_mul -> next);
    @<Operador Secundário de Pares: Multiplicação@>
    @<Operador Secundário de Pares: Divisão@>
    @<Operador Secundário de Pares: Rotação@>
    @<Operador Secundário de Pares: Escala@>
    @<Operador Secundário de Pares: Deslocamento@>
    @<Operador Secundário de Pares: Inclinação@>
    @<Operador Secundário de Pares: X-Escala@>
    @<Operador Secundário de Pares: Y-Escala@>
    @<Operador Secundário de Pares: Z-Escala@>
    @<Operador Secundário de Pares: Operadores Adicionais@>
  }
  else
    return eval_pair_primary(mf, cx, begin_expression,
                             end_expression, result);
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O primeiro operador é o de multiplicação. Note que podemos ter dois
tipos de multiplicação: um par por um numérico ou um numérico por um
par. Para identificar qual dos dois tipos se aplica, devemos examinar
o tipo da expressão à direita do operador. Ela é uma expressão
primária e nós temos uma função que descobre o tipo de expressões
primárias:

\iniciocodigo
@<Operador Secundário de Pares: Multiplicação@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end_expression) ==
     TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    ret = eval_numeric_secondary(mf, cx, begin_expression, end_secondary,
                                 &a);
    if(!ret)
      return false;
    ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary,
                              &a);
    if(!ret)
      return false;
    ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }
}
@
\fimcodigo

Se temos uma divisão, então sempre será um par dividido por um
numérico. Devemos gerar erro em caso de divisão por zero:

\iniciocodigo
@<Operador Secundário de Pares: Divisão@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.",
            mf -> file, last_mul -> line);
#endif
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

Se temos uma rotação, rotacionamos nosso par no sentido anti-horário
em relação à origem, interpretando o ângulo em graus, não radianos:

\iniciocodigo
@<Operador Secundário de Pares: Rotação@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  theta = 0.0174533 * b.value;
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

Se temos uma mudança de escala, isso é sinônimo a uma multiplicação:

\iniciocodigo
@<Operador Secundário de Pares: Escala@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Um deslocamento é igual a uma soma, mas tem uma ordem de precedência
maior:

\iniciocodigo
@<Operador Secundário de Pares: Deslocamento@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

O operador de inclinação desloca mais à direita um ponto quanto mais
acima do eixo $x$ ele está e mais à esquerda quanto mais abaixo do
eixo $x$ ele está:

\iniciocodigo
@<Operador Secundário de Pares: Inclinação@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Mudança de escala no eixo $x$ multiplica um escalar apenas pelo
primeiro valor do par:

\iniciocodigo
@<Operador Secundário de Pares: X-Escala@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Assim como no eixo $y$ multiplica o escalar só pelo segundo valor do
par:

\iniciocodigo
@<Operador Secundário de Pares: Y-Escala@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Por fim, a mudança de escala $z$ înterpreta dois pares como números
complexos e os multiplica:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Operador Secundário de Pares: Z-Escala@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  ret = eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Valores Intermediários de Pares, Literais e Variáveis}

As regras gramaticais finais para a expressão de pares é:

\alinhaverbatim
<Primário de Par> -> <Variável de Par> |
                     ( <Expressão Numérica> , <Expressão Numérica> ) |
                     ( <Expressão de Par> ) |
                     (...) |
                     <Átomo Numérico>[<Expressão de Par,
                                      <Expressão de Par]  |
                     <Operador de Multiplicação Escalar><Primário de Par>
\alinhanormal

A novidade é a construção do tipo $a[b, c]$ onde $b$ e $c$ são
pares. Ela representa um valor intermediário entre os
pontos. Basicamente é avaliado como $a(b+c)$, de modo que $.5[b,c]$
representa o meio do caminho entre os dois pontos.

As outras regras são análogas às que já vimos na gramática de
expressões numéricas.

A função que avaliará expressões de pares primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result);
@
\fimcodigo

E cada uma das cinco regras gramaticais acima será testada
separadamente para sabermos qual regra devemos aplicar ao encontrar
uma expressão primária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result){
  if(begin_expression == end_expression){
    @<Primário de Par: Regra 1@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Primário de Par: Regra 2@>
    @<Primário de Par: Regra 3@>
  }
  @<Primário de Par: Outras Regras a Definir Depois@>
  @<Primário de Par: Regra 4@>
  @<Primário de Par: Regra 5@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

A primeira regra será aplicada quando temos um único token na
expressão. O único caso em que isso ocorre é quando a expressão é uma
variável de par:

\iniciocodigo
@<Primário de Par: Regra 1@>=
struct symbolic_token *tok = (struct symbolic_token *) begin_expression;
struct pair_variable *var;
if(tok -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable token "
          "in pair expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
var = (struct pair_variable *) tok -> var;
if(var == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
          "'%s'.\n", mf -> file, begin_expression -> line, tok -> value);
#endif
  return false;
}
if(var -> type != TYPE_T_PAIR){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Non-pair variable "
          "'%s' in pair expression.\n", mf -> file,
          begin_expression -> line, tok -> value);
#endif
  return false;
}
result -> x = var -> x;
result -> y = var -> y;
return true;
@
\fimcodigo

Se a expressão é delimitada por parênteses, nós tanto podemos estar
diante de uma representação literal de um par ($(a, b)$) como podemos
estar diante de parênteses com uma expressão de par completa dentro
dele, ao invés de um literal. Podemos diferenciar os dois casos pela
vírgula interna no parênteses, a qual está no mesmo escopo que $a$ e
$b$, não deve estar dentro de outros parênteses e colchetes.

\iniciocodigo
@<Primário de Par: Regra 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression (empty parenthesis).\n ", mf -> file,
              begin_expression -> line);
#endif
    return false;
  }
  begin_a = (struct generic_token *) begin_expression -> next;
  end_a = begin_a;
  DECLARE_NESTING_CONTROL();
  bool literal = true;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    bool ret;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    ret = eval_numeric_expression(mf, cx, begin_a, end_a, &a);
    if(!ret)
      return false;
    ret = eval_numeric_expression(mf, cx, begin_b, end_b, &b);
    if(!ret)
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

No código acima nós identificamos se estamos diante de um literal pela
presença da vírgula e nós identificamos isso marcando na variável
booleana \monoespaco{literal}. Portanto, se esta variável não for
verdadeira, imediatamente após o último \monoespaco{if} acima,
executamos o \monoespaco{else} como a próxima regra:

\iniciocodigo
@<Primário de Par: Regra 3@>=
else{
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
}
@
\fimcodigo

Se o último token for um \monoespaco{]}, então temos uma construção do
tipo $a[b,c]$. Nossa tarefa é separar essas três partes $a$, $b$ e
$c$, interpretá-las e retornar $a(b+c)$:

\iniciocodigo
@<Primário de Par: Regra 4@>=
else if(end_expression -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  DECLARE_NESTING_CONTROL();
  begin_a = begin_expression;
  end_a = begin_a;
  while(end_a != NULL){
    COUNT_NESTING(end_a);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_a -> next) -> type ==
        TYPE_OPEN_BRACKETS)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_b = (struct generic_token *) end_a -> next;
  begin_b = (struct generic_token *) begin_b -> next;
  if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_b = begin_b;
  while(end_b != end_expression){
    COUNT_NESTING(end_b);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_b -> next) -> type == TYPE_COMMA)
      break;
    if(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_c = (struct generic_token *) end_b -> next;
  begin_c = (struct generic_token *) begin_c -> next;
  if(begin_c == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_c = begin_c;
  while(end_c -> next != end_expression)
    end_c = (struct generic_token *) end_c -> next;
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c))
    return false;
  result -> x = (b.x + c.x) * a.value;
  result -> y = (b.y + c.y) * a.value;
  return true;
}
@
\fimcodigo

A última regra é quando temos um operador de multiplicação escalar e
um par. O operador pode ser um token
de \monoespaco{+}, \monoespaco{-}, um único token numérico, ou então
uma fração:

% Primario par

\iniciocodigo
@<Primário de Par: Regra 5@>=
else{
  bool ret;
  if(begin_expression -> type == TYPE_SUM)
    return eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
  else if(begin_expression -> type == TYPE_SUBTRACT){
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin_expression -> type == TYPE_NUMERIC){
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin_expression) -> value;
    tok = (struct generic_token *) begin_expression -> next;
    if(tok -> type == TYPE_DIVISION){
      tok = (struct generic_token *) begin_expression -> next;
      if(tok == end_expression || tok -> next == end_expression ||
         tok -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "expression.\n ", mf -> file, begin_expression -> line);
#endif
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = (struct generic_token *) tok -> next;
    }
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pares em Expressões Numéricas}

Subexpressões numéricas podem aparecer dentro de expressões de
pares. Por exemplo, em $a[b,c]$ onde $a$ é um átomo numérico. Da mesma
forma, subexpressões de pares podem aparecer em expressões
numéricas. Mas não definimos os casos quando definimos as expressões
numéricas porque então não tínhamos ainda definido como avaliar
expressões de pares. Existem quatro operadores numéricos primários que
envolvem avaliar pares:

\alinhaverbatim
<Primário Numérico> -> length <Par Primário> | xpart <Par Primário> |
                       ypart <Par Primário> | angle <Par Primário>
\alinhanormal

Isso requer definir os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_XPART,  // O token simbólico 'xpart'
TYPE_YPART,  // O token simbólico 'ypart'
TYPE_ANGLE,  // O token simbólico 'angle'
@
\fimcodigo

Correspondentes às seguintes palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

O primeiro caso, que não precisou de um token
novo, \monoespaco{length} já era usado para obter o módulo de números
e havíamos avisado que ele poderia ser usado para outros tipos. No
caso de pares, ele mede a norma euclideana deles:

\iniciocodigo
@<Avalia 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) hypot(p.x * p.x, p.y * p.y);
  return true;
}
@
\fimcodigo

O operador \monoespaco{xpart} simplesmente retorna o primeiro valor de
um par. Entretanto, devemos ter um cuidado adicional: este operador
pode ser usado em outro contexto como ainda será visto na Sub-subseção
8.3.3. Então devemos primeiro nos certificar que o que vem depois do
operador é um par. Em caso afirmativo, retornamos seu primeiro valor:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin_expression -> type == TYPE_XPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, (struct generic_token *)
                                                      begin_expression -> next,
                                                      end_expression);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                  begin_expression -> next, end_expression,
                                  &p))
      return false;
    result -> value = p.x;
    return true;
  }
  else{
    @<Primário Numérico: X-Part em Não-Par@>
  }
}
@
\fimcodigo

Enquanto o operador \monoespaco{ypart} retorna o segundo valor de um
par. Neste caso também devemos ter o mesmo cuidado de verificar se o
operando que temos depois é mesmo um par ou de algum outro tipo:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type == TYPE_YPART){
  struct pair_variable p;
  int expr_type = get_primary_expression_type(mf, cx, (struct generic_token *)
                                                      begin_expression -> next,
                                                      end_expression);
  if(expr_type == TYPE_T_PAIR){
    if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                  begin_expression -> next, end_expression,
                          &p))
      return false;
    result -> value = p.y;
    return true;
  }
  else{
    @<Primário Numérico: Y-Part em Não-Par@>
  }
}
@
\fimcodigo

Por fim, o último operador, \monoespaco{angle} retorna o ângulo de um
par. É o ângulo do segmento que conecta a origem ao par em relação ao
segmento que conecta a origem à $(1,0)$. Um erro deve ser gerado se
tentar medir o ângulo de $(0,0)$:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>=
else if(begin_expression -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Measuring the angle "
            "of (0,0).\n ", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = (float) asin(p.y / (hypot(p.x * p.x, p.y * p.y)));
  result -> value *= 57.2958; // Radianos para graus
  return true;
}
@
\fimcodigo

\subsecao{8.3. Atribuições e Expressões de Transformação}

Um dos momentos em que esperamos ter que avaliar uma expressão de
transformação quando formos fazer uma atribuição para uma variável de
transformação. Neste caso, devemos avaliar a expressão e realizar a
atribuição para todas as variáveis que estiverem do lado esquerdo da
expressão de atribuição:

\iniciocodigo
@<Atribuição de Variável de Transformação@>=
else if(type == TYPE_T_TRANSFORM){
  int i;
  struct transform_variable result;
  if(!eval_transform_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    memcpy(((struct transform_variable *) var -> var) -> value, result.value,
           sizeof(float) * 9);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Vamos agora ver como avaliar as expressões de transformação.

\subsubsecao{8.3.1. Transformações sobre Transformadores}

A regra gramatical para avaliar uma expressão de transformação começam
como:

\alinhaverbatim
<Expressão de Transformação> -> <Terciário de Transformação>
<Terciário de Transformação> -> <Secundário de Transformação>
<Secundário de Transformação> -> <Secundário de Transformação> <Transformador> |
                                 <Primário de Transformação>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário>
                   transformed <Primário de Transformação>
\alinhanormal

Temos aqui um novo tipo de token, representando o último tipo de
transformador que não havíamos definido na subseção anterior sobre
expressões de pares:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_TRANSFORMED,  // O token simbólico 'transformed'
@
\fimcodigo

Ele corresponde à seguinte palavra reservada:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"transformed",
@
\fimcodigo

Com relação às regras gramaticais, elas dizem que não existem no
momento operadores terciários de transformação. De qualquer forma,
vamos definir a função que avalia expressões, e avalia operadores
terciários apenas como uma função que chama o avaliador de operadores
secundários. Tanto para manter a uniformidade das funções que avaliam
expressões como para deixar essa função pronta para ser modificada
caso versões futuras da linguagem venham a trazer operadores
terciários de transformação.

A declaração da função:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expression,
                               struct generic_token *end_expression,
                               struct transform_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_expression(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expression,
                               struct generic_token *end_expression,
                               struct transform_variable *result){
  return eval_transform_secondary(mf, cx, begin_expression, end_expression,
                                  result);
}
@
\fimcodigo

Já a função que avalia expressões secundárias de transformação é esta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin_expression,
                              struct generic_token *end_expression,
                              struct transform_variable *result);
@
\fimcodigo

A função funciona percorrendo a lista de tokens da expressão,
ignorando tokens dentro de parênteses, colchetes e chaves. Toda vez
que encontra o último operador secundário, ele é armazenado em uma
variável. Depois de percorrer todos os tokens, se não achamos um
operador secundário, nós passamos a expressão inteira para o avaliador
de expressões primárias. Se encontramos um, tudo que vem antes dele é
avaliado como expressão secundária e o resultado passa pelo operador,
que será operador transformador.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_secondary(struct metafont *mf, struct context *cx,
                              struct generic_token *begin_expression,
                              struct generic_token *end_expression,
                              struct transform_variable *result){
  struct generic_token *p, *last_transform = NULL, *last_token = NULL,
                       *end_secondary = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() &&
       (p -> type == TYPE_ROTATED || p -> type == TYPE_SCALED ||
        p -> type == TYPE_SHIFTED || p -> type == TYPE_SLANTED ||
        p -> type == TYPE_XSCALED || p -> type == TYPE_YSCALED ||
        p -> type == TYPE_ZSCALED || p -> type == TYPE_TRANSFORMED)){
      last_transform = p;
      end_secondary = last_token;
    }
    last_token = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(last_transform == NULL)
    return eval_transform_primary(mf, cx, begin_expression, end_expression,
                                  result);
  else{
    if(end_secondary == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Transform expression began "
              "with transformer.",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_transform_secondary(mf, cx, begin_expression, end_secondary,
                                 result))
      return false;
    @<Aplica Operador Secundário de Transformação@>
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer "
            "in transform expression.",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Vamos agora aplicar os diferentes transformadores sobre as nossas
variáveis e resultados de transformação. O primeiro tipo de
transformador é a rotação, que aplicamos sobre um transformador com o
código abaixo:


\iniciocodigo
@<Aplica Operador Secundário de Transformação@>=
if(last_transform -> type == TYPE_ROTATED){
  struct numeric_variable theta;
  double angle_radian;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                           &theta))
    return false;
  // 1 grau = 0,0174533 radianos
  angle_radian = theta.value * 0.0174533;
  TRANSFORM_ROTATE(result -> value, angle_radian);
  return true;
}
@
\fimcodigo


Já mudar a escala de um transformador, ampliando ele $s$ vezes é feito
pelo código:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                           &scale))
    return false;
  TRANSFORM_SCALE(result -> value, scale.value);
  return true;
}
@
\fimcodigo

A próxima transformação é realizar uma translação, ou deslocamento
$(x, y)$ sobre uma transformação.

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SHIFTED){
  struct pair_variable shift;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end_expression,
                        &shift))
    return false;
  TRANSFORM_SHIFT(result -> value, shift.x, shift.y);
  return true;
}
@
\fimcodigo

Agora vamos tratar o transformador que inclina a nossa transformação
uma quantia $s$.

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_SLANTED){
  struct numeric_variable slant;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &slant))
    return false;
  TRANSFORM_SLANT(result -> value, slant.value);
  return true;
}
@
\fimcodigo

A mudança de escala somente no eixo $x$ estica ou comprime a
transformação neste eixo. Isso é obtido pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_XSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  TRANSFORM_SCALE_X(result -> value, scale.value);
  return true;
}
@
\fimcodigo

Podemos também fazer a mudança de escala somente no eixo $y$ usando o
fator de mudança $s$:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_YSCALED){
  struct numeric_variable scale;
  if(!eval_numeric_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  TRANSFORM_SCALE_Y(result -> value, scale.value);
  return true;
}
@
\fimcodigo

Por fim, há a mudança de escala no plano complexo, que envolve
multiplicar os pontos por um par $(s, t)$, interpretado como um número
complexo. Isso obtém ao mesmo tempo tanto rotação como mudança de
escala. Esse transformador é implementado pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_ZSCALED){
  struct pair_variable scale;
  if(!eval_pair_primary(mf, cx, last_transform -> next, end_expression,
                        &scale))
    return false;
  TRANSFORM_SCALE_Z(result -> value, scale.x, scale.y);
  return true;
}
@
\fimcodigo

Por fim, o último tipo de transformador. Quando temos duas
transformações e as multiplicamos para combiná-las em uma só:

$$\left[{{c \atop d}\atop
      {0\atop a}}{{e \atop f}\atop {0 \atop
      b}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{c' \atop d'}\atop
      {0\atop a'}}{{e' \atop f'}\atop {0 \atop
      b'}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
=
\left[{{cc'+ed' \atop dc'+fd'} \atop  {0\atop ac'+bd'+a'}}
      {{ce'+ef' \atop de'+ff'}\atop   {0 \atop ae'+bf'+b'}}
      {{0\atop 0}\atop{1 \atop 0}}
      {{0 \atop 0}\atop{0\atop 1}}\right]
$$

Essa combinação de transformações é implementada pelo código abaixo:

\iniciocodigo
@<Aplica Operador Secundário de Transformação@>+=
else if(last_transform -> type == TYPE_TRANSFORMED){
  struct transform_variable b;
  if(!eval_transform_primary(mf, cx, last_transform -> next, end_expression,
                            &b))
    return false;
  MATRIX_MULTIPLICATION(result -> value, b.value);
  return true;
}
@
\fimcodigo

\subsecao{8.3.2 Expressões Primárias de Transformação: Literais e Variáveis}

Continuando a gramática das expressões de transformadores, as próximas
regras são:

\alinhaverbatim
<Primário de Transformação> -> <Variável de Transformação> |
                               ( <Terciário de Transformação> ) |
                               ( <Expressão Numérica> , <Expressão Numérica> ,
                                 <Expressão Numérica> , <Expressão Numérica> ,
                                 <Expressão Numérica> , <Expressão Numérica> )
\alinhanormal

No primeiro caso, temos só um token simbólico com uma variável de
transformação. Nos dois outros casos, o primeiro Token é o abrir de
parênteses. No primeiro, há só uma expressão entre parênteses que
avaliará para um transformador. No segundo, temos seis expressões
numéricas que formarão os valores de nosso transformador.

A função que avaliará as expressões primárias de transformação é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct transform_variable *result);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_transform_primary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct transform_variable *result){
  if(begin_expression == end_expression &&
     begin_expression -> type == TYPE_SYMBOLIC){
    @<Transformação Primária: Variável@>
  }
  else if(begin_expression != end_expression &&
          begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS &&
          begin_expression -> next != end_expression){
    struct generic_token *p = begin_expression -> next;
    DECLARE_NESTING_CONTROL();
    bool has_comma = false;
    do{
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() && p -> type == TYPE_COMMA){
        RESET_NESTING_COUNT();
        has_comma = true;
        break;
      }
      if(p != end_expression)
        p = (struct generic_token *) p -> next;
      else
        p = NULL;
    } while(p != NULL && p != end_expression);
    if(has_comma){
      @<Transformação Primária: Literal@>
    }
    else{
      @<Transformação Primária: Parênteses@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transform primary "
          "expression.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O caso mais simples é quando estamos só lendo uma variável:

\iniciocodigo
@<Transformação Primária: Variável@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct transform_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not allocated variable: "
          "%s.\n", mf -> file, v -> line, v -> value);
#endif
  return false;
}
memcpy(result -> value, content -> value, sizeof(float) * 9);
return true;
@
\fimcodigo

O próximo caso que trataremos é quando temos uma subexpressão entre
parênteses. Devemos apenas avaliar ela após descartar os parênteses
delimitadores:

\iniciocodigo
@<Transformação Primária: Parênteses@>=
struct generic_token *end_expr;
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis in transform "
          "expression.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
for(end_expr = begin_expression -> next; end_expr -> next != end_expression;
    end_expr = end_expr -> next);
return eval_transform_expression(mf, cx, begin_expression -> next, end_expr,
                                 result);
@
\fimcodigo

E finalmente, quando temos um literal de transformação formado por
seis expressões numéricas separadas por vírgulas:

\iniciocodigo
@<Transformação Primária: Literal@>=
int i;
struct generic_token *begin_numeric_expr, *end_numeric_expr;
struct numeric_variable numeric_result;
begin_numeric_expr = begin_expression -> next;
end_numeric_expr = begin_numeric_expr;
float values[6];
for(i = 0; i < 6; i ++){
  p = begin_numeric_expr;
  do{
    if(p != end_expression){
      COUNT_NESTING(p);
    }
    if(IS_NOT_NESTED() && ((i < 5 && p -> type == TYPE_COMMA) ||
                            (i == 5 && p -> type == TYPE_CLOSE_PARENTHESIS))){
      break;
    }
    end_numeric_expr = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  } while(p != NULL);
  if(p == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Invalid transform literal in "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_numeric_expression(mf, cx, begin_numeric_expr, end_numeric_expr,
                              &numeric_result))
    return false;
  values[i] = numeric_result.value;
  begin_numeric_expr = p -> next;
  end_numeric_expr = begin_numeric_expr;
}
// Armazenando na ordem correta dentro da matriz:
result -> value[0] = values[2]; result -> value[1] = values[4];
result -> value[2] = 0.0;
result -> value[3] = values[3]; result -> value[4] = values[5];
result -> value[5] = 0.0;
result -> value[6] = values[0]; result -> value[7] = values[1];
result -> value[8] = 1.0;
return true;
@
\fimcodigo

\subsubsecao{8.3.3. Transformações em Expressões Numéricas}

Transformações podem aparecer dentro de expressões primárias
numéricas. Existem as seguintes regras gramaticais adicionais que as
prevêem:

\alinhaverbatim
<Primário Numérico> -> <Parte de Transformação><Primário de Transformação>
<Parte de Transformação> -> xpart | ypart | xxpart | xypart | yxpart | yypart
\alinhanormal

Os seis operadores acima servem para extrair cada um dos seis valores
numéricos que compõe uma transformação. A ordem em que aparecem acima
é a mesma ordem na qual eles extraem o elemento da transformação.

Como \monoespaco{xpart} e \monoespaco{ypart} já havia aparecido quando
definíamos as expressões de pares, resta definirmos tokens para os
outros quatro operadores que são novos:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_XXPART,  // O token simbólico xxpart'
TYPE_XYPART,  // O token simbólico xypart'
TYPE_YXPART,  // O token simbólico yxpart'
TYPE_YYPART,  // O token simbólico yypart'
@
\fimcodigo

E as palavras reservadas associadas a cada token:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"xxpart", "xypart", "yxpart", "yypart",
@
\fimcodigo

Estes quatro novos operadores são tratados na função que avalia
expressões numéricas primárias:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type >= TYPE_XXPART &&
         begin_expression -> type <= TYPE_YYPART){
  struct transform_variable t;
  if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                       begin_expression -> next, end_expression,
                             &t))
    return false;
  if(begin_expression -> type == TYPE_XXPART)
    result -> value = t.value[0];
  else if(begin_expression -> type == TYPE_XYPART)
    result -> value = t.value[3];
  else if(begin_expression -> type == TYPE_YXPART)
    result -> value = t.value[1];
  else if(begin_expression -> type == TYPE_YYPART)
    result -> value = t.value[4];
  return true;
}
@
\fimcodigo

Mas e quanto ao \monoespaco{xpart} e \monoespaco{ypart}? Em princípio,
eles já foram tratados para o caso em que extraimos valores de
pares. Precisamos apenas incrementar a definição já feita na
Sub-subseção 8.2.4. para tratar o caso em que devemos aplicá-la quando
não temos um par. Fazendo isso no caso do \monoespaco{xpart}:

\iniciocodigo
@<Primário Numérico: X-Part em Não-Par@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &t))
  return false;
result -> value = t.value[6];
return true;
@
\fimcodigo

O mesmo deve ser feito no operador \monoespaco{ypart}:

\iniciocodigo
@<Primário Numérico: Y-Part em Não-Par@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &t))
  return false;
result -> value = t.value[7];
return true;
@
\fimcodigo

\subsubsecao{8.3.4. Transformações em Expressões de Pares}

Transformações também aparecem nas regras gramaticais de expressões de
pares. Existe uma expressão secundária que obtém uma expressão
secundária de par do lado esquerdo e um primário de transformação do
lado direito:

\alinhaverbatim
<Secundário de Par> -> <Secundário de Par><Transformador>
<Transformador> -> (...) | transformed <Primário de Transformação>
\alinhanormal

O que este operador faz é aplicar a transformação linear sobre o
par. Vamos implementá-lo com o código adicional abaixo que irá se
somar ao código que implementa transformações sobre pares da
Subsubseção 8.2.2.

\iniciocodigo
@<Operador Secundário de Pares: Operadores Adicionais@>=
else if(last_mul -> type == TYPE_TRANSFORMED){
  struct pair_variable a;
  struct transform_variable b;
  if(!eval_pair_secondary(mf, cx, begin_expression, end_secondary, &a))
    return false;
  if(!eval_transform_primary(mf, cx, begin_primary, end_expression, &b))
    return false;
  result -> x = LINEAR_TRANSFORM_X(a.x, a.y, b.value);
  result -> y = LINEAR_TRANSFORM_Y(a.x, a.y, b.value);
  return true;
}
@
\fimcodigo

\subsecao{8.4. Atribuições e Expressões de Caminhos}

Para realizar a atribuição de caminhos a variáveis do tipo certo,
usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Caminho@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  if(!eval_path_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_path_variable(mf, (struct path_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &result, false);
}
@
\fimcodigo

A declaração da função faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> length != -1 && disalloc != NULL)
    path_recursive_free(disalloc, target, false);
  recursive_copy_points(alloc, &target, source, false);
}
@
\fimcodigo

Copiar um caminho recursivamente significa alocar espaço para o novo
caminho a ser copiado e copiar seus dados. Ao copiar seus pontos,
devemos também checar se há outros subcaminhos que devem ser copiados
recursivamente. Para fazer isso, usamos a seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target);
@
\fimcodigo

Essa função faz a alocação se necessário, obtém ponteiros necessários
e em seguida chama a função que efetivamente percorre recursivamente a
origem enquanto copia para o destino os pontos da origem:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source,
                          bool alloc_target){
  struct path_points *p;
  if(alloc_target)
    *target = (struct path_variable *) alloc(sizeof(struct path_variable));
  (*target) -> cyclic = source -> cyclic;
  (*target) -> length = source -> total_length;
  (*target) -> total_length = source -> total_length;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> total_length);
  p = (*target) -> points;
  recursive_aux_copy(&p, source);
}
@
\fimcodigo

A função que efetivamente percorre os pontos recursivamente e copia:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void recursive_aux_copy(struct path_points **dst, struct path_variable *origin){
  int index = 0;
  while(index <= origin -> length - 1){
    if(origin -> points[index].subpath == NULL &&
       !isnan(origin -> points[index].x)){
      // Copy:
      memcpy(*dst, &(origin -> points[index]),  sizeof(struct path_points));
      (*dst) -> subpath = NULL;
      (*dst) ++;
    }
    else if(origin -> points[index].subpath != NULL)
      recursive_aux_copy(dst, (struct path_variable *)
                              (origin -> points[index].subpath));
    index  ++;
  }
  return;
}
@
\fimcodigo


Vejamos agora a expressões que existem para expressões de caminhos:

\subsubsecao{8.4.1. Junção de Caminhos}

A gramática para a expressão de caminhos começa com:

\alinhaverbatim
<Expressão de Caminho> -> <Expressão de Par> | <Terciário de Caminho> |
                          <Sub-expressão de Caminho><Especificador de Direção> |
                          <Sub-expressão de Caminho><Junção de Caminho> cycle
<Junção de Caminho> -> <Especificador de Direção><Junção Básica>
                       <Especificador de Direção>
<Junção Básica> -> & | .. | .. <Tensão> .. | .. <Controles> .. | --
<Tensão> -> tension <Quantidade de Tensão> |
            tension <Quantidade de Tensão> and <Quantidade de Tensão>
<Quantidade de Tensão> -> <Primário Numérico> | atleast <Primário Numérico>
<Controles> -> controls <Par Primário> |
               controls <Par Primário> and <Par Primário>
<Especificação de Direção> -> Vazio |
                              { <Expressão de Par } |
                              { <Expressão Numérica> , <Expressão Numérica> }
<Sub-expressão de Caminho> -> <Expressão de Caminho> |
                              <Sub-expressão de Caminho><Junção de Caminho>
                              <Terciário de Caminho>
\alinhanormal

Tudo isso requer que registremos os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_CYCLE,          // O token simbólico 'cycle'
TYPE_AMPERSAND,      // O token simbólico '&'
TYPE_JOIN,           // O token simbólico '..'
TYPE_TENSION,        // O token simbólico 'tension'
TYPE_AND,            // O token simbólico 'and'
TYPE_ATLEAST,        // O token simbólico 'atleast'
TYPE_CONTROLS,       // O token simbólico 'controls'
TYPE_CURL,           // O token simbólico 'curl'
                     // (ainda não suportado)
TYPE_STRAIGHT_JOIN,  // O token simbólico '--'
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"cycle", "&", "..", "tension", "and", "atleast", "controls", "curl", "--",
@
\fimcodigo

O que as regras gramaticais revelam é que toda expressão de caminho é
formado pela junção de vários outros sub-caminhos. Se não existir
nenhuma junção, então nosso caminho é um par, que é considerado um
caminho de um único ponto.

Uma das coisas que temos a fazer então é contar quantas junções
existem em uma expressão de caminho. Realizar a contagem pode ser
feito com a seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end);
@
\fimcodigo

A função funciona contando o número de ``\&'', ``--'' e também contando os
``..'' quando eles aparecem sozinhos ou quando eles aparecem pela
segunda vez dentro de uma junção que especifica pontos de controle ou
tensão:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int count_path_joins(struct generic_token *begin, struct generic_token *end){
  int count = 0;
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin;
  while(p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_AMPERSAND)
        count ++;
      else if(p -> type == TYPE_STRAIGHT_JOIN)
        count ++;
      else if(p -> type == TYPE_JOIN){
        struct generic_token *next = (struct generic_token *) p -> next;
        if(p == end || (next -> type !=  TYPE_TENSION &&
                        next -> type != TYPE_CONTROLS))
          count ++;
      }
    }
    if(p != end)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }
  return count;
}
@
\fimcodigo

Agora podemos começar a tratar as expressões:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result);
@
\fimcodigo


Saber o número de junções é o primeiro passo para saber o tamanho da
variável de caminho que estamos gerando e saber como alocar espaço
para ela. O número de elementos (pontos e sub-caminhos) de uma
variável de caminho é sempre igual ao número de junções mais um:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct path_variable *result){
  int expected_length;
  int number_of_joins = count_path_joins(begin_expression, end_expression);
  expected_length = number_of_joins + 1;
  @<Expressão de Caminho: Quando Não Há Junção@>
  @<Expressão de Caminho: Alocar Variável de Caminho@>
  @<Expressão de Caminho: Itera sobre Junções@>
  return true;
}
@
\fimcodigo

E se o número de junções for zero? Neste caso, podemos estar diante de
uma expressão de par, ou de uma expressão terciária de caminho. De
qualquer forma, pode haver um ou mais especificador de direção depois
da expressão, o qual precisa ser ignorado. Podemos checar se temos
especificadores de direção checando se o último token é um
``$\}$''. Se for o caso, mudamos a posição do fim da expressão para
imediatamente antes do primeiro especificador de direção:

\iniciocodigo
@<Expressão de Caminho: Quando Não Há Junção@>=
if(number_of_joins == 0){
  if(end_expression -> type == TYPE_CLOSE_BRACES){
    struct generic_token *p = begin_expression;
    DECLARE_NESTING_CONTROL();
    while(p != end_expression){
      COUNT_NESTING(p);
      if(IS_NOT_NESTED() &&
         ((struct generic_token *) p -> next) -> type == TYPE_OPEN_BRACES)
        break;
      p = (struct generic_token *) p -> next;
    }
    end_expression = p;
  }
  return eval_path_tertiary(mf, cx, begin_expression, end_expression,
                            result);
}
@
\fimcodigo

Se existir uma ou mais junções, então caberá a nós criar uma nova
variável de caminho alocando as estruturas necessárias para ela. O que
temos a fazer é alocar nela um número de pontos igual à
variável \monoespaco{expected\_length}:

\iniciocodigo
@<Expressão de Caminho: Alocar Variável de Caminho@>=
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points) *
                     expected_length);
if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
          begin_expression -> line);
#endif
    return false;
}
result -> length = 0; // Inicialização
result -> total_length = 0;
result -> points[0].x = NAN;
result -> cyclic = false;
@
\fimcodigo

Agora temos que interpretar todas as junções. Temos que iterar sobre
cada junção presente na expressão, as quais possuem o formato:

$$
z_1{d} j {e}z_2
$$

Então vamos usar variáveis para indicar o começo e o fim de cada parte
à medida que iteramos. Vamos criar um laço onde iremos iterar sobre
cada uma das junções no formato acima para interpretá-las:

\iniciocodigo
@<Expressão de Caminho: Itera sobre Junções@>=
{
  struct generic_token *begin_z1, *end_z1 = NULL, *begin_z2, *end_z2;
  struct generic_token *begin_d = NULL, *end_d = NULL, *begin_e, *end_e;
  struct generic_token * begin_j, *end_j;
  struct path_points *z1_point = NULL, *z2_point = NULL;
  @<Expressão de Caminho: Declaração de Variáveis Adicionais@>
  begin_z1 = begin_expression;
  end_z1 = begin_z1;
  while(begin_z1 != end_expression || result -> length < expected_length){
    @<Expressão de Caminho: Separa Tokens da Junção@>
    @<Expressão de Caminho: Interpreta Extremidades da Junção@>
    @<Expressão de Caminho: Interpreta Direção se Existir@>
    @<Expressão de Caminho: Interpreta Junção@>
    @<Expressão de Caminho: Decide Forma da Curva@>
    @<Expressão de Caminho: Fim de Cada Iteração@>
    begin_z1 = begin_z2;
    end_z1 = end_z2;
  }
  
}
@
\fimcodigo

Para delimitar o primeiro elemento $z_1$, na primeira vez quando ainda
estamos no começo da expressão, basta avançarmos os tokens até
acharmos o primeiro ``{'', ``..'', ``\-\-'' ou ``\&'' fora de qualquer
parênteses ou colchetes. Nas demais vezes, o primeiro elemento $z_1$
já começa uma nova iteração delimitado como indicado no código acima.

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>=
if(begin_z1 == begin_expression){
  DECLARE_NESTING_CONTROL();
  int next_type;
  while(end_z1 != end_expression){
    COUNT_NESTING(end_z1);
    next_type = ((struct generic_token *) end_z1 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z1 = (struct generic_token *) end_z1 -> next;
  }
}
@
\fimcodigo

Agora vamos delimitar o primeiro especificador de direção. Primeiro
checamos se estamos no fim da expressão. Se estivermos, interrompemos
o laço e saímos, pois já terminamos de obter o resultado da expressão
e não haverá mais delimitador nenhum. Caso contrário, lemos o próximo
token para ver se é um ``$\{$''. Se não for, não há o primeiro
especificador de direção. Se for, então delimitamos ele até acharmos o
próximo ``$\}$'':

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_z1 == end_expression)
  return true;
begin_d = (struct generic_token *) end_z1 -> next;
if(begin_d -> type != TYPE_OPEN_BRACES){
  begin_d = NULL;
  end_d = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_d = begin_d;
  while(end_d  != end_expression){
    COUNT_NESTING(end_d);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_d) -> type == TYPE_CLOSE_BRACES)
      break;
    end_d = (struct generic_token *) end_d -> next;
  }
  if(begin_d == end_d){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_d -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Agora vamos delimitar a junção. Se ela for um ``\&'' ou um ``--'', ela
corresponde a um único token. Se for um ``..'', devemos checar o
próximo token para identificar se temos um ``\monoespaco{controls}''
ou ``\monoespaco{tension}''. Em caso afirmativo, teremos que delimitar
a junção englobando do primeiro ``..'' até o segundo ``..''. Em caso
negativo, a junção é somente um token ``..''.

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_d == NULL)
  begin_j = (struct generic_token *) end_z1 -> next;
else{
  if(end_d == end_expression)
    return true;
  begin_j = (struct generic_token *) end_d -> next;
}
end_j = begin_j;
if(begin_j -> type == TYPE_JOIN){
  struct generic_token *next_token;
  next_token = (struct generic_token *) begin_j -> next;
  if(next_token -> type == TYPE_CONTROLS || next_token -> type == TYPE_TENSION){
    DECLARE_NESTING_CONTROL();
    end_j = next_token;
    while(end_j != end_expression){
      COUNT_NESTING(end_j);
      if(IS_NOT_NESTED() && end_j -> type == TYPE_JOIN)
        break;
      end_j = (struct generic_token *) end_j -> next;
    }
  }
}
else if(begin_j -> type != TYPE_AMPERSAND &&
        begin_j -> type != TYPE_STRAIGHT_JOIN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, begin_j -> line);
#endif
  return false;
}
@
\fimcodigo

O próximo delimitador de direção pode existir ou não dependendo de
termos um token ``$\{$'' após a junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
if(end_j == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized path expression.\n",
          mf -> file, end_j -> line);
#endif
  return false;
}
begin_e = (struct generic_token *) end_j -> next;
if(begin_e -> type != TYPE_OPEN_BRACES){
  begin_e = NULL;
  end_e = NULL;
}
else{
  DECLARE_NESTING_CONTROL();
  end_e = begin_e;
  while(end_e  != end_expression){
    COUNT_NESTING(end_e);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_e) ->  type == TYPE_CLOSE_BRACES)
      break;
    end_e = (struct generic_token *) end_e -> next;
  }
  if(begin_e == end_e){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed brace '{'.\n",
            mf -> file, begin_e -> line);
#endif
    return false;
  }
}
@
\fimcodigo

E por fim, o último elemento da junção é o próximo ponto da junção,
que seria uma expressão de caminho terciária. Este próximo elemento
tem seu fim delimitado pelo fim da expressão, por um token de abrir
chaves, ou pelo começo da próxima junção:

\iniciocodigo
@<Expressão de Caminho: Separa Tokens da Junção@>+=
{
  DECLARE_NESTING_CONTROL();
  int next_type;
  if(end_e == NULL)
    begin_z2 = (struct generic_token *) end_j -> next;
  else{
    if(end_e == end_expression)
      return true;
    begin_z2 = (struct generic_token *) end_e -> next;
  }
  end_z2 = begin_z2;
  while(end_z2 != end_expression){
    COUNT_NESTING(end_z2);
    next_type = ((struct generic_token *) end_z2 -> next) -> type;
    if(IS_NOT_NESTED() &&
       (next_type == TYPE_OPEN_BRACES || next_type == TYPE_JOIN ||
        next_type == TYPE_AMPERSAND || next_type == TYPE_STRAIGHT_JOIN))
      break;
    end_z2 = (struct generic_token *) end_z2 -> next;
  }
}
@
\fimcodigo

Uma vez que tenhamos identificado cada parte da junção, temos que
interpretar cada uma delas. Primeiro devemos identificar os pontos das
extremidades da junção e copiá-las para o resultado da expressão. Para
isso primeiro interpretaremos $z_1$, a primeira extremidade de
junção. Ela precisa ser interpretada só no começo da expressão, nos
demais casos ela já foi obtida na iteração anterior:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>=
if(begin_z1 == begin_expression){
  bool ret;
  struct path_variable z1;
  ret = eval_path_tertiary(mf, cx, begin_z1, end_z1, &z1);
  if(!ret)
    return false;
  if(z1.length == 1 && z1.points[0].subpath == 0){
    result -> points[0].subpath = NULL;
    result -> points[0].x = z1.points[0].x;
    result -> points[0].y = z1.points[0].y;
    result -> total_length ++;
  }
  else{
    recursive_copy_points(temporary_alloc, (struct path_variable **)
                                           &(result -> points[0].subpath), &z1,
                                           true);
    result -> total_length += ((struct path_variable *)
                                result -> points[0].subpath) -> total_length;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z1, false);
}
@
\fimcodigo

E devemos fazer o mesmo com a outra extremidade da junção: $z_2$. Para
este caso, devemos levar em conta que podemos estar diante de um
token \monoespaco{cycle} ou de um ponto ou sub-caminho normal. Se for um
token \monoespaco{cycle}, devemos copiar o primeiro ponto. Caso
contrário, fazemos tal como fizemos para obter o $z_1$:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  struct path_points *p = result -> points;
  while(p[0].subpath != NULL)
    p = ((struct path_variable *) p[0].subpath) -> points;
  result -> points[result -> length].subpath = NULL;
  result -> points[result -> length].x = p[0].x;
  result -> points[result -> length].y = p[0].y;
  result -> points[result -> length].u_x = p[0].u_x;
  result -> points[result -> length].u_y = p[0].u_y;
  result -> points[result -> length].v_x = p[0].v_x;
  result -> points[result -> length].v_y = p[0].v_y;
  result -> length ++;
  result -> total_length ++;
  result -> cyclic = true;
}
else{
  bool ret;
  struct path_variable z2;
  ret = eval_path_tertiary(mf, cx, begin_z2, end_z2, &z2);
  if(!ret)
    return false;
  if(z2.length == 1 && z2.points[0].subpath == 0){
    result -> points[result -> length].subpath = NULL;
    result -> points[result -> length].x = z2.points[0].x;
    result -> points[result -> length].y = z2.points[0].y;
    result -> total_length ++;
  }
  else{
    recursive_copy_points(temporary_alloc,
                         (struct path_variable **)
                         &(result -> points[result -> length].subpath), &z2, true);
    result -> total_length +=
        ((struct path_variable *)
            result -> points[result -> length].subpath) -> total_length;
  }
  result -> length ++;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &z2, false);
}
@
\fimcodigo

Após rodarmos o código acima, nossa variável de resultado da expressão
que estamos montando já possui todos os pontos de extremidade desta
junção ajustados. Mas nós ainda não temos os pontos de controle. Mas
antes de poder calculá-los, vamos ajustar os
ponteiros \monoespaco{z1\_point} e \monoespaco{z2\_point} para apontar
para os pontos de extremidade da junção atual, obtendo tal informação
da variável \monoespaco{result} que estamos preenchendo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Extremidades da Junção@>+=
z1_point = &(result -> points[result -> length - 2]);
while(z1_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z1_point -> subpath;
  z1_point = &(p -> points[p -> length - 1]);
}
z2_point = &(result -> points[result -> length - 1]);
while(z2_point -> subpath != NULL){
  struct path_variable *p = (struct path_variable *) z2_point -> subpath;
  z2_point = &(p -> points[0]);
}
@
\fimcodigo

Agora temos que interpretar os dois especificadores de direção. Eles
podem ser vazios (equivalente a ter uma direção $(0, 0)$) ou podem ser
um par especificando um vetor de direção.

Vamos armazenar os especificadores em variáveis \monoespaco{(w0\_x,
w0\_y)} e \monoespaco{(w1\_x, w1\_y)}.  Também vamos armazenar estes
valores da iteração anterior e também da próxima, já que em alguns
casos será necessário lembrar o que havia antes ou espiar o que existe
depois para montarmos uma curva levando em conta um contexto maior:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>=
float w0_x = NAN, w0_y = NAN, w1_x = NAN, w1_y = NAN;
float prev_w_x = NAN, prev_w_y = NAN;
float next_w_x = NAN, next_w_y = NAN;
@
\fimcodigo

Durante a iteração em que estamos delimitando e interpretando os
valores presentes na junção devemos reinicializar tais valores. O
primeiro dos especificadores atuais não precisa ser lido novamente e
só herda valores já armazenados se por algum motivo ele foi lido
anteriormente e está armazenado na variável que na iteração anterior
armazenou o que seria o próximo valor. Depois disso, os próximos
valores são apagados. E por fim, lemos o segundo especificador de
direção:

\iniciocodigo
@<Expressão de Caminho: Interpreta Direção se Existir@>=
w0_x = w0_y = w1_x = w1_y = NAN;
if(!isnan(next_w_x)){
  w0_x = next_w_x;
  w0_y = next_w_y;
}
else if(!eval_direction_specifier(mf, cx, begin_d, end_d, &w0_x, &w0_y))
  return false;
next_w_x = next_w_y = NAN;
if(!eval_direction_specifier(mf, cx, begin_e, end_e, &w1_x, &w1_y))
  return false;
@
\fimcodigo

A função que avalia os especificadores de direção é declarada aqui:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y);
@
\fimcodigo

E ela funciona checando quatro casos diferentes: quando não há
especificador nenhum, quando ele é especificador de curvatura, quando
é um de direção no formato de dois números e quando é um de direção no
formato de um par:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_direction_specifier(struct metafont *mf, struct context *cx,
                              struct generic_token *begin,
                              struct generic_token *end, float *w_x,
                              float *w_y){
  @<Especificador de Direção: Caso 1@>
  @<Especificador de Direção: Caso 2@>
  @<Especificador de Direção: Caso 3@>
  return false;
}
@
\fimcodigo

Quando um especificador não existe, não marcamos nada e retornamos,
deixando como indefinidos os valores:

\iniciocodigo
@<Especificador de Direção: Caso 1@>=
if(begin == NULL || end == NULL){
  return true;
}
@
\fimcodigo

Agora devemos checar se temos um caso do tipo ``$\{ a , b\}$'' onde
$a$ e $b$ são números. Para isso, tentaremos delimitar os tokens de
$a$ e $b$ procurando pela vírgula. Mas somente se a vírgula for
encontrada, iremos tratar a especificação desta forma:

\iniciocodigo
@<Especificador de Direção: Caso 2@>=
DECLARE_NESTING_CONTROL();
struct generic_token *begin_a, *end_a, *begin_b = NULL, *end_b;
begin_a = (struct generic_token *) begin -> next;
end_a = begin_a;
while(end_a -> next != end){
  COUNT_NESTING(end_a);
  if(IS_NOT_NESTED() && end_a -> type == TYPE_COMMA){
    begin_b = (struct generic_token *) end_a -> next;
    break;
  }
  end_a = (struct generic_token *) end_a -> next;
}
if(begin_b != NULL){
  struct numeric_variable a, b;
  end_b = begin_b;
  while(end_b -> next != end)
    end_b = (struct generic_token *) end_b -> next;
  if(!eval_numeric_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_numeric_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(a.value != 0.0 || b.value != 0.0){
    *w_x = a.value;
    *w_y = b.value;
  }
  return true;
}
@
\fimcodigo

E finalmente, o último caso, onde teremos um elemento $\{a\}$, onde
$a$ é uma expressão de par. Para tratar este caso, observe que no caso
anterior nós já delimitamos $a$. Se a vírgula não foi encontrada, de
qualquer forma temos seus tokens delimitados. Então podemos
interpretá-los como uma expressão de par:

\iniciocodigo
@<Especificador de Direção: Caso 3@>=
else{ // Se no caso anterior não achamos a vírgula
  struct pair_variable a;
  if(!eval_pair_expression(mf, cx, begin_a, end_a, &a))
    return false;
  if(a.x != 0.0 || a.y != 0.0){
    *w_x = a.x;
    *w_y = a.y;
  }
  return true;
}
@
\fimcodigo

Agora finalmente devemos interpretar a junção em si. Assim como o
especificador de direção pode estar expresso como um par representando
um vetor de direção ou como um inteiro representando a curvatura, a
junção pode ser representada como dois números representando a tensão
(ou o limite inferior para a tensão) ou como dois pares $u$ e $v$
representando os dois pontos de controle diretamente. Vamos colocar
agora as variáveis que irão armazenar os valores:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>=
float tension0 = NAN, tension1 = NAN, u_x = NAN, u_y = NAN, v_x = NAN,
      v_y = NAN;
bool atleast0 = false, atleast1 = false; // Se a tensão é só um limite inferior
@
\fimcodigo

Primeiro vamos tratar os casos mais simples. Se nossa junção for um
token ``\&'', então estamos lidando com a concatenação de dois pontos
ou (mais provavelmente) sub-caminhos. Neste caso, devemos checar se os
dois pontos que estão sendo unidos ocupam a mesma posição
(consideramos a mesma posição como sendo uma distância menor que
0,00002). Se não estiverem, um erro deve ser gerado. Se estiverem,
juntaremos ambos os caminhos removendo a segunda cópia do ponto onde
está sendo feita a junção.

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
  double dif_x = z1_point -> x - z2_point -> x;
  double dif_y = z1_point -> y - z2_point -> y;
  if(hypot(dif_x * dif_x, dif_y * dif_y) > 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Concatenating discontinuous paths.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  v_x = u_x = z1_point -> x;
  v_y = u_y = z1_point -> y;
  // Isso fará o primeiro ponto de extremidade ser sobrescrito
  result -> total_length --;
  z1_point -> x = NAN;
  z1_point -> y = NAN;
}
@
\fimcodigo

Outro caso simples será quando usamos a junção composta por
``\monoespaco{--}''. Neste caso, devemos preencher os pontos de
controle como igualmente espaçados entre os dois pontos de extremidade
formando uma reta:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN){
  u_x = z1_point -> x + (1.0/3.0) * (z2_point -> x - z1_point -> x);
  u_y = z1_point -> y + (1.0/3.0) * (z2_point -> y - z1_point -> y);
  v_x = z1_point -> x + (2.0/3.0) * (z2_point -> x - z1_point -> x);
  v_y = z1_point -> y + (2.0/3.0) * (z2_point -> y - z1_point -> y);
}
@
\fimcodigo


Se a nossa junção for somente o token ``..'', então nossa junção será
definida como tendo uma tensão de exatamente 1 e 1:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j == end_j && begin_j -> type == TYPE_JOIN){
  tension0 = 1.0;
  tension1 = 1.0;
  atleast0 = false;
  atleast1 = false;
}
@
\fimcodigo

Nossa junção também pode ser que esteja especificando diretamente os
pontos de controle na forma de ``.. controls $c_0$ ..'' ou
``.. controls $c_0$ and $c_1$ .. '', onde $c_0$ e $c_1$ são expressões
de pares. Neste caso tentamos delimitar os valores de $c_0$ e $c_1$
(se este segundo existir) e usamos eles diretamente como os pontos de
controle (se $c_1$ não existir, ele será igual a $c_0$):

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_c0, *end_c0, *begin_c1 = NULL, *end_c1 = NULL;
  struct pair_variable c0, c1;
  begin_c0 = (struct generic_token *) begin_j -> next;
  begin_c0 = (struct generic_token *) begin_c0 -> next;
  if(begin_c0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  end_c0 = begin_c0;
  while(end_c0 -> next != end_j){
    COUNT_NESTING(end_c0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_c0 -> next) -> type == TYPE_AND)
      break;
    end_c0 = (struct generic_token *) end_c0 -> next;
  }
  if(end_c0 -> next != end_j){
    begin_c1 = end_c0 -> next;
    begin_c1 = (struct generic_token *) begin_c1 -> next;
    if(begin_c1 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    end_c1 = begin_c1;
    while(end_c1 -> next != end_j)
      end_c1 = (struct generic_token *) end_c1 -> next;
  }
  if(!eval_pair_primary(mf, cx, begin_c0, end_c0, &c0))
    return false;
  u_x = c0.x;
  u_y = c0.y;
  if(begin_c1 != NULL){
    if(!eval_pair_primary(mf, cx, begin_c1, end_c1, &c1))
      return false;
     v_x = c1.x;
     v_y = c1.y;
  }
  else{
    v_x = c0.x;
    v_y = c0.y;
  }
}
@
\fimcodigo

O último tipo de junção tem a forma ``.. tension $t_0$ ..'' ou
``.. tension $t_0$ and $t_1$ .. '' onde $t_0$ e $t_1$ são expressões
primárias numéricas representando um número maior ou igual a 3/4 que
podem ou não estar precedidas pelo token ``\monoespaco{atleast}''. Se
somente um valor de tensão for especificado, assumimos que ambos os
valores necessários são iguais a este valor único
passado. Interpretemos então este tipo de junção com o código abaixo:

\iniciocodigo
@<Expressão de Caminho: Interpreta Junção@>+=
else if(begin_j -> type == TYPE_JOIN &&
        ((struct generic_token *) (begin_j -> next)) -> type == TYPE_TENSION){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_t0, *end_t0, *begin_t1 = NULL, *end_t1 = NULL;
  struct numeric_variable t0, t1;
  begin_t0 = (struct generic_token *) begin_j -> next;
  begin_t0 = (struct generic_token *) begin_t0 -> next;
  if(begin_t0 == end_j){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  if(begin_t0 == end_j ||
     (begin_t0 -> type == TYPE_ATLEAST && begin_t0 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
    return false;
  }
  if(begin_t0 -> type == TYPE_ATLEAST){
    atleast0 = true;
    begin_t0 = (struct generic_token *) begin_t0 -> next;
  }
  else
    atleast0 = false;
  end_t0 = begin_t0;
  while(end_t0 -> next != end_j){
    COUNT_NESTING(end_t0);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_t0 -> next) -> type == TYPE_AND)
      break;
    end_t0 = (struct generic_token *) end_t0 -> next;
  }
  if(end_t0 -> next != end_j){
    begin_t1 = end_t0 -> next;
    begin_t1 = (struct generic_token *) begin_t1 -> next;
    if(begin_t1 == end_j ||
       (begin_t1 -> type == TYPE_ATLEAST && begin_t1 -> next == end_j)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
            mf -> file, begin_j -> line);
#endif
      return false;
    }
    if(begin_t1 -> type == TYPE_ATLEAST){
      atleast1 = true;
      begin_t1 = (struct generic_token *) begin_t1 -> next;
    }
    else
      atleast1 = false;
    end_t1 = begin_t1;
    while(end_t1 -> next != end_j)
      end_t1 = (struct generic_token *) end_t1 -> next;
  }
  if(!eval_numeric_primary(mf, cx, begin_t0, end_t0, &t0))
    return false;
  tension0 = t0.value;
  if(begin_t1 != NULL){
    if(!eval_numeric_primary(mf, cx, begin_t1, end_t1, &t1))
      return false;
    tension1 = t1.value;
  }
  else{
    tension1 = t0.value;
  }
  if(tension0 < 0.75 || tension1 < 0.75){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
          "METAFONT: Error: %s:%d: Improper tension. Should be >= 0.75\n",
          mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Depois de termos interpretado a junção, isso significa que já temos ou
um par de pontos de controle, caso em que não precisaremos fazer mais
nada além de apenas registrar tais pontos de controle na nossa
variável que estamos interpretando, ou que temos dois números
representando a tensão da curva. Neste segundo caso, será importante
levar em conta os especificadores de direção para determinar o formato
final da curva.

Contudo, os especificadores de direção podem estar vazios. Neste caso,
devemos usar várias regras diferentes para determinar qual deve ser o
valor deles.

%A primeira regra é que o começo e fim de um caminho não-cíclico sempre
%tem um ``\monoespaco{$\{$curl 1$\}$}'' implícito. O mesmo ocorre
%imediatamente antes e depois de uma concatenação. Assim:

%$$
%z_0 .. z_1 .. z_2 = \{\monoespaco{curl}\ 1\}z_0 .. z_1 .. z_2\{\monoespaco{curl}\ 1\}
%$$

%E também:

%$$
%.. z_n \& z_{n+1} .. = .. z_n\{\monoespaco{curl}\ 1\} \& \{\monoespaco{curl}\ 1\}z_{n+1} ..
%$$

%Isso significa que na primeira iteração, devemos considerar que o
%especificador de direção anterior é \monoespaco{curl 1}, desde que o
%caminho que estejamos lendo não seja cíclico:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>=
%if(begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE)
%  prev_curl = 1.0;
%
%\fimcodigo

%Já se estivermos em uma concatenação, se não existirem dois especificadores
%de direção atuais, também consideramos eles como \monoespaco{curl 1}:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>+=
%if(begin_j == end_j && begin_j -> type == TYPE_AMPERSAND){
%  if(isnan(curl0) && isnan(w0_x))
%    curl0 = 1.0;
%  if(isnan(curl1) && isnan(w1_x))
%    curl1 = 1.0;
%}
%
%\fimcodigo

%E finalmente, se não estivermos em um caminho cíclico e não existir um
%próximo especificador de direção após o segundo ponto atual, devemos
%checar se estamos na última junção do caminho. Isso pode ser conferido
%se não existir outra junção depois desta até o fim da expressão. Neste
%caso, marcamos o \monoespaco{curl 1} como próximo especificador de
%direção:

%\iniciocodigo
%<Expressão de Caminho: Decide Forma da Curva>+=
%if(end_z1 == end_expression)
%  next_curl = 1.0;
%else if(end_expression -> type != TYPE_CYCLE &&
%        ((struct generic_token *) (end_z1 -> next)) -> type !=
%        TYPE_OPEN_BRACES){
%  bool last_join = true;
%  struct generic_token *p = (struct generic_token *) end_z1 -> next;
%  DECLARE_NESTING_CONTROL();
%  while(p != end_expression){
%    COUNT_NESTING(p);
%    if(IS_NOT_NESTED() &&
%       (p -> type == TYPE_AMPERSAND || p -> type == TYPE_JOIN)){
%      last_join = false;
%      break;
%    }
%    p = (struct generic_token *) p -> next;
%  }
%  if(last_join)
%    next_curl = 1.0;
%}
%
%\fimcodigo

%Estas regras por si só não significam nada. O começo e fim de um
%caminho não-cíclico é um ponto descontínuo, não faz sentido definir
%pontos de controle após ele, não há continuação alguma. Já uma
%concatenação liga dois pontos iguais, também não há nada entre os
%pontos ligados. Contudo, essa regra passa a ser relevante quando
%combinada com as próximas.

Se existir um especificador após um ponto, mas não antes dele, é
copiada para antes dele. Da mesma forma, se houver um especificador
depois de um ponto, mas não antes dele, o especificador depois é
copiado. Assim:

$$
.. z_0 .. z_1\{d\} ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

E também:

$$
.. z_0 .. \{d\}z_1 ..  = .. z_0 .. \{d\}z_1\{d\} ..
$$

A natureza cíclica de um caminho deve ser levada em conta nesta regra.

Para o primeiro caso, no qual queremos copiar o especificador à
esquerda do primeiro ponto, será importante preservar este valor entre
iterações. Mas pelas nossas regras, só precisamos preservá-los quando
lemos ele diretamente por existir um especificador explícito. Então,
no fim da iteração que interpreta junções, nós armazenamos o
especificador anterior nestes casos. Nos demais, nós só os apagamos:

\iniciocodigo
@<Expressão de Caminho: Fim de Cada Iteração@>=
if((begin_z1 == begin_expression && end_expression -> type != TYPE_CYCLE) ||
   (begin_j == end_j && begin_j -> type == TYPE_AMPERSAND) ||
   (begin_j == end_j && begin_j -> type == TYPE_STRAIGHT_JOIN) ||
   (begin_e != NULL && end_e != NULL)){
  prev_w_x = w1_x;
  prev_w_y = w1_y;
}
else{
  prev_w_x = NAN;
  prev_w_y = NAN;
}
@
\fimcodigo

Então, para aplicar a regra e copiar o especificador da esquerda para
a direita, usamos o seguinte código:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(w0_x) && isnan(w0_y)){
  w0_x = prev_w_x;
  w0_y = prev_w_y;
}
@
\fimcodigo

Temos agora que copiar o especificador da direita pra esquerda. Vamos
fazer isso somente se não temos ainda um especificador definido e se
existir um especificador explícito à direita do segundo ponto:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(w1_x) && isnan(w1_y)){
  if(end_z2 -> next != NULL && end_z2 != end_expression &&
     ((struct generic_token *) (end_z2 -> next)) -> type ==
     TYPE_OPEN_BRACES){
    struct generic_token *next0, *next1;
    DECLARE_NESTING_CONTROL();
    next0 = (struct generic_token *) end_z2 -> next;
    next1 = next0;
    while(next1 != end_expression){
      COUNT_NESTING(next1);
      if(IS_NOT_NESTED() && next1 -> type == TYPE_CLOSE_BRACES)
        break;
      next1 = (struct generic_token *) next1 -> next;
    }
    if(next0 -> type == TYPE_OPEN_BRACES && next1 -> type == TYPE_CLOSE_BRACES){
      if(!eval_direction_specifier(mf, cx, next0, next1, &next_w_x,
                                   &next_w_y))
        return false;
      w1_x = next_w_x;
      w1_y = next_w_y;
    }
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr,
              "METAFONT: Error: %s:%d: Unrecognized join expression.\n",
              mf -> file, begin_j -> line);
#endif
      return false;
    }
  }
}
@
\fimcodigo

Mas também temos que levar em conta o caso cíclico. Pelas regras
gramaticais, não há nenhum especificador de direção antes do primeiro
ponto. Mas pode existir um especificador de direção antes do
token \monoespaco{cycle} e se ele existir, ele pode ser passado para a
direita do primeiro ponto. Da mesma forma, o especificador de direção
logo depois do primeiro ponto pode ser copiado para antes do
token \monoespaco{cycle} se não houver um especificador explícito.

Primeiro o caso mais simples: há um especificador de direção explícito
após o primeiro ponto no começo da expressão e estamos em um caminho
cíclico. Neste caso, devemos memorizá-lo para caso precisemos usar ele
no último ponto do caminho. Para memorizá-lo, vamos usar as seguintes
variáveis:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float first_w_x = NAN, first_w_y = NAN;
@
\fimcodigo

E então, na primeira iteração sobre os pontos do caminho, se
estivermos em um caminho cíclico e existir um especificador explícito,
armazenamos seu conteúdo:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d != NULL && end_d != NULL){
  first_w_x = w0_x;
  first_w_y = w0_y;
}
@
\fimcodigo

Depois, quando chegarmos na última iteração de um caminho cíclico,
vamos levar estes valores em conta:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE){
  if(!isnan(first_w_x) && isnan(w1_x)){
    w1_x = first_w_x;
    w1_y = first_w_y;
  }
}
@
\fimcodigo

Já para fazer a cópia na direção oposta, quando estamos na primeira
iteração ficamos obrigados a ir olhar a última junção. Primeiro
percorremos e expressão até o fim (até encontrar o
token \monoespaco{cycle}) tomando nota do último especificador de
direção e última junção. Se o token \monoespaco{cycle} vier logo
depois do último especificador, então devemos obter seu valor e
copiá-lo se não existir um especificador explícito.

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_d == NULL && isnan(w0_x) && isnan(u_x)){
  struct generic_token *begin_last_spec = NULL, *end_last_spec = NULL,
                       *last_join = NULL, *second_last_join = NULL, *p;
  DECLARE_NESTING_CONTROL();
  p = end_z1 -> next;
  while(p != end_expression){
    if(IS_NOT_NESTED()){
      if(p -> type == TYPE_OPEN_BRACES){
        begin_last_spec = p;
      }
      else if(p -> type == TYPE_CLOSE_BRACES)
        end_last_spec = p;
      else if(p -> type == TYPE_JOIN || p -> type == TYPE_AMPERSAND ||
              p -> type == TYPE_STRAIGHT_JOIN){
        second_last_join = last_join;
        last_join = p;
      }
      else if(p -> type == TYPE_CYCLE)
        break;
      else
        COUNT_NESTING(p);
    }
    else
      COUNT_NESTING(p);
    p = (struct generic_token *) p -> next;
  }
  if(end_last_spec != NULL && end_last_spec -> next == p &&
     p -> type == TYPE_CYCLE){
    if(!eval_direction_specifier(mf, cx, begin_last_spec, end_last_spec,
                                 &w0_x, &w0_y))
      return false;
  }
  @<Código Após Espiarmos Última Junção de Caminho Cíclico@>
}
@
\fimcodigo

A próxima regra se aplica quando temos uma construção como:

\alinhaverbatim
.. z .. controls  u  and  v ..  = .. z{u-z} .. controls  u  and  v ..
\alinhanormal

E também:

\alinhaverbatim
.. controls u and v .. z =  .. controls u and v .. z{z-v} ..
\alinhanormal

Isso se aplica somente quando o resultado da subtração de pares $u-z$
e $z-v$ é diferente de zero. Se for igual a zero, iremos retornar um
erro por ainda não suportarmos este caso.

Primeiro o caso mais fácil: os pontos de controle explícitos vem antes
do caminho atual. Foram os pontos de controle explícitos que lemos na
iteração anterior. Então, precisamos de uma variável para armazenar
este ponto de controle:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float previous_point_x = NAN, previous_point_y = NAN;
@
\fimcodigo


Se nós temos algum valor armazenado nestas variáveis e se nós não
temos especificador de direção explícito, então geramos o
especificador com as regras que descrevemos. Só observando que
consideramos como iguais quaisquer pontos cuja distância for menor que
0,00002.

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_d == NULL && end_d == NULL && !isnan(previous_point_x) &&
   !isnan(previous_point_y) && isnan(w0_x)){
  w0_x = z1_point -> x - previous_point_x;
  w0_y = z1_point -> y - previous_point_y;
  if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Neste momento, depois de possivelmente termos usado o especificador
anterior, não precisaremos mais dele e o atualizamos para o valor atual:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  previous_point_x = v_x;
  previous_point_y = v_y;
}
else{
  previous_point_x = NAN;
  previous_point_y = NAN;
}
@
\fimcodigo

Já se não temos um valor explícito até agora no segundo especificador
de direção, devemos checar a próxima junção para saber se ela contém
pontos de controle explícitos. Se tiver, lemos o primeiro destes
pontos, o interpretamos e usamos seu valor pelas regras acima:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_e == NULL && end_e == NULL &&  isnan(w1_x) &&
   end_z2 != end_expression){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_point, *end_point;
  begin_point = (struct generic_token *) end_z2 -> next;
  while(begin_point != end_expression){
    COUNT_NESTING(begin_point);
    if(IS_NOT_NESTED() && (begin_point -> type == TYPE_JOIN ||
                          begin_point -> type == TYPE_AMPERSAND ||
                          begin_point -> type == TYPE_STRAIGHT_JOIN))
      break;
    begin_point = (struct generic_token *) begin_point -> next;
  }
  if(begin_point != end_expression &&
     begin_point -> type != TYPE_AMPERSAND &&
     begin_point -> type != TYPE_STRAIGHT_JOIN){
    begin_point = (struct generic_token *) begin_point -> next;
    if(begin_point != end_expression && begin_point -> type == TYPE_CONTROLS){
      begin_point = (struct generic_token *) begin_point -> next;
      end_point = begin_point;
      while(end_point != end_expression){
        struct generic_token *next = (struct generic_token *) end_point -> next;
        COUNT_NESTING(end_point);
        if(IS_NOT_NESTED() && next != NULL &&
           (next -> type == TYPE_AND || next -> type == TYPE_JOIN))
          break;
        end_point = (struct generic_token *) end_point -> next;
      }
      if(end_point != end_expression){
        struct pair_variable var;
        if(!eval_pair_primary(mf, cx, begin_point, end_point, &var))
          return false;
        w1_x = var.x - z2_point -> x;
        w1_y = var.y - z2_point -> y;
        if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                          "direction specifier.\n",  mf -> file,
                          begin_j -> line);
#endif
          return false;
        }
      }
    }
  }
}
@
\fimcodigo

Agora vamos ao caso cíclico. Se estamos na primeira iteração, nosso
caminho é cíclico e temos pontos de controle explícitos, então devemos
ter uma variável adicional para armazenar tal ponto de controle
explícito:

\iniciocodigo
@<Expressão de Caminho: Declaração de Variáveis Adicionais@>+=
float first_point_x = NAN, first_point_y = NAN;
@
\fimcodigo

E inicializamos a variável se for o caso na primeira iteração:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z1 == begin_expression && end_expression -> type == TYPE_CYCLE &&
   begin_j != end_j &&
   ((struct generic_token *) (begin_j -> next)) -> type == TYPE_CONTROLS){
  first_point_x = u_x;
  first_point_y = u_y;
}
@
\fimcodigo

Depois, quando chegar a hora de escolher o formato da junção das
extremidades cíclicas, levaremos a existência desta variável em conta:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(begin_z2 == end_z2 && begin_z2 -> type == TYPE_CYCLE && begin_d == NULL &&
   end_d == NULL && isnan(w1_x) && !isnan(first_point_x) && isnan(w1_x)){
  w1_x = first_point_x - z2_point -> x;
  w1_y = first_point_y - z2_point -> y;
  if(hypot(w1_x * w1_x, w1_y * w1_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

E agora a direção oposta. Se estamos na primeira iteração de um
caminho cíclico, devemos espiar a última junção e checar se temos
pontos de controle explícitos para aplicar esta regra. Mas na regra
anterior nós já escrevemos o código para obter dentre outras coisas, a
última junção. Então podemos continuar à partir do código anterior:


\iniciocodigo
@<Código Após Espiarmos Última Junção de Caminho Cíclico@>=
if(last_join != NULL && last_join -> type == TYPE_JOIN){
  struct generic_token *p = (struct generic_token *) second_last_join -> next;
  if(p -> type == TYPE_CONTROLS){
    struct generic_token *p_end;
    p = (struct generic_token *) p -> next;
    p_end = p;
    while(p_end != end_expression){
      struct generic_token *next = (struct generic_token *) p_end -> next;
      COUNT_NESTING(p_end);
      if(IS_NOT_NESTED()){
        if(next -> type == TYPE_AND)
          p = (struct generic_token *) next -> next;
        else if(next -> type == TYPE_JOIN)
          break;
      }
      p_end = next;
    }
    if(p_end != end_expression){
      struct pair_variable var;
      if(!eval_pair_primary(mf, cx, p, p_end, &var))
        return false;
      w0_x = z1_point -> x - var.x;
      w0_y = z1_point -> y - var.y;
      if(hypot(w0_x * w0_x, w0_y * w0_y) <= 0.00002){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                        "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
        return false;
      }
    }
  }
}
@
\fimcodigo

Após executar as regras, espera-se que tenhamos já ou dois pontos de
controle bem-definidos, ou então valores de tensão com especificadores
de direção à partir dos quais iremos deduzir os pontos de controle. Se
não tivermos nem um e nem outro, geraremos um erro e encerraremos:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  if(isnan(w0_x) || isnan(w0_y) || isnan(w1_x) || isnan(w1_y)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Could not find a suitable "
                    "direction specifier.\n",  mf -> file, begin_j -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Se tudo deu certo até aqui, ou já temos os nossos pontos de controle,
ou então temos que descobrir quais são os pontos de controle por meio
de uma construção como a abaixo:

$$
z_n\{w_n\}..\ {\hskip2mm \monoespaco{tension}\hskip2mm } \alpha {\hskip2mm \monoespaco{and}\hskip2mm } \beta .. \{w_{n+1}\}z_{n+1}
$$

Para calcular os pontos de controle à partir destas informações,
tratamos os pontos como números complexos e calculamos:

$$
\theta = arg(w_n/(z_{n+1}-z_n))
$$

$$
\phi = arg((z_{n+1}-z_n)/w_{n+1})
$$

Em seguida, os pontos de controle $u$ e $v$ são:

$$
u = z_{n} + e^{i\theta}(z_{n+1}-z_n)f(\theta, \phi)/\alpha
$$

$$
v = z_{n+1} - e^{-i\phi}(z_{n+1}-z_n)f(\phi, \theta)/\beta
$$

Exceto quando é usada a palavra-chave ``atleast'', o que significa que
o valor de $\alpha$ ou $\beta$ é aumentado de modo que o resultado
fique dentro da área delimitada pelo triângulo cujos dois pontos são
os pontos de extremidade e o ângulo em cada um destes pontos é dado
pelo especificador de direção. Caso isso não forme um triângulo
válido, mantemos os valores de tensão sem os modificar.

A função $f$ que aparece acima é definida como:

$$
f(\theta, \phi) = {{2+\sqrt{2}(\sin\theta-{{1}\over{16}}\sin\phi)(\sin\phi-{{1}\over{16}}\sin\theta)(\cos\theta-\cos\phi)}\over{3(1+{1\over 2}(\sqrt 5 - 1)\cos\theta+{1\over 2}(3-\sqrt 5)\cos\phi)}}
$$

Primeiro vamos implementar a função $f$ como uma função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
double compute_f(double theta, double phi);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double compute_f(double theta, double phi){
  double n = 2 + sqrt(2) * (sin(theta) - 0.0625 * sin(phi)) *
             (sin(phi) - 0.0625 * sin(theta)) * (cos(theta) - cos(phi));
  double d = 3 * (1 + 0.5 * (sqrt(5.0) - 1) * cos(theta) + 0.5 * (3 - sqrt(5)) *
                  cos(phi));
  return n/d;
}
@
\fimcodigo

Agora podemos calcular os pontos de controle caso ainda não tenhamos
eles. Como devemos tratar os pontos como números complexos, vamos
precisar do seguinte cabeçalho:

\iniciocodigo
@<Cabeçalhos Locais (metafont.c)@>+=
#include <complex.h>
@
\fimcodigo

E com ajuda das funções da biblioteca padrão para números complexos,
calculamos a fórmula para os pontos de controle:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
if(isnan(u_x) || isnan(u_y) || isnan(v_x) ||  isnan(v_y)){
  double complex u, v;
  double complex z0 = z1_point -> x + z1_point -> y * I;
  double complex z1 = z2_point -> x + z2_point -> y * I;
  double theta = carg((w0_x + w0_y * I) / (z1 - z0));
  double phi = carg((z1 - z0)/(w1_x + w1_y * I));
  u = z0 + (cexp(theta * I) * (z1 - z0) * compute_f(theta, phi)) / tension0;
  v = z1 - (cexp(-phi * I) * (z1 - z0) * compute_f(phi, theta)) / tension1;
  u_x = creal(u);
  u_y = cimag(u);
  v_x = creal(v);
  v_y = cimag(v);
  @<Ajusta Tensão em Caso de 'atleast'@>
}
@
\fimcodigo

Vamos agora tratar o caso de termos encontrado a palavra-chave
``atleast''. Se ela existir, o ponto de controle correspondente deve,
se possível, ser ajustado para estar dentro do triângulo delimitado
pelos dois pontos de extremidade e pelos ângulos definidos pelos seus
especificadores de direção.

A primeira coisa que teremos que calcular é se temos um triângulo
válido. Para isso devemos checar os seus ângulos internos. Dados três
pares de coordenadas, sendo o primeiro par um vértice onde queremos
medir o ângulo, podemos calcular o ângulo existente ali com ajuda da
seguinte função auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
double get_angle(double v_x, double v_y, double c0_x, double c0_y,
                 double c1_x, double c1_y){
  double v0_x, v0_y, v1_x, v1_y;
  v0_x = c0_x - v_x;
  v0_y = c0_y - v_y;
  v1_x = c1_x - v_x;
  v1_y = c1_y - v_y;
  if(fabs(v0_x) <= 0.00002 &&  fabs(v0_y) <= 0.00002)
    return INFINITY;
  if(fabs(v1_x) <= 0.00002 &&  fabs(v1_y) <= 0.00002)
    return INFINITY;
  return acos((v0_x * v1_x + v0_y * v1_y) /
                (hypot(v0_x * v0_x, v0_y * v0_y) *
                 hypot(v1_x * v1_x, v1_y * v1_y)));
}
@
\fimcodigo

Sabendo medir os ângulos podemos verificar se o triângulo é
válido. Sabendo fazer isso, podemos escrever uma função que ajusta o
valor do ponto de controle para o valor adequado de modo a permanecer
dentro do triângulo. Primeiro medimos e obtemos todos os ângulos
internos. Depois, para descobrir a coordenada do terceiro vértice do
triângulo (os dois outros vértices são pontos de extremidade) usamos a
Lei do Senos. Sabendo quais são os vértices todos, verificamos se os
pontos de controle estão dentro do triângulo. E somente se não
estiver, fazemos o ajuste:


\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void correct_tension(double p0_x, double p0_y, double p1_x, double p1_y,
                     double d0_x, double d0_y, double d1_x, double d1_y,
                     float *control_x, float *control_y){
  double internal_angle0, internal_angle1, internal_angle2;
  double triangle_angle;
  double p2_x, p2_y;
  internal_angle0 = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + d0_x, p0_y + d0_y);
  internal_angle1 = get_angle(p1_x, p1_y, p0_x, p0_y, p1_x + d1_x, p1_y + d1_y);
  internal_angle2 = M_PI - internal_angle0 - internal_angle1;
  if(internal_angle0 + internal_angle1 >= M_PI - 0.00002)
    return; // Não é triângulo válido
  { // Descobrir coordenada do terceiro vértice:
    // Primeiro calculamos o lado do triângulo que vai de p0 ao vértice
    // desconhecido
    double known_side = hypot((p1_x - p0_x) * (p1_x - p0_x),
                              (p1_y - p0_y) * (p1_y - p0_y));
    double triangle_side = known_side * sin(internal_angle0) /
                           sin(internal_angle2);
    // Conhecendo o tamanho do lado do triângulo, basta combinar com o
    // ângulo e chegamos ao vértice desconhecido:
    triangle_angle = get_angle(p0_x, p0_y, p1_x, p1_y, p0_x + 1.0, p0_y);
    p2_x = p0_x + triangle_side * cos(triangle_angle + internal_angle0);
    p2_y = p0_y + triangle_side * sin(triangle_angle + internal_angle0);
  }
  {
    @<Checa se Ponto Está Dentro do Triângulo@>
    @<Se Não Estiver, Ajusta Tensão para Ficar@>
  }
}
@
\fimcodigo

Como checar se um ponto está dentro de um triângulo? Há várias formas,
a que usaremos consiste em medir a área com sinal dos três novos
triângulos formados pelo ponto e dois vértices do triângulo. A ``área
com sinal'' é a área do triângulo, só que ela tem valor positivo ou
negativo dependendo se passamos os vértices no sentido horário ou
anti-horário. Em seguida, apenas verificamos se todas as áreas tem o
mesmo sinal (positivo ou negativo). Se tiver, então o ponto certamente
está fora. Caso contrário, o ponto está dentro do triângulo:

\iniciocodigo
@<Checa se Ponto Está Dentro do Triângulo@>=
bool s1, s2, s3; // O sinal das áreas
s1 = ((*control_x - p1_x) * (p0_y - p1_y) -
      (p0_x - p1_x) * (*control_y - p1_y)) < 0;
s2 = ((*control_x - p2_x) * (p1_y - p2_y) -
      (p1_x - p2_x) * (*control_y - p2_y)) < 0;
s3 = ((*control_x - p0_x) * (p2_y - p0_y) -
      (p2_x - p0_x) * (*control_y - p0_y)) < 0;
if(s1 == s2 && s2 == s3)
  return;
@
\fimcodigo

Uma vantagem deste método é que dependendo de qual área com sinal tem
um sinal diferente das outras, isso determina qual dos lados do
triângulo é mais próximo do ponto. Então, se ainda estivermos na
função, checamos qual é o lado mais próximo, obtemos sua equação de
reta e calculamos o ponto mais próximo na reta. Se o ponto estiver no
lado do triângulo, este é o novo ponto do ponto de controle. Se não, o
ponto de controle se torna a extremidade do triângulo mais próxima do
ponto.

\iniciocodigo
@<Se Não Estiver, Ajusta Tensão para Ficar@>=
{
  double x0, y0, x1, y1;
  if(s1 != s2 && s1 != s3){
    x0 = p0_x; y0 = p0_y;
    x1 = p1_x; y1 = p1_y;
  }
  else if(s2 != s1 && s2 != s3){
    x0 = p1_x; y0 = p1_y;
    x1 = p2_x; y1 = p2_y;
  }
  else{
    x0 = p2_x; y0 = p2_y;
    x1 = p0_x; y1 = p0_y;
  }
  if(x1 < x0){ // x1 deve ser maior ou igual a x0
    double tmp;
    tmp = x1 ; x1 = x0; x0 = tmp;
    tmp = y1; y1 = y0; y0 = tmp;
  }
  if(x0 == x1){ // Reta vertical (equação da reta daria divisão por zero)
    *control_x = x0;
    if(*control_y > y0 && *control_y > y1){
      if(y0 > y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
    else if(*control_y < y0 && *control_y < y1){
      if(y0 < y1)
        *control_y = y0;
      else
        *control_y = y1;
    }
  }
  else if(y0 == y1) // Reta horizontal
    *control_y = y0;
  else{ // Usar equação da reta
    // m0 x + b0 = y é a reta que contém o lado do triângulo
    double m0 = (y1 - y0) / (x1 - x0);
    double b0 = y1 - m0 * x1;
    // m1 x + b1 = y é a perpendicular ao lado do triângulo e passa pelo ponto
    double m1 = - m0;
    double b1 = *control_y - m1 * *control_x;
    *control_x = (b1 - b0) / (m0 - m1);
    *control_y = m0 * *control_x + b0;
  }
  if(*control_x > x1){
    *control_x = x1;
    *control_y = y1;
  }
  else if(*control_x < x0){
    *control_x = x0;
    *control_y = y0;
  }
}
@
\fimcodigo

Isso finaliza a nossa função para ajustar a tensão caso estejamos
lidando com pontos de controle com a palavra-chave
``\monoespaco{atleast}''. Agora podemos apenas usar esta função sempre
que estivermos lidando com um caso assim:

\iniciocodigo
@<Ajusta Tensão em Caso de 'atleast'@>=
if(atleast0)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &u_x, &u_y);
if(atleast1)
  correct_tension(z1_point -> x, z1_point -> y, z2_point -> x, z2_point -> y,
                  w0_x, w0_y, w1_x, w1_y, &v_x, &v_y);
@
\fimcodigo

E com isso terminamos de calcular os pontos de controle e podemos
atualizar seu valor na variável de caminho que estamos montando ao
avaliar a expressão. Se estivermos na última iteração de uma curva
não-cíclica, além disso nós preenchemos os últimos pontos de controle
como sendo iguais ao último ponto de extremidade:

\iniciocodigo
@<Expressão de Caminho: Decide Forma da Curva@>+=
z1_point -> u_x = u_x;
z1_point -> u_y = u_y;
z1_point -> v_x = v_x;
z1_point -> v_y = v_y;
if(result -> length >= expected_length && result -> cyclic == false){
  struct path_points *final_point =
                           &(result -> points[result -> length - 1]);
  while(final_point -> subpath != NULL){
    struct path_variable *p = (struct path_variable *)
                                (final_point -> subpath);
    final_point = &(p -> points[p -> length - 1]);
  }
  final_point -> u_x = final_point -> x;
  final_point -> u_y = final_point -> y;
  final_point -> v_x = final_point -> x;
  final_point -> v_y = final_point -> y;
}
@
\fimcodigo

Isso finaliza a construção de uma curva dados seus pontos e
subcaminhos lidos. Agora iremos estabelecer como ler os pontos e
subcaminhos.

\subsubsecao{8.4.2. Expressões Terciárias de Caminhos}

A gramática para expressões de caminho terciárias é:

\alinhaverbatim
<Terciário de Caminho> -> <Terciário de Par> | <Secundário de Caminho>
\alinhanormal

E é só isso. Então, para interpretar uma expressão terciária de
caminho, o que faremos é percorrer ela e verificar se encontramos uma
expressão terciária de par. Se encontrarmos, devemos interpretar a
expressão inteira como um terciário de par. Caso contrário, a
interpretaremos como um secundário de caminho. Se interpretarmos tudo
como um par, devemos também depois converter o resultado de um par
para um caminho com um único ponto.

De qualquer forma, depois de interpretar a expressão e obter um
caminho como resultado, nós retornamos o resultado.

A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_tertiary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  struct generic_token *p, *prev = NULL;
  bool this_expression_is_pair = false;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && IS_VALID_SUM_OR_SUB(prev, p)){
      this_expression_is_pair = true;
      break;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(this_expression_is_pair){
    struct pair_variable pair;
    if(!eval_pair_expression(mf, cx, begin_expression, end_expression,
                            &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> total_length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points -> x = pair.x;
    result -> points -> y = pair.y;
    result -> points -> u_x = pair.x;
    result -> points -> u_y = pair.y;
    result -> points -> v_x = pair.x;
    result -> points -> v_y = pair.y;
    result -> points -> subpath = NULL;
    return true;
  }
  else
    return eval_path_secondary(mf, cx, begin_expression, end_expression,
                               result);
}
@
\fimcodigo

\subsubsecao{8.4.3. Expressões Secundárias de Caminhos: Transformadores}

A gramática para expressões secundárias de caminho é:

\alinhaverbatim
<Secundário de Caminho> -> <Secundário de Par> | <Primário de Caminho> |
                           <Secundário de Caminho><Transformador>
\alinhanormal

Os transformadores são os mesmos que já foram apresentados na
expressão secundária de par, mas incluindo o
operador \monoespaco{transformed} introduzido na seção sobre
transformações. A primeira coisa que devemos testar é se temos um
transformador no fim e se temos uma operação secundária de par
(multiplicação e divisão). Depois de percorrer toda a expressão, se
houver o tranformador, aplicamos a terceira regra da gramática
acima. Se houver uma multiplicação e divisão, mas não um
transformador, aplicamos a segunda regra. E caso não haja nada disso,
aplicamos a primeira.

Transformar um caminho via rotação, escala e outras modificações
envolve aplicar tais modificações sobre cada ponto de extremidade e
cada ponto de controle.

A declaração da função que fará isso é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct path_variable *result){
  bool have_transform = false, have_pair_operator = false;
  struct generic_token *p, *last_fraction = NULL, *transform_op = NULL,
                       *before_transform = NULL, *prev = NULL,
                       *prev_prev = NULL;
  DECLARE_NESTING_CONTROL();
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
             p -> type == TYPE_TRANSFORMED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Separador de fração
         last_fraction = p;
       else if(p -> type == TYPE_DIVISION ||
               p -> type == TYPE_MULTIPLICATION)
         have_pair_operator = true;
       else{
         have_transform = true;
         transform_op = p;
         before_transform = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(have_transform){
    if(transform_op -> next == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_path_secondary(mf, cx, begin_expression, before_transform,
                            result))
      return false;
    @<Transformação de Caminho: Rotação@>
    @<Transformação de Caminho: Escala@>
    @<Transformação de Caminho: Deslocamento@>
    @<Transformação de Caminho: Inclinação@>
    @<Transformação de Caminho: X-Escala@>
    @<Transformação de Caminho: Y-Escala@>
    @<Transformação de Caminho: Z-Escala@>
    @<Transformação de Caminho: Transformação Genérica@>
  }
  else if(have_pair_operator){
    struct pair_variable pair;
    if(!eval_pair_secondary(mf, cx, begin_expression, end_expression,
                            &pair))
      return false;
    result -> cyclic = false;
    result -> length = 1;
    result -> total_length = 1;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory!\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    result -> points[0].x = pair.x;
    result -> points[0].y = pair.y;
    result -> points[0].u_x = pair.x;
    result -> points[0].u_y = pair.y;
    result -> points[0].v_x = pair.x;
    result -> points[0].v_y = pair.y;
    result -> points[0].subpath = NULL;
    return true;    
  }
  else
    return eval_path_primary(mf, cx, begin_expression, end_expression,
                             result);
}
@
\fimcodigo

No código acima, quando verificamos se temos um transformador na
expressão, sempre armazenamos o último transformador encontrado na
variável \monoespaco{transform\_op} e o último token antes do
transformador em \monoespaco{before\_transform}. Isso nos permite
depois poder dividir a expressão em partes para poder interpretá-la e
obter o caminho sobre o qual devemos aplicar o transformador.

Se temos uma rotação, para interpretar um transformador de rotação
depois de termos obtido o caminho a ser rotacionado na
variável \monoespaco{result}, podemos então aplicar o código abaixo:

\iniciocodigo
@<Transformação de Caminho: Rotação@>=
if(transform_op -> type == TYPE_ROTATED){
  struct numeric_variable a;
  double theta, sin_theta, cos_theta;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  theta = 0.0174533 * a.value; // Converter de graus para radianos
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  path_rotate(result, sin_theta, cos_theta);
  return true;
}
@
\fimcodigo

O código acima assume que temos uma função recursiva que faz a rotação
uma vez que passemos o seno e cosseno do ângulo que devemos
rotacionar. Vamos usar a função abaixo para isso:


\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_rotate(struct path_variable *p, double sin_theta,
                 double cos_theta){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_rotate((struct path_variable *) (p -> points[i].subpath),
                  sin_theta, cos_theta);
    else{
      double x = p -> points[i].x, y = p -> points[i].y;
      p -> points[i].x = x * cos_theta - y * sin_theta;
      p -> points[i].y = x * sin_theta + y * cos_theta;
      x = p -> points[i].u_x;
      y = p -> points[i].u_y;
      p -> points[i].u_x = x * cos_theta - y * sin_theta;
      p -> points[i].u_y = x * sin_theta + y * cos_theta;
      x = p -> points[i].v_x;
      y = p -> points[i].v_y;
      p -> points[i].v_x = x * cos_theta - y * sin_theta;
      p -> points[i].v_y = x * sin_theta + y * cos_theta;
    }
  }
}
@
\fimcodigo

Agora vamos ao operador que muda a escala de um caminho. Ele deve
interpretar um valor numérico e depois multiplicar cada ponto do
caminho por tal valor numérico:

@<Transformação de Caminho: Escala@>=
else if(transform_op -> type == TYPE_SCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_xyscale(result, a.value, a.value);  
  return true;
}
@
\fimcodigo

A função recursiva que aplica isso a todos os pontos de um caminho é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y);
@
\fimcodigo

Note que a função é mais ampla e pode ser usada para aumentar de
maneira não-proporcional o tamanho de uma curva no eixo $x$ e $y$,
apesar de aqui só a estarmis usando para esticá-la a mesma quantidade
na horizontal e vertical. A sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_xyscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_xyscale((struct path_variable *) (p -> points[i].subpath), x,
                   y);
    else{
      p -> points[i].x *= x;
      p -> points[i].y *= y;
      p -> points[i].u_x *= x;
      p -> points[i].u_y *= y;
      p -> points[i].v_x *= x;
      p -> points[i].v_y *= y;
    }
  }
}
@
\fimcodigo

A próxima transformação é uma simples translação ou
deslocamento. Recebemos um par e este par determina o quanto cada
ponto deve ser deslocado no eixo $s$ e $y$:

\iniciocodigo
@<Transformação de Caminho: Deslocamento@>=
else if(transform_op -> type == TYPE_SHIFTED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_shift(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

E a função recursiva que faz o deslocamento:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_shift(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_shift((struct path_variable *) (p -> points[i].subpath), x, y);
    else{
      p -> points[i].x += x;
      p -> points[i].y += y;
      p -> points[i].u_x += x;
      p -> points[i].u_y += y;
      p -> points[i].v_x += x;
      p -> points[i].v_y += y;
    }
  }
}
@
\fimcodigo

Vamos agora à inclinação, o transformador que empurra os pontos mais à
direita se estiverem acima do 0 no eixo $y$ e mais à esquerda se
estiverem mais abaixo da origem no eixo $y$:

\iniciocodigo
@<Transformação de Caminho: Inclinação@>=
else if(transform_op -> type == TYPE_SLANTED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                          &a))
    return false;
  path_slant(result, a.value);  
  return true;
}
@
\fimcodigo

E a função recursiva que faz a inclinação em si:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_slant(struct path_variable *p, float s);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_slant(struct path_variable *p, float s){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_slant((struct path_variable *) (p -> points[i].subpath), s);
    else{
      p -> points[i].x += s * p -> points[i].y;
      p -> points[i].u_x += s * p -> points[i].u_y;
      p -> points[i].v_x += s * p -> points[i].v_y;
    }
  }
}
@
\fimcodigo

A próxima transformação muda o tamanho horizontal do caminho, mas
preserva o tamanho vertical. Devemos ler um valor numérico e ele
determina o quanto o caminho deve ser esticado horizontalmente:


\iniciocodigo
@<Transformação de Caminho: X-Escala@>=
else if(transform_op -> type == TYPE_XSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, a.value, 1.0);  
  return true;
}
@
\fimcodigo

Aqui estamos usando uma função recursiva já definida, então não
precisamos defini-la novamente. Além de transformar esticando
horizontalmente, vamos agora esticar verticalmente:

\iniciocodigo
@<Transformação de Caminho: Y-Escala@>=
else if(transform_op -> type == TYPE_YSCALED){
  struct numeric_variable a;
  if(!eval_numeric_primary(mf, cx, transform_op -> next, end_expression,
                           &a))
    return false;
  path_xyscale(result, 1.0, a.value);  
  return true;
}
@
\fimcodigo

A penúltima transformação é a mudança de escala Z que lê um par, o
interpreta como número complexo, e também interpreta cada ponto do
caminho como número complexo fazendo a multiplicação:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

Interpretamos e realizamos a transformação da forma abaixo, lembrando
também que esta é a última transformação possível:

\iniciocodigo
@<Transformação de Caminho: Z-Escala@>=
else if(transform_op -> type == TYPE_ZSCALED){
  struct pair_variable a;
  if(!eval_pair_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_zscale(result, a.x, a.y);  
  return true;
}
@
\fimcodigo

E a função recursiva que fará isso:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_zscale(struct path_variable *p, float x, float y){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_zscale((struct path_variable *) (p -> points[i].subpath),
                  x, y);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = x0 * x - y0 * y;
      p -> points[i].y = x0 * y + y0 * x;
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = x0 * x - y0 * y;
      p -> points[i].u_y = x0 * y + y0 * x;
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = x0 * x - y0 * y;
      p -> points[i].v_x = x0 * y + y0 * x;
    }
  }
}
@
\fimcodigo

E o último tipo de transformador é a transformação genérica, onde
teremos um transformador que irá indicar como iremos mudar todos os
pontos do caminho. Tratamos este caso da seguinte forma:

\iniciocodigo
@<Transformação de Caminho: Transformação Genérica@>=
else if(transform_op -> type == TYPE_TRANSFORMED){
  struct transform_variable a;
  if(!eval_transform_primary(mf, cx, transform_op -> next, end_expression, &a))
    return false;
  path_transform(result, a.value);
  return true;
}
else{
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable transformer\n",
          mf -> file, transform_op -> line);
#endif
  return false;
}
@
\fimcodigo

Para isso usamos a seguinte função recursiva:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M);
@
\fimcodigo

A função é definida como:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_transform(struct path_variable *p, float *M){
  int i;
  for(i = 0; i < p -> length; i ++){
    if(p -> points[i].subpath != NULL)
      path_transform((struct path_variable *) (p -> points[i].subpath), M);
    else{
      float x0 = p -> points[i].x;
      float y0 = p -> points[i].y;
      p -> points[i].x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].y = LINEAR_TRANSFORM_Y(x0, y0, M);
      x0 = p -> points[i].u_x;
      y0 = p -> points[i].u_y;
      p -> points[i].u_x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].u_y = LINEAR_TRANSFORM_Y(x0, y0, M);
      x0 = p -> points[i].v_x;
      y0 = p -> points[i].v_y;
      p -> points[i].v_x = LINEAR_TRANSFORM_X(x0, y0, M);
      p -> points[i].v_x = LINEAR_TRANSFORM_Y(x0, y0, M);
    }
  }
}
@
\fimcodigo


\subsubsecao{8.4.4. Expressões Primárias de Caminhos}

A gramática para expressões primárias de caminho é:

\alinhaverbatim
<Primário de Caminho> -> <Primário de Par> | <Variável de Caminho> |
                       ( <Expressão de Caminho> ) |
                       reverse <Primário de Caminho> |
                       subpath <Expressão de Par> of <Primário de Caminho> |
                       ...
\alinhanormal

Isso significa que devemos registrar tokens
novos: \monoespaco{reverse}, \monoespaco{subpath} e \monoespaco{of}:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_REVERSE,        // O token simbólico 'reverse'
TYPE_SUBPATH,        // O token simbólico 'subpath'
TYPE_OF,             // O token simbólico 'of'
@
\fimcodigo

E para cada um deles adicionemos sua string na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"reverse", "subpath", "of",
@
\fimcodigo

O que as regras gramaticais dizem é que no fim de toda expressão de
caminho, terminaremos encontrando no fim uma variável de caminho,
um parênteses, algum destes operadores novos de subcaminho e de
caminho reverso, ou em todos os demais casos, isso se encaixa em uma
expressão primária de par que irá nos dar um par. Devemos então testar
se estamos nestes casos, e se não estivermos, basta interpretar como
par.

A função que irá interpretar expressões primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_path_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct path_variable *result){
  if(begin_expression -> type == TYPE_REVERSE){
    @<Caminho Primário: Reverso@>
  }
  else if(begin_expression -> type == TYPE_SUBPATH){
    @<Caminho Primário: Subcaminho@>
  }
  else if(begin_expression == end_expression &&
          begin_expression -> type == TYPE_SYMBOLIC){
    @<Caminho Primário: Variável@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Caminho Primário: Parênteses@>
  }
  @<Caminho Primário: Outras Expressões@>
  { // Se ainda não retornou, é um par primário
    @<Caminho Primário: Par Primário@>
  }
  return false;
}
@
\fimcodigo

Vamos ao primeiro caso: devemos calcular o reverso de um caminho. Para
isso, devemos inverter a ordem na qual aparecem os pontos de
extremidade e mover os pontos de controle para suas novas posições.

Dada a natureza recursiva das variáveis de caminho, precisamos de uma
função recursiva para copiar os pontos de uma variável de origem e
colocá-los na ordem reversa em uma variável de destino já alocada.

Esta função auxiliar recursiva precisa receber como argumento qual o
ponteiro de destino onde devemos copiar o próximo ponto. Como vamos
copiar na ordem reversa, a posição começará no último lugar e iremos
decrementar ela a cada cópia. Assim a variável de destino será
percorrida da direita para a esquerda.

Na variável de origem, precisamos passar como argumento a posição do
próximo ponto a ser percorrido. O qual é representado por uma variável
de caminho e o índice a ser consultado no vetor de pontos. A função
irá percorrer os pontos da origem para copiá-los da esquerda para a
direita.

Fazendo isso nós iremos obter como resultado uma variável plana, com
todos os seus pontos em um único vetor, sem mais variáveis de caminho
recursivas dentro de outra variável de caminho. Segue a definição da
função a seguir:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool aux_reverse(struct path_points **right_dst,
                 struct path_variable *pointer, int *index,
                 int *copied_points, int total_points){
  while(*copied_points < total_points){
    if(pointer -> points[*index].subpath == NULL &&
       !isnan(pointer -> points[*index].x)){
      // Copiar:
      memcpy(*right_dst, &(pointer -> points[*index]),
             sizeof(struct path_points));
      (*right_dst) -> subpath = NULL;
      (*right_dst) --;
      (*copied_points) ++;
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].subpath != NULL){
      int new_index = 0;
      aux_reverse(right_dst, (struct path_variable *)
                  (pointer -> points[*index].subpath),
                  &new_index, copied_points, total_points);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

Essa função auxiliar vai nos ajudar a definir a verdadeira função que
fará a reversão. A função de reversão será chamada abaixo, quando
detectarmos o operador de reversão:

\iniciocodigo
@<Caminho Primário: Reverso@>=
struct path_variable tmp;
if(begin_expression -> next == NULL ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                      &tmp))
  return false;
result -> length = tmp.total_length;
result -> total_length = tmp.total_length;
result -> points =
     (struct path_points *)
     temporary_alloc(sizeof(struct path_points) * tmp.total_length);
reverse_path(&tmp, result);
if(temporary_free != NULL)
  path_recursive_free(temporary_free, &tmp, false);
return true;
@
\fimcodigo

Temos agora que definir a verdadeira função que realizará a
reversão. A declaração da função é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void reverse_path(struct path_variable *src, struct path_variable *dst){
  int index = 0, i, copied_points = 0;
  struct path_points *right = &(dst -> points[dst -> length - 1]);
  struct path_variable *l = src;
  aux_reverse(&right, l, &index, &copied_points, dst -> length);
  for(i = 0; i < dst -> length - 1; i ++){
    dst -> points[i].u_x = dst -> points[i + 1].v_x;
    dst -> points[i].u_y = dst -> points[i + 1].v_y;
    dst -> points[i].v_x = dst -> points[i + 1].u_x;
    dst -> points[i].v_y = dst -> points[i + 1].u_y;
  }
  dst -> points[i].u_x = dst -> points[i].x;
  dst -> points[i].u_y = dst -> points[i].y;
  dst -> points[i].v_x = dst -> points[i].x;
  dst -> points[i].v_y = dst -> points[i].y;
  dst -> cyclic = src -> cyclic;
}
@
\iniciocodigo

O próximo passo é calcular um subcaminho. O subcaminho gera um novo
caminho que é parte de um caminho maior. Por exemplo:

\alinhaverbatim
subpath (0, 2) of p1 -- p2 -- p3;
\alinhanormal

O código acima avalia para o novo caminho \monoespaco{p1 -- p2},
assumindo que \monoespaco{p1} e \monoespaco{p2} são um único ponto
cada um.

No METAFONT original, é possível calcular subcaminhos entre pontos em
posições não-inteiras. Por exemplo, calcular o subcaminho do ponto 0,5
até 1,8. O METAFONT obteria um ponto intermediário entre os pontos de
controle 0 e 1 e entre 1 e 2 conforme pedido. Novos pontos de
extremidade e de controle adequados seriam gerados.  Aqui por hora
iremos suportar só uma versão mais simples de subcaminhos. Somente
subcaminhos inteiros serão suportados.

No caso de caminhos não-cíclicos, se tentarmos especificar um
subcaminho com uma posição menos que zero, tal índice será tratado
como zero. E se tentarmos especificar uma posição maior que seu índice
máximo, será tratada como igual ao seu índice máximo.

No case de caminhos cíclicos, índices negativos são contados
caminhando no ciclo na direção oposta do caminho. E também não há um
índice máximo permitido. Desta forma, você pode criar um subcaminho de
um caminho cíclico que é maior que o caminho original. Mas a natureza
cíclica do caminho será sempre perdida após a operação.

\iniciocodigo
@<Caminho Primário: Subcaminho@>=
DECLARE_NESTING_CONTROL();
struct pair_variable a;
struct path_variable b;
struct generic_token *of, *end_pair_expr = begin_expression;
struct generic_token *begin_subexpr;
if(begin_expression -> next == NULL ||  end_pair_expr -> type == TYPE_OF ||
   begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
of = (struct generic_token *) (end_pair_expr -> next);
while(of != NULL && of != end_expression){
  COUNT_NESTING(of);
  if(IS_NOT_NESTED() && of -> type == TYPE_OF)
    break;
  end_pair_expr = of;
  of = (struct generic_token *) (of -> next);
}
if(of == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.\n",  mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_expression(mf, cx, (struct generic_token *) begin_expression -> next,
                         end_pair_expr, &a))
  return false;
begin_subexpr = of -> next;
if(!eval_path_primary(mf, cx, begin_subexpr, end_expression, &b))
  return false;
{
  int final_path_size, offset;
  result -> cyclic = false;
  if(a.x < 0 && !b.cyclic)
    a.x = 0;
  if(a.y < 0  && !b.cyclic)
    a.y = 0;
  if(a.x >= b.total_length  && !b.cyclic)
    a.x = b.total_length - 1;
  if(a.y >= b.total_length  && !b.cyclic)
    a.y = b.total_length - 1;
  final_path_size = a.y - a.x;
  if(final_path_size < 0)
    final_path_size *= -1;
  final_path_size ++;
  offset = (a.x <= a.y)?(a.x):(a.y);
  if(b.cyclic)
    offset = offset % (b.total_length - 1);
  else
    offset = offset % b.total_length;
  if(offset < 0)
    offset *= -1;
  result -> length = final_path_size;
  result -> total_length = final_path_size;
  result -> points = (struct path_points *)
                       temporary_alloc(final_path_size *
                                       sizeof(struct path_points));
  if(result -> points == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  copy_subpath(result -> points, &b, offset, final_path_size);
  // Ajusta últimos pontos de controle se perdemos o caráter cíclico:
  result -> points[result -> length - 1].u_x =
                                      result -> points[result -> length - 1].x;
  result -> points[result -> length - 1].u_y =
                                      result -> points[result -> length - 1].y;
  result -> points[result -> length - 1].v_x =
                                      result -> points[result -> length - 1].x;
  result -> points[result -> length - 1].v_y =
                                      result -> points[result -> length - 1].y;
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  if(a.x > a.y){
    struct path_variable c;
    c.length = result -> total_length;
    c.total_length = result -> total_length;
    c.points = (struct path_points *) temporary_alloc(sizeof(struct path_points) *
                                                      c.total_length);
    if(c.points == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No enough memory!\n" , mf -> file,
              begin_expression -> line);
#endif
      return false;
    }
    reverse_path(result, &c);
    temporary_free(result -> points);
    result -> points = c.points;
  }
  return true;
}
@
\fimcodigo

Temos agora que apresentar a função que efetivamente copia
recursivamente um caminho para o outro, como visto no código
acima. Essa função recebe um ponteiro para onde cada ponto será
copiado da esquerda para a direita, recebe uma variável de caminho, um
offset representando quantos pontos iniciais serão ignorados e o
número de pontos que devem ser copiados:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size);
@
\fimcodigo

A definição da função será a seguinte:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void copy_subpath(struct path_points *dst, struct path_variable *src, int offset, int size){
  struct path_points *dst_pointer = dst;
  while(size > 0){
    int index = 0;
    int initial_offset = offset, initial_size = size;
    recursive_copy_subpath(&dst_pointer, src, &index, &offset, &size);
    // Se copiamos coisas, é um caminho cíclico e copiamos o último ponto:
    if(offset <= 0 && src -> cyclic &&
       initial_offset + initial_size >= src -> total_length){
      dst_pointer --; // O último ponto é redundante, igual ao 1o. Apagar.
      size ++;
    }
  }
}
@
\fimcodigo

E agora finalmente a função que irá percorrer recursivamente o caminho
de origem para copiá-lo:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size);
@
\fimcodigo


\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int recursive_copy_subpath(struct path_points **dst,
                           struct path_variable *pointer,
                           int *index, int *offset, int *size){
  while(*size > 0){
    if(pointer -> points[*index].subpath == NULL &&
       !isnan(pointer -> points[*index].x)){
      if(*offset > 0)
        (*offset) --;
      else{
        // Copy:
        memcpy(*dst, &(pointer -> points[*index]),
               sizeof(struct path_points));
        (*dst) -> subpath = NULL;
        (*dst) ++;
        (*size) --;
      }
      if(*index < pointer -> length - 1)
        (*index) ++;
      else
        return false;
    }
    else if(pointer -> points[*index].subpath != NULL){
      int new_index = 0;
      recursive_copy_subpath(dst, (struct path_variable *)
                                  (pointer -> points[*index].subpath),
                             &new_index, offset, size);
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index) ++;
    }
    else{
      if(*index >= pointer -> length - 1)
        return false;
      else
        (*index)  ++;
    }
  }
  return true;
}
@
\fimcodigo

O próximo caso a tratar é quando estamos diante de uma variável. Neste
caso, devemos determinar seu tipo. Pode ser um par ou um caminho. Em
seguida, alocamos o tamanho certo para nosso resultado e copiamos o
conteúdo da variável para ele:

\iniciocodigo
@<Caminho Primário: Variável@>=
{
  struct symbolic_token *v = (struct symbolic_token *) begin_expression;
  void *content = v -> var;
  if(((struct pair_variable *) content) -> type == TYPE_T_PAIR){
    result -> length = 1;
    result -> total_length = 1;
    result -> cyclic = false;
    result -> points = (struct path_points *)
                         temporary_alloc(sizeof(struct path_points));
    result -> points[0].x = ((struct pair_variable *) content) -> x;
    result -> points[0].y = ((struct pair_variable *) content) -> y;
    result -> points[0].u_x = ((struct pair_variable *) content) -> x;
    result -> points[0].u_y = ((struct pair_variable *) content) -> y;
    result -> points[0].v_x = ((struct pair_variable *) content) -> x;
    result -> points[0].v_y = ((struct pair_variable *) content) -> y;
    result -> points[0].subpath = NULL;
    return true;
  }
  else if(((struct path_variable *) content) -> type == TYPE_T_PATH){
    recursive_copy_points(temporary_alloc, &result,
                          (struct path_variable *) content, false);
    return true;
  }
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Variable is not pair nor path!\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

O próximo caso a ser tratado é quando a expressão primária de caminho
começa e termina com parênteses. E não estamos diante de um par. Neste
caso, devemos avaliar a expressão entre parênteses como uma nova
expressão de caminho. Mas para isso temos antes que checar que não há
uma vírgula dentro dela, caso em que estamos diante de um par:

\iniciocodigo
@<Caminho Primário: Parênteses@>=
struct generic_token *t = begin_expression -> next;
bool found_comma = false;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  if(IS_NOT_NESTED() && t -> type == TYPE_COMMA){
    found_comma = true;
    break;
  }
  t = t -> next;
}
if(!found_comma){
  return eval_path_expression(mf, cx, begin_expression -> next, t, result);
}
@
\fimcodigo

E finalmente, o último caso de expressãso primária é quando temos uma
expressão primária de par. Neste caso, alocamos o único ponto de nosso
caminho, avaliamos a expressão de par e passamos o resultado para o
ponto alocado:

\iniciocodigo
@<Caminho Primário: Par Primário@>=
struct pair_variable v;
if(!eval_pair_primary(mf, cx, begin_expression, end_expression, &v))
  return false;
result -> length = 1;
result -> total_length = 1;
result -> cyclic = false;
result -> points = (struct path_points *)
                     temporary_alloc(sizeof(struct path_points));
result -> points[0].subpath = NULL;
result -> points[0].x = v.x;
result -> points[0].y = v.y;
result -> points[0].u_x = v.x;
result -> points[0].u_y = v.y;
result -> points[0].v_x = v.x;
result -> points[0].v_y = v.y;
return true;
@
\fimcodigo

\subsubsecao{8.4.5. Caminhos em Expressões Numéricas}

Existe a expressão numérica primária com o
operador \monoespaco{length} que retorna o número de pontos de
extremidade de um caminho menos um. A sua sintaxe é:

\alinhaverbatim
<Primário Numérico> -> length <Caminho Primário>
\alinhanormal
%                       turningnumber <Caminho Primário> |
%                       directiontime <Expressão de Par> of <Caminho Primário>

Não precisamos aqui de nenhum tipo de token novo. A
expressão \monoespaco{length} já era usada para obter o módulo de
números e de pares. Para o caso deste operador obter um caminho, sua
implementação é ainda mais simples:

\iniciocodigo
@<Avalia 'length'@>+=
else if(expr_type == TYPE_T_PATH){
  struct path_variable p;
  if(!eval_path_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) (p.total_length - 1);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &p, false);
  return true;
}
@
\fimcodigo

\subsubsecao{8.4.6. Caminhos em Expressões de Pares}

Dado um caminho, nós podemos extrair pares dele. O par pode ser um dos
pontos de extremidade ou algum dos pontos de controle. A sintaxe para
isso é:

\alinhaverbatim
<Primário de Par> -> point <Expressão Numérica> of <Primário de Caminho> |
                     precontrol <Expressão Numérica> of <Primário de Caminho> |
                     postcontrol <Expressão Numérica> of <Primário de Caminho>
\alinhanormal

Isso requer adicionarmos os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_POINT,             // O token simbólico 'point'
TYPE_PRECONTROL,        // O token simbólico 'precontrol'
TYPE_POSTCONTROL,       // O token simbólico 'postcontrol'
@
\fimcodigo

E os adicionamos à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"point", "precontrol", "postcontrol",
@
\fimcodigo

Todos estes operadores requerem que nós encontremos determinado ponto
na posição $n$ de um caminho. Para isso, será útil uma função auxiliar
que irá receber uma variável de caminho e um número e irá retornar um
ponteiro para um dos pontos desta variável. Essa função irá primeiro
verificar se temos um caminho onde o tamanho total é igual ao tamanho
(\monoespaco{length == total\_length}). Se for o caso, assumiremos
estar diante de um caminho sem subcaminhos recursivos e retornar o
ponto correto será fácil e rápido. Caso contrário, vamos chamar uma
função recursiva auxiliaar para nos responder qual é o ponto correto:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct path_points *get_point(struct path_variable *v, int n){
  if(v -> length == v -> total_length){
    struct path_points *ret = (struct path_points *) &(v -> points[n]);
    while(ret -> subpath != NULL)
      ret = &(((struct path_variable *) (ret -> subpath)) -> points[0]);
    return ret;
  }
  else{
    int count = 0;
    return _get_point(v, n, &count);
  }
}
@
\fimcodigo

Essa função auxiliar recursiva para obter o ponto correto no caso de
caminhos com subcaminhos recursivos irá percorrer os pontos do caminho
na ordem, contando quantos são encontrados. E irá retornar o ponto
quando chegar ao correto. Para isso ela precisa saber qual a variável
de caminho, qual o índice $n$ do ponto e por fim, quantos pontos já
foram percorridos:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count);
@
\fimcodigo

A definição desta função será:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
struct path_points *_get_point(struct path_variable *v, int n, int *count){
  int i;
  for(i = 0; i < v -> length; i ++){
    if(v -> points[i].subpath == NULL) {
      if(*count == n && !isnan(v -> points[i].x))
	return ((struct path_points *) &(v -> points[i]));
      else if(!isnan(v -> points[i].x))
	(*count) ++;
    }
    else{
      struct path_points *r =
	_get_point((struct path_variable *) (v -> points[i].subpath),
		   n, count);
      if(r != NULL)
	return r;
    }
  }
  return NULL;
}
@
\fimcodigo


No caso do primeiro operador, \monoespaco{point}, ele nos retorna o
ponto de extremidade indicado. Se o caminho não for cíclico, os pontos
de índice menor que zero serão iguais ao de índice zero (o primeiro) e
os pontos de índice maior ou igual ao tamanho serão iguais ao último
ponto. Se o caminho for cíclico, o índice é contado seguindo o
ciclo. No METAFONT original, índices não-positivos eram permitidos,
mas aqui eles serão convertidos para inteiros.

O operador \monoespaco{postcontrol} é semelhante, mas ele obtém o
primeiro ponto de controle imediatamente após o ponto cujo índice é
indicado. E o \monoespaco{precontrol} obtém o ponto de controle
imediatamente antes do ponto indicado.

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>=
if(begin_expression -> type == TYPE_POINT ||
   begin_expression -> type == TYPE_PRECONTROL ||
   begin_expression -> type == TYPE_POSTCONTROL){
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_num, *end_num , *of = NULL, *begin_path, *end_path;
  struct numeric_variable a;
  struct path_variable b;
  begin_num = begin_expression -> next;
  end_num = begin_num;
  int index;
  while(end_num != NULL && end_num -> next != end_expression){
    COUNT_NESTING(end_num);
    if(IS_NOT_NESTED() &&
       ((struct generic_token *) end_num -> next) -> type == TYPE_OF){
      of = end_num -> next;
      break;
    }
    end_num = end_num -> next;
  }
  if(of == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing 'of' in 'point' expression\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(of -> next == NULL || of == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing path expression in "
            "'point' expression\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  begin_path = of -> next;
  end_path = end_expression;
  if(!eval_numeric_expression(mf, cx, begin_num, end_num, &a))
    return false;
  if(!eval_path_primary(mf, cx, begin_path, end_path, &b))
    return false;
  if(b.cyclic){
    index = ((int)(a.value)) % (b.total_length - 1);
    if(begin_expression -> type == TYPE_PRECONTROL)
      index = (index - 1) % (b.total_length - 1);
  }
  else{
    index = (int) (a.value);
    if(index < 0) index = 0;
    if(index >= b.total_length) index = b.total_length - 1;
    if(begin_expression -> type == TYPE_PRECONTROL)
      index --;
  }
  if(begin_expression -> type == TYPE_POINT){
    result -> x = get_point(&b, index) -> x;
    result -> y = get_point(&b, index) -> y;
  }
  else if(begin_expression -> type == TYPE_PRECONTROL){
    if(index < 0){
      result -> x = get_point(&b, 0) -> x;
      result -> y = get_point(&b, 0) -> y;
    }
    else{
      result -> x = get_point(&b, index) -> v_x;
      result -> y = get_point(&b, index) -> v_y;
    }
  }
  else{
    result -> x = get_point(&b, index) -> u_x;
    result -> y = get_point(&b, index) -> u_y;
  }
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &b, false);
  return true;
}
@
\fimcodigo

\subsecao{8.5. Atribuições e Expressões de Caneta}

Para realizar a atribuição de canetas a variáveis do tipo certo,
usamos o código abaixo:

\iniciocodigo
@<Atribuição de Variável de Caneta@>=
else if(type == TYPE_T_PEN){
  int i;
  struct pen_variable result;
  if(!eval_pen_expression(mf, cx, begin_expression,
                         (struct generic_token *) *end_token_list,
                         &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pen_variable(mf, (struct pen_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL && result.format !=  NULL)
    path_recursive_free(temporary_free, result.format, true);
  if(result.gl_vbo != 0 && result.referenced == NULL)
    glDeleteBuffers(1, &(result.gl_vbo));
}
@
\fimcodigo

A declaração da função que faz a atribuição:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_pen_variable(struct metafont *mf,
                        struct pen_variable *target,
                        struct pen_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_pen_variable(struct metafont *mf,
                          struct pen_variable *target,
                          struct pen_variable *source){
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> format != NULL && disalloc != NULL)
    path_recursive_free(disalloc, target -> format, true);
  if(target -> gl_vbo != 0)
    glDeleteBuffers(1, &(target -> gl_vbo));
  memcpy(target, source, sizeof(struct pen_variable));
  target -> type = TYPE_T_PEN;
  if(! (source -> flags & (FLAG_CIRCULAR | FLAG_SQUARE | FLAG_NULL)))
    recursive_copy_points(alloc, &(target -> format), source -> format, true);
  target -> gl_vbo = 0;
  target -> indices = 0;
  target -> referenced = NULL;
  // Se estamos atribuindo para 'currentpen', devemos retriangular a caneta.
  // Conforme descrito na Seção 10.
  if(target == &(mf -> internal_pen_variables[INTERNAL_PEN_CURRENTPEN]))
    triangulate_pen(mf, target, target -> gl_matrix);
}
@
\fimcodigo

\subsubsecao{8.5.1. Expressão Terciária de Caneta}

Por enquanto não existe nenhum operador terciário de caneta:

\alinhaverbatim
<Expressão de Caneta> -> <Terciário de Caneta>
<Terciário de Caneta> -> <Secundário de Caneta>
\alinhanormal

Então a função que avalia expressão terciária de canetas apenas
repassa a expressão para a expressão secundária:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_expression(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result){
  return eval_pen_secondary(mf, cx, begin_expression, end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.5.2. Transformadores de Caneta}

A sintaxe para expressões secundárias de caneta é:

\alinhaverbatim
<Secundário de Caneta> -> <Primário de Caneta> |
                          <Secundário de Caneta> <Transformador>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> |
                   transformed <Primário de Transformação>
\alinhanormal

Transformadores não são coisas novas, eles já eram usados em
expressões de pares, transformações e de caminho. Mas aplicá-los sobre
canetas é ligeiramente diferente, pois ao invés de modificar cada um
de seus pontos, nós modificamos apenas sua matriz de transformação
OpenGL.

A declaração da função que avaliará expressões secundárias de caneta
é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_token_list,
                        struct pen_variable *result);
@
\fimcodigo

Sua implementação consiste em percorrer os tokens da expressão até
achar o último transformador, se houver. Se não houver, é só repassar
a avaliação para a função que avalia expressões primárias. Se houver,
então avaliamos como expressão secundária o que vem antes e então
realizamos a transformação adequada:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_secondary(struct metafont *mf, struct context *cx,
                        struct generic_token *begin_expression,
                        struct generic_token *end_expression,
                        struct pen_variable *pen){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_pen_primary(mf, cx, begin_expression, end_expression, pen);
  else{
    if(!eval_pen_secondary(mf, cx, begin_expression, before_last_transformer, pen))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Secundário de Caneta: Rotação@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Secundário de Caneta: Escala@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Secundário de Caneta: Deslocamento@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Secundário de Caneta: Inclinação@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Secundário de Caneta: X-Escala@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Secundário de Caneta: Y-Escala@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Secundário de Caneta: Z-Escala@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Secundário de Caneta: Transformação Genérica@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Primeiro cuidaremos da rotação em um ângulo $\theta$. Primeiro fazemos
a conversão entre o ângulo medido em graus que o WeaveFONT usa e a
medida em radianos esperada pela biblioteca padrão C. Rotacionar
significa aplicar a transformação de rotação sobre a matriz de
transformação da caneta:

\iniciocodigo
@<Secundário de Caneta: Rotação@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(pen -> gl_matrix, rotation);
return true;
@
\fimcodigo

Para fazer a operação de escala também aplicamos tal transformação
sobre a matriz da caneta:

\iniciocodigo
@<Secundário de Caneta: Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(pen -> gl_matrix, a.value);
// Canetas curvas devem ser retrianguladas se aumentam de tamanho:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

A transformação de deslocamento que desloca a caneta na horizontal e
vertical é tratada abaixo:

\iniciocodigo
@<Secundário de Caneta: Deslocamento@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SHIFT(pen -> gl_matrix, p.x, p.y);
return true;
@
\fimcodigo

O próximo transformador é a inclinação. 

\iniciocodigo
@<Secundário de Caneta: Inclinação@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(pen -> gl_matrix, a.value);
// Inclinar canetas curvas não-circulares requer retriangulação:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT) &&
   !(pen -> flags & FLAG_CIRCULAR)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

A transformação de escala no eixo $x$ é igual à transformação de
escala, mas a caneta é esticada ou comprimida somente no eixo
horizontal:

\iniciocodigo
@<Secundário de Caneta: X-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(pen -> gl_matrix, a.value);
// Canetas curvas devem ser retrianguladas se aumentam de tamanho:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Da mesma forma, mudar a escala somente no eixo $y$ é feito no código
abaixo:

\iniciocodigo
@<Secundário de Caneta: Y-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(pen -> gl_matrix, a.value);
// Canetas curvas devem ser retrianguladas se aumentam de tamanho:
if(pen -> gl_vbo != 0 && a.value > 1.0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

A mudança de escala $z$ înterpreta dois pares como números
complexos e os multiplica:

$$
(x+yi)(a+bi) = ax + (bx)i + (ay)i + (by)i^2 = (ax - by) + (bx+ay)i
$$

Podemos então realizar a operação acima usando o código abaixo:

\iniciocodigo
@<Secundário de Caneta: Z-Escala@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(pen -> gl_matrix, p.x, p.y);
// Canetas curvas devem ser retrianguladas neste caso:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

Por fim, a última transformação é a genérica que envolve aplicar a
transformação linear que está armazenada em um transformador:

\iniciocodigo
@<Secundário de Caneta: Transformação Genérica@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression, &t))
  return false;
MATRIX_MULTIPLICATION(pen -> gl_matrix, t.value);
// Canetas curvas devem ser retrianguladas neste caso:
if(pen -> gl_vbo != 0 && !(pen -> flags & FLAG_STRAIGHT)){
  glDeleteBuffers(1, &(pen -> gl_vbo));
  pen -> gl_vbo = 0;
  pen -> indices = 0;
}
return true;
@
\fimcodigo

\subsubsecao{8.5.3. Expressões Primárias de Caneta}

A gramática das expressões primárias de caminho é definida como:

\alinhaverbatim
<Primário de Caneta> -> <Variável de Caneta> |
                        nullpen | ( <Expressão de Caneta> ) |
                        pencircle | makepen <Primário de Caminho>
\alinhanormal


Isso requer registrar três novas palavras reservadas:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_NULLPEN,        // O token simbólico 'nullpen'
TYPE_PENCIRCLE,      // O token simbólico 'pencircle'
TYPE_MAKEPEN,        // O token simbólico 'makepen'
@
\fimcodigo

E adicionamos uma string com o nome delas na lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"nullpen", "pencircle", "makepen",
@
\fimcodigo

A função que irá interpretar expressões primárias de caneta é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_pen_primary(struct metafont *mf, struct context *cx,
                      struct generic_token *begin_expression,
                      struct generic_token *end_expression,
                      struct pen_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Caneta Primária: Variável@>
    }
    else if(begin_expression -> type == TYPE_NULLPEN){
      @<Caneta Primária: Caneta Nula@>
    }
    else if(begin_expression -> type == TYPE_PENCIRCLE){
      @<Caneta Primária: Caneta Circular@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Caneta Primária: Parênteses@>
    }
    else if(begin_expression -> type == TYPE_MAKEPEN){
      @<Caneta Primária: Formato Personalizado@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized pen expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

Se a expressão avaliar para uma variável, devemos copiar o conteúdo da
variável. Se avaliar para uma variável que aponta para outra (o caso
do \monoespaco{currentpen}), devemos ao invés disso copiar o conteúdo
da variável referenciada. Mas depois disso devemos multiplicar a
matriz da variável que aponta pela matriz obtida copiada.

\iniciocodigo
@<Caneta Primária: Variável@>=
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct pen_variable *content = v -> var, *to_copy = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-pen variable (%d) in pen expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
if(content -> referenced != NULL)
  to_copy = content -> referenced;
memcpy(result, to_copy, sizeof(struct pen_variable));
if(to_copy -> format != NULL)
  recursive_copy_points(temporary_alloc, &(result -> format),
                        to_copy -> format, true);
if(to_copy != content)
  MATRIX_MULTIPLICATION(result -> gl_matrix, content -> gl_matrix);
return true;
@
\fimcodigo

Se a expressão avaliar para uma caneta nula, devemos apenas gerar uma
nova caneta com a flag de \monoespaco{FLAG\_NULL} ativa. Esta caneta
nunca será triangulada e nunca produzirá qualquer desenho:

\iniciocodigo
@<Caneta Primária: Caneta Nula@>=
result -> format = NULL;
result -> flags = FLAG_NULL;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

Se a expressão avaliar para uma caneta circular, geraremos uma nova
caneta com as flags de ser circular e convexa. Também inicializamos a
matriz de transformação como sendo a matriz identidade:

\iniciocodigo
@<Caneta Primária: Caneta Circular@>=
result -> format = NULL;
result -> flags = FLAG_CONVEX | FLAG_CIRCULAR;
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

Avaliar parênteses envolve avaliar como expressão de caneta os tokens
do que vem após o abrir parênteses até o que vem imediatamente antes
do fechar parênteses:

\iniciocodigo
@<Caneta Primária: Parênteses@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_pen_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

O último caso de expressão primária de caneta é quando o usuário
escolhe um formato personalizado. Neste caso devemos avaliar a
expressão de caminho indicada e com ela criamos a nova caneta com tal
formato:

\iniciocodigo
@<Caneta Primária: Formato Personalizado@>=
struct generic_token *p = begin_expression -> next;
result -> format =
        (struct path_variable *) temporary_alloc(sizeof(struct path_variable));
if(result -> format == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not enough memory.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_path_primary(mf, cx, p, end_expression, result -> format))
  return false;
if(!(result -> format -> cyclic)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr,
          "METAFONT: Error: %s:%d: Using 'makepen' with non-cyclic path.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
result -> flags = read_flags(result -> format); // Função a ser implemementada
result -> referenced = NULL;
result -> gl_vbo = 0;
result -> indices = 0;
INITIALIZE_IDENTITY_MATRIX(result -> gl_matrix);
return true;
@
\fimcodigo

O que falta implementar para que o código acima funcione é a função
que percorra os pontos de uma variável de caminho e retorne quais
flags teria uma caneta com aquele formato.

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int read_flags(struct path_variable *path);
@
\fimcodigo

Já sabemos que ela nunca seria circular, pois círculos perfeitos não
podem ser expressos como curvas de Beziér. Iremos então verificar se
ela é reta ou convexa percorrendo os seus pontos:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int read_flags(struct path_variable *path){
  int i, positive_cross_product = -1;
  int flag = FLAG_CONVEX | FLAG_STRAIGHT;
  for(i = 0; i < path -> total_length - 1; i ++){
    struct path_points *current, *next;
    current = get_point(path, i);
    next = get_point(path, i + 1);
    if(flag & FLAG_STRAIGHT){
      // Ela não é reta se os pontos de extremidade e de controle não estão
      // na mesma reta. Eles estão na mesma reta se a área de seu triângulo
      // é igual a zero (ou suficientemente próxima):
      double area =  current -> x * (current -> u_y - next -> y) +
                     current -> u_x * (next -> y - current -> y) +
                     next -> x * (current -> y - current -> u_y);
      if(area > 0.00002)
        flag -= FLAG_STRAIGHT;
      area =  current -> x * (current -> v_y - next -> y) +
              current -> v_x * (next -> y - current -> y) +
              next -> x * (current -> y - current -> v_y);
      if((flag & FLAG_STRAIGHT) && area > 0.00002)
        flag -= FLAG_STRAIGHT;
    }
    if(flag & FLAG_CONVEX){
      // Ela é convexa somente se o componente z do produto vetorial dos
      // vetores formados pelos pontos de extremidade e controle na ordem
      // de desenho são todos ou não-positivos ou não-negativos.
      int j;
      double d1_x, d1_y, d2_x, d2_y, z_cross_product;
      double p1_x, p1_y, p2_x, p2_y, p3_x, p3_y; // Pontos
      for(j = 0; j < 3; j ++){
        switch(j){
          case 0:
            p1_x = current -> x; p1_y = current -> y;
            p2_x = current -> u_x; p2_y = current -> u_y;
            p3_x = current -> v_x; p3_y = current -> v_y;
            break;
          case 1:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> x; p3_y = next -> y;
            break;
          default:
            p1_x = p2_x; p1_y = p2_y;
            p2_x = p3_x; p2_y = p3_y;
            p3_x = next -> u_x; p3_y = next -> u_y;
            break;
        }
        d1_x = p2_x - p1_x;
        d1_y = p2_y - p1_y;
        d2_x = p3_x - p2_x;
        d2_y = p3_y - p2_y;
        z_cross_product = d1_x * d2_y - d1_y * d2_x;
        if(z_cross_product > 0.00002 || z_cross_product < -0.00002){
          if(positive_cross_product == -1)
            positive_cross_product = (z_cross_product > 0);
          else if((z_cross_product > 0) != positive_cross_product){
            flag -= FLAG_CONVEX;
            break;
          }
        }
      }
    }
  }
  return flag;
}
@
\fimcodigo

\subsubsecao{8.5.4. Canetas em Expressões de Caminho}

Expressões primárias de caneta podem aparecer também quando avaliamos
uma expressão primária de caminho. Isso permite que possamos extrair
um caminho à partir do formato de uma caneta. A gramática de tal
operação é:

\alinhaverbatim
<Primário de Caminho> -> makepath <Primário de Caneta>
\alinhanormal

Temos que registrar um novo token para o ``makepath'':

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_MAKEPATH,       // O token simbólico 'makepath'
@
\fimcodigo

E adicionamos a string com seu nome à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"makepath",
@
\fimcodigo

O operador ``makepath'' deve avaliar tudo o que vem depois dele como
sendo uma expressão primária da caneta. Em seguida, o resultado da
avaliação é um caminho com o formato da caneta. Contudo, devemos
lembrar que nem sempre armazenamos o formato de uma caneta
explicitamente. Caso tenhamos uma \monoespaco{nullpen},
um \monoespaco{circlepen} ou se estivermos diante de um quadrado,
então precisamos gerar um caminho novo, já que não temos caminho nenhum:

\iniciocodigo
@<Caminho Primário: Outras Expressões@>=
else if(begin_expression -> type == TYPE_MAKEPATH){
  struct pen_variable tmp;
  if(begin_expression -> next == NULL ||
     begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_pen_primary(mf, cx, begin_expression -> next, end_expression,
                       &tmp))
    return false;
  if(tmp.flags & FLAG_NULL){ // nullpen: Avalia para ponto único (0, 0)
    @<'makepath': 'nullpen'@>
  }
  else if(tmp.flags & FLAG_CIRCULAR){ // circlepen: Cria aproximação de círculo
    @<'makepath': 'pencircle'@>
  }
  else if(tmp.flags & FLAG_SQUARE){ // Caneta quadrada
    @<'makepath': 'pensquare'@>
  }
  else{ // Caneta com formato personalizado
    @<'makepath': Formato Personalizado@>
  }
  @<'makepath': Realiza Transformação Linear@>
  return true;
}
@
\fimcodigo

Assim como na linguagem METAFONT original, o \monoespaco{nullpen}
significa um único ponto na posição $(0, 0)$ que nunca é desenhado:

\iniciocodigo
@<'makepath': 'nullpen'@>=
result -> length = 1;
result -> total_length = 1;
result -> cyclic = false;
result -> points =
  (struct path_points *) temporary_alloc(sizeof(struct path_points));
result -> points[0].x = 0.0;
result -> points[0].y = 0.0;
result -> points[0].u_x = 0.0;
result -> points[0].u_y = 0.0;
result -> points[0].v_x = 0.0;
result -> points[0].v_y = 0.0;
result -> points[0].subpath = NULL;
@
\fimcodigo

Caso estejamos diante de um caminho circular, usaremos como
representação do caminho os mesmos valores que o METAFONT original usa
para representar o caminho na macro \monoespaco{fullcircle}. O
resultado será algo próximo a um círculo.

\iniciocodigo
@<'makepath': 'pencircle'@>=
result -> length = 9;
result -> total_length = 9;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 9);
result -> points[0].subpath = NULL;
result -> points[0].x = 0.5; result -> points[0].y = 0.0;
result -> points[0].u_x = 0.5; result -> points[0].u_y = 0.13261;
result -> points[0].v_x = 0.44733; result -> points[0].v_y = 0.2598;
result -> points[1].subpath = NULL;
result -> points[1].x = 0.35356; result -> points[1].y = 0.35356;
result -> points[1].u_x = 0.2598; result -> points[1].u_y = 0.44733;
result -> points[1].v_x = 0.13261; result -> points[1].v_y = 0.5;
result -> points[2].subpath = NULL;
result -> points[2].x = 0.0; result -> points[2].y = 0.5;
result -> points[2].u_x = -0.13261; result -> points[2].u_y = 0.5;
result -> points[2].v_x = -0.2598; result -> points[2].v_y = 0.44733;
result -> points[3].subpath = NULL;
result -> points[3].x = -0.35356; result -> points[3].y = 0.35356;
result -> points[3].u_x = -0.44733; result -> points[3].u_y = 0.2598;
result -> points[3].v_x = -0.5; result -> points[3].v_y = 0.13261;
result -> points[4].subpath = NULL;
result -> points[4].x = -0.5; result -> points[4].y = 0.0;
result -> points[4].u_x = -0.5; result -> points[4].u_y = -0.13261;
result -> points[4].v_x = -0.44733; result -> points[4].v_y = -0.2598;
result -> points[5].subpath = NULL;
result -> points[5].x = -0.35356; result -> points[5].y = -0.35356;
result -> points[5].u_x = -0.2598; result -> points[5].u_y = -0.44733;
result -> points[5].v_x = -0.13261; result -> points[5].v_y = -0.5;
result -> points[6].subpath = NULL;
result -> points[6].x = 0.0; result -> points[6].y = -0.5;
result -> points[6].u_x = 0.13261; result -> points[6].u_y = -0.5;
result -> points[6].v_x = 0.2598; result -> points[6].v_y = -0.44733;
result -> points[7].subpath = NULL;
result -> points[7].x = 0.35356; result -> points[7].y = -0.35356;
result -> points[7].u_x = 0.44733; result -> points[7].u_y = -0.2598;
result -> points[7].v_x = 0.5; result -> points[7].v_y = -0.13261;
result -> points[8].subpath = NULL;
result -> points[8].x = 0.5; result -> points[8].y = 0.0;
result -> points[8].u_x = 0.5; result -> points[8].u_y = 0.13261;
result -> points[8].v_x = 0.44733; result -> points[8].v_y = 0.2598;
result -> cyclic = true;
@
\fimcodigo

Se acaneta for quadrada, geramos seu formato verdadeiro preenchendo
manualmente seus pontos de extremidade e de controle:

\iniciocodigo
@<'makepath': 'pensquare'@>=
result -> length = 5;
result -> total_length = 5;
result -> points =
   (struct path_points *) temporary_alloc(sizeof(struct path_points) * 5);
result -> points[0].subpath = NULL;
result -> points[0].x = -0.5; result -> points[0].y = -0.5;
result -> points[0].u_x = (-0.5+(1.0/3.0)); result -> points[0].u_y = -0.5;
result -> points[0].v_x = (-0.5+(2.0/3.0)); result -> points[0].v_y = -0.5;
result -> points[1].subpath = NULL;
result -> points[1].x = 0.5; result -> points[1].y = -0.5;
result -> points[1].u_x = 0.5; result -> points[1].u_y = (-0.5+(1.0/3.0));
result -> points[1].v_x = 0.5; result -> points[1].v_y = (-0.5+(2.0/3.0));
result -> points[2].subpath = NULL;
result -> points[2].x = 0.5; result -> points[2].y = 0.5;
result -> points[2].u_x = (0.5-(1.0/3.0)); result -> points[2].u_y = 0.5;
result -> points[2].v_x = (0.5-(2.0/3.0)); result -> points[2].v_y = 0.5;
result -> points[3].subpath = NULL;
result -> points[3].x = -0.5; result -> points[3].y = 0.5;
result -> points[3].u_x = -0.5; result -> points[3].u_y = (0.5-(1.0/3.0));
result -> points[3].v_x = -0.5; result -> points[3].v_y = (0.5-(2.0/3.0));
result -> points[4].subpath = NULL;
result -> points[4].x = -0.5; result -> points[4].y = -0.5;
result -> points[4].u_x = (-0.5+(1.0/3.0)); result -> points[4].u_y = -0.5;
result -> points[4].v_x = (-0.5+(2.0/3.0)); result -> points[4].v_y = -0.5;
result -> cyclic = true;
@
\fimcodigo

Por fim, se estivermos diante de uma caneta com formato personalizado,
então nós já temos uma representação de seu formato na forma de um
caminho e nós só temos que copiá-la:

\iniciocodigo
@<'makepath': Formato Personalizado@>=
recursive_copy_points(temporary_alloc, &result, tmp.format, false);
if(temporary_free != NULL && tmp.referenced == NULL)
  temporary_free(tmp.format);
@
\fimcodigo

E finalmente, uma vez que tenhamos o nosso caminho, devemos aplicar
todas as transformações de rotação, translação e demais transformações
lineares que estiverem registradas na matriz de transformação OpenGL:

\iniciocodigo
@<'makepath': Realiza Transformação Linear@>=
{
  int i;
  for(i = 0; i < result -> length; i ++){
    float x0 = result -> points[i].x, y0 = result -> points[i].y;
    result -> points[i].x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].u_x;
    y0 = result -> points[i].u_y;
    result -> points[i].u_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].u_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
    x0 = result -> points[i].v_x;
    y0 = result -> points[i].v_y;
    result -> points[i].v_x = LINEAR_TRANSFORM_X(x0, y0, tmp.gl_matrix);
    result -> points[i].v_y = LINEAR_TRANSFORM_Y(x0, y0, tmp.gl_matrix);
  }
}
@
\fimcodigo

\subsecao{8.6. Atribuições e Expressões de Imagens}

Para realizar a atribuição de imagens a variáveis do tipo certo,
usamos o código abaixo. O que ele faz é avaliar uma expressão de
imagem e coletar o resultado. Em seguida, ele precisa fazer com que
todas as variáveis da atribuição recebam uma cópia da imagem
avaliada. Se existe somente uma variável a ser atribuída, nós apenas
copiamos o identificador textura já obtida e desenhada na
avaliação. Se houver mais de uma variável, a primeira delas recebe uma
cópia direta do identificador da imagem já obtida. Para as demais,
precisaremos usar comandos OpenGL para copiar a textura avaliada para
o destino.

\iniciocodigo
@<Atribuição de Variável de Imagem@>=
else if(type == TYPE_T_PICTURE){
  int i;
  struct picture_variable result;
  if(!eval_picture_expression(mf, cx, begin_expression,
                              (struct generic_token *) *end_token_list,
                              &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    if(i == 0){
      struct picture_variable *pic = (struct picture_variable *) var -> var;
      if(pic -> texture != 0)
        glDeleteTextures(1, &(pic -> texture));
      memcpy(pic, &result, sizeof(struct picture_variable));
      pic -> type = TYPE_T_PICTURE;
      // Se atribuindo para 'currentpicture', precisamos de código adicional
      if(pic ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
        // O código abaixo será definido na Subseção 11.2:
        @<Gera nova 'currentpicture'@>
      }
    }
    else 
      assign_picture_variable(mf, (struct picture_variable *) var -> var,
                              &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }  
}
@
\fimcodigo

A função \monoespaco{assign\_picture\_variable} acima precisa gerar
uma nova textura na variável de destino (apagando a textura já
existente se for o caso) e copiar o conteúdo da textura de origem no
destino. Isso significa que nós precisaremos renderizar o conteúdo de
uma textura na outra.

Para renderizar algo, primeiro precisaremos de vértices. Como tudo que
vamos renderizar são sempre imagens e texturas retangulares, os únicos
vértices que precisaremos renderizar são:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
const static float square[20] = {
  -1.0, -1.0, //Primeiro vértice
  0.0, 0.0, // Coordenada da textura
  1.0, -1.0, // Segundo vértice
  1.0, 0.0, // Textura
  1.0, 1.0, // Terceiro vértice
  1.0, 1.0, // Textura
  -1.0, 1.0, // Quarto vértice
  0.0, 1.0}; // Textura
static GLuint vbo; // OpenGL Vertex Buffer Object
@
\fimcodigo

Associamos acima a cada vértice uma coordenada de textura. Desta forma
conseguiremos enviar para a placa de vídeo ambas as informações de uma
só vez. Note que o que definimos acima é um quadrado de lado 2
centralizado na origem. Este é o tamanho padrão para que ele seja
renderizado em todo o espaço disponível nas convenções OpenGL. Nós
também definimos o quadrado definindo seus vértices no sentido
anti-horário, o que faz com que por convenção ele seja renderizado de
frente para a câmera. Isso é necessário para que o quadrado sempre
seja renderizado, mesmo que otimizações estejam ativas fazendo com que
o lado de trás dos polígonos não sejam desenhados.

Na inicialização do Weaver Metafont nós enviamos estes vértices para
a placa de vídeo:

\iniciocodigo
@<Inicialização de Weaver Metafont@>=
glGenBuffers(1, &vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// Enviando os vértices para a placa de vídeo:
glBufferData(GL_ARRAY_BUFFER, sizeof(square), square, GL_STATIC_DRAW);
@
\fimcodigo

Na finalização nós removemos os vértices da placa de vídeo:

\iniciocodigo
@<Finalização de Weaver Metafont@>=
glDeleteBuffers(1, &vbo);
@
\fimcodigo

Além de vértices, precisamos de um shader de vértice que nos indique
como renderizar tais vértices. O programa deve ser versátil o bastante
para receber como argumento uma matriz com transformações lineares a
serem aplicadas a cada vértice. Os atributos do programa são a
coordenada do vértice e da textura. O valor uniforme recebido é a
matriz para transformação linear. E o valor de retorno a ser passado para o shader de
fragmento é a posição final da coordenada depois da transformação,
além da coordenada de textura. 

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "varying highp vec2 texture_coordinate;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "  texture_coordinate = vertex_data.zw;\n"
  "}\n";
@
\fimcodigo

Já o código do shader de fragmento recebe a saída do shader de vértice
acima além de uma textura:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  gl_FragColor = texture2D(texture1, texture_coordinate);"
  "}\n";
static GLuint program; // Armazenará o programa após compilar os shaders acima
GLint uniform_matrix; // Armazenará a posição da matriz de modelo visualização acima
GLint uniform_texture; // A posição da variável de textura no código acima
@
\fimcodigo

Estes shaders simples precisam ser compilados na inicialização. Vamos
criar uma função auxiliar local para nos ajudar na compilação:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source);
@
\fimcodigo

Esta função irá retornar o identificador do programa compilado à
partir dos códigos-fontes dos shaders passados como argumento. Se algo
der errado, irá retornar zero.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
GLuint compile_shader_program(const char *vertex_shader_source,
                              const char *fragment_shader_source){
  GLuint vertex, fragment, prog;
  GLint status = GL_TRUE;
  // Criando shader de vértice e de fragmento
  vertex = glCreateShader(GL_VERTEX_SHADER);
  fragment = glCreateShader(GL_FRAGMENT_SHADER);
  // Passando o código-fonte a cada um deles
  glShaderSource(vertex, 1, &vertex_shader_source, NULL);
  glShaderSource(fragment, 1, &fragment_shader_source, NULL);
  // Compilando shader de vértice:
  glCompileShader(vertex);
  glGetShaderiv(vertex, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont vertex shader compilation failed!\n");
    return 0;
  }
  // Compilando shader de fragmento:
  glCompileShader(fragment);
  glGetShaderiv(fragment, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr,
            "ERROR: Weaver Metafont fragment shader compilation failed!\n");
    return 0;
  }
  // Criando programa:
  prog = glCreateProgram();
  // Ligando o programa:
  glAttachShader(prog, vertex);
  glAttachShader(prog, fragment);
  glBindAttribLocation(prog, 0, "vertex_data");
  glLinkProgram(prog);
  glGetProgramiv(prog, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    fprintf(stderr, "ERROR: Weaver Metafont shader linking failed!\n");
    return 0;
  }
  // Finalização:
  glDeleteShader(vertex);
  glDeleteShader(fragment);
  return prog;
}
@
\fimcodigo

E podemos usar esta função para inicializar nosso programa de shader padrão:

\iniciocodigo
@<Inicialização de Weaver Metafont@>+=
{
  program = compile_shader_program(vertex_shader, fragment_shader);
  uniform_matrix = glGetUniformLocation(program, "model_view_matrix");
  uniform_texture = glGetUniformLocation(program, "texture1");
}
@
\fimcodigo

Na finalização iremos destruir o programa compilado acima:

\iniciocodigo
@<Finalização de Weaver Metafont@>+=
glDeleteProgram(program);
@
\fimcodigo

Para a parte de renderizar o conteúdo de uma textura para dentro de
outra, devemos criar um framebuffer com uma nova textura associada a
ele. A função abaixo cria tanto um novo framebuffer como uma nova
textura, deixando-os ligados e ativos. Tudo o que for renderizado em
seguida será renderizado na nova textura, e não na tela.

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool get_new_framebuffer(GLuint *new_framebuffer, GLuint *new_texture,
                         int width, int height){
  glGenFramebuffers(1, new_framebuffer);
  glGenTextures(1, new_texture);
  glBindTexture(GL_TEXTURE_2D, *new_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
               GL_UNSIGNED_BYTE, NULL);
  glBindFramebuffer(GL_FRAMEBUFFER, *new_framebuffer);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                         *new_texture, 0);
  if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: OpenGL cannot create framebuffer!\n");
#endif
    glBindTexture(GL_TEXTURE_2D, 0);
    return false;
  }
  glBindTexture(GL_TEXTURE_2D, 0);
  return true;
}
@
\fimcodigo

Outro código que vamos usar muito e por isso é importante isolar em
uma função é para renderizar uma imagem usando o framebuffer atual e o
programa de shader padrão que fizemos:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background);
// XXX:
void print_picture(struct picture_variable *pic);
@
\fimcodigo

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void render_picture(struct picture_variable *pic, float *matrix, int dst_width,
                    int dst_height, bool clear_background){
  glColorMask(true, true, true, true);
  glViewport(0, 0, dst_width, dst_height);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *) 0);
  glEnableVertexAttribArray(0);
  glUseProgram(program);
  glUniformMatrix3fv(uniform_matrix, 1, true, matrix);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, pic -> texture);
  glUniform1i(uniform_texture, 0);
  if(clear_background){
    // Limpando o destino para branco transparente antes de renderizar:
    glClearColor(1.0, 1.0, 1.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
  }
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBindTexture(GL_TEXTURE_2D, 0);
}
// XXX:
void print_picture(struct picture_variable *pic){
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  GLuint framebuffer;
  GLuint texture;
  unsigned char data[100000];
  get_new_framebuffer(&framebuffer, &texture, pic -> width, pic -> height);
  render_picture(pic, model_view_matrix, pic -> width, pic -> height, true);
  // Ler dados do framebuffer:
  glFinish();
  glReadPixels(0, 0, pic -> width, pic -> height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    int i, j;
    for(i = pic -> width * (pic -> height - 1) * 4;
        i >= 0; i -= (pic -> width * 4)){
      for(j = 0; j < (pic -> width * 4); j += 4)
        printf("(%hu %hu %hu %hu)", (unsigned char) data[i + j], (unsigned char) data[i+j+1], (unsigned char) data[i+j+2], (unsigned char) data[i+j+3]);
        printf("\n");
    }
  }
}
@
\fimcodigo

Agora vamos declarar a função que atribui o conteúdo de uma variável
de imagem à outra, gerando uma nova textura e copiando o conteúdo das
texturas:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source);
@
\fimcodigo

E a sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void assign_picture_variable(struct metafont *mf,
                             struct picture_variable *target,
                             struct picture_variable *source){
  GLuint temporary_framebuffer;
  GLint previous_framebuffer;
  float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(target -> texture != 0)
    glDeleteTextures(1, &(target -> texture));
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(target -> texture),
                      source -> width, source -> height);
  render_picture(source, model_view_matrix, source -> width, source -> height, true);
  // Finalizando
  glBindTexture(GL_TEXTURE_2D, 0);
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  if(target ==
         &(mf -> internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE])){
    // O código abaixo será definido na Subseção 11.2:
    @<Gera nova 'currentpicture'@>
  }
}
@
\fimcodigo

\subsubsecao{8.6.1. Expressões Terciárias de Imagem: Soma e Subtração}

A operação terciária de imagem é a soma e a subtração:

\alinhaverbatim
<Expressão de Imagem> -> <Terciário de Imagem>
<Terciário de Imagem> -> <Terciário de Imagem><Mais ou Menos><Secundário de Imagem>
<Mais ou Menos> -> + | -
\alinhanormal

Imagens então podem ser somadas ou subtraídas. O resultado de
$p_1+p_2$ representa uma nova imagem composta por todos os pixels da
primeira imagem mais os pixels da segunda imagem. Já $p_1-p_2$ são os
pixels da primeira menos os pixels da segunda.  A imagem resultante
sempre terá a largura igual ao maior valor em ambas as imagens e terá
a altura igual ao maior valor em ambas as imagens. A soma dos seus
pixels sempre ocorrerá com ambas as imagens centralizadas uma na
outra.

A função que avalia expressões terciárias de imagem:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct picture_variable *result);
@
\fimcodigo

A implementação da função consiste em identificar o operador $+$ ou o
operador $-$ que estiver mais ao fim da expressão. Se ele não existe,
então devemos avaliar tudo como uma expressão secundária. Se ele
existe, o lado à esquerda dele será avaliado como expressão terciária
e o lado à direita como expressão secundária. E só então fazemos a
soma ou subtração.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct picture_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_SUM || p -> type == TYPE_SUBTRACT) &&
       prev -> type != TYPE_SUM && prev -> type != TYPE_SUBTRACT){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL || before_last_operator == NULL){
    struct picture_variable a;
    struct picture_variable *sec = &a;
    @<Imagem: Avalia Expressão Secundária em 'sec'@>
    return true;
  }
  else{
    struct picture_variable a, b;
    struct picture_variable *sec = &b;
    if(last_operator == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Incomplete picture expression "
                      "ending with '+' or '-'.\n",
              mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(!eval_picture_expression(mf, cx, begin_expression, before_last_operator, &a))
      return false;
    @<Imagem: Avalia Expressão Secundária em 'sec'@>
    @<Expressão de Imagem: Soma ou Subtração@>
    if(a.texture != 0)
      glDeleteTextures(1, &(a.texture));
    if(b.texture != 0)
      glDeleteTextures(1, &(b.texture));
    return true;
  }
}
@
\fimcodigo

Para somar ou subtrair as imagens, devemos primeiro obter qual deve
ser o tamanho da imagem de destino. Ela terá a maior altura e maior
largura dentre as imagens sendo somadas. Em seguida, a criamos e a
inicializamos como sendo uma imagem transparente. Tanto na soma como
na subtração, desenhamos o primeiro operando no destino. Em seguida,
dependendo se estamos realizando soma ou subtração, usamos o OpenGL
para ajustar como as cores serão misturadas. No caso da soma,
ajustamos para que seja feita uma mistura de cores de modo que a nova
cor $(y_R, y_G, y_B, y_A)$ seja multiplicada pelo seu valor alfa e
somada à cor de destino $(x_R, x_G, x_B, x_A)$ multiplicada pelo
complemento do alfa da nova cor:

$$(1-y_A)(x_R, x_G, x_B, x_A) + y_A(y_R, y_G, y_B, y_A)$$

O caso da subtração é mais complexo e para entendê-la, devemos
entender as regras de como representamos nossas texturas com
imagens. Por padrão, assumimos que uma imagem inicializada vazia com
um dado tamanho é toda preenchida por uma cor branca totalmente
transparente (representada pelo vetor RGBA $(1, 1, 1, 0)$). Já quando
escrevemos algo em uma imagem usando canetas ou outro método, usamos
uma tinta preta totalmente opaca (representada pelo vetor RGBA $(0, 0,
0, 1)$). Para nós a cor branca é o zero, a ausência de tinta e a cor
preta é a presença de tinta. O branco é o elemento neutro da
subtração, remover o branco não deve mudar nada. Já remover o preto
remove toda a tinta. Isso é o oposto da representação do branco como 1
e o preto como 0 usada no OpenGL. Por causa disso, a equação de quando
subtraímos uma cor existente $(x_R, x_G, x_B, x_A)$ por uma nova cor
$(y_R, y_G, y_B, y_A)$ é:

$$
(max(x_R, 1-y_R), max(x_G, 1-y_G), max(x_B, 1-y_B), x_A-y_A)
$$

Infelizmente não é possível expressar a equação acima usando apenas o
recurso de ajuste da equação de combinação de cores. O OpenGL ES 3.0 e
OpenGL 4 suporta o uso da função $max$, mas quando a usa, ele ignora
os fatores configurados. O que significa que é possível calcular
$max(x_R, y_R)$, mas não $max(x_R, 1- y_R)$. Essa inversão precisa ser
feita então a nível de shader. O shader de fragmento que inverte uma
cor deixando o alfa intacto é:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char fragment_shader_inverse[] =
  "#version 100\n"
  "precision mediump float;\n"
  "varying mediump vec2 texture_coordinate;\n"
  "uniform sampler2D texture1;\n"
  "void main(){\n"
  "  vec4 texture = texture2D(texture1, texture_coordinate);\n"
  "  gl_FragColor = vec4(1.0 - texture.r, 1.0 - texture.g, 1.0 - texture.b, \n"
  "                      texture.a);\n"
  "}\n";
static GLuint inv_program; // O programa acima compilado
static GLint uniform_inv_texture; // A posição da textura acima
static GLint uniform_inv_matrix; // A posição da matriz do programa acima
@
\fimcodigo

Um novo programa de shader deve ser então compilado na inicialização
para podermos inverter os valores RGB de imagens:

\iniciocodigo
@<Inicialização de Weaver Metafont@>+=
{
  inv_program = compile_shader_program(vertex_shader, fragment_shader_inverse);
  uniform_inv_matrix = glGetUniformLocation(inv_program, "model_view_matrix");
  uniform_inv_texture = glGetUniformLocation(inv_program, "texture1");
}
@
\fimcodigo

E na finalização nós destruimos este programa:

\iniciocodigo
@<Finalização de Weaver Metafont@>+=
glDeleteProgram(inv_program);
@
\fimcodigo

E usando esse novo programa shader para ajudar a inverter valores RGB,
podemos enfim computar a equação de mistura de cores no caso da
subtração:

\iniciocodigo
@<Expressão de Imagem: Soma ou Subtração@>=
// Alocando e declarando dados, gerando imagem vazia inicial
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float model_view_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
result -> width = ((a.width >= b.width)?(a.width):(b.width));
result -> height = ((a.height >= b.height)?(a.height):(b.height));
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Renderizando imagem 'a'
model_view_matrix[0] = (double) a.width / (double) result -> width;
model_view_matrix[4] = (double) a.height / (double) result -> height;
render_picture(&a, model_view_matrix, result -> width, result -> height, true);
// Renderizando imagem 'b'
model_view_matrix[0] = (double) b.width / (double) result -> width;
model_view_matrix[4] = (double) b.height / (double) result -> height;
if(last_operator -> type == TYPE_SUBTRACT){
  glEnable(GL_BLEND);
  // Os fatores a serem usados na mistura
  glBlendFunc(GL_ONE, GL_ONE);
  // Função 'max' para RGB e subtração para o canal alfa:
  glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  glUseProgram(inv_program);
  glUniformMatrix3fv(uniform_inv_matrix, 1, true, model_view_matrix);
  glUniform1i(uniform_inv_texture, 0);
  glBindTexture(GL_TEXTURE_2D, b.texture);
  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
  glBlendEquation(GL_FUNC_ADD);
  glDisable(GL_BLEND);
}
else{ // Soma
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glBlendEquation(GL_FUNC_ADD);
  render_picture(&b, model_view_matrix, result -> width, result -> height, false);
  glDisable(GL_BLEND);
}
// Finalizando
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glBindTexture(GL_TEXTURE_2D, 0);
glDeleteFramebuffers(1, &temporary_framebuffer);
@
\fimcodigo

\subsubsecao{8.6.2. Expressões Secundárias de Imagem: Transformadores}

Uma expressão secundária de imagem tem a seguinte sintaxe:

\alinhaverbatim
<Secundário de Imagem> -> <Primário de Imagem> |
                          <Secundário de Imagem><Transformador>
<Transformador> -> rotated <Primário Numérico> |
                   scaled <Primário Numérico> |
                   shifted <Par Primário> |
                   slanted <Numérico Primário> |
                   xscaled <Numérico Primário> |
                   yscaled <Numérico Primário> |
                   zscaled <Par Primário> |
                   transformed <Primário de Transformação>
\alinhanormal

Os mesmos transformadores que podem ser usados em pares,
transformações, caminhos e canetas podem também ser usados em
imagens. Mas o modo como transformamos as imagens é diferente. Assim
como canetas, as transformações lineares sobre imagens são armazenadas
na forma de uma matriz que acumula todas as transformações. Desta
forma, podemos realizar as transformações de uma só vez somente depois
que o usuário especificar todas as que serão necessárias. Mas ao
contrário de canetas, as variáveis de imagem não possuem uma matriz
própria armazenada na variável.

As matrizes são recursos que irão existir somente enquanto estivermos
avaliando expressões secundárias de imagem. E serão efetivamente
usadas para transformar a imagem somente ao terminarmos a avaliação de
uma expressão tercisária. Desta forma, no código abaixo:

\alinhaverbatim
a = img totated 45 slanted 0.2 zscaled(2, 3)
\alinhanormal

Ao invés de realizarmos três transformações diferentes, nós apenas
acumularemos as transformações em uma matriz. Já quando não houver
mais transformação e estivermos terminando de interpretar a expressão
terciária, é quando usaremos a matriz para efetivamente transformar a
imagem em sua forma final. Isso significa que a função que avaliará as
expressões secundárias de imagem deverá ser diferente das demais. Ela
irá receber dois argumentos adicionais: uma matriz pré-inicializada
como a matriz identidade e um ponteiro para uma variável booleana
pré-inicializada como falso. Esta variável será mudada para verdadeira
somente se a matriz passada for modificada.

\iniciocodigo
@<Imagem: Avalia Expressão Secundária em 'sec'@>=
{
  float matrix[9];
  bool modified = false;
  INITIALIZE_IDENTITY_MATRIX(matrix);
  if(last_operator == NULL){
     if(!eval_picture_secondary(mf, cx, begin_expression, end_expression, sec,
                             matrix, &modified))
      return false;
  }
  else if(!eval_picture_secondary(mf, cx, last_operator -> next,
                                  end_expression, sec, matrix, &modified))
    return false;
  if(modified){
    if(!apply_image_transformation(mf, result, sec, matrix))
      return false;
    if(sec -> texture != 0)
      glDeleteTextures(1, &(sec -> texture));
  }
  else{
    result -> width = sec -> width;
    result -> height = sec -> height;
    result -> texture = sec -> texture;
  }
}
@
\fimcodigo

A declaração da função que avalia expressões secundárias de imagem é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_token_list,
                            struct picture_variable *result,
                            float *matrix, bool *modified);
@
\fimcodigo

E a sua implementação consiste primeiramente em percorrermos toda a
expressão até achar o último token com um operador secundário de
transformação. Se não achamos nada, é só avaliar tudo como expressão
primária. Se achamos um, avaliamos tudo antes dele como expressão
secundária e aplicamos a transformação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct picture_variable *result,
                            float *matrix, bool *modified){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p, *prev = NULL, *last_transformer = NULL,
                       *before_last_transformer = begin_expression;
  p = begin_expression;
  do{
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && (p -> type == TYPE_ROTATED ||
       p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
       p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
       p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED ||
       p -> type == TYPE_TRANSFORMED)){
      last_transformer = p;
      before_last_transformer = prev;
    }
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(last_transformer == NULL)
    return eval_picture_primary(mf, cx, begin_expression, end_expression, result);
  else{
    if(!eval_picture_secondary(mf, cx, begin_expression,
                               before_last_transformer, result, matrix, modified))
      return false;
    if(last_transformer -> type == TYPE_ROTATED){
      @<Secundário de Imagem: Rotação@>
    }
    else if(last_transformer -> type == TYPE_SCALED){
      @<Secundário de Imagem: Escala@>
    }
    else if(last_transformer -> type == TYPE_SHIFTED){
      @<Secundário de Imagem: Deslocamento@>
    }
    else if(last_transformer -> type == TYPE_SLANTED){
      @<Secundário de Imagem: Inclinação@>
    }
    else if(last_transformer -> type == TYPE_XSCALED){
      @<Secundário de Imagem: X-Escala@>
    }
    else if(last_transformer -> type == TYPE_YSCALED){
      @<Secundário de Imagem: Y-Escala@>
    }
    else if(last_transformer -> type == TYPE_ZSCALED){
      @<Secundário de Imagem: Z-Escala@>
    }
    else if(last_transformer -> type == TYPE_TRANSFORMED){
      @<Secundário de Imagem: Transformação Genérica@>
    }
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture transformer\n",
            mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

Avaliar cada um dos diferentes tipos de transformadores significa
modificar a matriz multiplicando ela pela matriz que representa a
transformação. Exatamente como fizemos com as canetas. Conforme
descrito por código da Subseção X.Y.

Esta é a mudança de escala:

\iniciocodigo
@<Secundário de Imagem: Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

Este é o código que realiza a rotação:

\iniciocodigo
@<Secundário de Imagem: Rotação@>=
struct numeric_variable r;
double rotation;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &r))
  return false;
rotation = 0.017453292519943295 * r.value;
TRANSFORM_ROTATE(matrix, rotation);
*modified = true;
return true;
@
\fimcodigo

O código que desloca a imagem uma coordenada $(x, y)$ segue
abaixo. Para imagens, nós representamos o deslocamento em pixels,
então antes de aplicá-lo à matriz, devemos convertê-lo para
coordenadas OpenGL que dependem do tamanho da imagem:

\iniciocodigo
@<Secundário de Imagem: Deslocamento@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
p.x = 2.0 * (p.x / result -> width);
p.y = 2.0 * (p.y / result -> height);
TRANSFORM_SHIFT(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

O código que inclina uma imagem:

\iniciocodigo
@<Secundário de Imagem: Inclinação@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SLANT(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

O código que muda a escala somente no eixo $x$:

\iniciocodigo
@<Secundário de Imagem: X-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_X(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

O código que muda a escala somente no eixo $y$:

\iniciocodigo
@<Secundário de Imagem: Y-Escala@>=
struct numeric_variable a;
if(!eval_numeric_primary(mf, cx, last_transformer -> next, end_expression, &a))
  return false;
TRANSFORM_SCALE_Y(matrix, a.value);
*modified = true;
return true;
@
\fimcodigo

Mudança de escala usando o plano complexo e multiplicaçãop por número
complexo:

\iniciocodigo
@<Secundário de Imagem: Z-Escala@>=
struct pair_variable p;
if(!eval_pair_primary(mf, cx, last_transformer -> next, end_expression, &p))
  return false;
TRANSFORM_SCALE_Z(matrix, p.x, p.y);
*modified = true;
return true;
@
\fimcodigo

Finalmente, a transformação genérica que aplica a transformação linear
armazenada em um transformador:

\iniciocodigo
@<Secundário de Imagem: Transformação Genérica@>=
struct transform_variable t;
if(!eval_transform_primary(mf, cx, last_transformer -> next, end_expression,
                           &t))
  return false;
MATRIX_MULTIPLICATION(matrix, t.value);
*modified = true;
return true;
@
\fimcodigo

Agora resta definir como iremos aplicar as transformações lineares
sobre uma imagem uma vez que tenhamos a matriz, a variável de imagem
de origem e a de destino. Isso é feito com ajuda da seguinte função
auxiliar:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix);
@
\fimcodigo

Aplicar a transformação da imagem envolve usar a matriz de
transformação obtida para transformar a imagem de origem gerando assim
a nova imagem de destino. Para isso aplicamos as seguintes etapas:

1) Devemos descobrir qual deve ser o tamanho em pixels da imagem de
destino. Para isso, multiplicamos as coordenadas da origem pela
matriz. Mas neste caso, medidmos tais coordenadas por pixels, não
pelas coordenadas OpenGL. Se a imagem de origem é um quadrado de 5
pixels de lado, um de seus vértices será $(-5/2, -5/2)$ e outro será
$(5/2, 5/2)$. O resultado da transformação serão as coordenadas dos
vértices medidos por pixels, à partir das quais obtemos o tamanho em
pixels. Nesta etapa, podemos ignorar a translação presente na matriz.

2) Para levar em conta a translação, devemos somar o dobro da
distância em píxels da translação ao tamanho da imagem. Lembre-se que a
translação não muda o centro da imagem. Então, ao deslocar $(1, 1)$
uma imagem com um píxel preto $1\times 1$, geramos nova imagem de
$3\times 3$ com o píxel preto no canto. O centro da imagem continua
sendo a posição em que o píxel preto estava antes do deslocamento.

3) A mudança de tamanho do desenho da imagem original será obtida
simplesmente renderizando o desenho transformado em uma imagem de
destino ou menor. Então devemos remover da matriz de transformação a
mudança de tamanho e escala que estiver presente. Também devemos
ajustar levando em conta isso qualquer translação sendo feita. Isso é
feito aplicando um valor calculado de correção para as posições $x$ e
$y$ da matriz.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool apply_image_transformation(struct metafont *mf,
                                struct picture_variable *dst,
                                struct picture_variable *origin,
                                float *matrix){
  int i;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  // Para calcular o tamanho final da imagem, armazenaremos as maiores e
  // menores coordenadas que encontrarmos nas extremidades da imagem
  // nos dois eixos após aplicar a matriz de transformação. (Etapa 1)
  float min_x = INFINITY, min_y = INFINITY, max_x = -INFINITY, max_y = -INFINITY;
  float origin_coordinates[8];
  origin_coordinates[0] = -((float) origin -> width) / 2.0;
  origin_coordinates[1] = -((float) origin -> height) / 2.0;
  origin_coordinates[2] = ((float) origin -> width) / 2.0;
  origin_coordinates[3] = -((float) origin -> height) / 2.0;
  origin_coordinates[4] = ((float) origin -> width) / 2.0;
  origin_coordinates[5] = ((float) origin -> height) / 2.0;
  origin_coordinates[6] = -((float) origin -> width) / 2.0;
  origin_coordinates[7] = ((float) origin -> height) / 2.0;
  for(i = 0; i < 8; i += 2){
    float x = LINEAR_TRANSFORM_X(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    float y = LINEAR_TRANSFORM_Y(origin_coordinates[i],
                                 origin_coordinates[i + 1], matrix);
    if(x > max_x) max_x = x;
    if(x < min_x) min_x = x;
    if(y > max_y) max_y = y;
    if(y < min_y) min_y = y;
  }
  // Ajuste de tamanho da imagem final devido ao deslocamento (Etapa 2)
  dst -> width = (int) (max_x - min_x) +
                 (int) (origin -> width * matrix[6]);
  dst -> height = (int) (max_y - min_y) +
                  (int) (origin -> height * matrix[7]);
  // Ajustando escala e translação da imagem final levando em conta novo tamanho
  // do destino (Etapa 3):
  {
    double x_correction = ((double) origin -> width) / (double) dst -> width;
    double y_correction = ((double) origin -> height) / (double) dst -> height;
    matrix[0] = matrix[0] * x_correction;
    matrix[3] = matrix[3] * x_correction;
    matrix[6] = matrix[6] * x_correction;
    matrix[1] = matrix[1] * y_correction;
    matrix[4] = matrix[4] * y_correction;
    matrix[7] = matrix[7] * y_correction;
  }
  // Gerando textura inicial, framebuffer
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(dst -> texture), dst -> width,
                    dst -> height);
  // Renderizando:
  render_picture(origin, matrix, dst -> width, dst -> height, true);
  // Finalização
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.3. Expressões Primárias de Imagem: Inversores, Identidade e Imagens Vazias}

Segundo a gramática da linguagem, a sintaxe para expressões primárias
de imagens é:

\alinhaverbatim
<Primário de Imagem> -> <Variável de Imagem> |
                        nullpicture <Primário de Par> |
                        ( <Expressão de Imagem> ) |
                        <Mais ou Menos> <Primário de Imagem> |
                        subpicture <Primário de Par> and <Primário de Par> of
                                   <Primário de Imagem>
\alinhanormal

Isso requer registrar ``nullpicture'' e ``subpicture'' como um token:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_NULLPICTURE,        // O token simbólico 'nullpicture'
TYPE_SUBPICTURE,         // O token simbólico 'subpicture'
@
\fimcodigo

E requer que essas strings seja adicionada à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"nullpicture", "subpicture",
@
\fimcodigo

A função que irá interpretar expressões primárias de imagem é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct picture_variable *result);
@
\fimcodigo

E sua implementação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_picture_primary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct picture_variable *result){
  if(begin_expression == end_expression){
    if(begin_expression -> type == TYPE_SYMBOLIC){
      @<Imagem Primária: Variável@>
    }
  }
  else{
    if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
      end_expression -> type == TYPE_CLOSE_PARENTHESIS){
      @<Imagem Primária: Parênteses@>
    }
    else if(begin_expression -> type == TYPE_NULLPICTURE){
      @<Imagem Primária: Imagem em Branco@>
    }
    else if(begin_expression -> type == TYPE_SUM){
      @<Imagem Primária: Identidade@>
    }
    else if(begin_expression -> type == TYPE_SUBTRACT){
      @<Imagem Primária: Inverso@>
    }
    else if(begin_expression -> type == TYPE_SUBPICTURE){
      @<Imagem Primária: Subimagem@>
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognized picture expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

O primeiro caso de expressão primária de imagem é ler uma imagem de
uma variável. Isso envolve copiar o conteúdo da variável armazenada no
resultado da avaliação.

\iniciocodigo
@<Imagem Primária: Variável@>=
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
struct symbolic_token *v = (struct symbolic_token *) begin_expression;
struct picture_variable *content = v -> var;
if(content == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Using unknown variable '%s'.\n",
          mf -> file, begin_expression -> line, v -> value);
#endif
  return false;
}
if(content -> type != TYPE_T_PICTURE){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Got non-picture variable (%d) in "
                  "picture expression.\n",
          mf -> file, begin_expression -> line, content -> type);
#endif
  return false;
}
// Preparar renderização:
result -> width = content -> width;
result -> height = content -> height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Renderiza:
render_picture(content, identity_matrix, result -> width, result -> height, true);
// Finaliza:
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

Lidar com os parênteses envolve percorrer os tokens até encontrar o
último token antes do fechar de parênteses. E avaliar como uma nova
expressão de imagem tudo aquilo que estiver entre o parênteses inicial
e o final:

\iniciocodigo
@<Imagem Primária: Parênteses@>=
struct generic_token *t = begin_expression -> next;
DECLARE_NESTING_CONTROL();
if(begin_expression -> next == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
while(t != NULL && t -> next != end_expression){
  COUNT_NESTING(t);
  t = t -> next;
}
return eval_picture_expression(mf, cx, begin_expression -> next, t, result);
@
\fimcodigo

A próxima expressão primária é a criação de uma imagem em branco com
um dado tamanho. Isso ocorre quando lemos um
token \monoespaco{nullpicture} seguido de um par primário. Criar a
imagem vazia envolve primeiro interpretar o par primário que contém o
seu tamanho e em seguida criar uma textura vazia com tal tamanho.

\iniciocodigo
@<Imagem Primária: Imagem em Branco@>=
struct generic_token *begin_pair_expression, *end_pair_expression;
struct pair_variable p;
unsigned char *data;
begin_pair_expression = begin_expression -> next;
end_pair_expression = end_expression;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing pair expression.\n",
          mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_pair_primary(mf, cx, begin_pair_expression, end_pair_expression, &p))
  return false;
result -> width = p.x;
result -> height = p.y;
data = temporary_alloc(p.x * p.y * 4);
if(data == NULL){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
  return false;
}
// Pintando a nova textura de branco
memset(data, 255, result -> width * result -> height * 4);
{ // E deixando ela totalmente transparente:
  int i, size = result -> width * result -> height * 4;
  for(i = 3; i < size; i += 4)
    data[i] = 0;
}
glGenTextures(1, &(result -> texture));
glBindTexture(GL_TEXTURE_2D, result -> texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, result -> width, result -> height, 0,
             GL_RGBA, GL_UNSIGNED_BYTE, data);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glBindTexture(GL_TEXTURE_2D, 0);
if(temporary_free != NULL)
  temporary_free(data);
return true;
@
\fimcodigo

E agora o antepenúltimo caso de imagem primária: quando vem um
token \monoespaco{+} antes de uma imagem. Neste caso o operador não faz
nada, é um operador de identidade para imagens. Então só precisamos
ignorar ele e avaliar os tokens restantes:

\iniciocodigo
@<Imagem Primária: Identidade@>=
struct generic_token *p = begin_expression -> next;
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing image expression "
                  "after '+'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
return eval_picture_primary(mf, cx, p, end_expression, result);
@
\fimcodigo

Para o operador \monoespaco{-} que é usado para inverter uma imagem,
nós iremos novamente renderizar ativando a equação de mistura de
cores, mas fazendo com que a nova cor seja obtida usando $(1, 1, 1,
1)$ como a cor atural e subtraindo disso a nova cor. Isso é obtido
tratando os fatores de mistura como 1 (GL\_ONE) e usando a subtração
como operador (GL\_FUNC\_SUBTRACT):


\iniciocodigo
@<Imagem Primária: Inverso@>=
struct picture_variable p;
GLuint temporary_framebuffer = 0;
GLint previous_framebuffer;
float identity_matrix[9] = {1.0, 0.0, 0.0,
                             0.0, 1.0, 0.0,
                             0.0, 0.0, 1.0};
if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                  "'-'.\n", mf -> file, begin_expression -> line);
#endif
  return false;
}
if(!eval_picture_primary(mf, cx, begin_expression -> next, end_expression, &p))
  return false;
// Preparar renderização:
result -> width = p.width;
result -> height = p.height;
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                    result -> width, result -> height);
// Inicializar nova textura com branco opaco (1, 1, 1, 1)
glClearColor(1.0, 1.0, 1.0, 1.0);
glClear(GL_COLOR_BUFFER_BIT);
// Ajustar equação de mistura pra subtrair ela do branco opaco:
glEnable(GL_BLEND);
glBlendFuncSeparate(GL_ONE, GL_ONE, GL_ONE, GL_ONE);
glBlendEquationSeparate(GL_FUNC_REVERSE_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT);
// Renderiza:
render_picture(&p, identity_matrix, result -> width, result -> height, false);
// Finaliza:
glDisable(GL_BLEND);
glDeleteTextures(1, &(p.texture));
glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
glDeleteFramebuffers(1, &temporary_framebuffer);
return true;
@
\fimcodigo

FInalmente, a expressão primária de computar sub-imagens. Esta
expressão começa com um token \monoespaco{subpicture}, recebe um par
primário (o offset em pixels), um token \monoespaco{and}, um segundo
par (com o tamanho da sub-imagem a ser extraída), o
token \monoespaco{of} e uma expressão primária de imagem (de onde a
sub-imagem deve ser extraída).

A primeira parte da avaliação desta expressão envolve extrair os pares
e a imagem das subexpressões. A segunda parte é executar o comando de
gerar uma sub-imagem:

\iniciocodigo
@<Imagem Primária: Subimagem@>=
struct pair_variable pair_offset, subpicture_size;
struct picture_variable original_picture;
@<Subimagem: Extrai Subexpressões@>
@<Subimagem: Extrai Subimagem@>
return false;
@
\fimcodigo

Extrair as subexpressões envolve delimitar o começo e fim de cada uma
delas. Para isso percorremos a expressão como um todo buscando pelos
tokens de auxílio \monoespaco{of} e \monoespaco{and}. Armazenamos
também um estado para saber quantas subexpressões já delimitamos. Isso
nos ajuda a detectar se temos uma expressão mal-formada onde os tokens
de auxílio aparecem, mas na ordem errada ou sem expressões entre eles:

\iniciocodigo
@<Subimagem: Extrai Subexpressões@>=
{
  DECLARE_NESTING_CONTROL();
  struct generic_token *begin_pair1 = NULL, *end_pair1 = NULL,
                       *begin_pair2 = NULL, *end_pair2 = NULL,
                       *begin_pic = NULL, *end_pic = NULL,
                       *p = begin_expression -> next,
                       *last_token = begin_expression;
  int state = 0;
  begin_pair1 = p;
  while(p != end_expression && p != NULL){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p -> type == TYPE_AND){
      if(state != 0 || last_token -> type == TYPE_SUBPICTURE){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair1 = last_token;
      state ++;
      begin_pair2 = p -> next;
    }
    else if(IS_NOT_NESTED() && p -> type == TYPE_OF){
      if(state != 1 || last_token -> type == TYPE_AND){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr,
                "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
                mf -> file, p -> line);
#endif
        return false;
      }
      end_pair2 = last_token;
      state ++;
      begin_pic = p -> next;
    }
    last_token = p;
    p = p -> next;
  }
  if(p == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr,
            "METAFONT: Error: %s:%d: Malformed subpicture expression.\n",
            mf -> file, p -> line);
#endif
    return false;
  }
  end_pic = p;
  if(!eval_pair_primary(mf, cx, begin_pair1, end_pair1, &pair_offset))
    return false;
  if(!eval_pair_primary(mf, cx, begin_pair2, end_pair2, &subpicture_size))
    return false;
  if(!eval_picture_primary(mf, cx, begin_pic, end_pic, &original_picture))
    return false;
}
@
\fimcodigo

Extrair a sub-imagem requer gerar uma nova textura com o tamanho
indicado pelo segundo par e renderizar a imagem lida nesta nova
textura, de acordo com as informações presentes nos pares sobre
tamanho e offset:

\iniciocodigo
@<Subimagem: Extrai Subimagem@>=
{
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  float render_matrix[9];
  INITIALIZE_IDENTITY_MATRIX(render_matrix);
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(result -> texture),
                      subpicture_size.x, subpicture_size.y);
  result -> width = subpicture_size.x;
  result -> height = subpicture_size.y;
  // Inicializar nova textura com branco transparente (1, 1, 1, 0)
  glClearColor(1.0, 1.0, 1.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT);
  // Ajustando tamanho da renderização na textura
  render_matrix[0] = original_picture.width / subpicture_size.x;
  render_matrix[4] = original_picture.height / subpicture_size.y;
  // Passando o offset para a matriz de renderização
  render_matrix[6] = -2.0 * (pair_offset.x +
                      0.5 * (subpicture_size.x - original_picture.width)) /
                      subpicture_size.x;
  render_matrix[7] = -2.0 * (pair_offset.y +
                      0.5 * (subpicture_size.y - original_picture.height)) /
                      subpicture_size.y;
  // Renderiza:
  render_picture(&original_picture, render_matrix, result -> width, result -> height,
                 false);
  
  // Finaliza:
  glDisable(GL_BLEND);
  glDeleteTextures(1, &(original_picture.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

\subsubsecao{8.6.4. Imagens em Expressões Numéricas}

Há casos nos quais precisamos avaliar uma expressão de imagem dentro
de uma expressão numérica. Há três expressões primárias numéricas
adicionais onde devemos avaliar uma imagem:

\alinhaverbatim
<Primário Numérico> -> totalweight <Primário de Imagem> |
                       width <Primário de Imagem> |
                       height <Primário de Imagem>
\alinhanormal

Os dois últimos operadores apenas retornam respectivamente a largura e
altura da imagem. Já o operador \monoespaco{totalweight} avalia
uma expressão de imagem, lê a imagem obtida e retorna a soma do
``peso'' de cada pixel. O peso de um pixel branco transparente deve
ser zero e o de um pixel preto opaco deve ser 1. Já para calcular
valores intermediários, converteremos um pixel colorido para um tom de
cinza. Para isso obteremos uma média ponderada entre os valores entre
0 e 1 deles, dando um peso maior para o verde e menor para o
azul. Isso porque a visão humana é mais sensível ao verde que ao
azul. O resultado desta média sera o peso do píxel colorido. Depois de
obter o valor, multiplicamos pela transparência.

Primeiro vamos adicionar novos tipos de tokens para esses operadores:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_TOTALWEIGHT,        // O token simbólico 'totalweight'
TYPE_WIDTH,              // O token simbólico 'width'
TYPE_HEIGHT,             // O token simbólico 'height'
@
\fimcodigo

E adicionamos seus nomes à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"totalweight", "width", "height",
@
\fimcodigo

Para o primeiro operador, o modo pelo qual iremos obter os pixels de
uma textura será renderizando ela para um framebuffer e lendo
usando \monoespaco{glReadPixels} para obter o conteúdo do framebuffer:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type == TYPE_TOTALWEIGHT){
  struct picture_variable p;
  char *data;
  GLuint temporary_framebuffer = 0;
  GLint previous_framebuffer;
  GLuint temporary_texture = 0;
  float identity_matrix[9] = {1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0};
  if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'totalweight'.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &p))
    return false;
  data = temporary_alloc(p.width * p.height * 4);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s: Not enough memory!\n", mf -> file);
#endif
    return false;
  }
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_framebuffer);
  get_new_framebuffer(&temporary_framebuffer, &(temporary_texture),
                    p.width, p.height);
  // Renderiza:
  render_picture(&p, identity_matrix, p.width, p.height, true);
  // Ler dados do framebuffer:
  glReadPixels(0, 0, p.width, p.height, GL_RGBA, GL_UNSIGNED_BYTE, data);
  {
    //printf("--WEIGHT---\n");
    int i, size = p.width * p.height * 4;
    double sum = 0.0;
    for(i = 0; i < size; i += 4){
      //if(i%(4*p.width) == 0) printf("\n");
      //printf("(%d %d %d %d)", (unsigned char) data[i], (unsigned char) data[i+1], (unsigned char) data[i+2], (unsigned char) data[i+3]);
      // If the values are equal, let's avoid rounding errors:
      if(data[i] == data[i+1] && data[i+1] == data[i+2]){
        sum += ((255 - (unsigned char) data[i]) / 255.0) *
               (((unsigned char) data[i+3]) / 255.0);
      }
      else{
        double r = ((255 - (unsigned char) data[i]) / 255.0) * 0.2989,
               g = ((255 - (unsigned char) data[i+1]) / 255.0) * 0.5870,
               b = ((255 - (unsigned char) data[i+2]) / 255.0) * 0.1140,
               a = ((unsigned char) data[i+3]) / 255.0;
        sum += ((r+g+b) * a);
      }
    }
    result -> value = sum;
  }
  // Finalização:
  if(temporary_free != NULL)
    temporary_free(data);
  glDeleteTextures(1, &temporary_texture);
  glDeleteTextures(1, &(p.texture));
  glBindFramebuffer(GL_FRAMEBUFFER, previous_framebuffer);
  glDeleteFramebuffers(1, &temporary_framebuffer);
  return true;
}
@
\fimcodigo

Para os operadores \monoespaco{width} e \monoespaco{height}, tudo é
mais simples. Basta obter a imagem e retornar respectivamente a
largura e altura. No caso da largura:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type == TYPE_WIDTH){
  struct picture_variable p;
  if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'width'.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &p))
    return false;
  result -> value = (float) p.width;
  return true;
}
@
\fimcodigo

E no caso da altura:

\iniciocodigo
@<Primário Numérico: Operadores Adicionais@>+=
else if(begin_expression -> type == TYPE_HEIGHT){
  struct picture_variable p;
  if(begin_expression == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Missing picture expression after "
                    "'height'.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  if(!eval_picture_primary(mf, cx, (struct generic_token *)
                                   begin_expression -> next, end_expression,
                           &p))
    return false;
  result -> value = (float) p.height;
  return true;
}
@
\fimcodigo


\subsecao{8.7. Atribuições e Expressões Booleanas}

Como em todos os outros tipos de atribuições e expressões, começamos
definindo o código que faz a atribuição de variáveis após avaliar a
expressão:

\iniciocodigo
@<Atribuição de Variável Booleana@>=
else if(type == TYPE_T_BOOLEAN){
  int i;
  bool ret;
  struct boolean_variable result;
  ret = eval_boolean_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                                &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    ((struct boolean_variable *) var -> var) -> value = result.value;
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

Podendo atribuir o resultado de expressões às variáveis, vamos agora à
parte de escrever código para avaliar as expressões booleanas.

\subsubsecao{8.7.1. Comparações}

Comparações são feitas usando relações. Elas permitem avaliar se duas
variáveis ou expressões nos dão o mesmo resultado, um resultado
diferente, bem como avaliar a relação de ordem entre seus
resultados. As regras gramaticais para comparar valores são:

\alinhaverbatim
<Expressão Booleana> -> <Terciário Booleano> |
                        <Expressão Numérica> <Relação> <Terciário Numérico> |
                        <Expressão de Par> <Relação> <Terciário de Par>     |
                        <Expressão Booleana> <Relação> <Terciário Booleano> |
                        <Expressão de Transformação> <Relação>
                                           <Terciário de Transformação>
<Relação> -> < | <= | > | >= | = | <>
\alinhanormal

Isso significa que as comparações usando estas relações são expressões
quarternárias. Elas tem uma precedência ainda menor que as expressões
terciárias booleanas. Para outros tipos de expressão, nós consideramos
uma expressão terciária como sendo sinônimo para a expressão daquele
tipo. Mas para expressões booleanas, expressões terciárias são um tipo
interno das expressões mais gerais.

As relações mostradas acima requerem que novos tipos de tokens sejam
considerados:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_LT,                    // O token simbólico '<'
TYPE_LEQ,                   // O token simbólico '<='
TYPE_GT,                    // O token simbólico '>'
TYPE_GEQ,                   // O token simbólico '>='
TYPE_NEQ,                   // O token simbólico '<>'
@
\fimcodigo

E adicionamos seus nomes à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"<", "<=", ">", ">=", "<>",
@
\fimcodigo

A declaração da função que avaliará expressões booleanas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct boolean_variable *result);
@
\fimcodigo

Esta função deverá checar se temos um dos operadores de relações
booleanas. Se não tivermos, a expressão deve ser avaliada como
terciária. Se tivermos, devemos identificar a relação mais à direita e
avaliar ela após avaliar as duas outras sub-expressões. Mas antes de
fazer isso, precisamos saber qual o tipo destas expressões. Para isso,
vamos assumir que temos uma função que dada uma expressão terciária,
retorna seu tipo. Ela será
chamada \monoespaco{get\_tertiary\_expression\_type}. Iremos definir
ela na Subseção 8.8. Mas por hora, vamos simplesmente assumir que ela
existe.

A implementação desta função é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression &&
       (p -> type == TYPE_LT || p -> type == TYPE_LEQ ||
        p -> type == TYPE_GT || p -> type == TYPE_GEQ ||
        p -> type == TYPE_NEQ || p -> type == TYPE_ASSIGNMENT)){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_tertiary(mf, cx, begin_expression, end_expression,
                                 result);
  else{
    int type;
    if(before_last_operator == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Relational operator without "
                      "l-value.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    type = get_tertiary_expression_type(mf, cx,  last_operator -> next,
                                        end_expression);
    switch(type){
    case TYPE_T_NUMERIC:
    {
      struct numeric_variable a, b;
      if(!eval_numeric_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_numeric_expression(mf, cx, last_operator -> next,
                                  end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_ASSIGNMENT:
        result -> value = a.value == b.value;
        return true;
      case TYPE_NEQ:
        result -> value = a.value != b.value;
        return true;
      }
      break;
    }
    case TYPE_T_PAIR:
    {
      struct pair_variable a, b;
      if(!eval_pair_expression(mf, cx, begin_expression,
                               before_last_operator, &a))
        return false;
      if(!eval_pair_expression(mf, cx, last_operator -> next,
                               end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y < b.y);
        return true;
      case TYPE_LEQ:
        result -> value = (a.x < b.x) || (a.x == b.x && a.y <= b.y);
        return true;
      case TYPE_GT:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_GEQ:
        result -> value = (a.x > b.x) || (a.x == b.x && a.y > b.y);
        return true;
      case TYPE_ASSIGNMENT:
        result -> value = (a.x == b.x && a.y == b.y);
        return true;
      case TYPE_NEQ:
        result -> value = (a.x != b.x || a.y != b.y);
        return true;
      }
      break;
    }
    case TYPE_T_TRANSFORM:
    {
      struct transform_variable a, b;
      int i, order[6] = {6, 7, 0, 3, 1, 4};
      if(!eval_transform_expression(mf, cx, begin_expression,
                                    before_last_operator, &a))
        return false;
      if(!eval_transform_expression(mf, cx, last_operator -> next,
                                    end_expression, &b))
        return false;
      switch(last_operator -> type){
        case TYPE_LT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] < b.value[order[i]]);
          return true;
        case TYPE_LEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] < b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] <= b.value[order[i]]);
          return true;
        case TYPE_GT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] > b.value[order[i]]);
          return true;
        case TYPE_GEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = (a.value[order[i]] > b.value[order[i]]);
              return true;
            }
          result -> value = (a.value[order[i]] >= b.value[order[i]]);
          return true;
        case TYPE_ASSIGNMENT:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = false;
              return true;
            }
          result -> value = (a.value[order[i]] == b.value[order[i]]);
          return true;
        case TYPE_NEQ:
          for(i = 0; i < 5; i ++)
            if(a.value[order[i]] != b.value[order[i]]){
              result -> value = true;
              return true;
            }
          result -> value = (a.value[order[i]] != b.value[order[i]]);
          return true;
      }          
      break;
    }
    case TYPE_T_BOOLEAN:
    {
      struct boolean_variable a, b;
      a.value = b.value = -1;
      if(!eval_boolean_expression(mf, cx, begin_expression,
                                  before_last_operator, &a))
        return false;
      if(!eval_boolean_tertiary(mf, cx, last_operator -> next,
                                end_expression, &b))
        return false;
      switch(last_operator -> type){
      case TYPE_LT:
        result -> value = a.value < b.value;
        return true;
      case TYPE_LEQ:
        result -> value = a.value <= b.value;
        return true;
      case TYPE_GT:
        result -> value = a.value > b.value;
        return true;
      case TYPE_GEQ:
        result -> value = a.value >= b.value;
        return true;
      case TYPE_ASSIGNMENT:
        result -> value = (a.value == b.value);
        return true;
      case TYPE_NEQ:
        result -> value = (a.value != b.value);
        return true;
      }
      break;
    }
    default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression after boolean operator.\n",  mf -> file,
              begin_expression -> line);
#endif
      return false;
    }
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.2. A Operação OR}

O operador booleano OR é a única operação booleana terciária. A
gramática das expressões booleanas terciárias é:

\alinhaverbatim
<Terciário Booleano> -> <Terciário Booleano> or <Secundário Booleano> |
                        <Secundário Booleano>
\alinhanormal

Para implementarmos esta expressão, precisamos então
definir \monoespaco{or} como um novo tipo de token simbólico:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_OR,                    // O token simbólico 'or'
@
\fimcodigo

O qual deve ser adicionado à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"or",
@
\fimcodigo

A declaração da função que tratará expressões terciárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result);
@
\fimcodigo

E a implementação desta função segue o modelo esperado. Ela percorre a
lista de tokens até achar o último \monoespaco{or} não-aninhado em
parênteses e outros delimitadores e aplica o operador sobre o
resultado das subexpressões que o cercam. Se não existir um
operador \monoespaco{or}, toda a expressão é tradada como uma
expressão secundária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_tertiary(struct metafont *mf, struct context *cx,
                           struct generic_token *begin_expression,
                           struct generic_token *end_expression,
                           struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_OR){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_secondary(mf, cx, begin_expression, end_expression,
                                  result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_secondary(mf, cx, begin_expression,
                               before_last_operator, &a))
      return false;
    if(!eval_boolean_tertiary(mf, cx, last_operator -> next,
                              end_expression, &b))
      return false;
    result -> value =  (a.value || b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.3. A Operação AND}

O operador booleano AND é a única operação booleana secundária. A
gramática das expressões booleanas secundárias é:

\alinhaverbatim
<Secundário Booleano> -> <Secundário Booleano> and <Primário Booleano> |
                         <Primário Booleano>
\alinhanormal

O token \monoespaco{and} já foi definido previamente. Ele é também
usado para descrever caminhos, quando há dois pontos de controle
diferentes em uma curva.

A declaração da função que tratará expressões secundárias booleanas é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result);
@
\fimcodigo

E a implementação desta função é praticamente igual ao do operador OR,
apenas mudando qual operador estamos procurando e a operação que
aplicamos sobre o resultado das subexpressões que delimitam o AND. E,
caso não haja um operador AND não-aninhado na expressão, nós tratamos
ela inteira como uma expressão booleana primária:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_secondary(struct metafont *mf, struct context *cx,
                            struct generic_token *begin_expression,
                            struct generic_token *end_expression,
                            struct boolean_variable *result){
  DECLARE_NESTING_CONTROL();
  struct generic_token *p = begin_expression, *prev = NULL;
  struct generic_token *last_operator = NULL, *before_last_operator = NULL;
  while(p != end_expression){
    COUNT_NESTING(p);
    if(IS_NOT_NESTED() && p != begin_expression && p -> type == TYPE_AND){
      last_operator = p;
      before_last_operator = prev;
    }
    prev = p;
    p = p -> next;
  }
  if(last_operator == NULL)
    return eval_boolean_primary(mf, cx, begin_expression, end_expression,
                                result);
  else{
    struct boolean_variable a, b;
    a.value = b.value = -1;
    if(!eval_boolean_secondary(mf, cx, begin_expression,
                               before_last_operator, &a))
      return false;
    if(!eval_boolean_primary(mf, cx, last_operator -> next,
                             end_expression, &b))
      return false;
    result -> value = (a.value && b.value);
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.7.4. Expressões Primárias Booleanos}

A gramática das expressões primárias booleanas é:

\alinhaverbatim
<Primário Booleano> -> <Variável Booleana> | true | false |
                       cycle <Caminho Primário> | odd <Primário Numérico> |
                       not <Primário Booleano> |
                       ( <Expressão Booleana> )
\alinhanormal

A maioria destas expressões é auto-explictiva. Uma variável booleana é
avaliada para seja qual for o seu valor armazenado. Os
valores \monoespaco{true} e \monoespaco{false} representam verdadeiro
e falso. O \monoespaco{not} é o operador NOT de negação. Parênteses
podem ser usados para mudar a ordem de avaliação de operadores. O
token \monoespaco{odd} serve para checar se o número à seguir é ímpar
após arredondá-lo para o inteiro mais próximo. E \monoespaco{cycle}
serve para checar se um caminho é cíclico ou não.

Os seguintes novos tipos de token não foram ainda definidos:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_TRUE,                    // O token simbólico 'true'
TYPE_FALSE,                   // O token simbólico 'false'
TYPE_ODD,                     // O token simbólico 'odd'
TYPE_NOT,                     // O token simbólico 'not'
@
\fimcodigo

E o nome de cada um deles deve ser adicionado à lista de palavras
reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"true", "false", "odd", "not",
@
\fimcodigo

A função que avaliará expressões booleanas primárias é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result);
@
\fimcodigo

No caso de expressões booleanas primárias, é perfeitamente possível
identificar qual regra gramatical seguir após observar o primeiro
token encontrado. Então a função apenas observa o primeiro token, e
depois disso ela decide o que fazer:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool eval_boolean_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct boolean_variable *result){
  switch(begin_expression -> type){
    case TYPE_SYMBOLIC: // Variável
      struct boolean_variable *var;
      var = ((struct symbolic_token *) begin_expression) -> var;
      if(var -> value == -1){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
                "'%s'.\n", mf -> file, begin_expression -> line,
                ((struct symbolic_token *) begin_expression) -> value);
#endif
        return false;
      }
      result -> value = var -> value;
      return true;
    break;
    case TYPE_TRUE: // Verdadeiro
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        printf("DEBUG: %d %d\n", begin_expression -> type, end_expression -> type);
        return false;
      }
      result -> value = 1;
      return true;
    break;
    case TYPE_FALSE: // Falso
      if(end_expression != begin_expression){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "boolean expression. Did you miss a ';'?\n",
                mf -> file, begin_expression -> line);
#endif
        printf("DEBUG: %d %d %d\n", begin_expression -> type,
               ((struct generic_token *) begin_expression -> next) -> type,
               end_expression -> type);
        printf("DEBUG: %p %p\n", begin_expression, end_expression);
        return false;
      }
      result -> value = 0;
      return true;
    break;
    case TYPE_CYCLE: // 'cycle'
      struct path_variable path;
      if(!eval_path_primary(mf, cx, begin_expression -> next, end_expression,
                            &path))
        return false;
      result -> value = path.cyclic;
      if(temporary_free != NULL)
        path_recursive_free(temporary_free, &path, false);
      return true;
    break;
    case TYPE_ODD: // 'odd'
      struct numeric_variable num;
      if(!eval_numeric_primary(mf, cx, begin_expression -> next, end_expression,
                               &num))
        return false;
      result -> value = (((int) round(num.value)) % 2);
      return true;
    break;
    case TYPE_NOT: // 'not'
      struct boolean_variable b;
      if(!eval_boolean_primary(mf, cx, begin_expression -> next, end_expression,
                              &b))
        return false;
      result -> value = !(b.value);
      return true;
    break;
    case TYPE_OPEN_PARENTHESIS: // '('
      if(end_expression -> type != TYPE_CLOSE_PARENTHESIS){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
        return false;
      }
      struct generic_token *last_token = begin_expression;
      while(last_token -> next != end_expression)
        last_token = last_token -> next;
      return eval_boolean_expression(mf, cx, begin_expression -> next,
                                     last_token, result);
    break;
    default:
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
}
@
\fimcodigo

\subsecao{8.8. Identificando Tipos de Expressões}

Muitas vezes temos uma expressão e devemos identificar qual o tipo da
expressão para tratá-la corretamente. Por exemplo, quando temos uma
expressão booleana comparando qual valor é maior, o que estamos
comparando pode ser uma expressão numérica, de par, de transformação
ou outra expressão booleana. Em uma expressão numérica, podemos usar o
operador \monoespaco{length} sobre outros números ou sobre pares. Uma
multiplicação pode ser entre números ou entre um escalar e um
vetor. Os operadores \monoespaco{xpart} funcionam tanto em pares como
em transformadores.

Note que nenhuma das vezes em que precisamos identificar o tipo de uma
expressão espera-se que encontremos um caminho, imagem ou uma caneta. Por
causa disso, vamos ignorar esses tipos nas nossas funções.

Identificar o tipo de uma expressão pode ser complexo e
trabalhoso. Felizmente, os casos mais comuns tentem a ser simples e
serão avaliados rapidamente. De qualquer forma, vamos usar funções
diferentes para poder identificar expressões primárias, secundárias e
terciárias:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr);
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr);
@
\fimcodigo

Para identificar expressões primárias, primeiro podemos tratar os
casos mais simples (a expressão é composta por um único token) e
depois lidar com os casos mais complexos. As regras que nos permitem
identificar são:

1) Uma variável é uma expressão com o tipo da variável.

2) São expressões booleanas as que tem como único
token \monoespaco{true} ou \monoespaco{false}. Ou que começam
com \monoespaco{cycle}, \monoespaco{odd} e
\monoespaco{not}.

3) São expressões de pares os que começam
com \monoespaco{point}, \monoespaco{precontrol}
e \monoespaco{postcontrol}. Ou se dentro da expressão tivermos
um \monoespaco{[}. E também algo que começa com token numérico e tem
parênteses ou o começo de um primário de par um pouco depois
(\monoespaco{-3(8, 4)}).

4) É expressão numérica um único token numérico, o
token \monoespaco{normaldeviate}, um token numérico seguido
por \monoespaco{/} e toda expressão que começa
com \monoespaco{length}, \monoespaco{xpart}, \monoespaco{ypart}, \monoespaco{xxpart},
\monoespaco{xypart}, \monoespaco{yxpart}, \monoespaco{yypart}, \monoespaco{angle},
\monoespaco{sqrt}, \monoespaco{sind}, \monoespaco{cosd}, \monoespaco{log},
\monoespaco{mexp}, \monoespaco{floor}, \monoespaco{uniformdeviate}.

5) Se temos um \monoespaco{+} ou \monoespaco{-}, descobrimos o tipo
avaliando o tipo do restante da expressão.

6) Se temos parênteses e dentro deles temos uma vírgula, é um par. Se
houverem mais vírgulas, é uma transformação. Se não houverem vírgulas,
devemos avaliar o tipo da expressão terciária interna.

7) Nos demais casos, o tipo é desconhecido e um erro deve ter ocorrido.

Na nossa implementação, para testar mais rapidamente, primeiro
checamos se temos ou não um caso simples composto por um único
token. Todos os casos acima são tratados separadamente de acordo com
isso:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_SYMBOLIC){ // Caso 1
      struct variable *var = (struct variable *)
                               ((struct symbolic_token *) begin_expr) -> var;
      return var -> type;
    }
    if(begin_expr -> type == TYPE_TRUE || begin_expr -> type == TYPE_FALSE ||
       begin_expr -> type == TYPE_NOT) // Caso 2
      return TYPE_T_BOOLEAN;
    if(begin_expr -> type == TYPE_NUMERIC ||
       begin_expr -> type == TYPE_NORMALDEVIATE) // Caso 4
      return TYPE_T_NUMERIC;
    else
      return -1;
  }
  else{
    if(begin_expr -> type == TYPE_CYCLE || begin_expr -> type == TYPE_ODD ||
       begin_expr -> type == TYPE_NOT) // Caso 2
      return TYPE_T_BOOLEAN;
    // Expressão de par (caso 3):
    if(begin_expr -> type == TYPE_POINT ||
       begin_expr -> type == TYPE_PRECONTROL ||
       begin_expr -> type == TYPE_POSTCONTROL)
      return TYPE_T_PAIR;    
    // Expressão numérica (Caso 4):
    if(begin_expr -> type == TYPE_LENGTH || begin_expr -> type == TYPE_XPART ||
       begin_expr -> type == TYPE_YPART || begin_expr -> type == TYPE_ANGLE ||
       begin_expr -> type == TYPE_XXPART || begin_expr -> type == TYPE_FLOOR ||
       begin_expr -> type == TYPE_XYPART || begin_expr -> type == TYPE_SIND ||
       begin_expr -> type == TYPE_YXPART || begin_expr -> type == TYPE_SQRT ||
       begin_expr -> type == TYPE_YYPART || begin_expr -> type == TYPE_LOG ||
       begin_expr -> type == TYPE_COSD ||   begin_expr -> type == TYPE_EXP ||
       begin_expr -> type == TYPE_UNIFORMDEVIATE) // Caso 4
      return TYPE_T_NUMERIC;
    // Caso 5:
    if(begin_expr -> type == TYPE_SUM || begin_expr -> type == TYPE_SUBTRACT)
      return get_primary_expression_type(mf, cx, begin_expr -> next, end_expr);
    // Token numérico, pode ser expressão numérica ou de par:
    if(begin_expr -> type == TYPE_NUMERIC){
      struct generic_token *t = begin_expr;
      while(t != NULL && t != end_expr){
        if(t -> type == TYPE_OPEN_BRACKETS || t -> type == TYPE_PRECONTROL ||
           t -> type == TYPE_OPEN_PARENTHESIS || t -> type == TYPE_POINT ||
           t -> type == TYPE_POSTCONTROL)
          return TYPE_T_PAIR;
        t = t -> next;
      }
      return TYPE_T_NUMERIC;
    }
    // Pode haver expressão de par que começa com parênteses e não termina:
    // (1+1)[p1, p2] e também: normaldeviate[p1, p2]
    if((begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
        end_expr -> type != TYPE_CLOSE_PARENTHESIS) ||
       begin_expr -> type == TYPE_NORMALDEVIATE)
      return TYPE_T_PAIR;
    if(begin_expr -> type == TYPE_OPEN_PARENTHESIS &&
       end_expr -> type == TYPE_CLOSE_PARENTHESIS &&
       begin_expr -> next != end_expr){
      DECLARE_NESTING_CONTROL();
      int number_of_commas = 0;
      struct generic_token *t = begin_expr -> next;
      while(t != NULL && t -> next != end_expr){
        COUNT_NESTING(t);
        if(IS_NOT_NESTED() && t -> type == TYPE_COMMA)
          number_of_commas ++;
        t = t -> next;
      }
      if(number_of_commas == 0)
        return get_tertiary_expression_type(mf, cx, begin_expr -> next, t);
      else if(number_of_commas == 1)
        return TYPE_T_PAIR;
      else if(number_of_commas == 5)
        return TYPE_T_TRANSFORM;
    }
    return -1;
  }
}
@
\fimcodigo

Agora vamos às expressões secundárias. As regras que usaremos são:

1) Se temos um único token, avaliamos tudo como expressão primária.

2) Se temos \monoespaco{and}, a expressão é booleana.

3) Se temos um transformador (\monoespaco{transformed}, \monoespaco{rotated},
\monoespaco{scaled}, \monoespaco{shifted}, \monoespaco{slanted},
\monoespaco{xscaled}, \monoespaco{yscaled}, \monoespaco{zscaled}), ignoramos
ele e o que há depois dele, voltando a avaliar o restante da expressão
como expressão secundária. Pode ser um transformador ou um par.

4) Se temos multiplicações e divisões, devemos checar a que está mais
à direita. Se um dos operandos for um par, é um par. Caso contrário, é
expressão numérica. Lembrando que a regra para a divisão é um pouco
complexa. Um token \monoespaco{/} só é divisão quando não é delimitada
por dois tokens numéricos. Neste caso, temos uma fração, não uma
divisão, e não há aí um operador secundário. A exceção é quando o
token anterior já faz parte de uma fração. Assim, 1/3 é fração ao
invésd e divisão, e não há nenhum operador secundário aí. Já 1/3/1/3
contém um operador secundário de divisão, dividindo duas frações de
1/3.

5) Nos demais casos, não pudemos identificar e o tipo deve ser
avaliado como se a expressão fôsse primária.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_secondary_expression_type(struct metafont *mf, struct context *cx,
                                 struct generic_token *begin_expr,
                                 struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  struct generic_token *last_fraction = NULL;
  struct generic_token *before_last_op = NULL, *prev_prev = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_AND)
        return TYPE_T_BOOLEAN;
      if(t -> type == TYPE_TRANSFORMED || t -> type == TYPE_ROTATED ||
         t -> type == TYPE_SCALED || t -> type == TYPE_SHIFTED ||
         t -> type == TYPE_SLANTED || t -> type == TYPE_XSCALED ||
         t -> type == TYPE_YSCALED || t -> type == TYPE_ZSCALED){
        if(prev == NULL)
          return -1;
        return get_secondary_expression_type(mf, cx, begin_expr, prev);
      }
      if(t -> type == TYPE_MULTIPLICATION || t -> type == TYPE_DIVISION){
        if(t -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
           t != end_expr &&
           ((struct generic_token *) t -> next) -> type != TYPE_NUMERIC &&
           last_fraction != prev_prev)
          last_fraction = t;
        else{
          last_op = t;
          before_last_op = prev;
        }
      }
    }
    prev_prev = prev;
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL){
    int s = get_primary_expression_type(mf, cx, last_op -> next, end_expr) +
            get_secondary_expression_type(mf, cx, begin_expr, before_last_op);
    if(s == 2 * TYPE_T_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(s == TYPE_T_NUMERIC + TYPE_T_PAIR)
      return TYPE_T_PAIR;
    else return -1;
  }
  else return get_primary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

Por fim, as expressões terciárias. Neste caso, as regras seguidas são:

1) Se temos um único token, avaliamos tudo como expressão primária.

2) Se temos um \monoespaco{or} ou uma relação
(\monoespaco{<}, \monoespaco{<=}, \monoespaco{>}, \monoespaco{>=},
\monoespaco{=}, \monoespaco{<>}), então é uma expressão booleana. Tecnicamente as
relações não são expressões terciárias. A ordem de precedência delas
seria de expressões quarternárias. Mas podemos considerar todos esses
operadores aqui, já que não estamos de fato avaliando as expressões,
onde seguir regras de precedência é fundamental.

3) Se temos soma e subtração pitagóricos
(\monoespaco{++}, \monoespaco{+-+}), então é expressão numérica.

4) Se temos soma ou subtração, o tipo da expressão é o mesmo de
qualquer um de seus operandos.

5) Nos demais casos, tentamos novamente avaliando a expressão como
secundária.

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
int get_tertiary_expression_type(struct metafont *mf, struct context *cx,
                                struct generic_token *begin_expr,
                                struct generic_token *end_expr){
  DECLARE_NESTING_CONTROL();
  struct generic_token *t = begin_expr, *prev = NULL, *last_op = NULL;
  if(begin_expr == end_expr)
    return get_primary_expression_type(mf, cx, begin_expr, end_expr);
  while(t != end_expr && t != NULL){
    COUNT_NESTING(t);
    if(IS_NOT_NESTED()){
      if(t -> type == TYPE_OR || t -> type == TYPE_LT ||
           t -> type == TYPE_GT || t -> type == TYPE_GEQ ||
           t -> type == TYPE_LEQ || t -> type == TYPE_ASSIGNMENT ||
           t -> type == TYPE_NEQ){
        return TYPE_T_BOOLEAN;
      }
      if(t -> type == TYPE_PYTHAGOREAN_SUM ||
         t -> type == TYPE_PYTHAGOREAN_SUBTRACT){
        return TYPE_T_NUMERIC;
      }
      if(IS_VALID_SUM_OR_SUB(prev, t) && t != end_expr)
        last_op = t;
    }
    prev = t;
    t = t -> next;
  }
  if(last_op != NULL)
    return get_secondary_expression_type(mf, cx, last_op -> next, end_expr);
  else return get_secondary_expression_type(mf, cx, begin_expr, end_expr);
}
@
\fimcodigo

\secao{9. Declaração Composta: Declaração Condicional}

Uma declaração condicional é um \monoespaco{if}, uma estrutura que
garante que certos trechos de código sejam executados somente se
certas condições forem verdadeiras. A gramática completa para
expressões deste tipo é:

\alinhaverbatim
<Bloco Condicional> -> if <Expressão Booleana> :
                         <Lista de Declarações>
                         <Alternativas>
                       fi
<Alternativas> -> <Vazio> |
                  elseif <Expressão Booleana>:
                    <Lista de Declarações>
                  <Alternativas> |
                  else: <Lista de Declarações>
\alinhanormal

Declararemos então os seguintes novos tipos de tokens:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_ELSEIF,  // O token simbólico 'elseif'
TYPE_ELSE,    // O token simbólico 'else'
TYPE_COLON,   // O token simbólico ':'
@
\fimcodigo

Os quais devem ser adicionados à lista de palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"elseif", "else", ":",
@
\fimcodigo

Na Seção 6 nós vimos a primeira das declarações compostas. A que
começa com \monoespaco{begingroup} e termina
com \monoespaco{endgroup}. A declaração condicional
usando \monoespaco{if} também é uma declaração composta do tipo, que
contém dentro de si várias outras declarações.

Lembre-se que código é primeiro avaliado na
função \monoespaco{eval\_list\_of\_statement}, qe separa o código
usando ponto-e-vírgula como delimitador e passa para a
função \monoespaco{eval\_statement} tratar cada parte. Esta função
deve interpretar o código que recebe, mas tem também a liberdade de
mudar a posição do ponteiro que delimita o fim da expressão que
avaliou, o qual é usado para depois escolher os próximos tokens a
serem lidos. É nessa segunda função que o código que trata
um \monoespaco{if} é localizado.

Assim como no caso do \monoespaco{begingroup} da Seção 6,
quando encontramos tokens a serem avaliados que começam
com \monoespaco{if}, o que fazemos é iniciar um novo nível de
aninhamento e depois disso corrigimos a posição do ponteiro do último
token avaliado para que os próximos tokens a serem avaliados sejam os
corretos. Mas aqui, para determinar a posição do ponteiro do próximo
token temos que executar uma lógica mais complexa, avaliando
expressões booleanas.

Basicamente, diante de um \monoespaco{if}, primeiro avaliamos a
expressão booleana diante dele. Se ela for verdadeira, posicionamos o
ponteiro para o próximo dois pontos (``:'') encontrado. Se não, então
percorremos os próximos tokens tentando encontrar o
próximo \monoespaco{elseif} ou \monoespaco{else}. No caso de
um \monoespaco{elseif}, novamente avaliamos sua expressão booleana
para saber se devemos colocar o ponteiro diante do código de seu
corpo. Já no caso de um \monoespaco{else}, sempre devemos colocar o
ponteiro diante de seu corpo. E se não encontrarmos nem
um \monoespaco{else}, e nem um \monoespaco{elseif} onde a expressão
booleana é verdadeira, então pulamos a declaração condicional,
colocando o ponteiro de fim no \monoespaco{fi}.

Entretanto, mesmo o código que iremos ignorar por estar dentro de um
bloco condicional que não deve ser executado, deve passar por um
mínimo de checagem para que erros de sintaxe não sejam ignorados. Por
exemplo, pode haver um \monoespaco{endgroup} ou \monoespaco{endchar}
solto, sem que qualquer uma destas declarações compostas tenha sido
iniciada com um \monoespaco{begingroup} ou \monoespaco{beginchar}
correspondente. Esse tipo de erro pode ser um sintoma de que
o \monoespaco{if} foi finalizado incorretamente e por isso não devemos
ignorar tais erros. À medida que percorremos código que não deve ser
executado por corresponder à uma expressão falsa de um \monoespaco{if}
ou \monoespaco{elseif}, devemos fazer uma checagem ao passarmos por
tokens que aumentam ou diminuem o nível de aninhamento para garantir
que eles estão corretos.

O código que trata então um \monoespaco{if} é:

\iniciocodigo
@<Declaração: Composta@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_IF){
  struct generic_token *begin_bool, *end_bool;
  struct boolean_variable b;
  int current_nesting_level;
  // Iniciando o aninhamento
  begin_nesting_level(mf, cx, begin_token_list);
  current_nesting_level = cx -> nesting_level;
  // Delimitando a expressão booleana
  begin_bool = ((struct generic_token *) begin_token_list) -> next;
  end_bool = begin_bool;
  while(end_bool != *end_token_list &&
        ((struct generic_token *) (end_bool -> next)) -> type != TYPE_COLON)
    end_bool = end_bool -> next;
  if(end_bool == *end_token_list){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Error delimiting boolean "
                    "condition.\n", mf -> file, end_bool -> line);
#endif
    return false;
  }
  // Avaliando a expressão booleana:
  if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
    return false;
  if(b.value == 1){ // Verdadeiro: código no 'if' deve ser avaliado
    *end_token_list = end_bool -> next;
    return true;
  }
  else{ // Falso: pulamos o código no 'if'
    struct generic_token *t = end_bool -> next;
    while(t -> next != NULL){
      if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
        // Achamos o 'fi' correspondente ao nosso 'if'
        if(!end_nesting_level(mf, cx, t))
          return false;
        *end_token_list = t;
        return true;
      }
      else if(t -> type == TYPE_ELSE &&
              cx -> nesting_level == current_nesting_level){
        // Achamos o 'else' correspondente ao nosso 'if'
        *end_token_list = t -> next;
        if(((struct generic_token *) *end_token_list) -> type != TYPE_COLON){
#if defined(W_DEBUG_METAFONT)
          fprintf(stderr, "METAFONT: Error: %s:%d: Expected ':' after "
                  "'else'.\n", mf -> file,
                  ((struct generic_token *) *end_token_list) -> line);
#endif
          return false;
        }
        return true;
      }
      else if(t -> type == TYPE_ELSEIF &&
              cx -> nesting_level == current_nesting_level){
        // Achamos um 'elseif' correspondente ao nosos 'if'
        begin_bool = t -> next;
        end_bool = begin_bool;
        while(end_bool != *end_token_list &&
              ((struct generic_token *)
                (end_bool -> next)) -> type != TYPE_COLON)
          end_bool = end_bool -> next;
        if(!eval_boolean_expression(mf, cx, begin_bool, end_bool, &b))
          return false;
        if(b.value == 1){ // Verdadeiro: código no 'elseif' deve ser avaliado
          *end_token_list = end_bool -> next;
          return true;
        }
      }
      // Outros tokens que mudam nível de aninhamento
      else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
              t -> type == TYPE_BEGINCHAR)
        begin_nesting_level(mf, cx, t);
      else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
              t -> type == TYPE_ENDCHAR)
        if(!end_nesting_level(mf, cx, t))
          return false;
      t = t -> next;
    }
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'if' statement.\n", mf -> file,
          ((struct generic_token *) begin_token_list) -> line);
#endif  
  return false;
}
@
\fimcodigo

A responsabilidade de encontrar o código certo a ser executado é do
trecho acima que trata o \monoespaco{if}. Mas nós podemos também
encontrar um \monoespaco{elseif} ou um \monoespaco{else} no começo de
uma declaração a ser avaliada. Quando isso ocorre, ou indica que é um
erro de sintaxe, quando um destes tokens está solto, sem
um \monoespaco{if} correspondenteo, ou então significa que estamos
dentro de um \monoespaco{if}, onde já terminamos de executar o código
correto e encontramos um delimitador onde novas expressões booleanas
podems ser testadas. Independente da expressão que estiver lá, nós já
terminamos de executar o nosso \monoespaco{if}. Então devemos ignorar
tudo que vem a seguir até achar o \monoespaco{fi} que encerra
o \monoespaco{if} em que estamos:

\iniciocodigo
@<Declaração: Composta@>+=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_ELSEIF ||
        ((struct generic_token *) begin_token_list) -> type ==
        TYPE_ELSE){
  int current_nesting_level;
  struct generic_token *t;
  if(cx -> end_token_stack == NULL ||
     cx -> end_token_stack -> type != TYPE_FI){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Token 'elseif' or 'else' should "
          "have a corresponding 'if'.\n", mf -> file,
          ((struct generic_token *) begin_token_list) -> line);
#endif  
    return false;
  }
  current_nesting_level = cx -> nesting_level;
  t = begin_token_list;
  while(t != NULL){
    if(t -> type == TYPE_FI && cx -> nesting_level == current_nesting_level){
      // Achamos o 'fi' correspondente ao nosso 'if'
      if(!end_nesting_level(mf, cx, t))
        return false;
      *end_token_list = t;
      return true;
    }
    else if(t -> type == TYPE_IF || t -> type == TYPE_BEGINGROUP ||
            t -> type == TYPE_BEGINCHAR)
      begin_nesting_level(mf, cx, t);
    else if(t -> type == TYPE_FI || t -> type == TYPE_ENDGROUP ||
            t -> type == TYPE_ENDCHAR)
      if(!end_nesting_level(mf, cx, t))
        return false;
    t = t -> next;
  }
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Not found corresponding 'fi' "
          "for 'else' or 'elseif' statement.\n", mf -> file,
          ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

Finalmente, nós podemos também encontrar um \monoespaco{fi} no começo
de declaração a ser avaliada. Neste caso, nós apenas diminuimos o
nível de aninhamento e marcamos o fim do que avaliamos para o próprio
token \monoespaco{fi}:

\iniciocodigo
@<Declaração: Composta@>+=
else if(((struct generic_token *) begin_token_list) -> type == TYPE_FI){
  if(!end_nesting_level(mf, cx, begin_token_list))
    return false;
  *end_token_list = begin_token_list;
  return true;
}
@
\fimcodigo

\secao{10. O Comando \monoespaco{pickup}}

Agora podemos começar a definir o nosso primeiro comando. A sintaxe do
comando \monoespaco{pickup} é dada por:

\alinhaverbatim
<Comando> -> <Comando 'pickup'>
<Comando 'pickup'> -> pickup <Variável de Caneta, 'nullpen' ou 'pencircle'>
                             <Transformadores Opcionais>
<Variável de Caneta ou 'nullpen'> -> nullpen | pencircle | <Variável de Caneta>
<Transformadores Opcionais> -> <Vazio> |
                               <Transformador> <Transformadores Opcionais>
\alinhanormal

O comando requer que criemos um novo token e palavra reservada:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_PICKUP,   // O token simbólico 'pickup'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"pickup",
@
\fimcodigo

O que este comando faz é armazenar um novo valor na
variável \monoespaco{currentpen}, a qual usaremos para fazer desenhos
(conforme definiremos na próxima Seção).

\subsecao{10.1. Pontos de Extremidade de Caneta}

Uma coisa que devemos fazer ao recebermos uma caneta com o
comando \monoespaco{pickup} é armazenar 4 valores internamente. Dois
deles para armazenar o menor e maior valor na coordenada $x$ que esta
caneta gera ao ser renderizada e também o menor e maior valor na
coordenada $y$. Armazenar tais valores será útil para que possamos
ajustar melhor os pontos que vamos desenhar. Por exemplo, podemos
querer desenhar com a caneta o mais próximo possível do canto inferior
esquerdo da imagem, sem que a caneta saia para fora da imagem. Tal
tipo de controle requer que saibamos o tamanho da caneta. Por isso
vamos ter que armazenar internamente os
valores \monoespaco{pen\_lft}, \monoespaco{pen\_rt}, \monoespaco{pen\_top}
e \monoespaco{pen\_bot}. Como estes valores são sempre referentes
à \monoespaco{currentpen}, uma variável com escopo global, vamos
armazenar ela no \monoespaco{struct metafont}:

\iniciocodigo
@<Atributos (struct metafont)@>+=
float pen_lft, pen_rt, pen_top, pen_bot;
@
\fimcodigo

Estes valores são inicializados como zero porque
a \monoespaco{currentpen} começa como uma \monoespaco{nullpen}:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> pen_lft = mf -> pen_rt = mf -> pen_top = mf -> pen_bot = 0.0;
@
\fimcodigo

Uma operação muito comum que faremos nesta Seção será, ao gerar novos
vértices que irão compor o formato da caneta, verificar se geramos um
ponto mais à esquerda que \monoespaco{pen\_lft}, mais à direita
que \monoespaco{pen\_rt}, acima de \monoespaco{pen\_top} ou abaixo
de \monoespaco{pen\_bot}. Em tais casos devemos atualizar a informação
sobre os pontos de extremidade da caneta.

Para reduzir o tamanho do código, a macro abaixo vai representar o
código no qual declaramos as variáveis que armazenam a coordenada mais
à esquerda, direito, acima ou abaixo de um vértice que geramos:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define DECLARE_PEN_EXTREMITIES() float _max_x = -INFINITY, _min_x = INFINITY,\
                                  _max_y = -INFINITY, _min_y = INFINITY;
@
\fimcodigo

Diante de um novo ponto, vamos usar a macro abaixo para obter sua
coordenada $(x, y)$, multiplicar por uma amtriz de transformação e
assim checar se temos algo que deve ser armazenado como um dos menores
ou maiores pontos da caneta no eixo $x$ ou eixo $y$:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define CHECK_PEN_EXTREMITIES(x, y, matrix) {\
   float _x, _y;\
   _x = LINEAR_TRANSFORM_X(x, y, matrix);\
   _y = LINEAR_TRANSFORM_Y(x, y, matrix);\
   if(_x < _min_x) _min_x = _x;\
   if(_x > _max_x) _max_x = _x;\
   if(_y < _min_y) _min_y = _y;\
   if(_y > _max_y) _max_y = _y;\
  }
// Se a matriz é a identidade, podemos usar esta macro:
#define CHECK_PEN_EXTREMITIES_I(x, y) {\
   if(x < _min_x) _min_x = x;\
   if(x > _max_x) _max_x = x;\
   if(y < _min_y) _min_y = y;\
   if(y > _max_y) _max_y = y;\
  }
@
\fimcodigo

Depois de checarmos todos os pontos de uma caneta, podemos então
atualizar seus pontos de extremidade:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define UPDATE_PEN_EXTREMITIES() {\
  mf -> pen_lft = _min_x;\
  mf -> pen_rt = _max_x;\
  mf -> pen_top = _max_y;\
  mf -> pen_bot = _min_y;\
}
@
\fimcodigo

As macros anteriores presumem que iremos iterar sobre cada um dos
pontos que compõe o perímetro de uma caneta. Fazendo isso, podemos
chamar \monoespaco{CHECK\_PEN\_EXTREMITIES} em todos os pontos e assim
obtemos os que forem maiores no eixo $x$ e $y$. Nos casos em que não
queremos iterar sobre todos os pontos, vamos criar também algumas
funções para deduzi-los para nós. Por exemplo, caso tenhamos usado o
comando \monoespaco{pickup} sobre \monoespaco{pencircle} e a nossa
caneta tenha passado por uma transformação linear representada por uma
matriz. A função abaixo pode ser usada para obter os pontos de
extremidade para esta caneta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix);
@
\fimcodigo

Um \monoespaco{pencircle} padrão, sem senhuma transformação é uma
caneta circular de raio $1/2$. O que quer dizer que toda coordenada
$(x,y)$ atende à seguinte fórmula:

$$
x^2+y^2= 0.25
$$

Ou, de maneira equivalente:

$$
x=\pm\sqrt{0.25-y^2}
$$

$$
y=\pm\sqrt{0.25-x^2}
$$

Dada uma transformação linear definida pela matriz $M$, obtemos os novos
valores de $x$ e $y$ seguindo a fórmula abaixo:

$$
f_x(x) = M_{11}x \pm M_{21}\sqrt{0.25-x^2} + M_{31}
$$

$$
f_y(y) = M_{22}y \pm M_{12}\sqrt{0.25-y^2} + M_{32}
$$

Quando $M_{11}$ é igual à 0, os pontos mais extremos no eixo $x$ serão
a transformação linear dada por $M$ de $(-0.5, 0)$ e $(0.5, 0)$. Se
$M_{21}$ for igual à zero, os pontos mais extremos serão dados por
$(0, -0.5)$ e $(0, 0.5)$ transformados por $M$. A mesma lógica se
aplica aos extremos no eixo $y$ quando $M_{22}$ ou $M_{12}$ é igual à
zero. Em todos estes casos, o valor depende somente de maximizar ou a
coordenada $x$ ou $y$.

Para todos os demais casos, achar o ponto de máximo ou de mínimo
destas funções requer calcular a derivada das fórmulas acima e
igualamos à zero:

$$
f_x'(x)=M_{11} \pm (M_{21}x)/(\sqrt{0.25-x^2})=0
$$

$$
f_y'(y)=M_{22} \pm (M_{12}y)/(\sqrt{0.25-y^2})=0
$$

Como não há uma fórmula que nos dê a solução de maneira direta, temos
que usar métodos iterativos como o Método de Newton. para achar os
valores $x$ e $y$ que tornam as fórmulas acima corretas. Para poder
usar o médodo de Newton, começamos calculando a derivada de segunda
ordem destas fórmulas:

$$
f_x''(x)= \pm (M_{21}\sqrt{0.25-x^2}+(M_{21}x^2)/(\sqrt{0.25-x^2}))
$$

$$
f_y''(y)= \pm (M_{12}\sqrt{0.25-x^2}+(M_{12}x^2)/(\sqrt{0.25-x^2}))
$$

Pelo Método de Newton, uma vez que tenhamos uma estimativa $x_n$ e
$y_n$ para o zero da função $f'_x$ e $f'_y$, podemos obter uma
estimativa melhor calculando:

$$
x_{n+1} = x_{n} - (f'_x(x_n)/f''_x(x_n))
$$

$$
y_{n+1} = y_{n} - (f'_y(y_n)/f''_y(y_n))
$$

O problema do Método de Newton é que como nossa função $f_x$ e $f_y$
está definida somente entre -0,5 e +0,5, se o valor que estamos
buscando estiver muito próximo destas extremidades, ele pode acabar
nos empurrando para fora do Domínio da função. Caso isso ocorra,
teremos que recorrer a outro método. No caso, usaremos o mais lento
Método da Bissecção. Note que $f'_x(-0,5)$ e $f'_x(+0,5)$ tem sinais
opostos sempre, assumindo que um zero da função exista. Sendo assim,
este método começa com este intervalo e depois checa o sinal de $f_x$
no meiio das duas extremidades. Baseado no sinal ele reduz o tamanho
do intervalo até reduzi-lo à zero e encontrar o valor.

Após revisar toda a teoria, podemos enfim implementar a função que
obtém os pontos de extremidade de uma caneta redonda:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void pencircle_extremity_points(struct metafont *mf, float *matrix){
  DECLARE_PEN_EXTREMITIES();
  int i, index[4] = {0, 3, 4, 1};
  for(i = 0; i < 2; i ++){ // i=0 computa eixo x, i=1 computa eixo y
    // Primeiro os casos mais simples:
    if((i == 0 && matrix[3] == 0.0) ||
       (i == 1 && matrix[4] == 0.0)){
      CHECK_PEN_EXTREMITIES(-0.5, 0.0, matrix);
      CHECK_PEN_EXTREMITIES(0.5, 0.0, matrix);
    }
    else if((i == 0 && matrix[0] == 0.0) ||
            (i == 1 && matrix[1] == 0.0)){
      CHECK_PEN_EXTREMITIES(0.0, 0.5, matrix);
      CHECK_PEN_EXTREMITIES(0.0, -0.5, matrix);
    }
    else{
      // Método de newton
      float x0 = INFINITY, x1 = 0.0;
      do{
        x0 = x1;
        x1 = x0 - ((matrix[index[2*i]]+(matrix[index[2*i+1]]*
                  x0/sqrt(0.25-x0*x0))) /
             (matrix[index[2*i+1]]*sqrt(0.25-x0*x0)+
                  ((matrix[index[2*i+1]]*x0*x0)/
             (sqrt(0.25-x0*x0)))));
        if(x1 <= -0.5 || x1 >= 0.5){
          // Convergência falhou, usar método da Bissecção
          float y1;
          x0 = -0.5;
          x1 = 0.5;
          y1 = matrix[3-i*2] * sqrt(0.25-x1*x1) +
               (matrix[index[3-i*2]]*x1/sqrt(0.25-x1*x1));
          while(x0 != x1){
            float x2 = (x0+x1)/2;
            float y2 = matrix[index[3-i*2]] * sqrt(0.25-x2*x2) +
                       (matrix[index[3-i*2]]*x2/sqrt(0.25-x2*x2));
            if(y2 == 0.0 || x0 == x2 || x1 == x2)
              x0 = x1 = x2;
            else if(y2 > 0){
              if(y1 > 0)
                x1 = x2;
              else
                x0 = x2;
            }
            else{
              if(y1 > 0)
                x0 = x2;
              else
                x1 = x2;
            } 
          }
        }
      } while(x0 != x1);
      if(i == 0){
        CHECK_PEN_EXTREMITIES(x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(x0, -sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, sqrt(0.25-x0*x0), matrix);
        CHECK_PEN_EXTREMITIES(-x0, -sqrt(0.25-x0*x0), matrix);
      }
      else{
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), x0, matrix);
        CHECK_PEN_EXTREMITIES(sqrt(0.25-x0*x0), -x0, matrix);
        CHECK_PEN_EXTREMITIES(-sqrt(0.25-x0*x0), -x0, matrix);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo

Também podemos querer achar os pontos de extremidade não para um
círculo, mas para um caminho definido como curvas de Bézier:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix);
@
\fimcodigo

Curiosamente, neste caso as fórmulas são mais simples. Uma curva de
Bézier cúbica como as que usamos tem a seguinte fórmula, com $t$
variando entre 0 e 1, com $z_1$ e $z_4$ sendo pontos de extremidade e
com  $z_2$ e $z_3$ sendo pontos de controle:

$$
z(t) = (1-t)^3z_1+3(1-t)^2tz_2+3(1-t)t^2z_3+t^3z_4
$$

A derivada da função é:

$$
z'(t) = (-3z_1+9z_2-9z_3+3z_4)t^2+(6z_1-12z_2+6z_3)t+(-3z_1+3z_2)
$$

Descobrir em quais valores isso é igual à zero requer meramente usar a
fórmula de Bháskara.

Achar os pontos de extremidade então será feito iterando sobre os
pontos do caminho e computando os zeros de $z'(t)$. Se acharmos um
zero entre 0 e 1, checamos o valor para ver se precisamos
armazená-lo. Também checamos cada um dos pontos de extremidade. Os
pontos $z_1, z_2, z_3, z_4$ que usamos são aqueles que estão
armazenados após passar pela transformação linear da matriz
correspondente:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void path_extremity_points(struct metafont *mf, struct path_variable *p,
                           float *matrix){
  int i, j, length = p -> length;
  DECLARE_PEN_EXTREMITIES();
  for(i = 0; i < length; i ++){
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    CHECK_PEN_EXTREMITIES(p -> points[i].x, p -> points[i].y, matrix);
    x0 = LINEAR_TRANSFORM_X(p -> points[i].x, p -> points[i].y, matrix);
    y0 = LINEAR_TRANSFORM_Y(p -> points[i].x, p -> points[i].y, matrix);
    u_x = LINEAR_TRANSFORM_X(p -> points[i].u_x, p -> points[i].u_y, matrix);
    u_y = LINEAR_TRANSFORM_Y(p -> points[i].u_x, p -> points[i].u_y, matrix);
    v_x = LINEAR_TRANSFORM_X(p -> points[i].v_x, p -> points[i].v_y, matrix);
    v_y = LINEAR_TRANSFORM_Y(p -> points[i].v_x, p -> points[i].v_y, matrix);    
    x1 = LINEAR_TRANSFORM_X(p -> points[(i+1)%length].x, p -> points[i].y,
                            matrix);
    y1 = LINEAR_TRANSFORM_Y(p -> points[(i+1)%length].y, p -> points[i].y,
                            matrix);
    // Fórmula de Bháskara (eixo x)
    float a, b, c, deltah, t;
    a = (-3*x0+9*u_x-9*v_x+3*x1);
    b = (6*x0-12*u_x+6*v_x);
    c = (-3*x0+3*u_x);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(deltah)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
    // Fórmula de Bháskara (eixo y)
    a = (-3*y0+9*u_y-9*v_y+3*y1);
    b = (6*y0-12*u_y+6*v_y);
    c = (-3*y0+3*u_y);
    deltah = b * b - 4 * a * c;
    for(j = -1; j < 2; j += 2){
      t = (-b + j * sqrt(b * b - 4 * a * c)) / (2 * a);
      if(t > 0.0 && t < 1.0){
        float x, y;
        x = (1-t)*(1-t)*(1-t)*x0+3*(1-t)*(1-t)*t*u_x+3*(1-t)*t*t*v_x+
            t*t*t*x1;
        y = (1-t)*(1-t)*(1-t)*y0+3*(1-t)*(1-t)*t*u_y+3*(1-t)*t*t*v_y+
            t*t*t*y1;
        CHECK_PEN_EXTREMITIES_I(x, y);
      }
    }
  }
  UPDATE_PEN_EXTREMITIES();
}
@
\fimcodigo

\subsecao{10.2. Triangulação}

Vamos agora lidar com o código de triangulação. As placas de vídeo e o
OpenGL trabalha com triângulos. Nós devemos então triangular um pincel
antes de podermos representá-lo graficamente. Devemos representá-lo
como uma lista de triângulos. Isso chegou a ser mencionado na Subseção
7.5. sobre variáveis de caneta, mas o processo de triangulação não foi
definido lá.

Para recapitular, estas são as variáveis relevantes para a
triangulação que estão definidas dentro de um \monoespaco{struct
pen\_variable}:

* \monoespaco{struct path\_variable *format}: Possui um caminho
  cíclico com o formato da caneta.

* \monoespaco{GLuint gl\_vbo}: Referência para os vértices armazenados
  na placa de vídeo. Será 0 se a caneta ainda não foi triangulada.

* \monoespaco{float triang\_resolution}: Uma medida interna do nível
  de detalhamento de nossa triangulação. Relevante para saber se devemos
  retriangular uma caneta curva ou circular para podermos mostrar mais
  detalhes dela quando seu tamanho muda.

* \monoespaco{int flags}: Possui informação se o caminho acima define
  uma forma convexa ou côncava, um polígono ou uma figura com curvas,
  se é um quadrado, um círculo ou um polígono nulo sem lados. Além
  disso, nesta seção vamos definir e usar os novos valores desta flag:

\iniciocodigo
@<Macros Locais (metafont.c)@>+=
#define FLAG_ORIENTATION      32
#define FLAG_COUNTERCLOCKWISE 64
@
\fimcodigo

A segunda flag acima será usada para indicar se estamos armazenando
osvértices do formato da caneta no sentido anti-horário (se estiver
ativa) ou horário (se não estiver ativa). Entretanto, só vamos
considerar o valor válido e inicializado se a flag anterior acima
estiver ativa.

Vamos usar a seguinte função para obter tal informação de uma caneta:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen);
@
\fimcodigo

A função funciona checando se temos tal informação armazenada na flag
e a retornando. Se não, ela busca descobrir. Ela faz isso encontrando
o vértice com a menor coordenada $y$ (e o maior $x$ se houver
empate). Seja $A$ este vértice, $P$ o vértice anterior e $N$ o
próximo. O sinal do resultado do produto escalar de $AP$ e $AN$
determina a orientação:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool is_pen_counterclockwise(struct pen_variable *pen){
  int i, index = 0;
  int size = pen -> format -> length;
  float smallest_y = INFINITY, biggest_x = -INFINITY;
  if(pen -> flags & FLAG_ORIENTATION)
    return (pen -> flags & FLAG_COUNTERCLOCKWISE);
  for(i = 0; i < size; i ++){
    if(pen -> format -> points[i].y < smallest_y ||
       (pen -> format -> points[i].y == smallest_y &&
        pen -> format -> points[i].y > biggest_x)){
      smallest_y = pen -> format -> points[i].y;
      biggest_x = pen -> format -> points[i].x;
      index = i;
    }
  }
  {
    int n = (index - 1) % size, p = (index + 1) % size;
    while(pen -> format -> points[index].x == pen -> format -> points[n].x &&
          pen -> format -> points[index].y == pen -> format -> points[n].y)
      n = (n + 1) % size;
    while(pen -> format -> points[index].x == pen -> format -> points[p].x &&
          pen -> format -> points[index].y == pen -> format -> points[p].y)
      p = (p - 1) % size;
    float ap_x = pen -> format -> points[p].x -
                 pen -> format -> points[index].x;
    float ap_y = pen -> format -> points[p].y -
                 pen -> format -> points[index].y;
    float an_x = pen -> format -> points[n].x -
                 pen -> format -> points[index].x;
    float an_y = pen -> format -> points[n].y -
                 pen -> format -> points[index].y;
    float prod = ap_x * an_x + ap_y * an_y;
    pen -> flags += FLAG_ORIENTATION;
    pen -> flags += FLAG_COUNTERCLOCKWISE * (prod > 0);
    return (prod > 0);
  }
}
@
\fimcodigo

A função que fará a triangulação é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix);
@
\fimcodigo

E a sua implementação é:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
bool triangulate_pen(struct metafont *mf, struct pen_variable *pen,
                     float *transform_matrix){
  @<Triangulação: Caneta Nula@>
  @<Triangulação: Caneta Quadrada@>
  @<Triangulação: Polígono Convexo@>
  @<Triangulação: Círculo@>
  @<Triangulação: Forma Curva Convexa@>
  @<Triangulação: Forma Côncava@>
}
@
\fimcodigo

O caso mais simples é se tentarmos triangular uma caneta nula,
definida pelo comando \monoespaco{nullpen}. Essas canetas nunca serão
trianguladas, pois elas não fazem desenho algum. Consideramos elas
como sendo somente o ponto $(0, 0)$. Embora ela possa ser deslocada
com uma matriz de transformação. Este caso mais simples é tratado
abaixo:

\iniciocodigo
@<Triangulação: Caneta Nula@>=
if((pen -> flags & FLAG_NULL)){
  pen -> indices = 0;
  DECLARE_PEN_EXTREMITIES();
  CHECK_PEN_EXTREMITIES(0, 0, transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

O próximo caso é quando temos uma caneta quadrada. Este tipo de caneta
não precisa ser triangulada porque durante a inicialização nós já
fazemos uma só triangulação que será usada por toda e qualquer caneta
quadrada. Seus vértices serão armazenados aqui:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static GLuint pensquare_vbo;
@
\fimcodigo

E o código de triangulação que será usado na inicialização:

\iniciocodigo
@<Inicialização de Weaver Metafont@>+=
{
  float square_vertices[8] = {-0.5, -0.5,
                               +0.5, -0.5,
                               +0.5, +0.5,
                               -0.5, +0.5};
  glGenBuffers(1, &pensquare_vbo);
  glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  glBufferData(GL_ARRAY_BUFFER, 8 * sizeof(float), square_vertices,
               GL_STATIC_DRAW);
}
@
\fimcodigo

Na finalização podemos remover os vértices da placa de vídeo:

\iniciocodigo
@<Finalização de Weaver Metafont@>+=
glDeleteBuffers(1, &pensquare_vbo);
@
\fimcodigo

Sendo assim, quando temos que triangular uma caneta quadrada, nós não
a triangulamos. Mesmo assim, devemos obter os seus pontos de
extremidades:

\iniciocodigo
@<Triangulação: Caneta Quadrada@>=
if((pen -> flags & FLAG_SQUARE)){
  float square_vertices[8] = {-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5};
  pen -> indices = 4;
  DECLARE_PEN_EXTREMITIES();
  int i;
  for(i = 0; i < 4; i ++)
    CHECK_PEN_EXTREMITIES(square_vertices[2 * i], square_vertices[2 * i + 1],
                          transform_matrix);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

O próximo caso mais simples é quando temos um polígono convexo. Neste
caso, podemos usar o algoritmo mais simples. Escolhemos um único
vértice como pivô e fazemos uma triangulação gerando triângulos usando
o pivô e cada um dos vértices adjacentes que temos. É o método de
triangulação em leque:

\imagem{images/triangulacao_leque.eps}

Para isso basta passarmos os vértices da caneta na ordem anti-horária
para a placa de vídeo usando o OpenGL. Depois, quando chegar a hora de
desenhar, é só pedir para o OpenGL usar a triangulação em leque:

\iniciocodigo
@<Triangulação: Polígono Convexo@>=
if((pen -> flags & FLAG_STRAIGHT) && (pen -> flags & FLAG_CONVEX)){
  int i, index, increment;
  DECLARE_PEN_EXTREMITIES();
  GLsizei size = sizeof(float) * 2 * pen -> format -> length;
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  if(is_pen_counterclockwise(pen)){
    index = 0;
    increment = 1;
  }
  else{
    index = pen -> format -> length - 1;
    increment = -1;
  }
  for(i = 0; i < pen -> format -> length; i ++){
    data[2 * i] = pen -> format -> points[index].x;
    data[2 * i + 1] = pen -> format -> points[index].y;
    CHECK_PEN_EXTREMITIES(data[2 * i], data[2 * i + 1], transform_matrix);
    index += increment;
  }
  if(pen -> gl_vbo == 0){
    glGenBuffers(1, &(pen -> gl_vbo));
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
    glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
    pen -> indices = pen -> format -> length;
  }
  if(temporary_free != NULL)
    temporary_free(data);
  UPDATE_PEN_EXTREMITIES();
  return true;
}
@
\fimcodigo

Vamos agora passar para o próximo caso de triangulação: o círculo. Uma
caneta circular é gerada com a expressão \monoespaco{pencircle}. Para
este tipo de caneta, devemos gerar seus vértices na hora para fazer a
triangulação. Com saber quantos vértices gerar? Se o círculo tiver um
único pixel de diâmetro, 4 vértices já seriam o suficiente para
aproximá-lo e ninguém notaria estar diante de um quadrado ao invés de
um círculo. Mas quanto maior ele fica, maior o número de vértices que
devemos usar.

Devemos levar em conta a fórmula do arco de circunferência $L=\theta
r$. Aqui $\theta$ é um ângulo interno do círculo e $r$ seu raio. O
valor de $L$ é o comprimento de arco definido port ais
valores. Devemos então fazer com que cada arco que desenhamos tenha um
tamanho de 1 pixel, fazendo com que o desenho sempre se pareça com um
círculo. Para isso o ângulo interno entre cada um deles em radianos
deve ser $1/r$. Como o ângulo total é $2\pi$, então devemos
representar $2\pi r$ vértices diferentes no perímetro do círculo.

A triangulação que usaremos será a mesma triangulação em leque
anterior. Mas vamos escolher como pivô o centro do círculo. Desta
forma, vamos armazenar $2\pi r + 1$ vértices.

Já o raio do círculo é escolhido como sendo metade do maior lado do
quadrado de lado 1 que passa pela mesma transformação linear definida
pela matriz de transformação do círculo. Como um círculo de diâmetro 1
é inscrito em um quadrado de lado 1, então este valor nos dá um limite
superior adequado para representar o raio do círculo em cada ponto de
seu perímetro, mesmo depois de uma transformação linear possivelmente
transformar nosso círculo em uma elipse.

Esse maior número de diâmetro do quadrado no qual o círculo está
inscrito é também como mediremos a resolução da triangulação de um
círculo. Se um círculo já estiver triangulado e tivermos que desenhar
um com resolução menor, não é necessário triangular novamente. Mas se
tivermos que desenhar um com resoluçao maior, temos que triangulá-lo
novamente, mesmo que ele já tenha sido triangulado.

O código para a triangulação do círculo é:

\iniciocodigo
@<Triangulação: Círculo@>=
if((pen -> flags & FLAG_CIRCULAR)){
  float radius;
  // Obter pontos de extremidade:
  pencircle_extremity_points(mf, transform_matrix);
  // Checando resolução (raio):
  {
    float side1, side2;
    side1 = abs(mf -> pen_rt - mf -> pen_lft);
    side2 = abs(mf -> pen_top - mf -> pen_bot);
    radius = ((side1 >= side2)?(side1):(side2))/ 2.0;
  }
  // Só retriangula se raio for maior que resolução já triangulada:
  if(pen -> gl_vbo != 0){
    if(radius > pen -> triang_resolution)
      glDeleteBuffers(1, &(pen -> gl_vbo));
    else
      return true;
  }
  pen -> triang_resolution = radius;
  GLsizei size = sizeof(float) * 2 * (((int) (2 * M_PI * radius)) + 4);
  float *data = (float *) temporary_alloc(size);
  if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    int i;
    float angle = 0.0;
    data[0] = 0.0;
    data[1] = 0.0; // Centro do círculo
    for(i = 2; i < (size / sizeof(float)); i ++){
      data[i] = 0.5 * sin(angle);
      i ++;
      data[i] = 0.5 * cos(angle);
      angle += 1/radius;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
  pen -> indices = (size / (2 * sizeof(float)));
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

Vamos tratar agora o último caso restante de caneta convexa: quando
temos uma caneta cujo formato tem curvas, mas ela é convexa. Neste
caso, assim como no círculo, devemos levar em conta seu tamanho para
decidir quantos vértices devemos usar para aproximar corretamente a
curva. Mas agora temos que fazer isso iterando sobre cada par
adjacente de pontos de extremidade, levando em conta os pontos de
controle.

Para cada par de pontos $(A, D)$ de pontos de extremidade, com os
pontos de controle $(B, C)$, o número de vértices que geraremos será
dado pela soma das distâncias $AB$, $BC$ e $CD$. A estimativa gerará
valores razoáveis, exceto em casos nos quais os pontos de controle
aparecem em ordens problemáticas, nas quais a curva acabaria cruzando
sobre si mesma. Como não suportamos formas não-simples para canetas,
este é um caso indefinido e não nos preocuparemos com ele.

Esse cálculo de distância, somando a distância dos pontos ao iterar
sobre toda a curva é também como representaremos a resolução da
triangulação de uma caneta curva. Se a soma das distâncias for menor
do que a resolução da triangulação, então não precisamos triangular
novamente, pois a caneta já está triangulada em um nível de detalhe
aceitável.

Podemos também economizar o número de vértices quando a curva na
verdade é uma linha reta entre $A$ e $D$. Em tais casos, só é
necessário ter vértices para os pontos de extremidade.

Para gerar os pontos, após determinar o número de vértices, podemos
gerar cada um deles, modificando o valor de $t$ na fórmula abaixo,
variando entre 0 e 1 passando por um valor intermediário para cada
vértice a mais a ser gerado:

$$
P(t) = (1-t)^3A + 3(1-t)^2tB + 3(1-t)t^2C + t^3D
$$

Naturalmente, devemos também percorrer os pontos em um sentido
anti-horário, o que não necessariamente é a orientação na qual eles
estão armazenados. Outra coisa a lembrar é que ao medir a distância
entre os pontos, nós devemos levar em conta a transformação linear
armazenada na matriz de transformação. Mas ao renderizar os vértices,
isso não deve ser levado em conta, já que tal transformação será
aplicada pela placa de vídeo ao renderizar a caneta.

O código para triangular uma caneta neste caso é:

\iniciocodigo
@<Triangulação: Forma Curva Convexa@>=
if((pen -> flags & FLAG_CONVEX)){
  bool counterclockwise = is_pen_counterclockwise(pen);
  int i, number_of_vertices = 1;
  // Obtém pontos de extremidade:
  path_extremity_points(mf, pen -> format, transform_matrix);
  for(i = 0; i < pen -> format -> length - 1; i ++){
    int distance = 0;
    float x0, y0, u_x, u_y, v_x, v_y, x1, y1;
    float dx, dy;
    x0 = LINEAR_TRANSFORM_X(pen -> format -> points[i].x,
                            pen -> format -> points[i].y, transform_matrix);
    y0 = LINEAR_TRANSFORM_Y(pen -> format -> points[i].x,
                            pen -> format -> points[i].y, transform_matrix);
    u_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].u_x,
                            pen -> format -> points[i].u_y, transform_matrix);
    u_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].u_x,
                            pen -> format -> points[i].u_y, transform_matrix);
    dx = u_x - x0;
    dy = u_y - y0;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    v_x = LINEAR_TRANSFORM_X(pen -> format -> points[i].v_x,
                            pen -> format -> points[i].v_y, transform_matrix);
    v_y = LINEAR_TRANSFORM_Y(pen -> format -> points[i].v_x,
                            pen -> format -> points[i].v_y, transform_matrix);
    dx = v_x - u_x;
    dy = v_y - u_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    x1 = LINEAR_TRANSFORM_X(pen -> format -> points[i + 1].x,
                            pen -> format -> points[i + 1].y,
                            transform_matrix);
    y1 = LINEAR_TRANSFORM_Y(pen -> format -> points[i + 1].x,
                            pen -> format -> points[i + 1].y,
                            transform_matrix);
    dx = x1 - v_x;
    dy = y1 - v_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = x1 - x0;
    dy = y1 - y0;
    if(distance == (int) round(sqrt(dx * dx + dy * dy)))
      number_of_vertices ++; // Linha reta
    else
      number_of_vertices += distance;
  }
  if(pen -> gl_vbo != 0){
    if(number_of_vertices <= pen -> triang_resolution)
      return true; // No need to triangulate again
    else
      glDeleteBuffers(1, &(pen -> gl_vbo)); // Need to retriangulate
  }
  pen -> triang_resolution = number_of_vertices;
  float *data = (float *) temporary_alloc(number_of_vertices * 2 *
                                          sizeof(float));
    if(data == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: Not enough memory.\n");
#endif
    return false;
  }
  {
    struct path_points *p0, *p1;
    int v;
    if(counterclockwise)
      p0 = &(pen -> format -> points[0]);
    else
      p0 = &(pen -> format -> points[pen -> format -> length - 1]);
    data[0] = p0 -> x;
    data[1] = p0 -> y;
    v = 2;
    for(i = 0; i < pen -> format -> length - 1; i ++){
      float b_x, b_y, c_x, c_y, dx, dy, x0, y0, x1, x2, y1, y2;
      int distance = 0;
      if(counterclockwise){
        p1 = &(pen -> format -> points[1 + i]);
        b_x = p0 -> u_x;
        b_y = p0 -> u_y;
        c_x = p0 -> v_x;
        c_y = p0 -> v_y;
      }
      else{
        p1 = &(pen -> format -> points[pen -> format -> length - 2 - i]);
        b_x = p1 -> v_x;
        b_y = p1 -> v_y;
        c_x = p1 -> u_x;
        c_y = p1 -> u_y;
      }
      x0 = LINEAR_TRANSFORM_X(p0 -> x, p0 -> y, transform_matrix);
      y0 = LINEAR_TRANSFORM_Y(p0 -> x, p0 -> y, transform_matrix);
      x2 = LINEAR_TRANSFORM_X(b_x, b_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(b_x, b_y, transform_matrix);
      dx = x2 - x0;
      dy = y2 - y0;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(c_x, c_y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(c_x, c_y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      x1 = x2;
      y1 = y2;
      x2 = LINEAR_TRANSFORM_X(p1 -> x, p1 -> y, transform_matrix);
      y2 = LINEAR_TRANSFORM_Y(p1 -> x, p1 -> y, transform_matrix);
      dx = x2 - x1;
      dy = y2 - y1;
      distance += (int) round(sqrt(dx * dx + dy * dy));
      dx = x2 - x0;
      dy = y2 - y0;
      if(distance == (int) round(sqrt(dx * dx + dy * dy))){
        data[v++] = p1 -> x;
        data[v++] = p1 -> y;
      }
      else{
        int j;
        float dt = 1.0 / ((float) distance);
        for(j = 1; j <= distance; j ++){
          float t = dt * j;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> x + 3*(1-t)*(1-t)*t * b_x +
                      3*(1-t)*t*t * c_x + t * t * t * p1 -> x;
          data[v++] = (1-t)*(1-t)*(1-t)* p0 -> y + 3*(1-t)*(1-t)*t * b_y +
                      3*(1-t)*t*t * c_y + t * t * t * p1 -> y;
        }
      }
      p0 = p1;
    }
  }
  glGenBuffers(1, &(pen -> gl_vbo));
  glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glBufferData(GL_ARRAY_BUFFER, number_of_vertices * 2 *
                                sizeof(float), data, GL_STATIC_DRAW);
  pen -> indices = number_of_vertices;
  if(temporary_free != NULL)
    temporary_free(data);
  return true;
}
@
\fimcodigo

Com relação à canetas com formas côncavas, por enquanto nós não iremos
suportá-las, mas isso deve mudar futuramente:

\iniciocodigo
@<Triangulação: Forma Côncava@>=
if(!(pen -> flags & FLAG_CONVEX)){
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: Concave pens still not supported.\n");
#endif
  return false;
}
return false;
@
\fimcodigo

\subsecao{10.3. Lendo o Comando 'pickup'}

Agora vamos ao que efetivamente ocorre quando lemos o
comando \monoespaco{pickup}.

1) Primeiro lemos o próximo token. Se for \monoespaco{nullpen},
fazemos com que \monoespaco{currentpen} se torne uma caneta nula e se
for um \monoespaco{pencircle} se torna uma caneta circular. Se for uma
variável de caneta, fazemos com que ela aponte para essa variável. Em
ambos os casos, reiniciamos a matriz de transformação
de \monoespaco{currentpen} para a de uma identidade. Nos demais casos,
ou se a variável não estiver inicializada, nós retornamos um erro.

\iniciocodigo
@<Declaração: Comando@>=
else if(((struct generic_token *) begin_token_list) -> type == TYPE_PICKUP){
  struct generic_token *end_expression = *end_token_list;
  struct generic_token *next_token =
                           ((struct generic_token *) begin_token_list) -> next;
  if(begin_token_list == end_token_list ||
     (next_token -> type != TYPE_NULLPEN &&
      next_token -> type != TYPE_SYMBOLIC &&
      next_token -> type != TYPE_PENCIRCLE)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Expected 'nullpen' or pen "
                    "variable after 'pickup'. Not an arbitrary "
                    "expression.\n",
            mf -> file, next_token -> line);
#endif
    return false;
  }
  if(mf -> internal_pen_variables[0].gl_vbo != 0)
    glDeleteBuffers(1, &(mf -> internal_pen_variables[0].gl_vbo));
  if(next_token -> type == TYPE_NULLPEN){
    mf -> internal_pen_variables[0].flags = FLAG_NULL;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else if(next_token -> type == TYPE_PENCIRCLE){
    mf -> internal_pen_variables[0].flags = FLAG_CONVEX | FLAG_CIRCULAR;
    mf -> internal_pen_variables[0].referenced = NULL;
    mf -> internal_pen_variables[0].gl_vbo = 0;
  }
  else{
    struct pen_variable *var = ((struct symbolic_token *) next_token) -> var;
    if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-initialized variable after "
                      "after 'pickup' command.\n",
              mf -> file, next_token -> line);
#endif
      return false;
    }
    if(var -> type != TYPE_T_PEN){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable '%s' is not a "
                      "pen variable.\n",
              mf -> file, next_token -> line,
              ((struct symbolic_token *) next_token) -> value);
#endif
      return false;
    }
    mf -> internal_pen_variables[0].referenced = var;
  }
  INITIALIZE_IDENTITY_MATRIX(mf -> internal_pen_variables[0].gl_matrix);
  @<Comando 'pickup': Continuação@>
  return true;
}
@
\fimcodigo

Depois de saber a forma base da caneta, é hora de ler as
transformações lineares específicas que vamos aplicar
à \monoespaco{currentpen}. Enquanto não estivermos no fim da expressão
a ser interpretada, lemos o próximo token. Ele indicará qual
transformação linear devemos aplicar à matriz de transformação
de \monoespaco{nullpen}. Baseado nele, lemos uma expressão numérica,
de par ou de transformação que descreve a transformação em
questão. Fazemos isso até chegar ao fim da expressão, quando não
houver mais transformações a serem feitas.

\iniciocodigo
@<Comando 'pickup': Continuação@>=
while(next_token != end_expression){
  struct generic_token *begin_subexpr, *end_subexpr;
  DECLARE_NESTING_CONTROL();
  next_token = next_token -> next;
  if(next_token == NULL || next_token == end_expression){
    printf("END: %p\n", end_expression);
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                      "command format.\n",
              mf -> file, next_token -> line);
#endif
    return false;
  }
  begin_subexpr = next_token -> next;
  end_subexpr = begin_subexpr;
  while(end_subexpr != end_expression){
    struct generic_token *next = end_subexpr -> next;
    COUNT_NESTING(end_subexpr);
    if(IS_NOT_NESTED() &&
       (next -> type == TYPE_ROTATED || next -> type == TYPE_SCALED ||
        next -> type == TYPE_SHIFTED || next -> type == TYPE_SLANTED ||
        next -> type == TYPE_XSCALED || next -> type == TYPE_YSCALED ||
        next -> type == TYPE_ZSCALED || next -> type == TYPE_TRANSFORMED))
      break;
    end_subexpr = next;
  }
  switch(next_token -> type){
    struct numeric_variable a;
    struct pair_variable p;
    struct transform_variable t;
  case TYPE_ROTATED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_ROTATE(mf -> internal_pen_variables[0].gl_matrix, a.value);
    break;
  case TYPE_SCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_SHIFTED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SHIFT(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    break;
  case TYPE_SLANTED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SLANT(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Slant non-circular curved pens always require retriangulation:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT) &&
         !(v -> flags & FLAG_CIRCULAR)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_XSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_X(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_YSCALED:
    if(!eval_numeric_expression(mf, cx, begin_subexpr, end_subexpr, &a))
      return false;
    TRANSFORM_SCALE_Y(mf -> internal_pen_variables[0].gl_matrix, a.value);
    // Curved pens need retriangulation if the size increase:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_ZSCALED:
    if(!eval_pair_expression(mf, cx, begin_subexpr, end_subexpr, &p))
      return false;
    TRANSFORM_SCALE_Z(mf -> internal_pen_variables[0].gl_matrix, p.x, p.y);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  case TYPE_TRANSFORMED:
    if(!eval_transform_expression(mf, cx, begin_subexpr, end_subexpr, &t))
      return false;
    MATRIX_MULTIPLICATION(mf -> internal_pen_variables[0].gl_matrix, t.value);
    // Curved pens need retriangulation in this case:
    if(mf -> internal_pen_variables[0].referenced){
      struct pen_variable *v = mf -> internal_pen_variables[0].referenced;
      if(v -> gl_vbo != 0 && a.value > 1.0 && !(v -> flags & FLAG_STRAIGHT)){
        glDeleteBuffers(1, &(v -> gl_vbo));
        v -> gl_vbo = 0;
      }
    }
    break;
  default:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable 'pickup' "
                    "command format.\n",
            mf -> file, next_token -> line);
#endif
    return false;  
  }
  next_token = end_subexpr;
}
@
\fimcodigo

Depois de termos obtido tanto o formato da caneta nova, se ela é um
ponteiro e qual a sua transformação linear, enfim iremos à etapa de
triangular a caneta. Para isso, se a caneta atual ter sido ajustada
para um ponteiro, sua transformação é a multiplicação da matriz
armazenada na \monoespaco{currentpen} pela matriz da caneta para a
qual ela aponta. Ou, se não for um ponteiro, é apenas a matriz
armazenada em \monoespaco{currentpen}. Após obter a matriz final de
transformação, a passamos para a função que fará a triangulação:

\iniciocodigo
@<Comando 'pickup': Continuação@>+=
{
  float final_transform_matrix[9];
  if(mf -> internal_pen_variables[0].referenced == NULL){
    memcpy(final_transform_matrix, mf -> internal_pen_variables[0].gl_matrix,
           9 * sizeof(float));
    if(!triangulate_pen(mf, &(mf -> internal_pen_variables[0]),
                        final_transform_matrix))
      return false;
  }
  else{
    memcpy(final_transform_matrix,
           mf -> internal_pen_variables[0].referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(final_transform_matrix,
                          mf -> internal_pen_variables[0].gl_matrix);
    if(!triangulate_pen(mf, mf -> internal_pen_variables[0].referenced,
                        final_transform_matrix))
      return false;
  }
}
@
\fimcodigo

\subsecao{10.4. Os Operadores \monoespaco{bot}, \monoespaco{top}, \monoespaco{lft},
\monoespaco{rt}}

Embora tenhamos definido quase todos os operadores de pares na
Subseção 8.2, existem quatro operadores primários que deixamos para
definir aqui. A gramática deles é:

\alinhaverbatim
<Primário de Par> -> bot <Primário de Par> | top <Primário de Par> |
                     lft <Primário de Par> | rt <Primário de Par>
\alinhanormal

Isso requer adicionar 4 novos tokens para tais operadores:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_BOT,  // O token simbólico 'bot'
TYPE_TOP,  // O token simbólico 'top'
TYPE_LFT,  // O token simbólico 'lft'
TYPE_RT,   // O token simbólico 'rt'
@
\fimcodigo

E também adicionar o nome dos tokens como palavras reservadas:

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"bot", "top", "lft", "rt",
@
\fimcodigo

O que estes operadores fazem é deslocar um par uma distância que
depende do tamanho da caneta atual que estamos usando.  Se temos um
ponto $(x_0, y_0)$, então \monoespaco{bot (x0, y0)} representa $(x_0,
y_0)$ deslocado para baixo, de modo que fique embaixo da caneta quando
ela é centralizada no ponto $(x_0, y_0)$. Assumindo que uma caneta
padrão é centralizada na origem, o menor ponto $y$ dela será um valor
negativo. Então isso é obtido somando o ponto inicial com o ponto mais
abaixo da caneta:

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin_expression -> type == TYPE_BOT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> y += mf -> pen_bot;
  return true;
}
@
\fimcodigo

O operador \monoespaco{top} desloca o par para cima de modo
que \monoespaco{top (x0, y0)} passa a estar posicionado acima da
caneta se esta for posicionada em $(x_0, y_o)$.

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin_expression -> type == TYPE_TOP){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> y += mf -> pen_top;
  return true;
}
@
\fimcodigo

O operador \monoespaco{lft} desloca o ponto à esquerda uma quantidade
igual à menor coordenada $x$ da caneta. Assim, \monoespaco{lft (x0,
y0)} passa a estar posicionado à esquerda da caneta se esta for
posicionada em $(x_0, y_o)$. Como em uma caneta centrada na origem
temos que seu ponto mais à esquerda é negativo, basta somarmos o valor
$x_0$ com o menor valor no eixo $x$ do perímetro da caneta:

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin_expression -> type == TYPE_LFT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> x += mf -> pen_lft;
  return true;
}
@
\fimcodigo

Por fim, o operador \monoespaco{rt} desloca o par $(x_0, y_0)$ para a
direita uma quantidade equivalente à maior coordenada $x$ da caneta
atual, de modo que se as coordenadas do ponto ficarão à direita de uma
caneta centralizada em $(x_0, y_0)$:

\iniciocodigo
@<Primário de Par: Outras Regras a Definir Depois@>+=
else if(begin_expression -> type == TYPE_RT){
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next,
                        end_expression, result))
    return false;
  result -> x += mf -> pen_rt;
  return true;
}
@
\fimcodigo

\secao{11. O Comando \monoespaco{draw} e \monoespaco{erase}}

Finalmente podemos começar a especificar dois dos mais importantes
comandos da linguagem. O comando que usa uma caneta para caminhos em
uma imagem ou para apagar eles. A sintaxe do comando de desenho e de
apagar é:

\alinhaverbatim
<Comando> -> <Comando 'draw'> | <Comando 'erase'> | ...
<Comando 'draw'> -> draw <Expressão de Caminho>
<Comando 'erase'> -> erase <Expressão de Caminho>
\alinhanormal

Os quais requerem dois tokens e palavras reservada novas:

\iniciocodigo
@<METAFONT: Definição de Token Simbólico@>+=
TYPE_DRAW,   // O token simbólico 'draw'
TYPE_ERASE,  // O token simbólico 'erase'
@
\fimcodigo

\iniciocodigo
@<Lista de Palavras Reservadas@>+=
"draw", "erase",
@
\fimcodigo

\subsecao{11.1. Preparando o Framebuffer}

Para desenhar ou apagar com uma caneta na
imagem \monoespaco{currentpicture}, nós precisamos de um framebuffer
associado com esta imagem. Isso não é muito diferente do que quando
definimos as operações sobre variáveis do tipo imagem. Em boa parte
das operações, nós criamos um framebuffer novo, salvamos o framebuffer
anterior, mudamos para o novo, renderizamos, apagamos o framebuffer
novo e voltamos ao antigo. Para a \monoespaco{currentpicture}, ao
invés disso, vamos manter uma variável armazenando seu framebuffer:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static GLuint currentpicture_fb;
@
\fimcodigo

A qual é inicializada como zero:

\iniciocodigo
@<Inicialização de Weaver Metafont@>+=
currentpicture_fb = 0;
@
\fimcodigo

Antes de renderizar para \monoespaco{currentpicture}, devemos executar
o código abaixo que checa se o framebuffer está inicializado, e o
inicializa se não estiver:

\iniciocodigo
@<Prepara 'currentpicture' para Desenho@>=
{
  if(currentpicture_fb == 0){
    int width, height;
    GLuint texture;
    width = mf ->
             internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].width;
    height = mf ->
            internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].height;
    texture = mf ->
           internal_picture_variables[INTERNAL_PICTURE_CURRENTPICTURE].texture;
    glGenFramebuffers(1, &currentpicture_fb);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
                 GL_UNSIGNED_BYTE, NULL);
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                           texture, 0);
    if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: OpenGL cannot create framebuffer!\n");
#endif
      return false;
    }
  }
  else
    glBindFramebuffer(GL_FRAMEBUFFER, currentpicture_fb);
}
@
\fimcodigo

Se por algum motivo nós mudarmos a nossa \monoespaco{currentpicture}
para outra imagem, devemos remover o framebuffer anterior:

\iniciocodigo
@<Gera nova 'currentpicture'@>=
{
  if(currentpicture_fb != 0){
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glBindTexture(GL_TEXTURE_2D, 0);
    glDeleteFramebuffers(1, &currentpicture_fb);
  }
  currentpicture_fb = 0;
}
@
\fimcodigo

Antes de renderizar para nossa \monoespaco{currentpicture}, nós não
armazenamos o framebuffer anterior em uma variável. E depois de
renderizar, nós não restauramos o framebuffer anterior. Ao contrário
do que fazíamos em outras operações de imagens. Isso ocorre porque
enquanto estivermos interpretando nosso código, renderizar
na \monoespaco{currentpicture} é uma operação muito mais comum que
renderizar em outros lugares. Por causa disso, vamos sempre
preferencialmente manter o nosso framebuffer atual para o
da \monoespaco{currentpicture}.

Antes de começar a avaliar código, é quando nós salvamos o framebuffer
anterior. Para isso usamos a variável abaixo:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static GLint previous_fb;
@
\fimcodigo

E aqui é onde salvamos o framebuffer anterior antes de começar a
executar qualquer código em \monoespaco{eval\_list\_of\_expressions}:

\iniciocodigo
@<Antes de Avaliar Código@>=
glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &previous_fb);
@
\fimcodigo

E aqui nós restauramos o framebuffer de antes de começarmos a
interpretar código:

\iniciocodigo
@<Depois de Avaliar Código@>=
glBindFramebuffer(GL_FRAMEBUFFER, previous_fb);
@
\fimcodigo

\subsecao{11.2. Shaders de Desenho}

Desenhar e apagar com uma caneta vai exigir dois novos shaders (um
para cada operação) que precisamos definir. Os shaders que definimos
anteriormente era para fazermos operações envolvendo variáveis de
imagem, e eles exigiam que enviássemos uma textura. Já o shader para
desenhar e apagar não requer uma textura, ao invés disso ele requer a
cor que devemos usar para desenhar. Por hora vamos deixar que a cor
sempre seja preto opaco, mas isso pode mudar no futuro.

O código de nosso shader de vértice será então:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char pen_vertex_shader[] =
  "#version 100\n"
  "attribute vec4 vertex_data;\n"
  "uniform mat3 model_view_matrix;\n"
  "void main(){\n"
  "  highp vec3 coord;\n"
  "  coord = vec3(vertex_data.xy, 1.0) * model_view_matrix;\n"
  "  gl_Position = vec4(coord.x, coord.y, 0.0, 1.0);\n"
  "}\n";
@
\fimcodigo

Ele é idêntico ao que já definimos, mas não precisará receber e
extrair coordenadas de textura. Já os dois novos shaders de fragmento:

\iniciocodigo
@<Variáveis Locais (metafont.c)@>+=
static const char pen_erase_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, \n"
  "                      color.a);\n"
  "}\n";
static const char pen_fragment_shader[] =
  "#version 100\n"
  "precision mediump float;\n"
  "uniform vec4 color;\n"
  "void main(){\n"
  "  gl_FragColor = color;"
  "}\n";
static GLuint pen_program, pen_erase_program; // O programa após compilar
static GLint pen_uniform_matrix, pen_erase_uniform_matrix; // Matriz
static GLint pen_uniform_color, pen_erase_uniform_color; // Cor
@
\fimcodigo

Na inicialização nós compilamos estes dois shaders e obtemos a
localização de suas variáveis uniformes:

\iniciocodigo
@<Inicialização de Weaver Metafont@>+=
{
  pen_program = compile_shader_program(pen_vertex_shader, pen_fragment_shader);
  pen_uniform_matrix = glGetUniformLocation(pen_program, "model_view_matrix");
  pen_uniform_color = glGetUniformLocation(pen_program, "color");
  pen_erase_program = compile_shader_program(pen_vertex_shader,
                                            pen_erase_fragment_shader);
  pen_erase_uniform_matrix = glGetUniformLocation(pen_erase_program,
                                                  "model_view_matrix");
  pen_erase_uniform_color = glGetUniformLocation(pen_erase_program, "color");
}
@
\fimcodigo

E na finalização nós destruimos estes programas:

\iniciocodigo
@<Finalização de Weaver Metafont@>+=
glDeleteProgram(pen_program);
glDeleteProgram(pen_erase_program);
@
\fimcodigo

\subsecao{11.3. Desenhando Caminhos}

Terminada a preparação da triangulação, do framebuffer e do shader
usado, podemos escrever agora o código de desenho em si.

\iniciocodigo
@<Declaração: Comando@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_DRAW || ((struct generic_token *) begin_token_list) -> type ==
        TYPE_ERASE){
  int i, j;
  struct path_variable path;
  float transform_matrix[9];
  // Parte 1: Inicialização
  bool erasing = (((struct generic_token *) begin_token_list) -> type ==
    TYPE_ERASE);
  struct pen_variable *currentpen = &(mf -> internal_pen_variables[0]);
  struct picture_variable *currentpicture =
                                        &(mf -> internal_picture_variables[0]);
  // Parte 2: Avaliar a expressão de caminho
  if(!eval_path_expression(mf, cx,
                          ((struct generic_token *) begin_token_list) -> next,
                          (struct generic_token *) *end_token_list,
                           &path))
    return false;
  // Parte 3: Preparar a caneta, a imagem de destino e parâmetros OpenGL
  if(currentpen -> referenced != NULL){
    memcpy(transform_matrix, currentpen -> referenced -> gl_matrix,
           9 * sizeof(float));
    MATRIX_MULTIPLICATION(transform_matrix, currentpen -> gl_matrix);
    currentpen = currentpen -> referenced;
  }
  else
    memcpy(transform_matrix, currentpen -> gl_matrix, 9 * sizeof(float));
  @<Prepara 'currentpicture' para Desenho@>
  glEnable(GL_BLEND);
  if(erasing){
    glBlendFunc(GL_ONE, GL_ONE);
    glBlendEquationSeparate(GL_MAX, GL_FUNC_REVERSE_SUBTRACT);
  }
  else{
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glBlendEquation(GL_FUNC_ADD);
  }
  // Parte 4: Loop de desenho
  for(i = 0; i < path.length - 1; i ++){
    int distance = 0;
    float dx, dy, dt;
    dx = path.points[i].u_x - path.points[i].x;
    dy = path.points[i].u_y - path.points[i].y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = path.points[i].v_x - path.points[i].u_x;
    dy = path.points[i].v_y - path.points[i].u_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dx = path.points[(i+1) % (path.length)].x - path.points[i].v_x;
    dy = path.points[(i+1) % (path.length)].y - path.points[i].v_y;
    distance += (int) round(sqrt(dx * dx + dy * dy));
    dt = 1 / ((float) distance);
    for(j = 0; j <= distance; j ++){
      float t = dt * j;
      float x = (1-t)*(1-t)*(1-t) * path.points[i].x +
                3*(1-t)*(1-t)*t * path.points[i].u_x +
                3*(1-t)*t*t * path.points[i].v_x +
                t*t*t * path.points[(i + 1) % (path.length)].x;
      float y = (1-t)*(1-t)*(1-t) * path.points[i].y +
                3*(1-t)*(1-t)*t * path.points[i].u_y +
                3*(1-t)*t*t * path.points[i].v_y +
                t*t*t * path.points[(i + 1) % (path.length)].y;
      drawpoint(mf, currentpen, currentpicture, x, y, transform_matrix,
                erasing);
    }
  }
  // Quando é um único ponto e o loop acima não foi executado:
  if(path.length == 1)
    drawpoint(mf, currentpen, currentpicture, path.points[0].x,
              path.points[0].y, transform_matrix, erasing);
  // Parte 5: Finalização
  glDisable(GL_BLEND);
  if(temporary_free != NULL)
    path_recursive_free(temporary_free, &path, false);
  return true;
}
@
\fimcodigo

O código acima na parte 1 obtém as variáveis relevantes ao comando
(\monoespaco{currentpen}, \monoespaco{currentpicture}) e na parte 2
avalia a expressão de caminho após o token \monoespaco{draw}.

Em seguida, na parte 3, obtemos qual caneta que devemos usar, a
triangulamos e inicializamos os parâmetros OpenGL específicos deste
tipo de desenho, que definimos nas Subseções anteriores. Um dos dois
únicos lugares em que tratamos de forma diferente o \monoespaco{draw}
e \monoespaco{erase} aparece nesta parte. Dependendo do comando, nós
mudamos a operação de como misturamos os pixels novos desenhados com
os pixels já existentes na imagem de destino. As escolhas feitas são
análogas às que fizemos quando definimos a soma e subtração de
imagens.

Na parte 4 temos o loop no qual iremos desenhar ponto-a-ponto o nosso
caminho usando a função que ainda será
definida \monoespaco{drawpoint}. Para obter casa um dos pontos, usamos
a fórmula das curvas de Beziér cúbicas $z(t) = (1-t)^3z_1 +
3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4$. E para saber quantos pontos
intermediários devem ser desenhados entre dois pontos de extremidade,
nós somamos a distância em pixels de todos os pontos envolvidos em
cada curva: os dois pontos de extremidade e os de controle. Depois de
desenhar tudo, desalocamos a variável temporária que armazenou o
caminho desenhado na parte 5.

Resta apenas definir a função \monoespaco{drawpoint}. O seu cabeçalho
é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing);
@
\fimcodigo

A caneta possui todas as coordenadas de seus vértices triangulados
usando o número de pixels como coordenada. A imagem tem sua altura e
largura conhecida. Ao renderizar usando OpenGL, devemos usar as
coordenadas padrão, onde o centro da imagem é a origem e a imagem tem
sempre 2 de altura e de largura. Isso significa que devemos fazer uma
última transformação linear para converter a caneta na renderização.

Seja $h$ a altura da imagem em pixels e $w$ sua largura. Isso
significa que 1 pixel horizontal é $2/w$ e um vertical é $2/h$. Então,
basta multiplicarmos a matriz de transformação pela matriz diagonal
com $2/w$ como primeiro valor, $2/h$ como segundo valor na diagonal e
com o resto da diagonal sendo 1.

O próximo passo seria depois de converter de pixels para coordenadas
OpenGL, ajustar a matriz de transformação para deslocar cada vértice
da caneta $x$ e $y$ pixels, o que daria $2x/w$ e $2y/h$ nas
coordenadas OpenGL. E aí fazemos outro deslocamento para corrigirmos o
fato do OpenGL tratar o centro da imagem como origem, enquanto nós
tratamos o canto inferior esquerdo da imagem como origem.

Contudo, existe uma última complicação: na verdade nem sempre tratamos
o canto inferior esquerdo da imagem como origem. Existe um tipo de
valor interno $d$ que pode mudar verticalmente a posição do eixo $x$
que usamos para medir nossas coordenadas. Um valor interno de
profundidade. Ele é armazenado aqui:

\iniciocodigo
@<Atributos (struct metafont)@>+=
int current_depth;
@
\fimcodigo

E seu valor inicial é zero:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> current_depth = 0;
@
\fimcodigo

Este valor $d$ mostra o quão deslocado para cima está o eixo $x$ em
quando medimos em pixels (e ele vira $2d/h$ ao ser convertido nas
coordenadas OpenGL). Se ele é zero, então o eixo $x$ será o limite
inferior do espaço da imagem e a origem o canto inferior esquerdo da
imagem. Se for um valor positivo, ele estará deslocado $d$ pixels para
cima. 

Para fazer todos este ajustes, devemos então multiplicar a matriz de
transformação da caneta pela seguinte nova matriz:

$$
\left[{{a \atop c}\atop
      {0\atop e}}{{b \atop d}\atop {0 \atop
      f}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
\left[{{2/w \atop 0}\atop
      {0\atop 2x/w-1}}{{0 \atop 2/h}\atop {0 \atop
      2d/h+2y/w-1}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]=
\left[{{2a/w \atop 2c/w}\atop
      {0\atop (2e+2x)/w-1}}{{2b/h \atop 2d/h}\atop {0 \atop
      (2f+2d+2y)/h-1}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]
$$

E isso é feito internamente pela função \monoespaco{drawpoint}
imediatamente antes de desenhar. Depois de ajustar a matriz, só temos
que renderizar o resultado, e aqui também devemos usar programas de
shaders diferentes se estamos desenhando ou apagando:

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
void drawpoint(struct metafont *mf, struct pen_variable *pen,
               struct picture_variable *pic, float x, float y, float *matrix,
               bool erasing){
  float gl_matrix[9];
  gl_matrix[0] = (2 * matrix[0]) /  pic -> width;  // 2a/w
  gl_matrix[1] = (2 * matrix[1]) /  pic -> height; // 2b/h
  gl_matrix[2] = 0.0;
  gl_matrix[3] = (2 * matrix[3]) /  pic -> width;  // 2c/w
  gl_matrix[4] = (2 * matrix[4]) /  pic -> height; // 2d/h
  gl_matrix[5] = 0.0;
  gl_matrix[6] = 2 * (matrix[6] + x) /  pic -> width - 1.0;
  gl_matrix[7] = 2 * (matrix[7] + mf -> current_depth + y) / pic -> width -
                 1.0;
  gl_matrix[8] = 1.0;
  glViewport(0, 0, pic -> width, pic -> height); 
  // Se a caneta for quadrada, usamos a triangulação padrão de quadrado.
  // Se não for, usamos a triangulação da própria caneta.
  if(pen -> flags & FLAG_SQUARE)
    glBindBuffer(GL_ARRAY_BUFFER, pensquare_vbo);
  else 
    glBindBuffer(GL_ARRAY_BUFFER, pen -> gl_vbo);
  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, (void *) 0);
  if(erasing){
    glUseProgram(pen_erase_program);
    glUniformMatrix3fv(pen_erase_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_erase_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  else{
    glUseProgram(pen_program);
    glUniformMatrix3fv(pen_uniform_matrix, 1, true, gl_matrix);
    glUniform4f(pen_uniform_color, 0.0, 0.0, 0.0, 1.0);
  }
  glEnableVertexAttribArray(0);
  glDrawArrays(GL_TRIANGLE_FAN, 0, pen -> indices);
}
@
\fimcodigo

\secao{12. Declaração Composta: Declaração de Caractere}

Vamos agora à parte que é o prinicpal objetivo da linguagem: definir
novos caracteres para fontes tipográficas, ou então definir uma imagem
que será usada como ilustração, ou animação.

A sintaxe para isso é:

\alinhaverbatim
<Composta> -> <Declaração de Caractere>
<Declaração de Caractere> -> beginchar ( <Token de String> ,
                                         <Expressão Numérica> ,
                                         <Expressão Numérica> ,
                                         <Expressão Numérica> )
                             <Corpo do 'beginchar'>
                             endchar
<Corpo do 'beginchar'> -> <Declaração, exceto 'beginchar'>
<Declaração, exceto 'beginchar'> -> <Simples> | <Composta, exceto 'beginchar'>
<Composta, exceto 'beginchar'> -> <Bloco Composto> | <Bloco Condicional>
\alinhanormal

O token \monoespaco{beginchar} começa a definição de um novo caractere
e o token \monoespaco{endchar} termina. O token de string é o nome do
caractere definido. Para fontes tipográficas, deve ser a representação
em UTF-8 do caractere. Para animações e ilustrações, pode ser qualquer
nome, o token terminará sendo ignorado. Os valores numéricos após o
token de string representam respectivamente a largura, altura e
profundidade do caractere (profundidade sendo a altura dele abaixo da
linha de base, para caracteres como ``p'' com partes dele ficando
abaixo da linha).

A linguagem WEAVEFONT tem dois modos de operação: ela pode estar
carregando ou executando. O modo determina o comportamento dela ao
encontrar o token \monoespaco{beginchar}. No modo de carregamento, ela
copia o código que representa o caractere para uma posição adequada,
para que se necessário, o código seja executado para renderizar o
caractere. O código dentro do corpo de \monoespaco{beginchar} nem
chega a ser executado e interpretado. No modo de execução, aí sim este
código será executado para que o caracteres seja renderizado.

Armazenamos o modo de operação na seguinte variável:

\iniciocodigo
@<Atributos (struct metafont)@>+=
bool loading;
@
\fimcodigo

Durante a inicialização, nós começamos no modo de carregamento:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
mf -> loading = true;
@
\fimcodigo

Nós saímos do modo de carregamento e entramos no modo de execução
assim que lemos um \monoespaco{end} ou \monoespaco{dump}:

\iniciocodigo
@<Fim do Código: 'end' ou 'dump'@>=
mf -> loading = false;
@
\fimcodigo

\subsecao{12.1 Unicode e UTF-8}

Mas onde devemos armazenar o código de um caractere quando estamos no
modo de carregamento? Vamos definir a seguinte estrutura que armazena
o código de um caractere. Ela armazena o código, as dimensões do
caractere, a textura OpenGL onde ele foi renderizado e um atributo
booleano que diz se podemos usar essa textura ou se devemos renderizar
novamente o caractere:

\iniciocodigo
@<Declarações Gerais (metafont.h)@>=
struct _glyph;
@
\fimcodigo

\iniciocodigo
@<Estrutura de Dados Locais (metafont.c)@>+=
struct _glyph{
  struct generic_token *begin, *end;
  int width, height, depth;
  GLuint texture;
  bool need_rendering;
};
#define INITIALIZE_GLYPH(a) {a.begin = NULL; \
                            a.end = NULL; \
                            a.width = 0; \
                            a.height = 0;\
                            a.depth = 0; \
                            a.texture = 0; \
                            a.need_rendering = true; \
                            }
@
\fimcodigo

A lista de todos os glifos possíveis ficará aqui:

\iniciocodigo
@<Atributos (struct metafont)@>+=
struct _glyph *glyphs[332];
@
\fimcodigo

O número 332 comporta a quantidade de diferentes blocos Unicode
existentes (327) mais algumas regiões adicionais que não são usadas
pelo Unicode no momento, mas podemvir a ser no futuro. Cada bloco
potencialmente armazena de 1 a milhares de diferentes glifos
relacionados entre si, tipicamente pertencentes a um mesmo sistema de
escrita. Inicialmente, todos estes blocos serão inicializados como
vazios. Mas à medida que encontrarmos caracteres pertencentes à eles,
teremos que alocar cada um deles:

\iniciocodigo
@<Inicialização (struct metafont)@>+=
memset(mf -> glyphs, 0, sizeof(struct _glyph *) * 332);
@
\fimcodigo

A função que irá alocar e retornar a estrutura de um novo glifo, ou de
um glifo existente é:

\iniciocodigo
@<Declaração de Função Local (metafont.c)@>+=
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *utf8,
                                bool create_if_not_exist);
@
\fimcodigo

A função começa convertendo a representação UTF-8 para UTF-32,
tornando-a idêntica ao seu número Unicode. Em seguida, consultamos uma
tabela como maior valor existente em cada um dos blocos Unicode para
saber a qual bloco o caractere pertence, qual a sua posição dentro do
bloco e também o tamanho do bloco. Se o bloco não existir e o último
parâmetro da função for verdadeiro, alocamos o bloco. No fim,
retornamos o glifo representando o caractere (que pode ter sido
inicializado ou não). Ou NULL se não forpossível fazer isso (o bloco
não existe e foi pedido para não alocá-lo, o símbolo UTF-8 é inválido,
o código Unicode não existe ou não é suportado ou não há memória
suficiente para alocar o bloco).

\iniciocodigo
@<Funções Auxiliares Locais (metafont.c)@>+=
static struct _glyph *get_glyph(struct metafont *mf, unsigned char *c,
                                bool create_if_not_exist){
  const uint32_t greatest_point[332] = {
  // Plano Multilingual Básico (164 blocos)
0x7f, 0xff, 0x17f, 0x24f, 0x2af, 0x2ff, 0x36f, 0x3ff, 0x4ff, 0x52f,
0x58f, 0x5ff, 0x6ff, 0x74f, 0x7ff, 0x7bf, 0x7ff, 0x83f, 0x85f, 0x86f,
0x89f, 0x8ff, 0x97f, 0x9ff, 0xa7f, 0xaff, 0xb7f, 0xbff, 0xc7f, 0xcff,
0xd7f, 0xdff, 0xe7f, 0xeff, 0xfff, 0x109f, 0x10ff, 0x11ff, 0x137f, 0x139f,
0x13ff, 0x167f, 0x169f, 0x16ff, 0x171f, 0x173f, 0x175f, 0x177f, 0x17ff, 0x18af,
0x18ff, 0x194f, 0x197f, 0x19df, 0x19ff, 0x1a1f, 0x1aaf, 0x1aff, 0x1b7f, 0x1bbf,
0x1bff, 0x1c4f, 0x1c7f, 0x1c8f, 0x1cbf, 0x1ccf, 0x1cff, 0x1d7f, 0x1dbf, 0x1dff,
0x1eff, 0x1fff, 0x206f, 0x209f, 0x20cf, 0x20ff, 0x214f, 0x218f, 0x21ff, 0x22ff,
0x23ff, 0x243f, 0x245f, 0x24ff, 0x257f, 0x259f, 0x25ff, 0x26ff, 0x27bf, 0x27ef,
0x27ff, 0x28ff, 0x297f, 0x29ff, 0x2aff, 0x2bff, 0x2c5f, 0x2c7f, 0x2cff, 0x2d2f,
0x2d7f, 0x2ddf, 0x2dff, 0x2eff, 0x2fdf, 0x2fff, 0x303f, 0x309f, 0x30ff, 0x312f,
0x318f, 0x319f, 0x31bf, 0x31ef, 0x31ff, 0x32ff, 0x33ff, 0x4dbf, 0x4dff, 0x9fff,
0xa48f, 0xa4cf, 0xa4ff, 0xa63f, 0xa69f, 0xa69f, 0xa6ff, 0xa71f, 0xa7ff, 0xa82f,
0xa83f, 0xa87f, 0xa8df, 0xa8ff, 0xa92f, 0xa95f, 0xa97f, 0xa9df, 0xa9ff, 0xaa5f,
0xaa7f, 0xaadf, 0xaaff, 0xab2f, 0xab6f, 0xabbf, 0xabff, 0xd7af, 0xd7ff, 0xdb7f,
0xdbff, 0xdfff, 0xf8ff, 0xfaff, 0xfb4f, 0xfdff, 0xfe0f, 0xfe1f, 0xfe2f, 0xfe4f,
0xfe6f, 0xfeff, 0xffef, 0xffff,
  // Plano Multilingual Suplementar (151 blocos)
0x1007f, 0x100ff, 0x1013f, 0x1018f, 0x101cf, 0x101ff, 0x1029f, 0x102df,
0x102ff, 0x1032f, 0x1034f, 0x1037f, 0x1039f, 0x103df, 0x1044f, 0x1047f,
0x104af, 0x104ff, 0x1052f, 0x1056f, 0x105bf, 0x1077f, 0x107bf, 0x1083f,
0x1085f, 0x1087f, 0x108af, 0x108ff, 0x1091f, 0x1093f, 0x1099f, 0x109ff,
0x10a5f, 0x10a7f, 0x10a9f, 0x10aff, 0x10b3f, 0x10b5f, 0x10b7f, 0x10baf,
0x10c4f, 0x10cff, 0x10d3f, 0x10e7f, 0x10ebf, 0x10eff, 0x10f2f, 0x10f6f,
0x10faf, 0x10fdf, 0x10fff, 0x1107f, 0x110cf, 0x110ff, 0x1114f, 0x1117f,
0x111df, 0x111ff, 0x1124f, 0x112af, 0x112ff, 0x1137f, 0x1147f, 0x114df,
0x115ff, 0x1166f, 0x1167f, 0x116cf, 0x1174f, 0x1184f, 0x118ff, 0x1195f,
0x119ff, 0x11a4f, 0x11aaf, 0x11abf, 0x11aff, 0x11b5f, 0x11c6f, 0x11cbf,
0x11d5f, 0x11daf, 0x11eff, 0x11f5f, 0x11fbf, 0x11fff, 0x123ff, 0x1247f,
0x1254f, 0x12fff, 0x1342f, 0x1345f, 0x1467f, 0x16a3f, 0x16a6f, 0x16acf,
0x16aff, 0x16b8f, 0x16e9f, 0x16f9f, 0x16fff, 0x187ff, 0x18aff, 0x18cff,
0x18d7f, 0x1afff, 0x1b0ff, 0x1b12f, 0x1b16f, 0x1b2ff, 0x1bc9f, 0x1bcaf,
0x1cfcf, 0x1d0ff, 0x1d1ff, 0x1d24f, 0x1d2df, 0x1d2ff, 0x1d35f, 0x1d37f,
0x1d7ff, 0x1daaf, 0x1dfff, 0x1e02f, 0x1e08f, 0x1e14f, 0x1e2bf, 0x1e2ff,
0x1e4ff, 0x1e7ff, 0x1e8df, 0x1e95f, 0x1ecbf, 0x1ed4f, 0x1eeff, 0x1f02f,
0x1f09f, 0x1f0ff, 0x1f1ff, 0x1f2ff, 0x1f5ff, 0x1f64f, 0x1f67f, 0x1f6ff,
0x1f77f, 0x1f7ff, 0x1f8ff, 0x1f9ff, 0x1fa6f, 0x1faff, 0x1fbff,
  // Não Usado
  0x1ffff,
  // Plano Ideográfico Suplementar
  0x2a6df, 0x2b73f, 0x2b81f, 0x2ceaf, 0x2ebef, 0x2fa1f,
  // Não Usado
  0x2ffff,
  // Plano Ideográfico Terciário
  0x3134f, 0x323af,
  // Não Usado
  0xdffff,
  // Plano de Propósito Geral (a região do meio é não usada)
  0xe007f, 0xe00ff, 0xe01ef,
  // Não Usado
  0xeffff,
  // Área de Uso Privado Suplementar A
  0xfffff,
  // Área de Uso Privado Suplementar B
  0x10ffff
  };
  uint32_t code_point;
  int block, block_size, index;
  // UTF-8 -> UTF-32
  if(c[0] < 128)
    code_point = c[0];
  else if(c[0] >= 192 && c[0] <= 223 && c[1] >= 128 && c[1] <= 159){
    code_point = c[1] - 128;
    code_point += (c[0] - 192) * 64;
  }
  else if(c[0] >= 224 && c[0] <= 239 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159){
    code_point = c[2] - 128;
    code_point += (c[1] - 128) * 64;
    code_point += (c[0] - 224) * 4096;
  }
  else if(c[0] >= 240 && c[0] <= 247 && c[1] >= 128 && c[1] <= 159 &&
          c[2] >= 128 && c[2] <= 159 && c[3] >= 128 && c[3] <= 159){
    code_point = c[3] - 128;
    code_point += (c[2] - 128) * 64;
    code_point += (c[1] - 128) * 4096;
    code_point += (c[0] - 240) * 262144;
  }
  else return NULL; // String UTF-8 inválida
  if(code_point > greatest_point[331])
    return NULL; // Código Unicode não-existente ou não-suportado
  for(block = 0; code_point > greatest_point[block]; block ++);
  if(block == 0){
    block_size = greatest_point[block] + 1;
    index = code_point;
  }
  else{
    block_size = greatest_point[block] - greatest_point[block - 1];
    index = code_point - greatest_point[block - 1] - 1;
  }
  if(mf -> glyphs[block] == NULL){
    int i;
    if(!create_if_not_exist)
      return NULL;
    mf -> glyphs[block] = permanent_alloc(sizeof(struct _glyph) * block_size);
    if(mf -> glyphs[block] == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s: No memory to allocate "
                      "Unicode block.\n", mf -> file);
#endif
      return NULL;
    }
    for(i = 0; i < block_size; i ++)
      INITIALIZE_GLYPH(mf -> glyphs[block][i]);
  }
  return &(mf -> glyphs[block][index]);
}
@
\fimcodigo



\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}

\fim


