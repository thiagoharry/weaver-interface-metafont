\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains an implementation of an interpreter
 for a language based on METAFONT. This is aimed at allowing the
 definition of flexible and parameterized typographic fonts that could
 be interpreted and rendered on the fly.  Because of this, we
 sacrifice some flexibility from the original METAFONT language to be
 able to produce faster results. The implementation will be used by
 Weaver Game Engine as a module and uses modern OpenGL to render the
 fonts.}

\secao{1. Introduction}

The original METAFONT is a language made to describe typographical
fonts. It was created on 1984 by Donald Knuth and differs from other
formats for allowing a designer to create different fonts merely by
changing basic parameters in the base description of the font. This
way, a designer should not create a single typographic font, but a
meta-font from which new fonts could be obtained changing these basic
parameters.

The original specification for the METAFONT language can be found in
[KNUTH, 1989], but the implementation described here will not be
compatible with that language. Instead, a new language will be
defined, strongly based on the original METAFONT, but with a different
grammar. The new language will have similar objectives, but it will be
focused on defining typographical fonts that could be interpreted and
rendered on the fly.

As this article defines a subsystem for Weaver Game Engine, and more
specifically a subsystem for the user interface modulus, our objective
here will be define the following function that will interpret a file
with METAFONT source code and load as user interface using the letters
read as texture:

\iniciocodigo
@<Function Declaration (metafont.h)@>=
void _Wmetafont_loading(void *(*permanent_alloc)(size_t),
		      void (*permanent_free)(void *),
		      void *(*temporary_alloc)(size_t),
		      void (*temporary_free)(void *),
		      void (*before_loading_interface)(void),
		      void (*after_loading_interface)(void),
		      char *source_filename,
                      struct user_interface *target);
@
\fimcodigo

And we will need the header for Weaver user interfaces:

\iniciocodigo
@<Include General Headers (metafont.h)@>=
#include "interface.h"
@
\fimcodigo

But besides loading the typographical fonts to a texture, we also want
to create a font structure that could be used to render text for other
functions:

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
struct metafont *new_metafont(char *filename);
@
\fimcodigo

Before acalling any of these function, it is necessary to call a
initialization function that sets which functions will be called in
some contexts and also sets how many pixels correspond to ``1pt'':

\iniciocodigo
@<Function Declaration (metafont.h)@>+=
void Winit_metafont(void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *),
                    void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    uint64_t (*rand)(void), int pt);
@
\fimcodigo

The functions passed as parameters are respectivelly the one that
allocates memory temporarily , other to free what was allocated by it,
a function to make more permanent allocation, the function that frees
what was allocated by it, a function that returns 64 random bits and
finally how many pixels are ``1pt''. The disallocation functions can
be set to NULL.

\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{metafont.h}.

We can show the structure of the file \monoespaco{metafont.h}:

\iniciocodigo
@(src/metafont.h@>=
#ifndef __WEAVER_METAFONT
#define __WEAVER_METAFONT
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif  
@<Include General Headers (metafont.h)@>
//@<General Macros (metafont.h)@>
@<Data Structures (metafont.h)@>
@<Function Declaration (metafont.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Function Declaration
(weaver.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{metafont.c} file related
with this header, its structure is:

\iniciocodigo
@(src/metafont.c@>=
#include "metafont.h"
@<Local Headers (metafont.c)@>
@<Local Macros (metafont.c)@>
@<Local Data Structures (metafont.c)@>
@<Local Variables (metafont.c)@>
@<Local Function Declaration (metafont.c)@>
@<Auxiliary Local Functions (metafont.c)@>
@<API Functions Definition (metafont.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\secao{2. Initialization}

First we will define the initialization function. What it will do is
set some static variables with some functions that we will use in the
program. It also will set in a variable how many pixels correspond to
1pt. The variables that will store these information are:

\iniciocodigo
@<Local Variables (metafont.c)@>=
static void *(*temporary_alloc)(size_t);
static void (*temporary_free)(void *);
static void *(*permanent_alloc)(size_t);
static void (*permanent_free)(void *);
static uint64_t (*random_func)(void);
static int pt;
@
\fimcodigo

And the initialization function that sets these variables:

\iniciocodigo
@<API Functions Definition (metafont.c)@>=
void Winit_metafont(void *(*t_alloc)(size_t),
                    void (*t_free)(void *),
                    void *(*p_alloc)(size_t),
                    void (*p_free)(void *),
                    uint64_t (*random)(void), int pt_in_pixels){
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  random_func = random;
  pt = pt_in_pixels;
}
@
\fimcodigo


\secao{3. Lexer}

The first thing to be created for a language is its lexer. It will
read the source code in a file and will output a list of tokens, where
tokens are the most basic unit in the language. A token is like a
word.

METAFONT recognizes three kind of tokens: numeric, strings and
symbolic. In practice we will subdivide the symbolic tokens in several
kind of subtokens to store and read them in a more efficient way.

A numeric token will be represented internally as a floating point
number. This is different than specified in the original METAFONT,
where a custom numeric representation was used. As here we are
interested in more speed, we will choose floating point numbers
because they have nowadays more hardware support. This is how a
numeric token is represented:

\iniciocodigo
@<Local Data Structures (metafont.c)@>=
#define TYPE_NUMERIC 1
struct numeric_token{
  int type;   // Should be equal 'TYPE_NUMERIC'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  float value;
};
@
\fimcodigo

And this is how we will represent string tokens:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_STRING 2
struct string_token{
  int type;   // Should be equal 'TYPE_STRING'
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char value[5];
};
@
\fimcodigo

We will store only the first 5 bytes of each given string, even if in
the source code the string is bigger. This is so because unlike in the
original METAFONT, our only use for strings are saying wich Unicode
character each glyph should represent. For this we need only 5 bytes
(at most 4 for the character and a final byte 0). But we could use
them to associate a glyph with ligatures like ``ff'', which also fits
in these 5 bytes.

In the case of symbolic tokens, we need to store their entire name to
know which symbolic token we have. We shoul allocate dynamically
a string to store its name:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_SYMBOLIC 3
struct symbolic_token{
  int type;   // Should be equal 'TYPE_SYMBOLIC'
  void *next, *var;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
  char *value;
};
@
\fimcodigo

We also added in this token a pointer \monoespaco{var}, because the
token can represent a variable, and therefore could need to point to
the memory region with its content.

But this could consume much more memory than needed. Some symbols are
very common and are embedded in the language. These symbols could use
less space. For example, parenthesis, semicolon and commas. We can
represent them with the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
#define TYPE_OPEN_PARENTHESIS  4 // '('
#define TYPE_CLOSE_PARENTHESIS 5 // ')'
#define TYPE_COMMA             6 // ','
#define TYPE_SEMICOLON         7 // ';'
@<METAFONT: Symbolic Token Definition@>
// (...)
struct generic_token{
  int type;   // Should be one of the above
  void *next;
#if defined(W_DEBUG_METAFONT)
  int line;
#endif
};
@
\fimcodigo

We can define later more reserved symbolic tokens. We just need to
define them to an unique number greater than 6. Any token whose type
is a number greater or equal than 3 is a symbolic token.

Every token have a pointer to a next token. THis happens because
usually they will be part of a linked list. To deallocate the memory
occupied by a token list given a deallocation function and the given
list, we can use the following function:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void free_token_list(void (*dealloc)(void *), void *token_list){
  struct generic_token *p, *p_next;
  if(dealloc == NULL || token_list == NULL)
    return;
  p = token_list;
  while(p != NULL){
    p_next = p -> next;
    if(p -> type == TYPE_SYMBOLIC)
      dealloc(((struct symbolic_token *) p) -> value);
    dealloc(p);
    p = p_next;
  }
}
@
\fimcodigo

Now the funtion that represents our lexer. It will get as argument an
allocation function and a string with a path for the file with
METAFONT source code. It will return a linked list of tokens:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>=
void *lexer(struct metafont *mf, void *(*alloc)(size_t),
            void (*dealloc)(void *), char *path){
  FILE *fp;
  char c;
  int line = 1;
  void *first_token = NULL, *last_token = NULL;
  fp = fopen(path, "r");
  if(fp == NULL)
    return NULL;
  while((c = fgetc(fp)) != EOF){
    char next_char = fgetc(fp);
    ungetc(next_char, fp);
    if(c == '\n'){
      line ++;
      continue;
    }
    @<Lexer: Rule 1@>
    @<Lexer: Rule 2@>
    @<Lexer: Rule 3@>
    @<Lexer: Rule 4@>
    @<Lexer: Rule 5@>
    @<Lexer: Rule 6@>
    // No rule applied: error
    fprintf(stderr, "ERROR: %s:%d: Unknown character: '%c'\n",
            path, line, c);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  fclose(fp);
  return first_token;
}
@
\fimcodigo

Oh, we used the struct \monoespaco{FILE}, this means that we need to
include the header with data about input/output to be able to read
files:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <stdio.h>
@
\fimcodigo

The rules to read tokens consist in reading each line in the source
code applying the following rules for each character in the line:

1) If the next character is a space or a period and is not followed by
a period or a decimal digit, then ignore this character and go to the
next one.

\iniciocodigo
@<Lexer: Rule 1@>=
if(c == ' ' || (c == '.' && next_char != '.' && !isdigit(next_char)))
  continue;
@
\fimcodigo

As we are using \monoespaco{isdigit} function, we need to insert the
following header that declares this function:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <ctype.h>
@
\fimcodigo


2) If the character is a percent sign, ignore it and also ignore all
other following characters in this line. Percentage sign is how we
start comments in the language.

\iniciocodigo
@<Lexer: Rule 2@>=
if(c == '%'){
  do{
    c = fgetc(fp);
  } while(c != '\n' && c != EOF);
  ungetc(c, fp);
  continue;
}
@
\fimcodigo

3) If the next character is a decimal digit or a period, then the next
token in numeric. It will be interpreted from the biggest sequence of
decimal digests and a single optional period representing the decimal
dot present in the input.

\iniciocodigo
@<Lexer: Rule 3@>=
if((c == '.' && isdigit(next_char)) || isdigit(c)){
  char buffer[256];
  struct numeric_token *new_token = (struct numeric_token *)
                                      alloc(sizeof(struct numeric_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_NUMERIC;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  int number_of_dots = (c == '.');
  buffer[i] = c;
  i ++;
  do{
    c = fgetc(fp);
    if(c == '.')
      number_of_dots ++;
    buffer[i] = c;
    i ++;
  } while(isdigit(c) || (c == '.' && number_of_dots == 1));
  ungetc(c, fp);
  i --;
  buffer[i] = '\0';
  new_token -> value = atof(buffer);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

4) If the next character is a double quote, the next token will be a
string. Its content will be all other chacarters until the next double
quote that should be in the same line. If we have a double quote
opening a string, but the same line do not have another double quote
to close the string, this is an error.

\iniciocodigo
@<Lexer: Rule 4@>=
if(c == '"'){
  struct string_token *new_token = (struct string_token *)
                                     alloc(sizeof(struct string_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_STRING;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  int i = 0;
  do{
    c = fgetc(fp);
    if(i < 5){
      new_token -> value[i] = c;
      i ++;
    }
  } while(c != '"' && c != '\n' && c != EOF);
  i --;
  new_token -> value[i] = '\0';
  if(c == '\n' || c == EOF){
    fprintf(stderr, "ERROR: %s:%d: Incomplete String.\n", path, line);
    dealloc(new_token);
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo


5) If the next character is a parenthesis, semicolon or a comma, the
next token will be symbolic and composed by that single character.

\iniciocodigo
@<Lexer: Rule 5@>=
if(c == '(' || c == ')' || c == ',' || c == ';'){
  struct generic_token *new_token =
     (struct generic_token *) alloc(sizeof(struct generic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  if(c == '(')
    new_token -> type = TYPE_OPEN_PARENTHESIS;
  else if(c == ')')
    new_token -> type = TYPE_CLOSE_PARENTHESIS;
  else if(c == ';')
    new_token -> type = TYPE_SEMICOLON;
  else
    new_token -> type = TYPE_COMMA;
  new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

6) Otherwise, the next token will be symbolic and will be composed by
the longest sequence of 12 families of characteres:

\iniciocodigo
@<Lexer: Rule 6@>=
{
  char buffer[256];
  int i = 0;
  buffer[0] = '\0';
  // Buffer is read according with subrules 6-a to 6-l
  @<Lexer: Rule A@>
  @<Lexer: Rule B@>
  @<Lexer: Rule C@>
  @<Lexer: Rule D@>
  @<Lexer: Rule E@>
  @<Lexer: Rule F@>
  @<Lexer: Rule G@>
  @<Lexer: Rule H@>
  @<Lexer: Rule I@>
  @<Lexer: Rule J@>
  @<Lexer: Rule K@>
  @<Lexer: Rule L@>
  // Depending on buffer content, generates next token
  @<Lexer: New Reserved Symbolic Token@>
  @<Lexer: New Generic Symbolic Token@>
}
@
\fimcodigo

a) The first family of letters are the uppercase and lowercase
alphabetic letters, digits and underline. A digit cannot be the first
character in the sequence, otherwise it would be considered part of a
numeric token.

\iniciocodigo
@<Lexer: Rule A@>=
if(isalpha(c) || c == '_'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(isalpha(c) || c == '_' || isdigit(c));
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

b) The second family is composed by the symbols for greater, equal and
lesser, colon and ``|''.

\iniciocodigo
@<Lexer: Rule B@>=
else if(c == '>' || c == '<' || c == '=' || c == ':' || c == '|'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '>' || c == '<' || c == '=' || c == ':' || c == '|');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

c) Acute and grave accents.

\iniciocodigo
@<Lexer: Rule C@>=
else if(c == '`' || c == '\''){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '`' || c == '\'');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

d) Plus and minus.

\iniciocodigo
@<Lexer: Rule D@>=
else if(c == '+' || c == '-'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '+' || c == '-');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

e) Slash, backslash and multiplication symbol.

\iniciocodigo
@<Lexer: Rule E@>=
else if(c == '\\' || c == '/' || c == '*'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '\\' || c == '/' || c == '*');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

f) Opening brackets

\iniciocodigo
@<Lexer: Rule F@>=
else if(c == '?' || c == '!'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '?' || c == '!');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

g) Hash sign, ampersand, at sign and dollar sign.

\iniciocodigo
@<Lexer: Rule G@>=
else if(c == '#' || c == '&' || c == '@@' || c == '$'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '#' || c == '&' || c == '@@' || c == '$');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

h) Circumflex accent and tilde.

\iniciocodigo
@<Lexer: Rule H@>=
else if(c == '^' || c == '~'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '^' || c == '~');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

i) Opening brackets.

\iniciocodigo
@<Lexer: Rule I@>=
else if(c == '['){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '[');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

j) Closing brackets.

\iniciocodigo
@<Lexer: Rule J@>=
else if(c == ']'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == ']');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

k) Opening and closing braces.

\iniciocodigo
@<Lexer: Rule K@>=
else if(c == '{' || c == '}'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '{' || c == '}');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo

l) Ponto.

\iniciocodigo
@<Lexer: Rule L@>=
else if(c == '.'){
  do{
    buffer[i] = c;
    i ++;
    c = fgetc(fp);
  } while(c == '.');
  ungetc(c, fp);
  buffer[i] = '\0';
}
@
\fimcodigo


After reading the characters for our new symbolic token, we check if
we have a reserved symbolic token: a token representing a language
keyword. We can check this using function \monoespaco{strcmp}
comparing the buffer with some keywords. We will store a list of
keywords here:

\iniciocodigo
@<Local Variables (metafont.c)@>+=
static char* list_of_keywords[] = {
@<List of Keywords@>
  NULL};
@
\fimcodigo

Therefore, to know if we are dealing with a token that represents a
reserved keyword, we check if it is in this NULL terminated list. If
so, we create a token whose type is chosen according with the position
in this list:

\iniciocodigo
@<Lexer: New Reserved Symbolic Token@>=
{
  int i, token_type = 0;
  for(i = 0; list_of_keywords[i] != NULL; i ++)
    if(!strcmp(buffer, list_of_keywords[i]))
      token_type = i + 8; // Token types for keywords begin in 8
  if(token_type != 0){
    struct generic_token *new_token =
       (struct generic_token *) alloc(sizeof(struct generic_token));
    if(new_token == NULL){
      free_token_list(dealloc, first_token);
      return NULL;
    }
    @<Change Type in Token Creation for Special Cases@>
    new_token -> type = token_type;
    new_token -> next = NULL;
#if defined(W_DEBUG_METAFONT)
    new_token -> line = line;
#endif
    if(first_token == NULL)
      first_token = last_token = new_token;
    else{
      ((struct generic_token *) last_token) -> next = new_token;
      last_token = new_token;
    }
    continue;
  }
}
@
\fimcodigo

To use function \monoespaco{strcmp} we need the following header:

\iniciocodigo
@<Local Headers (metafont.c)@>=
#include <string.h>
@
\fimcodigo


If we do not have a reserved symbolic token, and if we have something
in our buffer, then we generate a new generic symbolic token:

\iniciocodigo
@<Lexer: New Generic Symbolic Token@>=
if(buffer[0] != '\0'){
  buffer[255] = '\0';
  size_t buffer_size = strlen(buffer) + 1;
  struct symbolic_token *new_token =
     (struct symbolic_token *) alloc(sizeof(struct symbolic_token));
  if(new_token == NULL){
    free_token_list(dealloc, first_token);
    return NULL;
  }
  new_token -> type = TYPE_SYMBOLIC;
  new_token -> next = NULL;
  new_token -> var = NULL;
  @<Set Pointer to Internal Variable@>
#if defined(W_DEBUG_METAFONT)
  new_token -> line = line;
#endif
  new_token -> value = (char *) alloc(buffer_size);
  memcpy(new_token -> value, buffer, buffer_size);
  if(first_token == NULL)
    first_token = last_token = new_token;
  else{
    ((struct generic_token *) last_token) -> next = new_token;
    last_token = new_token;
  }
  continue;
}
@
\fimcodigo

\secao{4. METAFONT Programs}

When we evaluate a METAFONT program, we need two additional
structures. The first one, which we will call \monoespaco{struct
metafont} will contain all the final information extracted from the
typographical font and that will be needed to render each glyph. The
second structure, which we will call \monoespaco{struct context}
represents the current state in our parser and represents information
that we need to know to interpret correctly the token list. This
second structure can be discarded after we read all the tokens from
our font.

The first thing that our parser needs to know is that a METAFONT
program is a list (possibly empty) of statements ended by a symbolic
token \monoespaco{end} or \monoespaco{dump}:

\alinhaverbatim
<Program> -> <List of Statements> end | <List of Statements> dump
\alinhanormal

for us, there will be no difference between these two kind of programs
and symbols \monoespaco{end} and \monoespaco{dump} will be
equivalent. In the original METAFONT, one of them ends programs that
define typographical fonts and the other ends the description of a
base file (something like a basic standard library).

We will define then a new kind of symbolic token to represent this
end-of-file marking:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>=
#define TYPE_END             8 // The symbolic token 'end'
#define TYPE_DUMP            9 // The symbolic token 'dump'
@
\fimcodigo

And let's add both the keywords \monoespaco{end} and \monoespaco{dump}
in ourt list of keywords:

\iniciocodigo
@<List of Keywords@>=
"end", "dump",
@
\fimcodigo

But to simplify, we will not use \monoespaco{TYPE\_DUMP},
only \monoespaco{TYPE\_END} to make the code simpler in the parser:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>=
if(token_type == TYPE_DUMP)
  token_type = TYPE_END;
@
\fimcodigo


The first parser function to be defined is the one that recognizes an
entire program. It basically checks if the program is ended correctly
and if not, generates an error. If the program is ended correctly, it
passes for the next parser function that evaluates list of statements,
marking the beginning and end of such list:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_program(struct metafont *mf, struct context *cx,
                  void *token_list){
  struct generic_token *end = (struct generic_token *) token_list;
  struct generic_token *previous = NULL;
  while(end != NULL && end -> type != TYPE_END){
    previous = end;
    end = (struct generic_token *) (end -> next);
  }
  if(end == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Program not finished with "
                    "'end' or 'dump'.\n", mf -> file,
                    (previous == NULL)?(1):(previous -> line));
#endif
    return false;
  }
  if(end == token_list)
    return true;
  return eval_list_of_statements(mf, cx, token_list, previous);
}
@
\fimcodigo

The context struct still will not be entirely defined. We will show
its content while each attribute becames necessary:

\iniciocodigo
@<Data Structures (metafont.h)@>=
struct context{
  @<Attributes (struct context)@>
};
@
\fimcodigo


And as seen above, one of the contents in \monoespaco{struct metafont}
is the file name from where the font was read. We also will store the
functions that will be use to allocate and disallocate the structure
and its elements:

\iniciocodigo
@<Data Structures (metafont.h)@>+=
struct metafont{
  char *file;
  void *(*alloc)(size_t);
  void (*free)(void *);
  @<Attributes (struct metafont)@>
};
@
\fimcodigo

Both data structures will have a function that initializes them and
also finalizes them:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename);
struct context *init_context(void);
void destroy_metafont(struct metafont *mf);
void destroy_context(struct context *cx);
@
\fimcodigo

The structure \monoespaco{metafont} needs to store more informations,
as it could be allocated both using permanent or temporary memory
allocations. Meanwhile, the context always will be temporary and will
be allocated with temporary functions.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct metafont *init_metafont(void *(*alloc)(size_t),
                              void (*disalloc)(void *),
                              char *filename){
  struct metafont *mf;
  size_t filename_size = strlen(filename) + 1;
  mf = (struct metafont *) alloc(sizeof(struct metafont));
  mf -> file = (char *) alloc(filename_size);
  memcpy(mf -> file, filename, filename_size);
  mf -> alloc = alloc;
  mf -> free = disalloc;
  @<Initialization (struct metafont)@>
  return mf;
}
struct context *init_context(void){
  struct context *cx;
  cx = (struct context *) temporary_alloc(sizeof(struct context));
  @<Initialization (struct context)@>
  return cx;
}
@
\fimcodigo

And this is the definition for the functions that frees the memory
occupied by these structures:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void destroy_metafont(struct metafont *mf){
  if(mf -> free != NULL){
    mf -> free(mf -> file);
    @<Finalization (struct metafont)@>
    mf -> free(mf);
  }
}
void destroy_context(struct context *cx){
  if(temporary_free != NULL){
    @<Finalization (struct context)@>
    temporary_free(cx);
  }
}
@
\fimcodigo


\secao{5. List of Statements}

A list of potentially empty statements delimited by a semicolon:

\alinhaverbatim
<List of Statements> -> <Empty> | <Statement> ; <List of Statements>
\alinhanormal

The function that will evaluate and interpret a list of statements is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list);
@
\fimcodigo

This function will iterate over each declaration and execute for all
them, in the order thay appear, the function that evaluates individual
statements. For this, the function will find all semicolons and use
them to detect where each statement begins and where they end:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_list_of_statements(struct metafont *mf, struct context *cx,
                            void *begin_token_list, void *end_token_list){
  bool ret = true;
  struct generic_token *begin, *end = NULL;
  begin = (struct generic_token *) begin_token_list;
  while(begin != NULL){
    while(begin != NULL && begin -> type == TYPE_SEMICOLON){
      if(begin != end_token_list)
        begin = (struct generic_token *) begin -> next;
      else
        begin = NULL;
    }
    end = begin;
    if(end != NULL){
      while(end != end_token_list &&
            ((struct generic_token *) (end -> next)) -> type !=
              TYPE_SEMICOLON)
        end = end -> next;
    }
    if(begin != NULL){
      ret = eval_statement(mf, cx, begin, (void **) &end);
        if(!ret)
          return false;
      begin = end -> next;
    }
  }
  return ret;
}
@
\fimcodigo

The function above iterates over each statement, ignoring empty
statements. For each non-empty statement, it assures that the
pointers \monoespaco{begin} and \monoespaco{end} delimit the
individual statement. During the iteration we always ensure that we do
not go outside the region delimited by \monoespaco{begin\_token\_list}
and \monoespaco{end\_token\_list}.

\secao{6. Compound Statements}

An individual statement in the language can be composed by many other
statements. The syntax for this is:

\alinhaverbatim
<Statement> -> <Empty> | <Compound> | <Declaration> | <Assignment> |
               <Definition> | <Command>
<Compound> -> begingroup <List of Statements> <Non-Title> endgroup
\alinhanormal

We already know what is a list of statements and already have a
function to eval them. The non-title declaration, for now, will be
treated as any other statement, because we still do not support title
statements (they are isolated strings). Therefore, a compund statement
is just a list of statements delimited by
tokens \monoespaco{begingroup} and \monoespaco{endgroup}.

Then we need to take into account the existance of these two new kind
of special symbolic tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_BEGINGROUP            10 // O token simbólico 'begingroup'
#define TYPE_ENDGROUP              11 // O token simbólico 'endgroup'
@
\fimcodigo

And we add them to the list of reserved keywords:

\iniciocodigo
@<List of Keywords@>+=
"begingroup", "endgroup",
@
\fimcodigo

And now the function that will evaluate individual statements. As
seen, there are 8 different kinds of statements:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_statement(struct metafont *, struct context *, void *, void **);
@
\fimcodigo


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_statement(struct metafont *mf, struct context *cx,
                     void *begin_token_list, void **end_token_list){
  @<Statement: Empty@>
  @<Statement: Compound@>
  @<Statement: Declaration@>
  @<Statement: Assignment@>
  //@<Statement: Definition@> 
  //@<Statement: Command@>
  // If we are here, we could not identify the statement:
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unknown statement.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
  return false;
}
@
\fimcodigo

In the case of an empty statement, probably we will not need to deal
with them. The function \monoespaco{eval\_list\_of\_statements}
silently ignore them before calling this function. But just in case an
empty statement appear by different means, we will explicitly accept
them with the code below:

\iniciocodigo
@<Statement: Empty@>=
if(begin_token_list == end_token_list && begin_token_list == NULL)
  return true;
@
\fimcodigo

Now let's deal with the compound statement. The first thing to recall
is that it will be important for the language to know in which nesting
level we are to know the scope of each declared variable. Because of
this, our context will store the current nesting
level. Each \monoespaco{begingroup} should increase by 1 the nesting
level and each \monoespaco{endgroup} should decrease by 1. We declare
the nesting level below:

\iniciocodigo
@<Attributes (struct context)@>=
  int nesting_level;
@
\fimcodigo

This should be initialized as zero:

\iniciocodigo
@<Initialization (struct context)@>=
  cx -> nesting_level = 0;
@
\fimcodigo


The second thing to recall is that if we are in a compound statement,
this means that the end of the declaration pointer could be wrong.
For example, supose that the
function \monoespaco{eval\_list\_of\_statements} evaluated the
following tokens:

\alinhaverbatim
[begingroup][T1][T2][;][T3][T4][;][endgroup][;]
\alinhanormal

The function correctly would consider the beginning of the first
statement the token \monoespaco{begingroup}. But wrongly would
consider the token \monoespaco{T2} as the end of this statement.
Because it works in a naive logic, always considering the semicolons
as the delimiters for statements, not considering that statements
could contain semicolons. The end of the first statement should be the
token \monoespaco{endgroup} instead.

Instead of increasing the complexity of
function \monoespaco{eval\_list\_of\_statements} making it aware of
compound statements, we will make the
function \monoespaco{eval\_statements} correct the pointers, making
the pointers to delimit correctly the statement. Only after correcting
the pointers, we can pass the list of statements from the compouns
statement to be evaluated:

\iniciocodigo
@<Statement: Compound@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_BEGINGROUP){
  struct generic_token *t = begin_token_list, *previous = NULL;
  int nesting_level = 0;
  while(t != NULL){
    if(t -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(t -> type == TYPE_ENDGROUP){
      nesting_level --;
      if(nesting_level == 0)
        break;
    }
    previous = t;
    t = (struct generic_token *) (t -> next);
  }
  *end_token_list = t; // Now the statement is correctly delimited
  if(*end_token_list == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unclosed 'begingroup'.\n",
            mf -> file,
            ((struct generic_token *) begin_token_list) -> line);
#endif
    return false;
  }
  if(previous == begin_token_list) // Empty compound statement
    return true;
  else{
    bool ret;
    cx -> nesting_level ++;
    ret = eval_list_of_statements(mf, cx, ((struct generic_token *)
                                         begin_token_list) -> next,
                                  previous);
    cx -> nesting_level --;
    return ret;
  }
}
@
\fimcodigo


\secao{7. Variable Declarations}

The syntax to declare variables is:

\alinhaverbatim
<Declaration> -> <Type> <List of Declarations>
<Type> -> boolean | string | path | pen | picture | transform | pair |
          numeric
<List of Declarations> -> <Tag> | <Tag> , <List of Declarations>
\alinhanormal

A ``tag'' is basically a symbolic token without a predefined meaning
in the language. For example, ``\monoespaco{tag}'' is a tag, but
``\monoespaco{begingroup}'' is not.

To interpret a declaration, we will introduce the following special
tokens:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_T_BOOLEAN               12 // Symbolic token 'boolean'
#define TYPE_T_PATH                  13 // Symbolic token 'path'
#define TYPE_T_PEN                   14 // Symbolic token 'pen'
#define TYPE_T_PICTURE               15 // Symbolic token 'picture'
#define TYPE_T_TRANSFORM             16 // Symbolic token 'transform'
#define TYPE_T_PAIR                  17 // Symbolic token 'pair'
#define TYPE_T_NUMERIC               18 // Symbolic token 'numeric'
@
\fimcodigo

And then we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"boolean", "path", "pen", "picture", "transform", "pair", "numeric",
@
\fimcodigo


When a variable is declared, we need to do two things:

1) If the variable do not exist in the current nesting level, we
should allocate a new structure to store its content. If it already
exist in the current nesting level, an error is returned. A default
value depending of its type if stored in the variable. But it should
not be used before being initialized.

2) We iterate over the following tokens in the list of tokens until
the end of the list or until the current nesting level ends. When we
find a symbolic token with the variable name, we update its pointer to
the newly allocated variable.


As each variable type has its own information and content, the
specifics about how the variable is created can be different. What all
variables have in common is the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
// Generic variable
struct variable{
  int type;
  int nesting_level;
  void *next;  
};
@
\fimcodigo

All variables first store their type, then their nesting level, and
finally, a ponter for the next variable. Depending on the variable
type, more information could be stored after the pointer for the next
variable.

If we are dealing with a global variable, we could want to preserve
and store its name, just in case if later the user would want to
change the variable content indentifying it by the name. In this case,
we would want to use the following structure to store the name with
the variable:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct named_variable{
  char *name;
  void *next;
  struct variable *var;
};
@
\fimcodigo

And the metafont structure will have pointers for these global
variables, with names and without:

\iniciocodigo
@<Attributes (struct metafont)@>=
  void *named_variables;
  void *global_variables;
@
\fimcodigo

These pointers are initialized with NULL:

\iniciocodigo
@<Initialization (struct metafont)@>=
mf -> named_variables = NULL;
mf -> global_variables = NULL;
@
\fimcodigo

To disallocate a list of global variables, we just iterate over the
linked list that they create. Some variables, which are more complex,
could need additional operations before removing them, but we will
deal with them later:

\iniciocodigo
@<Finalization (struct metafont)@>=
if(mf -> free != NULL){
  struct variable *v = (struct variable *) (mf -> global_variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Global Variable 'v'@>
    mf -> free(v);
    v = next;
  }
}
@
\fimcodigo

And to disallocate a list with preserved names, we act in a similar
way:

\iniciocodigo
@<Finalization (struct metafont)@>+=
if(mf -> free != NULL){
  struct named_variable *named = (struct named_variable *)
                                   (mf -> named_variables);
  struct named_variable *next;
  while(named != NULL){
    struct variable *v = (struct variable *) named -> var;
    next = (struct named_variable *) (named -> next);
    mf -> free(named -> name);
    @<Finalize Global Variable 'v'@>
    mf -> free(v);
    mf -> free(named);
    named = next;
  }
}
@
\fimcodigo

In the case of variables that are not global, they will be stored in
contexts, not in the metafont struct. After all, their duration always
will be temporary:

\iniciocodigo
@<Attributes (struct context)@>=
  void *variables;
@
\fimcodigo

The list of variables is initialized as empty:

\iniciocodigo
@<Initialization (struct context)@>+=
cx -> variables = NULL;
@
\fimcodigo

And we finalize it exactly as the list of global variables:

\iniciocodigo
@<Finalization (struct context)@>=
if(temporary_free != NULL){
  struct variable *v = (struct variable *) (cx -> variables);
  struct variable *next;
  while(v != NULL){
    next = (struct variable *) (v -> next);
    @<Finalize Local Variable 'v'@>
    temporary_free(v);
    v = next;
  }
}
@
\fimcodigo

And now let's interpret the variable declaration:

\iniciocodigo
@<Statement: Declaration@>=
else if(((struct generic_token *) begin_token_list) -> type >=
        TYPE_T_BOOLEAN &&
        ((struct generic_token *) begin_token_list) -> type <=
        TYPE_T_NUMERIC){ // All kinds of declarations
  int type = ((struct generic_token *) begin_token_list) -> type;
  struct symbolic_token *variable = (struct symbolic_token *)
           (((struct symbolic_token *) begin_token_list) -> next);
  do{
    if(variable -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: A declared variable "
                    "should be a single symbolic token.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    @<Insert Declared Variable@>
    if(variable != *end_token_list)
      variable = (struct symbolic_token *) (variable -> next);
    else{
      variable = NULL;
      continue;
    }
    if(variable -> type != TYPE_COMMA){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Declared variables "
                    "should be separed by commas.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    if(variable == *end_token_list){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable declaration "
                    "shouldn't end with comma.\n", mf -> file,
                    variable -> line);
#endif
      return false;
    }
    variable = (struct symbolic_token *) (variable -> next);
  } while(variable != NULL);
  return true;
}
@
\fimcodigo

Inserting a new variable follows the logic below:

\iniciocodigo
@<Insert Declared Variable@>=
{
  void *variable_pointer;
  if(cx -> nesting_level == 0){ // Variável global
    if(variable -> value[0] == '_')
      variable_pointer = insert_variable(0, mf -> alloc, type, variable,
                                         &(mf -> global_variables));
    else
      variable_pointer = insert_named_global_variable(mf, type, variable);
  }
  else
    variable_pointer = insert_variable(cx -> nesting_level,
                                      temporary_alloc, type,
                                      variable, &(cx -> variables));
  if(variable_pointer == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: No memory to create "
                    "variable.\n", mf -> file, variable -> line);
#endif
    return false;
  }
  update_token_pointer_for_variable(variable, variable_pointer);
}
@
\fimcodigo

The function that inserts a new global variable without its name is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target);
@
\fimcodigo

It will allocate a new variable and store it in the local pointed
by \monoespaco{target}:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_variable(int nesting_level,
                                 void *(*alloc)(size_t),
                                 int type,
                                 struct symbolic_token *variable,
                                 void **target){
  struct variable *var;
  size_t var_size;
  switch(type){
    case TYPE_T_NUMERIC:
      var_size = sizeof(struct numeric_variable);
      break;
    default:
      var_size = sizeof(struct variable);
  }
  var = (struct variable *) alloc(var_size);
  if(var != NULL){
    var -> type = type;
    var -> next = NULL;
    var -> nesting_level = nesting_level;
    @<Initializing New Variable@>
  }
  if(*target == NULL)
    *target = var;
  else{
    struct variable *p = (struct variable *) (*target);
    while(p -> next != NULL)
      p = (struct variable *) p -> next;
    p -> next = var;
  }
  return var;
}
@
\fimcodigo

Inserting a named variable is done with the following function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var);
@
\fimcodigo

The function works in a similar way, first allocating the structure
with the variable nam and then placing the variable there:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
struct variable *insert_named_global_variable(struct metafont *mf,
                                             int type,
                                             struct symbolic_token *var){
  struct named_variable *named;
  struct variable *new_var;
  size_t name_size;
  named = (struct named_variable *)
              mf -> alloc(sizeof(struct named_variable));
  if(named == NULL)
    return NULL;
  name_size = strlen(var -> value) + 1;
  named -> name = (char *) mf -> alloc(name_size);
  if(named -> name == NULL){
    if(mf -> free != NULL)
      mf -> free(named);
    return NULL;
  }
  memcpy(named -> name, var -> value, name_size);
  named -> next = NULL;
  named -> var = NULL;
  new_var = insert_variable(0, mf -> alloc, type, var,
                           (void **) &(named -> var));

  if(new_var == NULL){
    if(mf -> free != NULL){
      mf -> free(named -> name);
      mf -> free(named);
      return NULL;
    }
  }
  if(mf -> named_variables == NULL)
    mf -> named_variables = named;
  else{
    struct named_variable *p = (struct named_variable *)
                                   mf -> named_variables;
    while(p -> next != NULL)
      p = (struct named_variable *) p -> next;
    p -> next = named;
  }
  return new_var;
}
@
\fimcodigo

Anf finally, the function that search in a list of tokens for symbolic
tokens with the same name that the allocated new variable and updating
each one to make them point to the newly allocated variable position:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer);
@
\fimcodigo

The function will walk in the linked list starting in the token next
to the declared variable. And t will stop only when there is no more
tokens or when the variable do not exist anymore because we are not
more in its nesting level (it happens when we find
the \monoespaco{endgroup} which ends the current nesting level):

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void update_token_pointer_for_variable(struct symbolic_token *var_token,
                                      struct variable *var_pointer){
  struct symbolic_token *p = var_token -> next;
  int nesting_level = 0;
  while(p != NULL && nesting_level >= 0){
    if(p -> type == TYPE_BEGINGROUP)
      nesting_level ++;
    else if(p -> type == TYPE_ENDGROUP)
      nesting_level --;
    else if(p -> type == TYPE_SYMBOLIC){
      if(!strcmp(p -> value, var_token -> value)){
        p -> var = var_pointer;
      }
    }
    p = (struct symbolic_token *) (p -> next);
  }
}
@
\fimcodigo

\subsecao{7.1. Numeric Variables}

A numeric variable will be stored in the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct numeric_variable{
  int type; // Deve set 'TYPE_T_NUMERIC'
  int nesting_level;
  void *next;
  float value;
};
@
\fimcodigo

Comparing numeric variables with generic variables, the difference is
that we have an additional floating point variable in the structure
called \monoespaco{value}. It will store the numeric value. When we
create a numeric variable, we initialize it with NaN, which represents
an unknown value:

\iniciocodigo
@<Initializing New Variable@>=
if(type == TYPE_T_NUMERIC){
  ((struct numeric_variable *) var) -> value = NAN;
}
@
\fimcodigo

Using the macro \monoespaco{NAN} requires the mathematical header:

\iniciocodigo
@<Local Headers (metafont.c)@>+=
#include <math.h>
@
\fimcodigo

In the case of numeric variables, nothing additional is needed when we
deallocate them, as they have no additional structure besides a single
floating-point number.

However, besides the variables declared by the users, our version of
the Metafont language will have some additional internal
variables. They always will be present and do not need to be
declared. We will have exactly three of
them: \monoespaco{pt}, \monoespaco{cm} and \monoespaco{mm}. Basically
they will store how many pixels correspond to 1pt, 1cm and 1mm
respectively.

Such internal numeric variables will be declared in the metafont
struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
void *internal_numeric_variables;
@
\fimcodigo

During the initialization we will allocate space for the three
variables and fill their values:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> internal_numeric_variables =
             mf -> alloc(3 * sizeof(struct numeric_variable));
((struct numeric_variable *) mf -> internal_numeric_variables)[0].value =
   pt;
((struct numeric_variable *) mf -> internal_numeric_variables)[1].value =
   28.3465 * pt; // 1cm = 28.3465pt
((struct numeric_variable *) mf -> internal_numeric_variables)[2].value =
   2.83465 * pt; // 1mm = 2.83465pt
{
  int i;
  for(i = 0; i < 3; i ++){
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].type = TYPE_T_NUMERIC;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].nesting_level = 0;
    ((struct numeric_variable *)
      mf -> internal_numeric_variables)[i].next = NULL;    

  }
}
@
\fimcodigo

We also will create the following macros to access each one of these
variables more easily:

\iniciocodigo
@<Local Macros (metafont.c)@>=
#define INTERNAL_NUMERIC_PT 0
#define INTERNAL_NUMERIC_CM 1
#define INTERNAL_NUMERIC_MM 2
@
\fimcodigo

To finalize the metafont structure, we need to deallocate these
internal variables:

\iniciocodigo
@<Finalization (struct metafont)@>+=
mf -> free(mf -> internal_numeric_variables);
@
\fimcodigo

When our lexer creates a new symbolic token which is not a reserved
word, it should check if this token have the same name than an
internal variable. If so, we can then set correctly the pointer to the
variable:

\iniciocodigo
@<Set Pointer to Internal Variable@>=
if(!strcmp(buffer, "pt")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_PT]);
}
else if(!strcmp(buffer, "cm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_CM]);
}
else if(!strcmp(buffer, "mm")){
  new_token -> var =
          &(((struct numeric_variable *)
                mf -> internal_numeric_variables)[INTERNAL_NUMERIC_MM]);
}
@
\fimcodigo

\subsecao{7.2. Pair Variables}

A pair variable will store point coordinates. They will be stored in
the following structure:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct pair_variable{
  int type; // Must be 'TYPE_T_PAIR'
  int nesting_level;
  void *next;
  float x, y;
};
@
\fimcodigo

The difference is that they have space for two floating point values
instead of one. Initially we will represent the first of them with NaN
to represent a non-initialized pair:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PAIR){
  ((struct pair_variable *) var) -> x = NAN;
}
@
\fimcodigo

\subsecao{7.3. Path Variables}

A path variable store a sequence of points and control
points. Together they compose a sequence of Cubic Beziér Curves.

A Cubic Beziér Curve is defined by two extremity points ($z_1$ and
$z_4$) and two control points ($z_2'$ and $z_3'$). The two extremity
curves are always part of the curve. To obtain the other curve points
given the four points $(z_1, z_2', z_3', z_4)$, we use the following
procedure:

1) Get three intermediate points: $z_{12}'$ is the point halfway the
points $z_1$ and $z_2'$, $z_{23}'$ is the point halfway between $z_2'$
and $z_3'$ and $z_{34}$ is the point halfway between $z_3'$ and $z_4$.

2) Get two intermediate points: $z_{123}'$ is the point halfway
between $z_{12}'$ and $z_{23}'$ while $z_{234}'$ is the point halfway
between $z_{23}'$ and $z_{34}'$.

3) Get the new curve point $z_{1234}$ located halfway between
$z_{123}'$ and $z_{234}'$.

4) Generate the remaining curve points repeating this procedure
recursively over the points $(z_1, z_{12}', z_{123}', z_{1234})$ and
over $(z_{1234}, z_{234}', z_{34}', z_4)$.

It is also possible to define such curves using a formula. Given the
extremity points and the control points, a Cubic Beziér Curve is
defined by the following formula if we vary $t$ between 0 and 1:

$$
z(t) = (1-t)^3z_1 + 3(1-t)^2tz_2' + 3(1-t)t^2z_3'+t^3z_4
$$

The data structure that will represent a sequence of Cubic Beziér
Curves is:

\iniciocodigo
@<Local Data Structures (metafont.c)@>+=
struct path_points{
  float x, y; // Extremity point
  float u_x, u_y, v_x, v_y;   // Control Points
  void *subpath;  
};
struct path_variable{
  int type; // Must be 'TYPE_T_PATH'
  int nesting_level;
  void *next;
  bool cyclic;
  int length;
  struct path_points *points;
};
@
\fimcodigo

Basically its points will be stored in the
pointer \monoespaco{points}, an array of structs whose number of
elements is equal \monoespaco{length}. Each structure will represent a
point $(x, y)$ or a subpath (if \monoespaco{subpath} is not null, and
in this case we ignore $x$ and $y$). The control points defined
by \monoespaco{u\_x}, \monoespaco{u\_y}, \monoespaco{v\_x}
and \monoespaco{v\_y} are the control points between the current point
or subpath and the next one if it exists. If we have a cyclic path,
the control points in the last point or subpath show how it is
connected to the first point in the path. If we are not in a cyclic
path, then the control points of the last point is ignored.

We will represent a non-initialized oath variable setting its length
as -1:

\iniciocodigo
@<Initializing New Variable@>+=
if(type == TYPE_T_PATH){
  ((struct path_variable *) var) -> length = -1;
}
@
\fimcodigo

When we remove a global variable, if it is a path variable and if it
is initialized, then we also need to remove the allocated list of
points:

\iniciocodigo
@<Finalize Global Variable 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && mf -> free != NULL){
    int i;
    for(i = 0; i < path -> length; i ++)
      if(path -> points[i].subpath != NULL)
        path_recursive_free(mf -> free, (struct path_variable *)
                                        path -> points[i].subpath);
    mf -> free(path -> points);
  }
}
@
\fimcodigo

If the variable is not global we do the same, but using a different
disallocation function:

\iniciocodigo
@<Finalize Local Variable 'v'@>=
if(v -> type == TYPE_T_PATH){
  struct path_variable *path = (struct path_variable *) v;
  if(path -> length != -1 && temporary_free != NULL){
    int i;
    for(i = 0; i < path -> length; i ++)
      if(path -> points[i].subpath != NULL)
        path_recursive_free(temporary_free, (struct path_variable *)
                                            path -> points[i].subpath);
    temporary_free(path -> points);
  }
}
@
\fimcodigo

As a path can contain subpaths and each subpath also can contain more
subpaths, we will use a recursive function to disallocate their
memory. Given a disallocation function and a pointer to a path
variable, we disalloc all its subpaths, and then we disalloc the path
variable. The function declaration is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void path_recursive_free(void (*free_func)(void *),
                         struct path_variable *path){
  if(free_func != NULL){
    int i;
    for(i = 0; i < path -> length; i ++){
      if(path -> points[i].subpath != NULL)
        path_recursive_free(free_func, (struct path_variable *)
                                       path -> points[i].subpath);
    }
    free_func(path -> points);
    free_func(path);
  }
}
@
\fimcodigo

\secao{8. Assignments}

Assignments are how we initialize variables, how we modify their
values and how we store the result of expressions.

The syntax for an assignment is:

\alinhaverbatim
<Assignment> -> <Variable> = <Right Side> |
                <Variable> := <Right Side> |
<Right Side> -> <Expression> | <Assignment>
\alinhanormal

This means that we can chain assignments, for example, in the code
below, all variables, if numeric, will store the value 5:

\alinhaverbatim
a = b = c = 5;
\alinhanormal

If in the beginning of a statement we find a variable, then certainly
we are dealing with an assignment.

We will begin teaching our lexer that both tokens ``\monoespaco{=}''
and ``\monoespaco{:=}'' are equivalent, represent the same thing and
have an special meaning:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_ASSIGNMENT            19 // Symbolic token '='
#define TYPE_ASSIGNMENT2           20 // Symbolic token ':='
@
\fimcodigo

Both types are added to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"=", ":=",
@
\fimcodigo

But to simplify the code, we will transform the second type in the
first and consider only the first kind of assignment:

\iniciocodigo
@<Change Type in Token Creation for Special Cases@>+=
else if(token_type == TYPE_ASSIGNMENT2)
  token_type = TYPE_ASSIGNMENT;
@
\fimcodigo


Now that we have this new kind of token, the code to evaluate
assignments is described below. What it does is walk over the tokens
in the assignment detecting all variables that should pass by the
assignment. While it does it, it checks if all them are declared, if
all them have the same type, if we are assigning to something that is
not a variable, if we forget the assignment symbol, or if we are
missing an expression after the assignment. If one of these things are
detected, an error is generated.

The part that we still will not show is how we evaluate the expression
after the last assignment symbol and how in the end we update the
value for each variable to be equal what was evaluated. How we do
these things change depending on the variable types, each type have
its own expressions and its own way of storing the value in the
variables. These details will be shown in the next subsections.

\iniciocodigo
@<Statement: Assignment@>=
else if(((struct generic_token *) begin_token_list) -> type ==
        TYPE_SYMBOLIC){
  struct symbolic_token *var = (struct symbolic_token *) begin_token_list;
  struct generic_token *begin_expression;
  int type = 0; // Type for the variables being assigned
  int number_of_variables = 0;
  do{
    if(var -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Non-symbolic "
              "token in left side of assignment.\n", mf -> file,
              var -> line);
#endif
      return false;
    }
    if(var -> var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
              "'%s'.\n", mf -> file, var -> line, var -> value);
#endif
      return false;
    }
    number_of_variables ++;
    if(type == 0)
      type = ((struct variable *) (var -> var)) -> type;
    else if(((struct variable *) (var -> var)) -> type != type){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Assigning variables "
              "with different types: '%s'.\n", mf -> file,
              var -> line, var -> value);
#endif
      return false;    
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
    if(var -> type != TYPE_ASSIGNMENT){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Variable in left-side "
              "without assignment.\n", mf -> file, var -> line);
#endif
      return false;    
    }
    if((void *) var != end_token_list)
      var = (struct symbolic_token *) (var -> next);
    else
      var = NULL;
  } while(var != NULL &&
          ((struct generic_token *) (var -> next)) -> type ==
          TYPE_ASSIGNMENT);
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Empty expression in "
              "assignment.\n", mf -> file, var -> line);
#endif
      return false;
  }
  begin_expression = (struct generic_token *) var;
  @<Assignment for Numeric Variables@>
  @<Assignment for Pair Variables@>
  @<Assignment for Path Variables@>
  return true;
}
@
\fimcodigo

\subsecao{8.1. Numeric Assignments and Expressions}

How do we assign numeric variables given the code above? We use the
following code:

\iniciocodigo
@<Assignment for Numeric Variables@>=
if(type == TYPE_T_NUMERIC){
  int i;
  bool ret;
  struct numeric_variable result;
  ret = eval_numeric_expression(mf, cx, begin_expression,
                               (struct generic_token *) *end_token_list,
                               &result);
  if(!ret)
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_numeric_variable((struct numeric_variable *) var -> var,
                            &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The function that makes the assignment is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source);
@
\fimcodigo

And its simple implementation is given below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_numeric_variable(struct numeric_variable *target,
                            struct numeric_variable *source){
  target -> value = source -> value;
}
@
\fimcodigo

Now we will write how to interpret numeric expressions.

\subsubsecao{8.1.1. Sum and Subtraction: Normal and Pythagorean}

The rules for numeric expressions begins as:

\alinhaverbatim
<Numeric Expression> -> <Numeric Tertiary>
<Numeric Tertiary> -> <Numeric Secundary> |
                      <Numeric Tertiary> <T-Op> <Numeric Secundary>
<T-Op> -> + | - | ++ | +-+
\alinhanormal

The symbols \monoespaco{+} and \monoespaco{-} represent the usual
addition and subtraction. The symbol \monoespaco{++} should not be
confused with C language increment and means the pythagorean sum:

$$
a ++ b = \sqrt{a^2 + b^2}
$$

This can be easily computed in C using the
function \monoespaco{hypot} from the standard math library.

The symbol \monoespaco{+-+} is the ``pythagorean subtraction'' defined
below:

$$
a +-+ b = \sqrt{a^2 - b^2} = \sqrt{(a+b)(a-b)} = \sqrt{a+b}\sqrt{a-b}
$$

We will compute the pythagorean subtraction using the last definition,
as the multiplication of two square roots. This is the computation
that minimizes errors involving overflows and underflows.

The four operators above are the ones with smaller precedence. These
operations will be done only after all other mathematical operations.

Now we will improve our lexer making it identify and create the new
tokens for these operators. We also will create new token types for
``['' and ``]'', as we will need to identify these tokens in our
parser:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_SUM                   21 // Symbolic token '+'
#define TYPE_SUBTRACT              22 // Symbolic token '-'
#define TYPE_PYTHAGOREAN_SUM       23 // Symbolic token '++'
#define TYPE_PYTHAGOREAN_SUBTRACT  24 // Symbolic token '+-+'
#define TYPE_OPEN_BRACKETS         25 // Symbolic token '['
#define TYPE_CLOSE_BRACKETS        26 // Symbolic token ']'
#define TYPE_OPEN_BRACES           27 // Symbolic token '{'
#define TYPE_CLOSE_BRACES          28 // Symbolic token '}'
@
\fimcodigo

And we add them to the list of keywords:

\iniciocodigo
@<List of Keywords@>+=
"+", "-", "++", "+-+", "[", "]", "{", "}",
@
\fimcodigo

Now let's evaluate numeric expressions, which means evaluating
tertiary numeric expressions. The function is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

The tertiary numeric expressions is where we solve additions and
subtractions. By the syntax rules, what we need to do is walk over the
tokens in the expression until find the last tertiary operator that is
not delimited by parenthesis or brackets. Everything in the left side
should be recursively evaluated as another tertiary
expression. Everything in the right side should be interpreted as a
secundary numeric expression. Finally, if we did not find any tertiary
operator, the entire expression is evaluated as a secundary numeric
expression.

However, there are some exceptions, cases in which the
symbols \monoespaco{+} and \monoespaco{-} should not be treated as a
sum or subtraction. This happens if they are in the beginning of the
numeric expression, or if before them there is a comma, an opening
bracket, a multiplication or division symbol, another tertiary
operator, or one of the following tokens that we will define later:
\monoespaco{length}, \monoespaco{sqrt}, \monoespaco{sind},
\monoespaco{cosd}, \monoespaco{log}, \monoespaco{exp},
\monoespaco{floor},  \monoespaco{uniformdeviate}, \monoespaco{rotated},
\monoespaco{shifted}, \monoespaco{slanted}, \monoespaco{xscaled},
\monoespaco{yscaled}, \monoespaco{zscaled}.

If we have a previous token (\monoespaco{prev}) and the current one
(\monoespaco{cur}), we can check if it represents a valid sum or
subtraction with the macro below:

\iniciocodigo
@<Local Macros (metafont.c)@>+=
#define IS_VALID_SUM_OR_SUB(prev, cur)                   \
        ((cur -> type == TYPE_SUM ||                    \
         cur -> type == TYPE_SUBTRACT) &&               \
         (prev != NULL && prev -> type != TYPE_COMMA && \
          prev -> type != TYPE_OPEN_BRACKETS &&          \
          prev -> type != TYPE_MULTIPLICATION &&        \
          prev -> type != TYPE_DIVISION &&              \
          prev -> type != TYPE_SUM &&                   \
          prev -> type != TYPE_SUBTRACT &&              \
          prev -> type != TYPE_PYTHAGOREAN_SUM &&       \
          prev -> type != TYPE_PYTHAGOREAN_SUBTRACT &&  \
          prev -> type != TYPE_LENGTH &&                \
          prev -> type != TYPE_SQRT &&                  \
          prev -> type != TYPE_SIND &&                  \
          prev -> type != TYPE_COSD &&                  \
          prev -> type != TYPE_LOG &&                   \
          prev -> type != TYPE_EXP &&                   \
          prev -> type != TYPE_FLOOR &&                 \
          prev -> type != TYPE_ROTATED &&               \
          prev -> type != TYPE_SCALED &&                \
          prev -> type != TYPE_SHIFTED &&               \
          prev -> type != TYPE_SLANTED &&               \
          prev -> type != TYPE_XSCALED &&               \
          prev -> type != TYPE_YSCALED &&               \
          prev -> type != TYPE_ZSCALED &&               \
          prev -> type != TYPE_UNIFORMDEVIATE))
@
\fimcodigo
\iniciocodigo
@<Operador Secundário de Pares: Escala-X@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

The following code interprets tertiary numeric expressions and
identify correctly the tertiary operators with the help of the macro:


\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_expression(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secundary,
                       *last_sum = NULL, *p, *prev = NULL;
  int nesting_parenthesis = 0, nesting_brackets = 0, nesting_braces = 0;
  struct numeric_variable a, b;
  p = begin_expression;
  do{
    if(p -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis --;
    else if(p -> type == TYPE_OPEN_BRACKETS)
      nesting_brackets ++;
    else if(p -> type == TYPE_CLOSE_BRACKETS)
      nesting_brackets --;
    else if(p -> type == TYPE_OPEN_BRACES)
      nesting_braces ++;
    else if(p -> type == TYPE_CLOSE_BRACES)
      nesting_braces --;
    else if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
            nesting_braces == 0 &&
            (p -> type == TYPE_PYTHAGOREAN_SUM ||
             p -> type == TYPE_PYTHAGOREAN_SUBTRACT ||
             IS_VALID_SUM_OR_SUB(prev, p))){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secundary = (struct generic_token *) (last_sum -> next);
    eval_numeric_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_numeric_secundary(mf, cx, begin_secundary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM)
      result -> value = a.value + b.value;
    else if(last_sum -> type == TYPE_SUBTRACT)
      result -> value = a.value - b.value;
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUM)
      result -> value = hypotf(a.value, b.value);
    else if(last_sum -> type == TYPE_PYTHAGOREAN_SUBTRACT){
      result -> value = sqrtf(a.value + b.value) *
        sqrtf(a.value - b.value);
      if(isnan(result -> value)){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Negative square root "
                " in pythagorean subtraction.\n", mf -> file,
                last_sum -> line);
#endif
        return false;
      }
    }
    return true;
  }
  else
    return eval_numeric_secundary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.2. Multiplication and Division}

The rules to deal with secundary numeric expressions are:

\alinhaverbatim
<Numeric Secundary> -> <Numeric Primary> |
                       <Numeric Secundary> <S-Op> <Numeric Primary>
<S-Op> -> * | /
\alinhanormal

The operators \monoespaco{*} and \monoespaco{/} are respectively the
multiplication and division.

Let's add these operators as reserved tokens and define their types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_MULTIPLICATION        29 // Symbolic token '*'
#define TYPE_DIVISION              30 // Symbolic token '/'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"*", "/",
@
\fimcodigo

The function that will evaluate numeric secundary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result);
@
\fimcodigo

And its definition is very similar with the function that evaluates
tertiary expressions, except that this function computes
multiplication and division.

However, there is an additional rule that we should be aware: the
token ``/'' will be considered division only if it is not delimited by
two numeric tokens. If so, then it represents a fraction and it should
be computed with a higher precedence than what we deal here. However,
if the token before the previous one already was considered part of a
fraction, then in this case we have a division despide being
surrounded by numeric tokens. This way the code \monoespaco{1/3/1/3}
is interpreted as a division between two fractions $(1/3)/(1/3)$:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_token_list,
                             struct numeric_variable *result){
  struct generic_token *end_secundary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  int nesting_parenthesis = 0, nesting_brackets = 0, nesting_braces = 0;
  struct numeric_variable a, b;
  b.value = 0.0;
  p = begin_expression;
  do{
    if(p -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis --;
    else if(p -> type == TYPE_OPEN_BRACKETS)
      nesting_brackets ++;
    else if(p -> type == TYPE_CLOSE_BRACKETS)
      nesting_brackets --;
    else if(p -> type == TYPE_OPEN_BRACES)
      nesting_braces ++;
    else if(p -> type == TYPE_CLOSE_BRACES)
      nesting_braces --;
    else if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
            nesting_braces == 0 &&
            (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_token_list &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ // Valid multiplication or division
         last_mul = p;
         end_secundary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secundary != NULL){
    begin_primary = (struct generic_token *) (last_mul -> next);
    eval_numeric_secundary(mf, cx, begin_expression, end_secundary, &a);
    eval_numeric_primary(mf, cx, begin_primary, end_token_list, &b);
    if(last_mul -> type == TYPE_MULTIPLICATION)
      result -> value = a.value * b.value;
    else if(last_mul -> type == TYPE_DIVISION){
      if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.\n",
                mf -> file, last_mul -> line);
#endif
        return false;
      }
      result -> value = a.value / b.value;
    }
    return true;
  }
  else
    return eval_numeric_primary(mf, cx, begin_expression,
                                end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.1.3. Modulus,
  Trigonometric Functions,  Exponentials, Floor and
  Random Uniform Values}

The rules for primary numeric expressions are:

\alinhaverbatim
<Numeric Primary> -> <Numeric Atom> |
                     length <Numeric Primary> | (...) |
                     <Numeric Operator> <Numeric Primary>
<Numeric Operator> -> sqrt | sind | cosd | mlog | mexp | floor |
                       uniformdeviate |
                       <Scalar Multiplication Operator>
<Scalar Multiplication Operator> -> + | - |
                       <Primary Numeric Token Before Variable>
<Primary Numeric Token> -> <Numeric Token> / <Numeric Token> |
                           <Numeric Token>
\alinhanormal

The operator \monoespaco{length}, when appearing before a numeric
primery means that we want its modulus. If it appears before another
kind of primary expression, it could mean different things.

The new modulus operator should be added to the list of reserved
words. We will add also the other new operators from the list of
numeric operators. The brackets are already in this list:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_LENGTH         31 // Symbolic token 'length'
#define TYPE_SQRT           32 // Symbolic token 'sqrt'
#define TYPE_SIND           33 // Symbolic token 'sind'
#define TYPE_COSD           34 // Symbolic token 'cosd'
#define TYPE_LOG            35 // Symbolic token 'log'
#define TYPE_EXP            36 // Symbolic token 'exp'
#define TYPE_FLOOR          37 // Symbolic token 'floor'
#define TYPE_UNIFORMDEVIATE 38 // Symbolic token 'uniformdeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"length", "sqrt", "sind", "cosd", "log", "exp", "floor", "uniformdeviate",
@
\fimcodigo

The function that evaluates a primary numeric expression is this:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result);
@
\fimcodigo


We can decide which syntax rule should be applied while evaluating the
primary numeric expression using seven different interpretation rules:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_primary(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_expression,
                          struct numeric_variable *result){
  @<Numeric Primary: Rule 1@>
  @<Numeric Primary: Rule 2@>
  @<Numeric Primary: Rule 3@>
  @<Numeric Primary: Additional Operators@>
  @<Numeric Primary: Rule 4@>
  return true;
}
@

The rules are:

1) If the expression is composed by a single token, or if it begins
with ``('' and ends with ``)'', or if it is composed by three tokens,
a numeric, a division and another numeric, then the entire expression
is a numeric atom:

\iniciocodigo
@<Numeric Primary: Rule 1@>=
if(begin_expression == end_expression ||
   (begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
    end_expression -> type == TYPE_CLOSE_PARENTHESIS) ||
    (begin_expression -> type == TYPE_NUMERIC &&
     begin_expression -> next != end_expression &&
     ((struct generic_token *) begin_expression -> next) -> type ==
       TYPE_DIVISION &&
     ((struct generic_token *) begin_expression -> next) -> next ==
       end_expression &&
     end_expression -> type == TYPE_NUMERIC)){
  return eval_numeric_atom(mf, cx, begin_expression, end_expression,
                          result);
}
@
\fimcodigo

2) If we find operator \monoespaco{length}, then we check if the
expression after it is numeric. If so, we compute its modulus. If the
expression have another type, we will define later how the operator
will proceed. We assume that we have a function that discovers the
type of a primary expression.

\iniciocodigo
@<Numeric Primary: Rule 2@>=
else if(begin_expression -> type == TYPE_LENGTH){
  int expr_type = get_primary_expression_type(mf, cx,
                                             (struct generic_token *)
                                             begin_expression -> next,
                                             end_expression);
  if(expr_type == TYPE_T_NUMERIC){
    bool ret;
    struct numeric_variable num;
    ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                               begin_expression -> next,
                               end_expression, &num);
    if(!ret)
      return false;
    result -> value = ((num.value > 0)?(num.value):(-num.value));
    return true;
  }
  @<Evaluate 'length'@>
  else{
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "primary expression after 'length'.\n", mf -> file,
            begin_expression -> line);
#endif
      return false;
  }
}
@
\fimcodigo

But how can we identify if we are facing a numeric priumary expression
or an expression of different kind? Well, reading its tokens. We still
cannot define a function that does this completely, as we still did
not define how are functions of different types. But for now we will
present the more simplist definition that if the expression is
composed by a single token, if numeric, the expression is numeric, and
if it is a variable, the expression have the same type than the
variable. This captures the simplest case:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
int get_primary_expression_type(struct metafont *mf, struct context *cx,
                               struct generic_token *begin_expr,
                               struct generic_token *end_expr){
  if(begin_expr == end_expr){
    if(begin_expr -> type == TYPE_NUMERIC)
      return TYPE_T_NUMERIC;
    else if(begin_expr -> type == TYPE_SYMBOLIC){
      struct symbolic_token *p = (struct symbolic_token *) begin_expr;
      if(p -> var == NULL)
        return 0; // Unknown
      else{
        struct variable *v = (struct variable *) (p -> var);
        return v -> type;
      }
    }
  }
  else{
    //@<Discover Primary Expression Type@>
  }
  return TYPE_T_NUMERIC;
  //return 0; // Unknown
}
@
\fimcodigo

3) If we find some of the numeric operators, we have a numeric
operator followed by a numeric primary expression.

The first numeric operator is the square root:

\iniciocodigo
@<Numeric Primary: Rule 3@>=
else if(begin_expression -> type == TYPE_SQRT){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value < 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Square root "
            "of negative number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = sqrtf(num.value);
  return true;  
}
@
\fimcodigo

Next we have the operator \monoespaco{sind}, which interprets the next
number in degrees (because of this it has the letter ``d'' in the end)
and computes the sine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SIND){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = sinf(num.value * 0.0174533);
  return true;  
}
@
\fimcodigo

Computing the cosine:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_COSD){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  // 1 degree = 0,0174533 radians
  result -> value = cosf(num.value * 0.0174533);
  return true;
}
@
\fimcodigo

Computing the logarithm in $e$ basis:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_LOG){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  if(num.value <= 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Computing logarithm of "
            "non-positive number.\n", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }    
  result -> value = logf(num.value);
  return true;  
}
@
\fimcodigo

And the exponential which means $exp x = e^x$:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_EXP){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = expf(num.value);
  return true;  
}
@
\fimcodigo

The floor of a given value:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_FLOOR){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  result -> value = floorf(num.value);
  return true;  
}
@
\fimcodigo

About the operator \monoespaco{uniformdeviate}, it generates a number
uniform and random between 0 and the value passed as operand. We can
compute this generating a number between 0 and 1 and then multiply
this value with the operand.

Generating a floating point number between 0 and 1 following a
distribution near to uniform can be done generating a random 64-bit
number and then multiplying it with $2^{-64}$. Not all possible
floating-point numbers could be represented generating them this
way. Numbers smaller than $2^{-64}$ would be ignored and the rounding
would make some numbers near 1 more probable, but we also would have
less density in the range near 1. However, despithe these drawbacks,
the result would be sufficiently precise for our purposes:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_UNIFORMDEVIATE){
  bool ret;
  struct numeric_variable num;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, &num);
  if(!ret)
    return false;
  { // Generating the random number
    uint64_t random_bits = random_func();
    float multiplicand = (float) ldexp((double) random_bits, -64);
    result -> value = multiplicand * num.value;  
  }
  return true;  
}
@
\fimcodigo

If the next operator is the symbol \monoespaco{+}, this means a
multiplication by 1. This operation can be ignored:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUM){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  return true;  
}
@
\fimcodigo

But if the operator is a symbol \monoespaco{-}, hen this means a
multiplication by -1:

\iniciocodigo
@<Numeric Primary: Rule 3@>+=
else if(begin_expression -> type == TYPE_SUBTRACT){
  bool ret;
  ret = eval_numeric_primary(mf, cx, (struct generic_token *)
                             begin_expression -> next,
                             end_expression, result);
  if(!ret)
    return false;
  result -> value *= -1; 
  return true;  
}
@
\fimcodigo

4) In the remaining cases, we have a scalar multiplicationwhere the
scalar is a primary numeric token that is not followed
by \monoespaco{+}, \monoespaco{-} or another numeric token. To deal
with this, we needto identify the beginning and end of the primary
numeric token. BY the rules it is a single numeric token, or three
tokens (two numeric ones separated by a \monoespaco{/}). After
separating the parts, the first part is multiplied by the second (a
numeric primary expression):

\iniciocodigo
@<Numeric Primary: Rule 4@>=
else{
  bool ret;
  float token_value;
  struct generic_token *after_token;
  if(begin_expression -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  token_value = ((struct numeric_token *) begin_expression) -> value;
  after_token = (struct generic_token *) (begin_expression -> next);
  if(after_token -> type == TYPE_DIVISION){
    if(after_token == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    after_token = (struct generic_token *) (after_token -> next);
    token_value /= ((struct numeric_token *) after_token) -> value;
    after_token = (struct generic_token *) (after_token -> next);
  }
  ret = eval_numeric_primary(mf, cx, after_token, end_expression, result);
  if(!ret)
    return false;
  result -> value *= token_value;
  return true;
}
@
\fimcodigo

\subsubsecao{8.1.4. Isolated Numbers and Random Normal Values}

The final rules for numeric expressions are:

\alinhaverbatim
<Numeric Atom> -> <Numeric Variable> |
                  <Primary Numeric Token> |
                  ( <Numeric Expression> ) |
                  normaldeviate
\alinhanormal

The only new token in this part is \monoespaco{normaldeviate}:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_NORMALDEVIATE  39 // O token simbólico 'normaldeviate'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"normaldeviate",
@
\fimcodigo

This operator creates a new random number taken from a n ormal
distribution with mean 0 and standard deviation 1.

The function that evaluates numeric atoms is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result);
@
\fimcodigo

We will decide which rule to apply while evaluating the numeric atom
first checking if we have a single token or not, and then applying
different rules based on this:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_numeric_atom(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct numeric_variable *result){
  if(begin_expression == end_expression){
    @<Numeric Atom: Rule 1@>
    @<Numeric Atom: Rule 2@>
    @<Numeric Atom: Rule 3@>
  }
  else{
    @<Numeric Atom: Rule 4@>
    @<Numeric Atom: Rule 5@>
  }
  return true;
}
@

1) If we have a single token and it is a numeric token, we just return
its value:

\iniciocodigo
@<Numeric Atom: Rule 1@>=
if(begin_expression -> type == TYPE_NUMERIC){
  result -> value = ((struct numeric_token *) begin_expression) -> value;
  return true;
}
@
\fimcodigo

2) If we have a single token and it is a variable, we return its
content. But we first need to check if the variable was declared, if
it is numeric and if it was initialized:

\iniciocodigo
@<Numeric Atom: Rule 2@>=
if(begin_expression -> type == TYPE_SYMBOLIC){
  struct numeric_variable *var;
  var = ((struct symbolic_token *) begin_expression) -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_NUMERIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-numeric variable "
            "'%s' in numeric expression.\n", mf -> file,
            begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  if(isnan(var -> value)){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unitialized variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            ((struct symbolic_token *) begin_expression) -> value);
#endif
    return false;
  }
  result -> value = var -> value;
  return true;
}
@
\fimcodigo

3) Finally, if we have a single token and it is
a \monoespaco{normaldeviate}, then we need to generate a random number
taken from a normal distribution. Given that we already have a
function to generate random bits, we can simulate a normal
distribution following these steps:

a) First we generate two random numbers between -1 and 1. We will call
them $u$ and $v$. e can generate them getting 64 random bits,
multiplying the first 63 by $2^{-63}$ and using the remaining bit to
choose the signal. The result is sufficiently close to uniform.

b) If $u^2+v^2\geq 1$, the numbers form a point outside a circle with
radius 1. In this case, the result should be discarded and we try to
generate numbers again. We also discard the result if both numbers are
zero, as in this case our method do not work.

c) After this, we can produce two numbers following a normal
distribution computing:

$$
x_0 = u\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

$$
x_1 = v\sqrt{-2\ln(u^2+v^2)/(u^2+v^2)}
$$

One of the values will be returned. The other can be stored to be
returned next time we need a random normal value. We store it in the
Metafont struct:

\iniciocodigo
@<Attributes (struct metafont)@>+=
  bool have_stored_normaldeviate;
  float normaldeviate;
@
\fimcodigo

Initially the structure will have no value stored. We will store
values there only after using the procedure descrbed above:

\iniciocodigo
@<Initialization (struct metafont)@>+=
mf -> have_stored_normaldeviate = false;
@
\fimcodigo

So, when we need to generate a normal rando value, we always check
first if we already have a pre-generated value, and if not, we
generate two values:

\iniciocodigo
@<Numeric Atom: Rule 3@>=
if(begin_expression -> type == TYPE_NORMALDEVIATE){
  if(mf -> have_stored_normaldeviate){
    mf -> have_stored_normaldeviate = false;
    result -> value = mf -> normaldeviate;
    return true;
  }
  else{
    uint64_t random_bits;
    float u, v, s;
    random_bits = random_func();
    do{
      u = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      v = (float) ldexp((double) (random_bits >> 1), -63) *
            ((random_bits %2)?(-1.0):(+1.0));
      s = u*u + v*v;
    } while(s >= 1.0 || s == 0.0);    
    u *= (float) sqrt((-2.0 * log((double) s))/s);
    v *= (float) sqrt((-2.0 * log((double) s))/s);
    mf -> have_stored_normaldeviate = true;
    mf -> normaldeviate = u;
    result -> value = v;
    return true;
  }
}
@
\fimcodigo

4) Now the cases where we have more than one token. If the first token
in ``('' and the last one is ``)'', we compute the inner expression as
a numeric expression, and then return the result discarding the
parenthesis:

\iniciocodigo
@<Numeric Atom: Rule 4@>=
if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
   end_expression -> type == TYPE_CLOSE_PARENTHESIS){
   bool ret;
   struct generic_token *p = begin_expression;
   while(p -> next != end_expression)
     p = (struct generic_token *) p -> next;
   if(p == begin_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Empty parenthesis.",
            mf -> file, begin_expression -> line);
#endif
     return false;
   }
   ret = eval_numeric_expression(mf, cx, (struct generic_token *)
                                         begin_expression -> next, p,
                                         result);
   if(!ret)
     return false;
   return true;
}
@
\fimcodigo

5) Finally, the case when the numeric atom is a fraction composed by a
numeric token, \monoespaco{/} and another numeric token. The result is
obtained dividing both tokens:

\iniciocodigo
@<Numeric Atom: Rule 5@>=
if(begin_expression -> type == TYPE_NUMERIC &&
   end_expression -> type == TYPE_NUMERIC &&
   ((struct generic_token * ) begin_expression -> next) -> type ==
   TYPE_DIVISION){
  result -> value = ((struct numeric_token *) begin_expression) -> value /
           ((struct numeric_token *) end_expression) -> value;
  return true;
}
@
\fimcodigo

\subsecao{8.2. Pair Assignments and Expressions}

To make the assignment to pair variables, we use the code below:

\iniciocodigo
@<Assignment for Pair Variables@>=
else if(type == TYPE_T_PAIR){
  int i;
  struct pair_variable result;
  if(!eval_pair_expression(mf, cx, begin_expression,
                           (struct generic_token *) *end_token_list,
                           &result))
    return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_pair_variable((struct pair_variable *) var -> var, &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
}
@
\fimcodigo

The declaration for the assignment function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_pair_variable(struct pair_variable *target,
                          struct pair_variable *source){
  target -> x = source -> x;
  target -> y = source -> y;
}
@
\fimcodigo

Now let's see how to evaluate  pair expressions.

\subsubsecao{8.2.1. Sum and Subtraction}

The grammar rules for pair tertiary expressions begin with sum and
subtraction:

\alinhaverbatim
<Pair Expression> -> <Pair Tertiary>
<Pair Tertiary> -> <Pair Secundary> | (...) |
                   <Pair Tertiary> <PT-Op> <Pair Secundary>
<PT-Op> -> + | -
\alinhanormal

Sum and subtraction is evaluated exactly as expected from vector sum
and subtraction.

The function that evaluates pair expressions is declared here:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result);
@
\fimcodigo

The method to evaluate tertiary pair expressions are not different
from what we already defined with numeric expressions. We just have
fewer tertiary operators here.

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_expression(struct metafont *mf, struct context *cx,
                          struct generic_token *begin_expression,
                          struct generic_token *end_token_list,
                          struct pair_variable *result){
  struct generic_token *end_tertiary = NULL, *begin_secundary,
                       *last_sum = NULL, *p, *prev = NULL;
  int nesting_parenthesis = 0, nesting_brackets = 0, nesting_braces = 0;
  struct pair_variable a, b;
  p = begin_expression;
  do{
    if(p -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis --;
    else if(p -> type == TYPE_OPEN_BRACKETS)
      nesting_brackets ++;
    else if(p -> type == TYPE_CLOSE_BRACKETS)
      nesting_brackets --;
    else if(p -> type == TYPE_OPEN_BRACES)
      nesting_braces ++;
    else if(p -> type == TYPE_CLOSE_BRACES)
      nesting_braces --;
    else if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
            nesting_braces == 0 && IS_VALID_SUM_OR_SUB(prev, p)){
      last_sum = p;
      end_tertiary = prev;
    }
    prev = p;
    if(p != end_token_list)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_tertiary != NULL){
    begin_secundary = (struct generic_token *) (last_sum -> next);
    eval_pair_expression(mf, cx, begin_expression, end_tertiary, &a);
    eval_pair_secundary(mf, cx, begin_secundary, end_token_list, &b);
    if(last_sum -> type == TYPE_SUM){
      result -> x = a.x + b.x;
      result -> y = a.y + b.y;
    }
    else if(last_sum -> type == TYPE_SUBTRACT){
      result -> x = a.x - b.x;
      result -> y = a.y - b.y;
    }
    return true;
  }
  else
    return eval_pair_secundary(mf, cx, begin_expression,
                                   end_token_list, result);
}
@
\fimcodigo

\subsubsecao{8.2.2. Transformers and Scalar Multiplication and Division}

The grammar for secundary pair expressions is:

\alinhaverbatim
<Pair Secundary> -> <Pair Primary> |
                    <Pair Secundary><Mul or Div><Numeric Primary> |
                    <Numeric Secundary> * <Pair Primary> |
                    <Pair Secundary><Transformer>
<Mul or Div> -> * | /
<Transformer> -> rotated <Numeric Primary> |
                 scaled <Numeric Primary> |
                 shifted <Pair Primary> |
                 slanted <Numeric Primary> |
                 xscaled <Numeric Primary> |
                 yscaled <Numeric Primary> |
                 zscaled <Pair Primary>
\alinhanormal

Let's add the seven new keywords representing transformers:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_ROTATED  40 // Symbolic token 'rotated'
#define TYPE_SCALED   41 // Symbolic token 'scaled'
#define TYPE_SHIFTED  42 // Symbolic token 'shifted'
#define TYPE_SLANTED  43 // Symbolic token 'slanted'
#define TYPE_XSCALED  44 // Symbolic token 'xscaled'
#define TYPE_YSCALED  45 // Symbolic token 'yscaled'
#define TYPE_ZSCALED  46 // Symbolic token 'zscaled'
@
\fimcodigo

\iniciocodigo
@<List of Keywords@>+=
"rotated", "scaled", "shifted", "slanted", "xscaled", "yscaled",
"zscaled",
@
\fimcodigo


The function that evaluates secundary pair expressions is declared
below:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_secundary(struct metafont *mf, struct context *cx,
                         struct generic_token *begin_expression,
                         struct generic_token *end_expression,
                         struct pair_variable *result);
@
\fimcodigo

Evaluating a secundary expression here is very similar to what we did
for numeric expressions. We also walk over the token list searching
for the rightmost secundary operator, ignoring anything nested inside
parenthesis and brackets. We follow the same rules to check when we
have a division and when the symbol \monoespaco{/} is just a fraction
separator. The difference is that here we have a total of nine
secundary operators including the transformers. Because of the big
quantity, we will show each of them separately instead of all them in
the code block below:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_secundary(struct metafont *mf, struct context *cx,
                             struct generic_token *begin_expression,
                             struct generic_token *end_expression,
                             struct pair_variable *result){
  struct generic_token *end_secundary = NULL, *begin_primary,
                       *last_mul = NULL, *p, *prev = NULL,
                       *prev_prev = NULL, *last_fraction = NULL;
  int nesting_parenthesis = 0, nesting_brackets = 0, nesting_braces = 0;
  p = begin_expression;
  do{
    if(p -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(p -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis --;
    else if(p -> type == TYPE_OPEN_BRACKETS)
      nesting_brackets ++;
    else if(p -> type == TYPE_CLOSE_BRACKETS)
      nesting_brackets --;
    else if(p -> type == TYPE_OPEN_BRACES)
      nesting_braces ++;
    else if(p -> type == TYPE_CLOSE_BRACES)
      nesting_braces --;
    else if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
            nesting_braces == 0 &&
            (p -> type == TYPE_MULTIPLICATION ||
             p -> type == TYPE_DIVISION || p -> type == TYPE_ROTATED ||
             p -> type == TYPE_SCALED || p -> type == TYPE_SHIFTED ||
             p -> type == TYPE_SLANTED || p -> type == TYPE_XSCALED ||
             p -> type == TYPE_YSCALED || p -> type == TYPE_ZSCALED)){
      if(p -> type == TYPE_DIVISION && prev -> type == TYPE_NUMERIC &&
         p != end_expression &&
         ((struct generic_token *) p -> next) -> type != TYPE_NUMERIC &&
         last_fraction != prev_prev) // Fraction separator
         last_fraction = p;
       else{ //  Divisão ou operadores válidos
         last_mul = p;
         end_secundary = prev;
       }
    }
    prev_prev = prev;
    prev = p;
    if(p != end_expression)
      p = (struct generic_token *) p -> next;
    else
      p = NULL;
  }while(p != NULL);
  if(end_secundary != NULL){
    bool ret;
    begin_primary = (struct generic_token *) (last_mul -> next);
    @<Secundary Pair Operator: Multiplication@>
    @<Secundary Pair Operator: Division@>
    @<Secundary Pair Operator: Rotation@>
    @<Secundary Pair Operator: Scaling@>
    @<Secundary Pair Operator: Shifting@>
    @<Secundary Pair Operator: Slanting@>
    @<Secundary Pair Operator: X-Scaling@>
    @<Secundary Pair Operator: Y-Scaling@>
    @<Secundary Pair Operator: Z-Scaling@>
  }
  else
    return eval_pair_primary(mf, cx, begin_expression,
                             end_expression, result);
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@
\fimcodigo

The first operator is the multiplication. Notice that we can have two
different multiplications: a pair multiplicated by a numeric or a
numeric multiplicated by a pair. To identify which of the two should
be applied, we must check the primary expression to the right of the
operator. It is a primary expression and we have a function that
identifies the type of a primary expression:

\iniciocodigo
@<Secundary Pair Operator: Multiplication@>=
if(last_mul -> type == TYPE_MULTIPLICATION){
  if(get_primary_expression_type(mf, cx, begin_primary, end_expression) ==
     TYPE_T_PAIR){
    struct numeric_variable a;
    struct pair_variable b;
    if(!eval_numeric_secundary(mf, cx, begin_expression, end_secundary,
                               &a))
      return false;
    if(!eval_pair_primary(mf, cx, begin_primary, end_expression, &b))
      return false;
    result -> x = b.x * a.value;
    result -> y = b.y * a.value;
    return true;
  }
  else{
    struct pair_variable a;
    struct numeric_variable b;
    ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary,
                              &a);
    if(!ret)
      return false;
    ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
    if(!ret)
      return false;
    result -> x = a.x * b.value;
    result -> y = a.y * b.value;
    return true;
  }    
}
@
\fimcodigo

If we have a division, then this always will be a pair divided by a
numeric. We should generate an error in case of division by zero:

\iniciocodigo
@<Secundary Pair Operator: Division@>=
else if(last_mul -> type == TYPE_DIVISION){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  if(b.value == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Division by zero.",
            mf -> file, last_mul -> line);
#endif
    return false;
  }
  result -> x = a.x / b.value;
  result -> y = a.y / b.value;
  return true;
}
@
\fimcodigo

If we have a rotation, we rotate our pair counter-clockwise using the
origin as the axis. We interpret angles in degrees, not in radians:

\iniciocodigo
@<Secundary Pair Operator: Rotation@>=
else if(last_mul -> type == TYPE_ROTATED){
  struct pair_variable a;
  struct numeric_variable b;
  double sin_theta, cos_theta, theta;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  theta = 0.0174533 * b.value;
  sin_theta = sin(theta);
  cos_theta = cos(theta);
  result -> x = a.x * cos_theta - a.y * sin_theta;
  result -> y = a.x * sin_theta + a.y * cos_theta;
  return true;
}
@
\fimcodigo

A scaling is the same thing than a multiplication:

\iniciocodigo
@<Secundary Pair Operator: Scaling@>=
else if(last_mul -> type == TYPE_SCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

A shifting is equal a sum, but this operator have a higher precedence:

\iniciocodigo
@<Secundary Pair Operator: Shifting@>=
else if(last_mul -> type == TYPE_SHIFTED){
  struct pair_variable a, b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.x;
  result -> y = a.y + b.y;
  return true;
}
@
\fimcodigo

The slanting operator shifts a point more to the right depending on
how above the axis $x$ it is and more to the left depending on how
below the axis $x$ it is:

\iniciocodigo
@<Secundary Pair Operator: Slanting@>=
else if(last_mul -> type == TYPE_SLANTED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x + b.value * a.y;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

A x-scaling multiplies a numeric scalar to the first value in the
pair:

\iniciocodigo
@<Secundary Pair Operator: X-Scaling@>=
else if(last_mul -> type == TYPE_XSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.value;
  result -> y = a.y;
  return true;
}
@
\fimcodigo

Likewise a y-scaling multiplies a numeric scalar to the second value
in the pair:

\iniciocodigo
@<Secundary Pair Operator: Y-Scaling@>=
else if(last_mul -> type == TYPE_YSCALED){
  struct pair_variable a;
  struct numeric_variable b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_numeric_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x;
  result -> y = a.y * b.value;
  return true;
}
@
\fimcodigo

Finally, a z-scaling interprets two pairs as complex numbers and
multiply them:

$$
(a+bi)(c+di) = ac + (ad)i + (cb)i + (bd)i^2 = (ac - bd) + (cb+ad)i
$$

\iniciocodigo
@<Secundary Pair Operator: Z-Scaling@>=
else if(last_mul -> type == TYPE_ZSCALED){
  struct pair_variable a, b;
  ret = eval_pair_secundary(mf, cx, begin_expression, end_secundary, &a);
  if(!ret)
    return false;
  ret = eval_pair_primary(mf, cx, begin_primary, end_expression, &b);
  if(!ret)
    return false;
  result -> x = a.x * b.x - a.y * b.y;
  result -> y = a.x * b.y + b.x * a.y;
  return true;
}
@
\fimcodigo

\subsubsecao{8.2.3. Pair Intermediary Values, Literals and Variables}

The final grammar rules for pair expressions are:

\alinhaverbatim
<Pair Primary> -> <Pair Variable> |
                  ( <Numeric Expression> , <Numeric Expression> ) |
                  ( <Pair Expression> ) |
                  <Numeric Atom> [ <Pair Expression, <Pair Expression>] |
                  (...) |
                  <Scalar Multiplication Operator><Pair Primary>
\alinhanormal

The novel operator is the constructionn $a[b, c]$, where $b$ and $c$
are pairs. It represents intermediary values between $b$ end $c$. It
is evaluated as $a(b+c)$. This means that $.5[a,b]$ is half the path
between $b$ and $c$.

The other rules are analogous to what we already described in the
grammar for numeric expressions.

The function that will evaluate pair primary expressions is:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result);
@
\fimcodigo

Each one of the five grammar rules will be tested separately to
discover which one we should apply when we find a primary expression:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
bool eval_pair_primary(struct metafont *mf, struct context *cx,
                       struct generic_token *begin_expression,
                       struct generic_token *end_expression,
                       struct pair_variable *result){
  if(begin_expression == end_expression){
    @<Pair Primary: Rule 1@>
  }
  else if(begin_expression -> type == TYPE_OPEN_PARENTHESIS &&
          end_expression -> type == TYPE_CLOSE_PARENTHESIS){
    @<Pair Primary: Rule 2@>
    @<Pair Primary: Rule 3@>
  }
  @<Pair Primary: Rule 4@>
  @<Pair Primary: Rule 5@>
#if defined(W_DEBUG_METAFONT)
  fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
          "expression.",  mf -> file, begin_expression -> line);
#endif
  return false;
}
@

The first rule will be applied when we have a single token in the
expression. The only case when it happens is when we are evaluating a
pair variable:

\iniciocodigo
@<Pair Primary: Rule 1@>=
if(begin_expression == end_expression){
  struct symbolic_token *tok = (struct symbolic_token *) begin_expression;
  struct pair_variable *var;
  if(tok -> type != TYPE_SYMBOLIC){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable token "
            "in pair expression.",  mf -> file, begin_expression -> line);
#endif
    return false;
  }
  var = (struct pair_variable *) tok -> var;
  if(var == NULL){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Undeclared variable "
            "'%s'.\n", mf -> file, begin_expression -> line,
            tok -> value);
#endif
    return false;
  }
  if(var -> type != TYPE_T_PAIR){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Non-pair variable "
            "'%s' in pair expression.\n", mf -> file,
            begin_expression -> line, tok -> value);
#endif
    return false;
  }
  result -> x = var -> x;
  result -> y = var -> y;
  return true;
}
@
\fimcodigo

If the expression is delimited by parenthesis, we could be facing a
literal representation of a pair in the form $(a, b)$, or we could be
dealing with a pair expression inside parenthesis. We can
differentiate the two cases checking the presence of a comma inside
the parenthesis, but not inside any other internal parenthesis or
bracket.

\iniciocodigo
@<Pair Primary: Rule 2@>=
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *comma;
  begin_a = (struct generic_token *) begin_expression -> next;
  end_a = begin_a;
  int nesting_parenthesis = 0, nesting_brackets = 0, nesting_braces = 0;
  bool literal = true;
  while(end_a != NULL){
    if(end_a -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(end_a -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis --;
    if(end_a -> type == TYPE_OPEN_BRACKETS)
      nesting_brackets ++;
    else if(end_a -> type == TYPE_CLOSE_BRACKETS)
      nesting_brackets --;
    if(end_a -> type == TYPE_OPEN_BRACES)
      nesting_braces ++;
    else if(end_a -> type == TYPE_CLOSE_BRACES)
      nesting_braces --;
    if(nesting_parenthesis < 0 || nesting_brackets < 0 ||
       nesting_braces < 0){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
       nesting_braces == 0 &&
       ((struct generic_token *) end_a -> next) -> type == TYPE_COMMA)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
      literal = false;
      break;
    }
  }
  if(literal){
    struct numeric_variable a, b;
    bool ret;
    comma = (struct generic_token *) end_a -> next;
    begin_b = (struct generic_token *) comma -> next;
    if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
    end_b = begin_b;
    while(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    ret = eval_numeric_expression(mf, cx, begin_a, end_a, &a);
    if(!ret)
      return false;
    ret = eval_numeric_expression(mf, cx, begin_b, end_b, &b);
    if(!ret)
      return false;
    result -> x = a.value;
    result -> y = b.value;
    return true;
  }
@
\fimcodigo

In the code above we identify if we are dealing with a literal
checking for a comma and we set in the boolean
variable \monoespaco{literal} if we found it. If this variable is not
true, immediately after the last \monoespaco{if} above, we run the
following \monoespaco{else} as the next rule:

\iniciocodigo
@<Pair Primary: Rule 3@>=
else{
  return eval_pair_expression(mf, cx, begin_a, end_a, result);
}
@
\fimcodigo

If the last token is a \monoespaco{]}, then we have a construction of
type $a[b,c]$. Our task is separate the three parts $a$, $b$ and $c$, evaluate them and return $a(b+c)$:

\iniciocodigo
@<Pair Primary: Rule 4@>=
if(end_expression -> type == TYPE_CLOSE_BRACKETS){
  struct generic_token *begin_a, *end_a, *begin_b, *end_b, *begin_c,
                       *end_c;
  struct numeric_variable a;
  struct pair_variable b, c;
  int nesting_parenthesis = 0, nesting_brackets = 0, nesting_braces = 0;
  begin_a = begin_expression;
  end_a = begin_a;
  while(end_a != NULL){
    if(end_a -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(end_a -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis --;
    else if(end_a -> type == TYPE_OPEN_BRACES)
      nesting_braces ++;
    else if(end_a -> type == TYPE_CLOSE_BRACES)
      nesting_braces --;
    if(nesting_parenthesis == 0 && nesting_braces == 0 &&
       ((struct generic_token *) end_a -> next) -> type ==
        TYPE_OPEN_BRACKETS)
      break;
    if(end_a -> next != end_expression)
      end_a = (struct generic_token *) end_a -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }
  }
  begin_b = (struct generic_token *) end_a -> next;
  begin_b = (struct generic_token *) begin_b -> next;
  if(begin_b == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_b = begin_b;
  while(end_b != end_expression){
    if(end_b -> type == TYPE_OPEN_PARENTHESIS)
      nesting_parenthesis ++;
    else if(end_b -> type == TYPE_CLOSE_PARENTHESIS)
      nesting_parenthesis --;
    else if(end_b -> type == TYPE_OPEN_BRACKETS)
      nesting_brackets ++;
    else if(end_b -> type == TYPE_CLOSE_BRACKETS)
      nesting_brackets --;
    else if(end_b -> type == TYPE_OPEN_BRACES)
      nesting_braces ++;
    else if(end_b -> type == TYPE_CLOSE_BRACES)
      nesting_braces --;
    if(nesting_parenthesis == 0 && nesting_brackets == 0 &&
       nesting_braces == 0 &&
       ((struct generic_token *) end_b -> next) -> type == TYPE_COMMA)
      break;
    if(end_b -> next != end_expression)
      end_b = (struct generic_token *) end_b -> next;
    else{
#if defined(W_DEBUG_METAFONT)
      fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
              "expression.\n ", mf -> file, begin_expression -> line);
#endif
      return false;
    }        
  }
  begin_c = (struct generic_token *) end_b -> next;
  begin_c = (struct generic_token *) begin_c -> next;
  if(begin_c == end_expression){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
            "expression.\n ", mf -> file, begin_expression -> line);
#endif
    return false;
  }
  end_c = begin_c;
  while(end_c -> next != end_expression)
    end_c = (struct generic_token *) end_c -> next;
  if(!eval_numeric_atom(mf, cx, begin_a, end_a, &a))
    return false;
  if(!eval_pair_expression(mf, cx, begin_b, end_b, &b))
    return false;
  if(!eval_pair_expression(mf, cx, begin_c, end_c, &c))
    return false;
  result -> x = (b.x + c.x) * a.value;
  result -> y = (b.y + c.y) * a.value;
  return true;
}
@
\fimcodigo

The last rule is when we have a scalar multiplication operator. The
operator can be \monoespaco{+}, \monoespaco{-}, a single numeric token
or a fraction:

\iniciocodigo
@<Pair Primary: Rule 5@>=
else{
  bool ret;
  if(begin_expression -> type == TYPE_SUM)
    return eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
  else if(begin_expression -> type == TYPE_SUBTRACT){
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x = - (result -> x);
    result -> y = - (result -> y);
    return true;
  }
  else if(begin_expression -> type == TYPE_NUMERIC){
    struct generic_token *tok;
    float value = ((struct numeric_token *) begin_expression) -> value;
    tok = (struct generic_token *) begin_expression -> next;
    if(tok -> type == TYPE_DIVISION){
      tok = (struct generic_token *) begin_expression -> next;
      if(tok == end_expression || tok -> next == end_expression ||
         tok -> type != TYPE_NUMERIC){
#if defined(W_DEBUG_METAFONT)
        fprintf(stderr, "METAFONT: Error: %s:%d: Unrecognizable "
                "expression.\n ", mf -> file, begin_expression -> line);
#endif
        return false;
      }
      value /= ((struct numeric_token *) tok) -> value;
      tok = (struct generic_token *) tok -> next;
    }
    ret = eval_pair_primary(mf, cx, (struct generic_token *)
                                     begin_expression -> next,
                             end_expression, result);
    if(!ret)
      return false;
    result -> x *= value;
    result -> y *= value;
    return true;
  }
}
@
\fimcodigo

\subsubsecao{8.2.4. Pairs in Numeric Expressions}

Numeric subexpressions can appear inside pair expressions. For
example, in $a[b,c]$, $a$ is a numeric atom. Likewise, pair
subexpressions can appear inside numeric expressions. We did not
define this in the section about numeric expressions because we still
had not defined how to evaluate pair expressions. There are four
numeric primary operators involving pairs:

\alinhaverbatim
<Numeric Primary> -> length <Pair Primary> | xpart <Pair Primary> |
                       ypart <Pair Primary> | angle <Pair Primary>
\alinhanormal

This require defining the following three new token types:

\iniciocodigo
@<METAFONT: Symbolic Token Definition@>+=
#define TYPE_XPART  47 // Symbolic token 'xpart'
#define TYPE_YPART  48 // Symbolic token 'ypart'
#define TYPE_ANGLE  49 // Symbolic token 'angle'
@
\fimcodigo

They correspond to the following keywords:

\iniciocodigo
@<List of Keywords@>+=
"xpart", "ypart", "angle",
@
\fimcodigo

The first case, which did not need a new token, othe
operator \monoespaco{length} was already being used to get the modulus
of a given number and we had written that it could be used on other
types, not only in numerics. In the case of pairs, this operators
returns the euclidean norm:

\iniciocodigo
@<Evaluate 'length'@>=
else if(expr_type == TYPE_T_PAIR){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = (float) hypot(p.x * p.x, p.y * p.y);
  return true;
}
@
\fimcodigo

The operator \monoespaco{xpart} returns the first value in a pair:

\iniciocodigo
@<Numeric Primary: Additional Operators@>=
else if(begin_expression -> type == TYPE_XPART){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = p.x;
  return true;
}
@
\fimcodigo

While the operator \monoespaco{ypart} returns the second value in a
pair:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_YPART){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  result -> value = p.y;
  return true;
}
@
\fimcodigo

Finally, the last operator, \monoespaco{angle}, measure the angle of a
pair. Which means the angle between the segment that connects the
origin to the pair coordintate and the segment that connects the
origin to $(1,0)$. An error will be generated if you try to measure
the angle of $(0,0)$:

\iniciocodigo
@<Numeric Primary: Additional Operators@>+=
else if(begin_expression -> type == TYPE_ANGLE){
  struct pair_variable p;
  if(!eval_pair_primary(mf, cx, (struct generic_token *)
                                begin_expression -> next, end_expression,
                                &p))
    return false;
  if(p.x == 0.0 && p.y == 0.0){
#if defined(W_DEBUG_METAFONT)
    fprintf(stderr, "METAFONT: Error: %s:%d: Measuring the angle "
            "of (0,0).\n ", mf -> file,
            begin_expression -> line);
#endif
    return false;
  }
  result -> value = (float) asin(p.y / (hypot(p.x * p.x, p.y * p.y)));
  result -> value *= 57.2958; // Radianos para graus
  return true;
}
@
\fimcodigo

\subsecao{8.3. Path Assignments and Expressions}

To assign a path to a variable with the right type, we use the
following code:

\iniciocodigo
@<Assignment for Path Variables@>=
else if(type == TYPE_T_PATH){
  int i;
  struct path_variable result;
  //if(!eval_path_expression(mf, cx, begin_expression,
  //                         (struct generic_token *) *end_token_list,
  //                         &result))
  //  return false;
  var = (struct symbolic_token *) begin_token_list;
  for(i = 0; i < number_of_variables; i ++){
    assign_path_variable(mf, (struct path_variable *) var -> var,
                         &result);
    var = (struct symbolic_token *) (var -> next);
    var = (struct symbolic_token *) (var -> next);
  }
  if(temporary_free != NULL)
    temporary_free(result.points);
}
@
\fimcodigo

The declaration for the assignment function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source);
@
\fimcodigo

And its implementation:

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void assign_path_variable(struct metafont *mf,
                          struct path_variable *target,
                          struct path_variable *source){
  int i;
  void *(*alloc)(size_t);
  void (*disalloc)(void *);
  if(target -> nesting_level == 0){
    disalloc = mf -> free;
    alloc = mf -> alloc;
  }
  else{
    disalloc = temporary_free;
    alloc = temporary_alloc;
  }
  if(target -> length != -1 && disalloc != NULL){
    for(i = 0; i < target -> length; i ++)
      if(target -> points[i].subpath != NULL)
        path_recursive_free(disalloc, (struct path_variable *)
                                      target -> points[i].subpath);
  }
  target -> cyclic = source -> cyclic;
  target -> length = source -> length;
  target -> points = (struct path_points *)
                       alloc(sizeof(struct path_points) *
                       target -> length);
  for(i = 0; i < target -> length; i ++){ // Copiar pontos
    memcpy(&(target -> points[i]), &(source -> points[i]),
           sizeof(struct path_points));
    if(source -> points[i].subpath != NULL)
      recursive_copy_points(alloc, (struct path_variable **)
                                   &(target -> points[i].subpath),
                            source -> points[i].subpath);
  }
}
@
\fimcodigo

Copying a path recursively means allocating space for the new path and
copying the data. While copying the points, we should also check if
there are other subpaths that should be copyied recursively. To do
this, we use the following auxiliary function:

\iniciocodigo
@<Local Function Declaration (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source);
@
\fimcodigo

\iniciocodigo
@<Auxiliary Local Functions (metafont.c)@>+=
void recursive_copy_points(void *(*alloc)(size_t),
                          struct path_variable **target,
                          struct path_variable *source){
  int i;
  *target = (struct path_variable *) alloc(sizeof(struct path_variable));
  (*target) -> cyclic = source -> cyclic;
  (*target) -> length = source -> length;
  (*target) -> points = (struct path_points *)
                          alloc(sizeof(struct path_points) *
                                (*target) -> length);
  for(i = 0; i < (*target) -> length; i ++){
    memcpy(&((*target) -> points[i]), &(source -> points[i]),
           sizeof(struct path_points));
    if(source -> points[i].subpath != NULL)
      recursive_copy_points(alloc, (struct path_variable **)
                                   &((*target) -> points[i].subpath),
                            source -> points[i].subpath);
  }
}
@
\fimcodigo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}

\referencia{Knuth, D. E. (1989) ``The METAFONT book'', Addison-Wesley
 Longsman Publishing Co., Inc}


\fim
